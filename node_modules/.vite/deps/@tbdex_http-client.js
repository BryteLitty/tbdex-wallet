"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports) {
      "use strict";
      init_dist();
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js"(exports) {
      init_dist();
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s2 = buffer[offset + i];
        i += d;
        e = s2 & (1 << -nBits) - 1;
        s2 >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s2 ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s2 * 128;
      };
    }
  });

  // node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js"(exports) {
      "use strict";
      init_dist();
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer2;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      var { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new GlobalUint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new GlobalUint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer2.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (GlobalArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b)
          return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);
      Object.setPrototypeOf(Buffer2, GlobalUint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, GlobalUint8Array)) {
          const copy = new GlobalUint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new GlobalUint8Array(array);
        } else if (length === void 0) {
          buf = new GlobalUint8Array(array, byteOffset);
        } else {
          buf = new GlobalUint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer2.alloc(+length);
      }
      Buffer2.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer2.prototype;
      };
      Buffer2.compare = function compare(a, b) {
        if (isInstance(a, GlobalUint8Array))
          a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b, GlobalUint8Array))
          b = Buffer2.from(b, b.offset, b.byteLength);
        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b)
          return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer = Buffer2.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, GlobalUint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer2.isBuffer(buf))
                buf = Buffer2.from(buf);
              buf.copy(buffer, pos);
            } else {
              GlobalUint8Array.prototype.set.call(
                buffer,
                buf,
                pos
              );
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }
        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer2.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
      Buffer2.prototype.equals = function equals(b) {
        if (!Buffer2.isBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }
      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, GlobalUint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }
        if (!Buffer2.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof GlobalUint8Array.prototype.indexOf === "function") {
            if (dir) {
              return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer2.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val = this[offset + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let i = byteLength2;
        let mul = 1;
        let val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          GlobalUint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length)
            break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js
  var require_browser = __commonJS({
    "node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js"(exports, module) {
      init_dist();
      var process = module.exports = {};
      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          if (typeof setTimeout === "function") {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === "function") {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e2) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e2) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      process.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      process.title = "browser";
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = "";
      process.versions = {};
      function noop() {
      }
      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;
      process.listeners = function(name) {
        return [];
      };
      process.binding = function(name) {
        throw new Error("process.binding is not supported");
      };
      process.cwd = function() {
        return "/";
      };
      process.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
      };
      process.umask = function() {
        return 0;
      };
    }
  });

  // shims/dist/index.js
  var import_buffer_polyfill, import_process, o;
  var init_dist = __esm({
    "shims/dist/index.js"() {
      "use strict";
      import_buffer_polyfill = __toESM(require_buffer(), 1);
      import_process = __toESM(require_browser(), 1);
      o = globalThis || void 0 || self;
    }
  });

  // shims/banner/index.cjs
  var require_banner = __commonJS({
    "shims/banner/index.cjs"() {
      init_dist();
      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;
      globalThis.global = globalThis.global || o;
      globalThis.process = globalThis.process || import_process.default;
    }
  });
  require_banner();
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/

import {
  PEX,
  require_ajv,
  require_equal
} from "./chunk-IDIKVVDV.js";
import {
  AUTHORITATIVE_ANSWER,
  IonDid,
  IonRequest,
  base32z,
  base58btc,
  base64url,
  bencode_default,
  crypto as crypto2,
  decode,
  ed25519,
  edwardsToMontgomeryPriv,
  edwardsToMontgomeryPub,
  encode,
  numberToBytesBE,
  randomBytes,
  require_browser as require_browser2,
  require_browser2 as require_browser3,
  require_canonicalize,
  require_events,
  require_string_decoder,
  secp256k1,
  secp256r1,
  sha256,
  varint_exports,
  x25519
} from "./chunk-UPUZYSSL.js";
import {
  __commonJS,
  __export,
  __publicField,
  __toESM,
  require_browser,
  require_buffer_polyfill,
  require_dist
} from "./chunk-C4XPKKSS.js";

// node_modules/@isaacs/ttlcache/index.js
var require_ttlcache = __commonJS({
  "node_modules/@isaacs/ttlcache/index.js"(exports, module) {
    var import_dist159 = __toESM(require_dist());
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var now = () => perf.now();
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var isPosIntOrInf = (n) => n === Infinity || isPosInt(n);
    var TTLCache3 = class _TTLCache {
      constructor({
        max = Infinity,
        ttl,
        updateAgeOnGet = false,
        checkAgeOnGet = false,
        noUpdateTTL = false,
        dispose,
        noDisposeOnSet = false
      } = {}) {
        this.expirations = /* @__PURE__ */ Object.create(null);
        this.data = /* @__PURE__ */ new Map();
        this.expirationMap = /* @__PURE__ */ new Map();
        if (ttl !== void 0 && !isPosIntOrInf(ttl)) {
          throw new TypeError(
            "ttl must be positive integer or Infinity if set"
          );
        }
        if (!isPosIntOrInf(max)) {
          throw new TypeError("max must be positive integer or Infinity");
        }
        this.ttl = ttl;
        this.max = max;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.checkAgeOnGet = !!checkAgeOnGet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDisposeOnSet = !!noDisposeOnSet;
        if (dispose !== void 0) {
          if (typeof dispose !== "function") {
            throw new TypeError("dispose must be function if set");
          }
          this.dispose = dispose;
        }
        this.timer = void 0;
        this.timerExpiration = void 0;
      }
      setTimer(expiration, ttl) {
        if (this.timerExpiration < expiration) {
          return;
        }
        if (this.timer) {
          clearTimeout(this.timer);
        }
        const t = setTimeout(() => {
          this.timer = void 0;
          this.timerExpiration = void 0;
          this.purgeStale();
          for (const exp in this.expirations) {
            this.setTimer(exp, exp - now());
            break;
          }
        }, ttl);
        if (t.unref)
          t.unref();
        this.timerExpiration = expiration;
        this.timer = t;
      }
      // hang onto the timer so we can clearTimeout if all items
      // are deleted.  Deno doesn't have Timer.unref(), so it
      // hangs otherwise.
      cancelTimer() {
        if (this.timer) {
          clearTimeout(this.timer);
          this.timerExpiration = void 0;
          this.timer = void 0;
        }
      }
      /* istanbul ignore next */
      cancelTimers() {
        process.emitWarning(
          'TTLCache.cancelTimers has been renamed to TTLCache.cancelTimer (no "s"), and will be removed in the next major version update'
        );
        return this.cancelTimer();
      }
      clear() {
        const entries = this.dispose !== _TTLCache.prototype.dispose ? [...this] : [];
        this.data.clear();
        this.expirationMap.clear();
        this.cancelTimer();
        this.expirations = /* @__PURE__ */ Object.create(null);
        for (const [key, val] of entries) {
          this.dispose(val, key, "delete");
        }
      }
      setTTL(key, ttl = this.ttl) {
        const current = this.expirationMap.get(key);
        if (current !== void 0) {
          const exp = this.expirations[current];
          if (!exp || exp.length <= 1) {
            delete this.expirations[current];
          } else {
            this.expirations[current] = exp.filter((k) => k !== key);
          }
        }
        if (ttl !== Infinity) {
          const expiration = Math.floor(now() + ttl);
          this.expirationMap.set(key, expiration);
          if (!this.expirations[expiration]) {
            this.expirations[expiration] = [];
            this.setTimer(expiration, ttl);
          }
          this.expirations[expiration].push(key);
        } else {
          this.expirationMap.set(key, Infinity);
        }
      }
      set(key, val, {
        ttl = this.ttl,
        noUpdateTTL = this.noUpdateTTL,
        noDisposeOnSet = this.noDisposeOnSet
      } = {}) {
        if (!isPosIntOrInf(ttl)) {
          throw new TypeError("ttl must be positive integer or Infinity");
        }
        if (this.expirationMap.has(key)) {
          if (!noUpdateTTL) {
            this.setTTL(key, ttl);
          }
          const oldValue = this.data.get(key);
          if (oldValue !== val) {
            this.data.set(key, val);
            if (!noDisposeOnSet) {
              this.dispose(oldValue, key, "set");
            }
          }
        } else {
          this.setTTL(key, ttl);
          this.data.set(key, val);
        }
        while (this.size > this.max) {
          this.purgeToCapacity();
        }
        return this;
      }
      has(key) {
        return this.data.has(key);
      }
      getRemainingTTL(key) {
        const expiration = this.expirationMap.get(key);
        return expiration === Infinity ? expiration : expiration !== void 0 ? Math.max(0, Math.ceil(expiration - now())) : 0;
      }
      get(key, {
        updateAgeOnGet = this.updateAgeOnGet,
        ttl = this.ttl,
        checkAgeOnGet = this.checkAgeOnGet
      } = {}) {
        const val = this.data.get(key);
        if (checkAgeOnGet && this.getRemainingTTL(key) === 0) {
          this.delete(key);
          return void 0;
        }
        if (updateAgeOnGet) {
          this.setTTL(key, ttl);
        }
        return val;
      }
      dispose(_, __) {
      }
      delete(key) {
        const current = this.expirationMap.get(key);
        if (current !== void 0) {
          const value = this.data.get(key);
          this.data.delete(key);
          this.expirationMap.delete(key);
          const exp = this.expirations[current];
          if (exp) {
            if (exp.length <= 1) {
              delete this.expirations[current];
            } else {
              this.expirations[current] = exp.filter((k) => k !== key);
            }
          }
          this.dispose(value, key, "delete");
          if (this.size === 0) {
            this.cancelTimer();
          }
          return true;
        }
        return false;
      }
      purgeToCapacity() {
        for (const exp in this.expirations) {
          const keys = this.expirations[exp];
          if (this.size - keys.length >= this.max) {
            delete this.expirations[exp];
            const entries = [];
            for (const key of keys) {
              entries.push([key, this.data.get(key)]);
              this.data.delete(key);
              this.expirationMap.delete(key);
            }
            for (const [key, val] of entries) {
              this.dispose(val, key, "evict");
            }
          } else {
            const s = this.size - this.max;
            const entries = [];
            for (const key of keys.splice(0, s)) {
              entries.push([key, this.data.get(key)]);
              this.data.delete(key);
              this.expirationMap.delete(key);
            }
            for (const [key, val] of entries) {
              this.dispose(val, key, "evict");
            }
            return;
          }
        }
      }
      get size() {
        return this.data.size;
      }
      purgeStale() {
        const n = Math.ceil(now());
        for (const exp in this.expirations) {
          if (exp === "Infinity" || exp > n) {
            return;
          }
          const keys = [...this.expirations[exp] || []];
          const entries = [];
          delete this.expirations[exp];
          for (const key of keys) {
            entries.push([key, this.data.get(key)]);
            this.data.delete(key);
            this.expirationMap.delete(key);
          }
          for (const [key, val] of entries) {
            this.dispose(val, key, "stale");
          }
        }
        if (this.size === 0) {
          this.cancelTimer();
        }
      }
      *entries() {
        for (const exp in this.expirations) {
          for (const key of this.expirations[exp]) {
            yield [key, this.data.get(key)];
          }
        }
      }
      *keys() {
        for (const exp in this.expirations) {
          for (const key of this.expirations[exp]) {
            yield key;
          }
        }
      }
      *values() {
        for (const exp in this.expirations) {
          for (const key of this.expirations[exp]) {
            yield this.data.get(key);
          }
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
    };
    module.exports = TTLCache3;
  }
});

// node_modules/@tbdex/protocol/node_modules/readable-stream/lib/ours/primordials.js
var require_primordials = __commonJS({
  "node_modules/@tbdex/protocol/node_modules/readable-stream/lib/ours/primordials.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    module.exports = {
      ArrayIsArray(self) {
        return Array.isArray(self);
      },
      ArrayPrototypeIncludes(self, el) {
        return self.includes(el);
      },
      ArrayPrototypeIndexOf(self, el) {
        return self.indexOf(el);
      },
      ArrayPrototypeJoin(self, sep) {
        return self.join(sep);
      },
      ArrayPrototypeMap(self, fn) {
        return self.map(fn);
      },
      ArrayPrototypePop(self, el) {
        return self.pop(el);
      },
      ArrayPrototypePush(self, el) {
        return self.push(el);
      },
      ArrayPrototypeSlice(self, start, end) {
        return self.slice(start, end);
      },
      Error,
      FunctionPrototypeCall(fn, thisArgs, ...args) {
        return fn.call(thisArgs, ...args);
      },
      FunctionPrototypeSymbolHasInstance(self, instance) {
        return Function.prototype[Symbol.hasInstance].call(self, instance);
      },
      MathFloor: Math.floor,
      Number,
      NumberIsInteger: Number.isInteger,
      NumberIsNaN: Number.isNaN,
      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
      NumberParseInt: Number.parseInt,
      ObjectDefineProperties(self, props) {
        return Object.defineProperties(self, props);
      },
      ObjectDefineProperty(self, name, prop) {
        return Object.defineProperty(self, name, prop);
      },
      ObjectGetOwnPropertyDescriptor(self, name) {
        return Object.getOwnPropertyDescriptor(self, name);
      },
      ObjectKeys(obj) {
        return Object.keys(obj);
      },
      ObjectSetPrototypeOf(target, proto) {
        return Object.setPrototypeOf(target, proto);
      },
      Promise,
      PromisePrototypeCatch(self, fn) {
        return self.catch(fn);
      },
      PromisePrototypeThen(self, thenFn, catchFn) {
        return self.then(thenFn, catchFn);
      },
      PromiseReject(err) {
        return Promise.reject(err);
      },
      ReflectApply: Reflect.apply,
      RegExpPrototypeTest(self, value) {
        return self.test(value);
      },
      SafeSet: Set,
      String,
      StringPrototypeSlice(self, start, end) {
        return self.slice(start, end);
      },
      StringPrototypeToLowerCase(self) {
        return self.toLowerCase();
      },
      StringPrototypeToUpperCase(self) {
        return self.toUpperCase();
      },
      StringPrototypeTrim(self) {
        return self.trim();
      },
      Symbol,
      SymbolFor: Symbol.for,
      SymbolAsyncIterator: Symbol.asyncIterator,
      SymbolHasInstance: Symbol.hasInstance,
      SymbolIterator: Symbol.iterator,
      TypedArrayPrototypeSet(self, buf, len) {
        return self.set(buf, len);
      },
      Uint8Array
    };
  }
});

// node_modules/@tbdex/protocol/node_modules/readable-stream/lib/ours/util.js
var require_util = __commonJS({
  "node_modules/@tbdex/protocol/node_modules/readable-stream/lib/ours/util.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var bufferModule = require_buffer_polyfill();
    var AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b) {
      return b instanceof Blob2;
    } : function isBlob2(b) {
      return false;
    };
    var AggregateError = class extends Error {
      constructor(errors) {
        if (!Array.isArray(errors)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        }
        let message2 = "";
        for (let i = 0; i < errors.length; i++) {
          message2 += `    ${errors[i].stack}
`;
        }
        super(message2);
        this.name = "AggregateError";
        this.errors = errors;
      }
    };
    module.exports = {
      AggregateError,
      kEmptyObject: Object.freeze({}),
      once(callback) {
        let called = false;
        return function(...args) {
          if (called) {
            return;
          }
          called = true;
          callback.apply(this, args);
        };
      },
      createDeferredPromise: function() {
        let resolve;
        let reject;
        const promise = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        });
        return {
          promise,
          resolve,
          reject
        };
      },
      promisify(fn) {
        return new Promise((resolve, reject) => {
          fn((err, ...args) => {
            if (err) {
              return reject(err);
            }
            return resolve(...args);
          });
        });
      },
      debuglog() {
        return function() {
        };
      },
      format(format, ...args) {
        return format.replace(/%([sdifj])/g, function(...[_unused, type]) {
          const replacement = args.shift();
          if (type === "f") {
            return replacement.toFixed(6);
          } else if (type === "j") {
            return JSON.stringify(replacement);
          } else if (type === "s" && typeof replacement === "object") {
            const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
            return `${ctor} {}`.trim();
          } else {
            return replacement.toString();
          }
        });
      },
      inspect(value) {
        switch (typeof value) {
          case "string":
            if (value.includes("'")) {
              if (!value.includes('"')) {
                return `"${value}"`;
              } else if (!value.includes("`") && !value.includes("${")) {
                return `\`${value}\``;
              }
            }
            return `'${value}'`;
          case "number":
            if (isNaN(value)) {
              return "NaN";
            } else if (Object.is(value, -0)) {
              return String(value);
            }
            return value;
          case "bigint":
            return `${String(value)}n`;
          case "boolean":
          case "undefined":
            return String(value);
          case "object":
            return "{}";
        }
      },
      types: {
        isAsyncFunction(fn) {
          return fn instanceof AsyncFunction;
        },
        isArrayBufferView(arr) {
          return ArrayBuffer.isView(arr);
        }
      },
      isBlob
    };
    module.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  }
});

// node_modules/@tbdex/protocol/node_modules/readable-stream/lib/ours/errors.js
var require_errors = __commonJS({
  "node_modules/@tbdex/protocol/node_modules/readable-stream/lib/ours/errors.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var { format, inspect, AggregateError: CustomAggregateError } = require_util();
    var AggregateError = globalThis.AggregateError || CustomAggregateError;
    var kIsNodeError = Symbol("kIsNodeError");
    var kTypes = [
      "string",
      "function",
      "number",
      "object",
      // Accept 'Function' and 'Object' as alternative to the lower cased version.
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ];
    var classRegExp = /^([A-Z][a-z0-9]*)+$/;
    var nodeInternalPrefix = "__node_internal_";
    var codes = {};
    function assert(value, message2) {
      if (!value) {
        throw new codes.ERR_INTERNAL_ASSERTION(message2);
      }
    }
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function getMessage(key, msg, args) {
      if (typeof msg === "function") {
        assert(
          msg.length <= args.length,
          // Default options do not count.
          `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
        );
        return msg(...args);
      }
      const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
      assert(
        expectedLength === args.length,
        `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
      );
      if (args.length === 0) {
        return msg;
      }
      return format(msg, ...args);
    }
    function E(code, message2, Base) {
      if (!Base) {
        Base = Error;
      }
      class NodeError extends Base {
        constructor(...args) {
          super(getMessage(code, message2, args));
        }
        toString() {
          return `${this.name} [${code}]: ${this.message}`;
        }
      }
      Object.defineProperties(NodeError.prototype, {
        name: {
          value: Base.name,
          writable: true,
          enumerable: false,
          configurable: true
        },
        toString: {
          value() {
            return `${this.name} [${code}]: ${this.message}`;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      NodeError.prototype.code = code;
      NodeError.prototype[kIsNodeError] = true;
      codes[code] = NodeError;
    }
    function hideStackFrames(fn) {
      const hidden = nodeInternalPrefix + fn.name;
      Object.defineProperty(fn, "name", {
        value: hidden
      });
      return fn;
    }
    function aggregateTwoErrors(innerError, outerError) {
      if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
          outerError.errors.push(innerError);
          return outerError;
        }
        const err = new AggregateError([outerError, innerError], outerError.message);
        err.code = outerError.code;
        return err;
      }
      return innerError || outerError;
    }
    var AbortError = class extends Error {
      constructor(message2 = "The operation was aborted", options = void 0) {
        if (options !== void 0 && typeof options !== "object") {
          throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        super(message2, options);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    E("ERR_ASSERTION", "%s", Error);
    E(
      "ERR_INVALID_ARG_TYPE",
      (name, expected, actual) => {
        assert(typeof name === "string", "'name' must be a string");
        if (!Array.isArray(expected)) {
          expected = [expected];
        }
        let msg = "The ";
        if (name.endsWith(" argument")) {
          msg += `${name} `;
        } else {
          msg += `"${name}" ${name.includes(".") ? "property" : "argument"} `;
        }
        msg += "must be ";
        const types = [];
        const instances = [];
        const other = [];
        for (const value of expected) {
          assert(typeof value === "string", "All expected entries have to be of type string");
          if (kTypes.includes(value)) {
            types.push(value.toLowerCase());
          } else if (classRegExp.test(value)) {
            instances.push(value);
          } else {
            assert(value !== "object", 'The value "object" should be written as "Object"');
            other.push(value);
          }
        }
        if (instances.length > 0) {
          const pos = types.indexOf("object");
          if (pos !== -1) {
            types.splice(types, pos, 1);
            instances.push("Object");
          }
        }
        if (types.length > 0) {
          switch (types.length) {
            case 1:
              msg += `of type ${types[0]}`;
              break;
            case 2:
              msg += `one of type ${types[0]} or ${types[1]}`;
              break;
            default: {
              const last = types.pop();
              msg += `one of type ${types.join(", ")}, or ${last}`;
            }
          }
          if (instances.length > 0 || other.length > 0) {
            msg += " or ";
          }
        }
        if (instances.length > 0) {
          switch (instances.length) {
            case 1:
              msg += `an instance of ${instances[0]}`;
              break;
            case 2:
              msg += `an instance of ${instances[0]} or ${instances[1]}`;
              break;
            default: {
              const last = instances.pop();
              msg += `an instance of ${instances.join(", ")}, or ${last}`;
            }
          }
          if (other.length > 0) {
            msg += " or ";
          }
        }
        switch (other.length) {
          case 0:
            break;
          case 1:
            if (other[0].toLowerCase() !== other[0]) {
              msg += "an ";
            }
            msg += `${other[0]}`;
            break;
          case 2:
            msg += `one of ${other[0]} or ${other[1]}`;
            break;
          default: {
            const last = other.pop();
            msg += `one of ${other.join(", ")}, or ${last}`;
          }
        }
        if (actual == null) {
          msg += `. Received ${actual}`;
        } else if (typeof actual === "function" && actual.name) {
          msg += `. Received function ${actual.name}`;
        } else if (typeof actual === "object") {
          var _actual$constructor;
          if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name) {
            msg += `. Received an instance of ${actual.constructor.name}`;
          } else {
            const inspected = inspect(actual, {
              depth: -1
            });
            msg += `. Received ${inspected}`;
          }
        } else {
          let inspected = inspect(actual, {
            colors: false
          });
          if (inspected.length > 25) {
            inspected = `${inspected.slice(0, 25)}...`;
          }
          msg += `. Received type ${typeof actual} (${inspected})`;
        }
        return msg;
      },
      TypeError
    );
    E(
      "ERR_INVALID_ARG_VALUE",
      (name, value, reason = "is invalid") => {
        let inspected = inspect(value);
        if (inspected.length > 128) {
          inspected = inspected.slice(0, 128) + "...";
        }
        const type = name.includes(".") ? "property" : "argument";
        return `The ${type} '${name}' ${reason}. Received ${inspected}`;
      },
      TypeError
    );
    E(
      "ERR_INVALID_RETURN_VALUE",
      (input, name, value) => {
        var _value$constructor;
        const type = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
        return `Expected ${input} to be returned from the "${name}" function but got ${type}.`;
      },
      TypeError
    );
    E(
      "ERR_MISSING_ARGS",
      (...args) => {
        assert(args.length > 0, "At least one arg needs to be specified");
        let msg;
        const len = args.length;
        args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(" or ");
        switch (len) {
          case 1:
            msg += `The ${args[0]} argument`;
            break;
          case 2:
            msg += `The ${args[0]} and ${args[1]} arguments`;
            break;
          default:
            {
              const last = args.pop();
              msg += `The ${args.join(", ")}, and ${last} arguments`;
            }
            break;
        }
        return `${msg} must be specified`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      (str, range, input) => {
        assert(range, 'Missing "range" argument');
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > 2n ** 32n || input < -(2n ** 32n)) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        } else {
          received = inspect(input);
        }
        return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
      },
      RangeError
    );
    E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    E("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    E("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    E("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    E("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    E("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    E("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    E("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    E("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    E("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    module.exports = {
      AbortError,
      aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
      hideStackFrames,
      codes
    };
  }
});

// node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/validators.js
var require_validators = __commonJS({
  "node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/validators.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var {
      ArrayIsArray,
      ArrayPrototypeIncludes,
      ArrayPrototypeJoin,
      ArrayPrototypeMap,
      NumberIsInteger,
      NumberIsNaN,
      NumberMAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER,
      NumberParseInt,
      ObjectPrototypeHasOwnProperty,
      RegExpPrototypeExec,
      String: String2,
      StringPrototypeToUpperCase,
      StringPrototypeTrim
    } = require_primordials();
    var {
      hideStackFrames,
      codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
    } = require_errors();
    var { normalizeEncoding } = require_util();
    var { isAsyncFunction, isArrayBufferView } = require_util().types;
    var signals = {};
    function isInt32(value) {
      return value === (value | 0);
    }
    function isUint32(value) {
      return value === value >>> 0;
    }
    var octalReg = /^[0-7]+$/;
    var modeDesc = "must be a 32-bit unsigned integer or an octal string";
    function parseFileMode(value, name, def) {
      if (typeof value === "undefined") {
        value = def;
      }
      if (typeof value === "string") {
        if (RegExpPrototypeExec(octalReg, value) === null) {
          throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);
        }
        value = NumberParseInt(value, 8);
      }
      validateUint32(value, name);
      return value;
    }
    var validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      if (!NumberIsInteger(value))
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      if (value < min || value > max)
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    });
    var validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
      }
    });
    var validateUint32 = hideStackFrames((value, name, positive = false) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      const min = positive ? 1 : 0;
      const max = 4294967295;
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
      }
    });
    function validateString(value, name) {
      if (typeof value !== "string")
        throw new ERR_INVALID_ARG_TYPE(name, "string", value);
    }
    function validateNumber(value, name, min = void 0, max) {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value)) {
        throw new ERR_OUT_OF_RANGE(
          name,
          `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`,
          value
        );
      }
    }
    var validateOneOf = hideStackFrames((value, name, oneOf) => {
      if (!ArrayPrototypeIncludes(oneOf, value)) {
        const allowed = ArrayPrototypeJoin(
          ArrayPrototypeMap(oneOf, (v) => typeof v === "string" ? `'${v}'` : String2(v)),
          ", "
        );
        const reason = "must be one of: " + allowed;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateBoolean(value, name) {
      if (typeof value !== "boolean")
        throw new ERR_INVALID_ARG_TYPE(name, "boolean", value);
    }
    function getOwnPropertyValueOrDefault(options, key, defaultValue) {
      return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
    }
    var validateObject = hideStackFrames((value, name, options = null) => {
      const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
      const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
      const nullable = getOwnPropertyValueOrDefault(options, "nullable", false);
      if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new ERR_INVALID_ARG_TYPE(name, "Object", value);
      }
    });
    var validateDictionary = hideStackFrames((value, name) => {
      if (value != null && typeof value !== "object" && typeof value !== "function") {
        throw new ERR_INVALID_ARG_TYPE(name, "a dictionary", value);
      }
    });
    var validateArray = hideStackFrames((value, name, minLength = 0) => {
      if (!ArrayIsArray(value)) {
        throw new ERR_INVALID_ARG_TYPE(name, "Array", value);
      }
      if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateStringArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        validateString(value[i], `${name}[${i}]`);
      }
    }
    function validateBooleanArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        validateBoolean(value[i], `${name}[${i}]`);
      }
    }
    function validateSignalName(signal, name = "signal") {
      validateString(signal, name);
      if (signals[signal] === void 0) {
        if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {
          throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
        }
        throw new ERR_UNKNOWN_SIGNAL(signal);
      }
    }
    var validateBuffer = hideStackFrames((buffer, name = "buffer") => {
      if (!isArrayBufferView(buffer)) {
        throw new ERR_INVALID_ARG_TYPE(name, ["Buffer", "TypedArray", "DataView"], buffer);
      }
    });
    function validateEncoding(data, encoding) {
      const normalizedEncoding = normalizeEncoding(encoding);
      const length = data.length;
      if (normalizedEncoding === "hex" && length % 2 !== 0) {
        throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
      }
    }
    function validatePort(port, name = "Port", allowZero = true) {
      if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
        throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);
      }
      return port | 0;
    }
    var validateAbortSignal = hideStackFrames((signal, name) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    });
    var validateFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function")
        throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    });
    var validatePlainFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function" || isAsyncFunction(value))
        throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    });
    var validateUndefined = hideStackFrames((value, name) => {
      if (value !== void 0)
        throw new ERR_INVALID_ARG_TYPE(name, "undefined", value);
    });
    function validateUnion(value, name, union) {
      if (!ArrayPrototypeIncludes(union, value)) {
        throw new ERR_INVALID_ARG_TYPE(name, `('${ArrayPrototypeJoin(union, "|")}')`, value);
      }
    }
    var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function validateLinkHeaderFormat(value, name) {
      if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value)) {
        throw new ERR_INVALID_ARG_VALUE(
          name,
          value,
          'must be an array or string of format "</styles.css>; rel=preload; as=style"'
        );
      }
    }
    function validateLinkHeaderValue(hints) {
      if (typeof hints === "string") {
        validateLinkHeaderFormat(hints, "hints");
        return hints;
      } else if (ArrayIsArray(hints)) {
        const hintsLength = hints.length;
        let result = "";
        if (hintsLength === 0) {
          return result;
        }
        for (let i = 0; i < hintsLength; i++) {
          const link = hints[i];
          validateLinkHeaderFormat(link, "hints");
          result += link;
          if (i !== hintsLength - 1) {
            result += ", ";
          }
        }
        return result;
      }
      throw new ERR_INVALID_ARG_VALUE(
        "hints",
        hints,
        'must be an array or string of format "</styles.css>; rel=preload; as=style"'
      );
    }
    module.exports = {
      isInt32,
      isUint32,
      parseFileMode,
      validateArray,
      validateStringArray,
      validateBooleanArray,
      validateBoolean,
      validateBuffer,
      validateDictionary,
      validateEncoding,
      validateFunction,
      validateInt32,
      validateInteger,
      validateNumber,
      validateObject,
      validateOneOf,
      validatePlainFunction,
      validatePort,
      validateSignalName,
      validateString,
      validateUint32,
      validateUndefined,
      validateUnion,
      validateAbortSignal,
      validateLinkHeaderValue
    };
  }
});

// node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/utils.js
var require_utils = __commonJS({
  "node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/utils.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var { Symbol: Symbol2, SymbolAsyncIterator, SymbolIterator, SymbolFor } = require_primordials();
    var kDestroyed = Symbol2("kDestroyed");
    var kIsErrored = Symbol2("kIsErrored");
    var kIsReadable = Symbol2("kIsReadable");
    var kIsDisturbed = Symbol2("kIsDisturbed");
    var kIsClosedPromise = SymbolFor("nodejs.webstream.isClosedPromise");
    var kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
    function isReadableNodeStream(obj, strict = false) {
      var _obj$_readableState;
      return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 ? void 0 : _obj$_readableState.readable) !== false) && // Duplex
      (!obj._writableState || obj._readableState));
    }
    function isWritableNodeStream(obj) {
      var _obj$_writableState;
      return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 ? void 0 : _obj$_writableState.writable) !== false));
    }
    function isDuplexNodeStream(obj) {
      return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
    }
    function isNodeStream(obj) {
      return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
    }
    function isReadableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
    }
    function isWritableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
    }
    function isTransformStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
    }
    function isWebStream(obj) {
      return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
    }
    function isIterable(obj, isAsync) {
      if (obj == null)
        return false;
      if (isAsync === true)
        return typeof obj[SymbolAsyncIterator] === "function";
      if (isAsync === false)
        return typeof obj[SymbolIterator] === "function";
      return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
    }
    function isDestroyed(stream) {
      if (!isNodeStream(stream))
        return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !!(stream.destroyed || stream[kDestroyed] || state !== null && state !== void 0 && state.destroyed);
    }
    function isWritableEnded(stream) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableEnded === true)
        return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored)
        return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== "boolean")
        return null;
      return wState.ended;
    }
    function isWritableFinished(stream, strict) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableFinished === true)
        return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored)
        return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== "boolean")
        return null;
      return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
    }
    function isReadableEnded(stream) {
      if (!isReadableNodeStream(stream))
        return null;
      if (stream.readableEnded === true)
        return true;
      const rState = stream._readableState;
      if (!rState || rState.errored)
        return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== "boolean")
        return null;
      return rState.ended;
    }
    function isReadableFinished(stream, strict) {
      if (!isReadableNodeStream(stream))
        return null;
      const rState = stream._readableState;
      if (rState !== null && rState !== void 0 && rState.errored)
        return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== "boolean")
        return null;
      return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
    }
    function isReadable(stream) {
      if (stream && stream[kIsReadable] != null)
        return stream[kIsReadable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
    }
    function isWritable(stream) {
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
    }
    function isFinished(stream, opts) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (isDestroyed(stream)) {
        return true;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable(stream)) {
        return false;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream)) {
        return false;
      }
      return true;
    }
    function isWritableErrored(stream) {
      var _stream$_writableStat, _stream$_writableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.writableErrored) {
        return stream.writableErrored;
      }
      return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0 ? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 ? _stream$_writableStat : null;
    }
    function isReadableErrored(stream) {
      var _stream$_readableStat, _stream$_readableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.readableErrored) {
        return stream.readableErrored;
      }
      return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0 ? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 ? _stream$_readableStat : null;
    }
    function isClosed(stream) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (typeof stream.closed === "boolean") {
        return stream.closed;
      }
      const wState = stream._writableState;
      const rState = stream._readableState;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === "boolean" || typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === "boolean") {
        return (wState === null || wState === void 0 ? void 0 : wState.closed) || (rState === null || rState === void 0 ? void 0 : rState.closed);
      }
      if (typeof stream._closed === "boolean" && isOutgoingMessage(stream)) {
        return stream._closed;
      }
      return null;
    }
    function isOutgoingMessage(stream) {
      return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
    }
    function isServerResponse(stream) {
      return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
    }
    function isServerRequest(stream) {
      var _stream$req;
      return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) === void 0;
    }
    function willEmitClose(stream) {
      if (!isNodeStream(stream))
        return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
    }
    function isDisturbed(stream) {
      var _stream$kIsDisturbed;
      return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
    }
    function isErrored(stream) {
      var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
      return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0 ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== void 0 ? _ref5 : stream.writableErrored) !== null && _ref4 !== void 0 ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0 ? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0 ? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0 ? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0 ? void 0 : _stream$_writableStat4.errored));
    }
    module.exports = {
      kDestroyed,
      isDisturbed,
      kIsDisturbed,
      isErrored,
      kIsErrored,
      isReadable,
      kIsReadable,
      kIsClosedPromise,
      kControllerErrorFunction,
      isClosed,
      isDestroyed,
      isDuplexNodeStream,
      isFinished,
      isIterable,
      isReadableNodeStream,
      isReadableStream,
      isReadableEnded,
      isReadableFinished,
      isReadableErrored,
      isNodeStream,
      isWebStream,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableEnded,
      isWritableFinished,
      isWritableErrored,
      isServerRequest,
      isServerResponse,
      willEmitClose,
      isTransformStream
    };
  }
});

// node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
    var import_dist159 = __toESM(require_dist());
    var process2 = require_browser();
    var { AbortError, codes } = require_errors();
    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes;
    var { kEmptyObject, once } = require_util();
    var { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require_validators();
    var { Promise: Promise2, PromisePrototypeThen } = require_primordials();
    var {
      isClosed,
      isReadable,
      isReadableNodeStream,
      isReadableStream,
      isReadableFinished,
      isReadableErrored,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableFinished,
      isWritableErrored,
      isNodeStream,
      willEmitClose: _willEmitClose,
      kIsClosedPromise
    } = require_utils();
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    var nop = () => {
    };
    function eos(stream, options, callback) {
      var _options$readable, _options$writable;
      if (arguments.length === 2) {
        callback = options;
        options = kEmptyObject;
      } else if (options == null) {
        options = kEmptyObject;
      } else {
        validateObject(options, "options");
      }
      validateFunction(callback, "callback");
      validateAbortSignal(options.signal, "options.signal");
      callback = once(callback);
      if (isReadableStream(stream) || isWritableStream(stream)) {
        return eosWeb(stream, options, callback);
      }
      if (!isNodeStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 ? _options$readable : isReadableNodeStream(stream);
      const writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 ? _options$writable : isWritableNodeStream(stream);
      const wState = stream._writableState;
      const rState = stream._readableState;
      const onlegacyfinish = () => {
        if (!stream.writable) {
          onfinish();
        }
      };
      let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
      let writableFinished = isWritableFinished(stream, false);
      const onfinish = () => {
        writableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.readable || readable)) {
          return;
        }
        if (!readable || readableFinished) {
          callback.call(stream);
        }
      };
      let readableFinished = isReadableFinished(stream, false);
      const onend = () => {
        readableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.writable || writable)) {
          return;
        }
        if (!writable || writableFinished) {
          callback.call(stream);
        }
      };
      const onerror = (err) => {
        callback.call(stream, err);
      };
      let closed = isClosed(stream);
      const onclose = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
          if (!isReadableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        if (writable && !writableFinished) {
          if (!isWritableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        callback.call(stream);
      };
      const onclosed = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        callback.call(stream);
      };
      const onrequest = () => {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
          stream.on("abort", onclose);
        }
        if (stream.req) {
          onrequest();
        } else {
          stream.on("request", onrequest);
        }
      } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (options.error !== false) {
        stream.on("error", onerror);
      }
      stream.on("close", onclose);
      if (closed) {
        process2.nextTick(onclose);
      } else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {
        if (!willEmitClose) {
          process2.nextTick(onclosed);
        }
      } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {
        process2.nextTick(onclosed);
      } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {
        process2.nextTick(onclosed);
      } else if (rState && stream.req && stream.aborted) {
        process2.nextTick(onclosed);
      }
      const cleanup = () => {
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
      if (options.signal && !closed) {
        const abort = () => {
          const endCallback = callback;
          cleanup();
          endCallback.call(
            stream,
            new AbortError(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process2.nextTick(abort);
        } else {
          const originalCallback = callback;
          callback = once((...args) => {
            options.signal.removeEventListener("abort", abort);
            originalCallback.apply(stream, args);
          });
          options.signal.addEventListener("abort", abort);
        }
      }
      return cleanup;
    }
    function eosWeb(stream, options, callback) {
      let isAborted = false;
      let abort = nop;
      if (options.signal) {
        abort = () => {
          isAborted = true;
          callback.call(
            stream,
            new AbortError(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process2.nextTick(abort);
        } else {
          const originalCallback = callback;
          callback = once((...args) => {
            options.signal.removeEventListener("abort", abort);
            originalCallback.apply(stream, args);
          });
          options.signal.addEventListener("abort", abort);
        }
      }
      const resolverFn = (...args) => {
        if (!isAborted) {
          process2.nextTick(() => callback.apply(stream, args));
        }
      };
      PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);
      return nop;
    }
    function finished(stream, opts) {
      var _opts;
      let autoCleanup = false;
      if (opts === null) {
        opts = kEmptyObject;
      }
      if ((_opts = opts) !== null && _opts !== void 0 && _opts.cleanup) {
        validateBoolean(opts.cleanup, "cleanup");
        autoCleanup = opts.cleanup;
      }
      return new Promise2((resolve, reject) => {
        const cleanup = eos(stream, opts, (err) => {
          if (autoCleanup) {
            cleanup();
          }
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }
    module.exports = eos;
    module.exports.finished = finished;
  }
});

// node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var process2 = require_browser();
    var {
      aggregateTwoErrors,
      codes: { ERR_MULTIPLE_CALLBACK },
      AbortError
    } = require_errors();
    var { Symbol: Symbol2 } = require_primordials();
    var { kDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils();
    var kDestroy = Symbol2("kDestroy");
    var kConstruct = Symbol2("kConstruct");
    function checkError(err, w, r) {
      if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
      }
    }
    function destroy(err, cb) {
      const r = this._readableState;
      const w = this._writableState;
      const s = w || r;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        if (typeof cb === "function") {
          cb();
        }
        return this;
      }
      checkError(err, w, r);
      if (w) {
        w.destroyed = true;
      }
      if (r) {
        r.destroyed = true;
      }
      if (!s.constructed) {
        this.once(kDestroy, function(er) {
          _destroy(this, aggregateTwoErrors(er, err), cb);
        });
      } else {
        _destroy(this, err, cb);
      }
      return this;
    }
    function _destroy(self, err, cb) {
      let called = false;
      function onDestroy(err2) {
        if (called) {
          return;
        }
        called = true;
        const r = self._readableState;
        const w = self._writableState;
        checkError(err2, w, r);
        if (w) {
          w.closed = true;
        }
        if (r) {
          r.closed = true;
        }
        if (typeof cb === "function") {
          cb(err2);
        }
        if (err2) {
          process2.nextTick(emitErrorCloseNT, self, err2);
        } else {
          process2.nextTick(emitCloseNT, self);
        }
      }
      try {
        self._destroy(err || null, onDestroy);
      } catch (err2) {
        onDestroy(err2);
      }
    }
    function emitErrorCloseNT(self, err) {
      emitErrorNT(self, err);
      emitCloseNT(self);
    }
    function emitCloseNT(self) {
      const r = self._readableState;
      const w = self._writableState;
      if (w) {
        w.closeEmitted = true;
      }
      if (r) {
        r.closeEmitted = true;
      }
      if (w !== null && w !== void 0 && w.emitClose || r !== null && r !== void 0 && r.emitClose) {
        self.emit("close");
      }
    }
    function emitErrorNT(self, err) {
      const r = self._readableState;
      const w = self._writableState;
      if (w !== null && w !== void 0 && w.errorEmitted || r !== null && r !== void 0 && r.errorEmitted) {
        return;
      }
      if (w) {
        w.errorEmitted = true;
      }
      if (r) {
        r.errorEmitted = true;
      }
      self.emit("error", err);
    }
    function undestroy() {
      const r = this._readableState;
      const w = this._writableState;
      if (r) {
        r.constructed = true;
        r.closed = false;
        r.closeEmitted = false;
        r.destroyed = false;
        r.errored = null;
        r.errorEmitted = false;
        r.reading = false;
        r.ended = r.readable === false;
        r.endEmitted = r.readable === false;
      }
      if (w) {
        w.constructed = true;
        w.destroyed = false;
        w.closed = false;
        w.closeEmitted = false;
        w.errored = null;
        w.errorEmitted = false;
        w.finalCalled = false;
        w.prefinished = false;
        w.ended = w.writable === false;
        w.ending = w.writable === false;
        w.finished = w.writable === false;
      }
    }
    function errorOrDestroy(stream, err, sync) {
      const r = stream._readableState;
      const w = stream._writableState;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        return this;
      }
      if (r !== null && r !== void 0 && r.autoDestroy || w !== null && w !== void 0 && w.autoDestroy)
        stream.destroy(err);
      else if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
        if (sync) {
          process2.nextTick(emitErrorNT, stream, err);
        } else {
          emitErrorNT(stream, err);
        }
      }
    }
    function construct(stream, cb) {
      if (typeof stream._construct !== "function") {
        return;
      }
      const r = stream._readableState;
      const w = stream._writableState;
      if (r) {
        r.constructed = false;
      }
      if (w) {
        w.constructed = false;
      }
      stream.once(kConstruct, cb);
      if (stream.listenerCount(kConstruct) > 1) {
        return;
      }
      process2.nextTick(constructNT, stream);
    }
    function constructNT(stream) {
      let called = false;
      function onConstruct(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        const r = stream._readableState;
        const w = stream._writableState;
        const s = w || r;
        if (r) {
          r.constructed = true;
        }
        if (w) {
          w.constructed = true;
        }
        if (s.destroyed) {
          stream.emit(kDestroy, err);
        } else if (err) {
          errorOrDestroy(stream, err, true);
        } else {
          process2.nextTick(emitConstructNT, stream);
        }
      }
      try {
        stream._construct((err) => {
          process2.nextTick(onConstruct, err);
        });
      } catch (err) {
        process2.nextTick(onConstruct, err);
      }
    }
    function emitConstructNT(stream) {
      stream.emit(kConstruct);
    }
    function isRequest(stream) {
      return (stream === null || stream === void 0 ? void 0 : stream.setHeader) && typeof stream.abort === "function";
    }
    function emitCloseLegacy(stream) {
      stream.emit("close");
    }
    function emitErrorCloseLegacy(stream, err) {
      stream.emit("error", err);
      process2.nextTick(emitCloseLegacy, stream);
    }
    function destroyer(stream, err) {
      if (!stream || isDestroyed(stream)) {
        return;
      }
      if (!err && !isFinished(stream)) {
        err = new AbortError();
      }
      if (isServerRequest(stream)) {
        stream.socket = null;
        stream.destroy(err);
      } else if (isRequest(stream)) {
        stream.abort();
      } else if (isRequest(stream.req)) {
        stream.req.abort();
      } else if (typeof stream.destroy === "function") {
        stream.destroy(err);
      } else if (typeof stream.close === "function") {
        stream.close();
      } else if (err) {
        process2.nextTick(emitErrorCloseLegacy, stream, err);
      } else {
        process2.nextTick(emitCloseLegacy, stream);
      }
      if (!stream.destroyed) {
        stream[kDestroyed] = true;
      }
    }
    module.exports = {
      construct,
      destroyer,
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/legacy.js
var require_legacy = __commonJS({
  "node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/legacy.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials();
    var { EventEmitter: EE } = require_events();
    function Stream3(opts) {
      EE.call(this, opts);
    }
    ObjectSetPrototypeOf(Stream3.prototype, EE.prototype);
    ObjectSetPrototypeOf(Stream3, EE);
    Stream3.prototype.pipe = function(dest, options) {
      const source = this;
      function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
          source.pause();
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      let didOnEnd = false;
      function onend() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          this.emit("error", er);
        }
      }
      prependListener(source, "error", onerror);
      prependListener(dest, "error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (ArrayIsArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    module.exports = {
      Stream: Stream3,
      prependListener
    };
  }
});

// node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js
var require_add_abort_signal = __commonJS({
  "node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var { AbortError, codes } = require_errors();
    var { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils();
    var eos = require_end_of_stream();
    var { ERR_INVALID_ARG_TYPE } = codes;
    var validateAbortSignal = (signal, name) => {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    };
    module.exports.addAbortSignal = function addAbortSignal(signal, stream) {
      validateAbortSignal(signal, "signal");
      if (!isNodeStream(stream) && !isWebStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      return module.exports.addAbortSignalNoValidate(signal, stream);
    };
    module.exports.addAbortSignalNoValidate = function(signal, stream) {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
      }
      const onAbort = isNodeStream(stream) ? () => {
        stream.destroy(
          new AbortError(void 0, {
            cause: signal.reason
          })
        );
      } : () => {
        stream[kControllerErrorFunction](
          new AbortError(void 0, {
            cause: signal.reason
          })
        );
      };
      if (signal.aborted) {
        onAbort();
      } else {
        signal.addEventListener("abort", onAbort);
        eos(stream, () => signal.removeEventListener("abort", onAbort));
      }
      return stream;
    };
  }
});

// node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials();
    var { Buffer } = require_buffer_polyfill();
    var { inspect } = require_util();
    module.exports = class BufferList {
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      push(v) {
        const entry = {
          data: v,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
      unshift(v) {
        const entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        const ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
      clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
      join(s) {
        if (this.length === 0)
          return "";
        let p = this.head;
        let ret = "" + p.data;
        while ((p = p.next) !== null)
          ret += s + p.data;
        return ret;
      }
      concat(n) {
        if (this.length === 0)
          return Buffer.alloc(0);
        const ret = Buffer.allocUnsafe(n >>> 0);
        let p = this.head;
        let i = 0;
        while (p) {
          TypedArrayPrototypeSet(ret, p.data, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
      consume(n, hasStrings) {
        const data = this.head.data;
        if (n < data.length) {
          const slice = data.slice(0, n);
          this.head.data = data.slice(n);
          return slice;
        }
        if (n === data.length) {
          return this.shift();
        }
        return hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      first() {
        return this.head.data;
      }
      *[SymbolIterator]() {
        for (let p = this.head; p; p = p.next) {
          yield p.data;
        }
      }
      // Consumes a specified amount of characters from the buffered data.
      _getString(n) {
        let ret = "";
        let p = this.head;
        let c = 0;
        do {
          const str = p.data;
          if (n > str.length) {
            ret += str;
            n -= str.length;
          } else {
            if (n === str.length) {
              ret += str;
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              ret += StringPrototypeSlice(str, 0, n);
              this.head = p;
              p.data = StringPrototypeSlice(str, n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
      _getBuffer(n) {
        const ret = Buffer.allocUnsafe(n);
        const retLen = n;
        let p = this.head;
        let c = 0;
        do {
          const buf = p.data;
          if (n > buf.length) {
            TypedArrayPrototypeSet(ret, buf, retLen - n);
            n -= buf.length;
          } else {
            if (n === buf.length) {
              TypedArrayPrototypeSet(ret, buf, retLen - n);
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n), retLen - n);
              this.head = p;
              p.data = buf.slice(n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
      [Symbol.for("nodejs.util.inspect.custom")](_, options) {
        return inspect(this, {
          ...options,
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        });
      }
    };
  }
});

// node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var { MathFloor, NumberIsInteger } = require_primordials();
    var { ERR_INVALID_ARG_VALUE } = require_errors().codes;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getDefaultHighWaterMark(objectMode) {
      return objectMode ? 16 : 16 * 1024;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!NumberIsInteger(hwm) || hwm < 0) {
          const name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
          throw new ERR_INVALID_ARG_VALUE(name, hwm);
        }
        return MathFloor(hwm);
      }
      return getDefaultHighWaterMark(state.objectMode);
    }
    module.exports = {
      getHighWaterMark,
      getDefaultHighWaterMark
    };
  }
});

// node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/from.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var process2 = require_browser();
    var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials();
    var { Buffer } = require_buffer_polyfill();
    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = require_errors().codes;
    function from(Readable5, iterable, opts) {
      let iterator;
      if (typeof iterable === "string" || iterable instanceof Buffer) {
        return new Readable5({
          objectMode: true,
          ...opts,
          read() {
            this.push(iterable);
            this.push(null);
          }
        });
      }
      let isAsync;
      if (iterable && iterable[SymbolAsyncIterator]) {
        isAsync = true;
        iterator = iterable[SymbolAsyncIterator]();
      } else if (iterable && iterable[SymbolIterator]) {
        isAsync = false;
        iterator = iterable[SymbolIterator]();
      } else {
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      }
      const readable = new Readable5({
        objectMode: true,
        highWaterMark: 1,
        // TODO(ronag): What options should be allowed?
        ...opts
      });
      let reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      readable._destroy = function(error, cb) {
        PromisePrototypeThen(
          close2(error),
          () => process2.nextTick(cb, error),
          // nextTick is here in case cb throws
          (e) => process2.nextTick(cb, e || error)
        );
      };
      async function close2(error) {
        const hadError = error !== void 0 && error !== null;
        const hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
          const { value, done } = await iterator.throw(error);
          await value;
          if (done) {
            return;
          }
        }
        if (typeof iterator.return === "function") {
          const { value } = await iterator.return();
          await value;
        }
      }
      async function next() {
        for (; ; ) {
          try {
            const { value, done } = isAsync ? await iterator.next() : iterator.next();
            if (done) {
              readable.push(null);
            } else {
              const res = value && typeof value.then === "function" ? await value : value;
              if (res === null) {
                reading = false;
                throw new ERR_STREAM_NULL_VALUES();
              } else if (readable.push(res)) {
                continue;
              } else {
                reading = false;
              }
            }
          } catch (err) {
            readable.destroy(err);
          }
          break;
        }
      }
      return readable;
    }
    module.exports = from;
  }
});

// node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/readable.js
var require_readable = __commonJS({
  "node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/readable.js"(exports, module) {
    var import_dist159 = __toESM(require_dist());
    var process2 = require_browser();
    var {
      ArrayPrototypeIndexOf,
      NumberIsInteger,
      NumberIsNaN,
      NumberParseInt,
      ObjectDefineProperties,
      ObjectKeys,
      ObjectSetPrototypeOf,
      Promise: Promise2,
      SafeSet,
      SymbolAsyncIterator,
      Symbol: Symbol2
    } = require_primordials();
    module.exports = Readable5;
    Readable5.ReadableState = ReadableState;
    var { EventEmitter: EE } = require_events();
    var { Stream: Stream3, prependListener } = require_legacy();
    var { Buffer } = require_buffer_polyfill();
    var { addAbortSignal } = require_add_abort_signal();
    var eos = require_end_of_stream();
    var debug = require_util().debuglog("stream", (fn) => {
      debug = fn;
    });
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE,
        ERR_METHOD_NOT_IMPLEMENTED,
        ERR_OUT_OF_RANGE,
        ERR_STREAM_PUSH_AFTER_EOF,
        ERR_STREAM_UNSHIFT_AFTER_END_EVENT
      }
    } = require_errors();
    var { validateObject } = require_validators();
    var kPaused = Symbol2("kPaused");
    var { StringDecoder } = require_string_decoder();
    var from = require_from();
    ObjectSetPrototypeOf(Readable5.prototype, Stream3.prototype);
    ObjectSetPrototypeOf(Readable5, Stream3);
    var nop = () => {
    };
    var { errorOrDestroy } = destroyImpl;
    function ReadableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      this.objectMode = !!(options && options.objectMode);
      if (isDuplex)
        this.objectMode = this.objectMode || !!(options && options.readableObjectMode);
      this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = [];
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.constructed = true;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this[kPaused] = null;
      this.errorEmitted = false;
      this.emitClose = !options || options.emitClose !== false;
      this.autoDestroy = !options || options.autoDestroy !== false;
      this.destroyed = false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.awaitDrainWriters = null;
      this.multiAwaitDrain = false;
      this.readingMore = false;
      this.dataEmitted = false;
      this.decoder = null;
      this.encoding = null;
      if (options && options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable5(options) {
      if (!(this instanceof Readable5))
        return new Readable5(options);
      const isDuplex = this instanceof require_duplex();
      this._readableState = new ReadableState(options, this, isDuplex);
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal && !isDuplex)
          addAbortSignal(options.signal, this);
      }
      Stream3.call(this, options);
      destroyImpl.construct(this, () => {
        if (this._readableState.needReadable) {
          maybeReadMore(this, this._readableState);
        }
      });
    }
    Readable5.prototype.destroy = destroyImpl.destroy;
    Readable5.prototype._undestroy = destroyImpl.undestroy;
    Readable5.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable5.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    Readable5.prototype.push = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, false);
    };
    Readable5.prototype.unshift = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, true);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront) {
      debug("readableAddChunk", chunk);
      const state = stream._readableState;
      let err;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (state.encoding !== encoding) {
            if (addToFront && state.encoding) {
              chunk = Buffer.from(chunk, encoding).toString(state.encoding);
            } else {
              chunk = Buffer.from(chunk, encoding);
              encoding = "";
            }
          }
        } else if (chunk instanceof Buffer) {
          encoding = "";
        } else if (Stream3._isUint8Array(chunk)) {
          chunk = Stream3._uint8ArrayToBuffer(chunk);
          encoding = "";
        } else if (chunk != null) {
          err = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      if (err) {
        errorOrDestroy(stream, err);
      } else if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (addToFront) {
          if (state.endEmitted)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else if (state.destroyed || state.errored)
            return false;
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed || state.errored) {
          return false;
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
        if (state.multiAwaitDrain) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
        state.dataEmitted = true;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    Readable5.prototype.isPaused = function() {
      const state = this._readableState;
      return state[kPaused] === true || state.flowing === false;
    };
    Readable5.prototype.setEncoding = function(enc) {
      const decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      const buffer = this._readableState.buffer;
      let content = "";
      for (const data of buffer) {
        content += decoder.write(data);
      }
      buffer.clear();
      if (content !== "")
        buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n > MAX_HWM) {
        throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n);
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (NumberIsNaN(n)) {
        if (state.flowing && state.length)
          return state.buffer.first().length;
        return state.length;
      }
      if (n <= state.length)
        return n;
      return state.ended ? state.length : 0;
    }
    Readable5.prototype.read = function(n) {
      debug("read", n);
      if (n === void 0) {
        n = NaN;
      } else if (!NumberIsInteger(n)) {
        n = NumberParseInt(n, 10);
      }
      const state = this._readableState;
      const nOrig = n;
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      let doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
        doRead = false;
        debug("reading, ended or constructing", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        try {
          this._read(state.highWaterMark);
        } catch (err) {
          errorOrDestroy(this, err);
        }
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      let ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        if (state.multiAwaitDrain) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
        state.dataEmitted = true;
        this.emit("data", ret);
      }
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        const chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
    function emitReadable(stream) {
      const state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process2.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      const state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && !state.errored && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore && state.constructed) {
        state.readingMore = true;
        process2.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        const len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable5.prototype._read = function(n) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
    };
    Readable5.prototype.pipe = function(dest, pipeOpts) {
      const src = this;
      const state = this._readableState;
      if (state.pipes.length === 1) {
        if (!state.multiAwaitDrain) {
          state.multiAwaitDrain = true;
          state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
        }
      }
      state.pipes.push(dest);
      debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
      const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process2.stdout && dest !== process2.stderr;
      const endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process2.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      let ondrain;
      let cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        if (ondrain) {
          dest.removeListener("drain", ondrain);
        }
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      function pause() {
        if (!cleanedUp) {
          if (state.pipes.length === 1 && state.pipes[0] === dest) {
            debug("false write response, pause", 0);
            state.awaitDrainWriters = dest;
            state.multiAwaitDrain = false;
          } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
            debug("false write response, pause", state.awaitDrainWriters.size);
            state.awaitDrainWriters.add(dest);
          }
          src.pause();
        }
        if (!ondrain) {
          ondrain = pipeOnDrain(src, dest);
          dest.on("drain", ondrain);
        }
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        const ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (dest.listenerCount("error") === 0) {
          const s = dest._writableState || dest._readableState;
          if (s && !s.errorEmitted) {
            errorOrDestroy(dest, er);
          } else {
            dest.emit("error", er);
          }
        }
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (dest.writableNeedDrain === true) {
        if (state.flowing) {
          pause();
        }
      } else if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src, dest) {
      return function pipeOnDrainFunctionResult() {
        const state = src._readableState;
        if (state.awaitDrainWriters === dest) {
          debug("pipeOnDrain", 1);
          state.awaitDrainWriters = null;
        } else if (state.multiAwaitDrain) {
          debug("pipeOnDrain", state.awaitDrainWriters.size);
          state.awaitDrainWriters.delete(dest);
        }
        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data")) {
          src.resume();
        }
      };
    }
    Readable5.prototype.unpipe = function(dest) {
      const state = this._readableState;
      const unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipes.length === 0)
        return this;
      if (!dest) {
        const dests = state.pipes;
        state.pipes = [];
        this.pause();
        for (let i = 0; i < dests.length; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      const index = ArrayPrototypeIndexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      if (state.pipes.length === 0)
        this.pause();
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable5.prototype.on = function(ev, fn) {
      const res = Stream3.prototype.on.call(this, ev, fn);
      const state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process2.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable5.prototype.addListener = Readable5.prototype.on;
    Readable5.prototype.removeListener = function(ev, fn) {
      const res = Stream3.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process2.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable5.prototype.off = Readable5.prototype.removeListener;
    Readable5.prototype.removeAllListeners = function(ev) {
      const res = Stream3.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process2.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self) {
      const state = self._readableState;
      state.readableListening = self.listenerCount("readable") > 0;
      if (state.resumeScheduled && state[kPaused] === false) {
        state.flowing = true;
      } else if (self.listenerCount("data") > 0) {
        self.resume();
      } else if (!state.readableListening) {
        state.flowing = null;
      }
    }
    function nReadingNextTick(self) {
      debug("readable nexttick read 0");
      self.read(0);
    }
    Readable5.prototype.resume = function() {
      const state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state[kPaused] = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process2.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable5.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState[kPaused] = true;
      return this;
    };
    function flow(stream) {
      const state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable5.prototype.wrap = function(stream) {
      let paused = false;
      stream.on("data", (chunk) => {
        if (!this.push(chunk) && stream.pause) {
          paused = true;
          stream.pause();
        }
      });
      stream.on("end", () => {
        this.push(null);
      });
      stream.on("error", (err) => {
        errorOrDestroy(this, err);
      });
      stream.on("close", () => {
        this.destroy();
      });
      stream.on("destroy", () => {
        this.destroy();
      });
      this._read = () => {
        if (paused && stream.resume) {
          paused = false;
          stream.resume();
        }
      };
      const streamKeys = ObjectKeys(stream);
      for (let j = 1; j < streamKeys.length; j++) {
        const i = streamKeys[j];
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = stream[i].bind(stream);
        }
      }
      return this;
    };
    Readable5.prototype[SymbolAsyncIterator] = function() {
      return streamToAsyncIterator(this);
    };
    Readable5.prototype.iterator = function(options) {
      if (options !== void 0) {
        validateObject(options, "options");
      }
      return streamToAsyncIterator(this, options);
    };
    function streamToAsyncIterator(stream, options) {
      if (typeof stream.read !== "function") {
        stream = Readable5.wrap(stream, {
          objectMode: true
        });
      }
      const iter = createAsyncIterator(stream, options);
      iter.stream = stream;
      return iter;
    }
    async function* createAsyncIterator(stream, options) {
      let callback = nop;
      function next(resolve) {
        if (this === stream) {
          callback();
          callback = nop;
        } else {
          callback = resolve;
        }
      }
      stream.on("readable", next);
      let error;
      const cleanup = eos(
        stream,
        {
          writable: false
        },
        (err) => {
          error = err ? aggregateTwoErrors(error, err) : null;
          callback();
          callback = nop;
        }
      );
      try {
        while (true) {
          const chunk = stream.destroyed ? null : stream.read();
          if (chunk !== null) {
            yield chunk;
          } else if (error) {
            throw error;
          } else if (error === null) {
            return;
          } else {
            await new Promise2(next);
          }
        }
      } catch (err) {
        error = aggregateTwoErrors(error, err);
        throw error;
      } finally {
        if ((error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) && (error === void 0 || stream._readableState.autoDestroy)) {
          destroyImpl.destroyer(stream, null);
        } else {
          stream.off("readable", next);
          cleanup();
        }
      }
    }
    ObjectDefineProperties(Readable5.prototype, {
      readable: {
        __proto__: null,
        get() {
          const r = this._readableState;
          return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
        },
        set(val) {
          if (this._readableState) {
            this._readableState.readable = !!val;
          }
        }
      },
      readableDidRead: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.dataEmitted;
        }
      },
      readableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
        }
      },
      readableHighWaterMark: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.highWaterMark;
        }
      },
      readableBuffer: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState && this._readableState.buffer;
        }
      },
      readableFlowing: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.flowing;
        },
        set: function(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      },
      readableLength: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState.length;
        }
      },
      readableObjectMode: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.objectMode : false;
        }
      },
      readableEncoding: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.encoding : null;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.errored : null;
        }
      },
      closed: {
        __proto__: null,
        get() {
          return this._readableState ? this._readableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.destroyed : false;
        },
        set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      },
      readableEnded: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.endEmitted : false;
        }
      }
    });
    ObjectDefineProperties(ReadableState.prototype, {
      // Legacy getter for `pipesCount`.
      pipesCount: {
        __proto__: null,
        get() {
          return this.pipes.length;
        }
      },
      // Legacy property for `paused`.
      paused: {
        __proto__: null,
        get() {
          return this[kPaused] !== false;
        },
        set(value) {
          this[kPaused] = !!value;
        }
      }
    });
    Readable5._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      let ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      const state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process2.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.emit("end");
        if (stream.writable && stream.allowHalfOpen === false) {
          process2.nextTick(endWritableNT, stream);
        } else if (state.autoDestroy) {
          const wState = stream._writableState;
          const autoDestroy = !wState || wState.autoDestroy && // We don't expect the writable to ever 'finish'
          // if writable is explicitly set to false.
          (wState.finished || wState.writable === false);
          if (autoDestroy) {
            stream.destroy();
          }
        }
      }
    }
    function endWritableNT(stream) {
      const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
      if (writable) {
        stream.end();
      }
    }
    Readable5.from = function(iterable, opts) {
      return from(Readable5, iterable, opts);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Readable5.fromWeb = function(readableStream, options) {
      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
    };
    Readable5.toWeb = function(streamReadable, options) {
      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
    };
    Readable5.wrap = function(src, options) {
      var _ref, _src$readableObjectMo;
      return new Readable5({
        objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 ? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 ? _ref : true,
        ...options,
        destroy(err, callback) {
          destroyImpl.destroyer(src, err);
          callback(err);
        }
      }).wrap(src);
    };
  }
});

// node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/writable.js
var require_writable = __commonJS({
  "node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/writable.js"(exports, module) {
    var import_dist159 = __toESM(require_dist());
    var process2 = require_browser();
    var {
      ArrayPrototypeSlice,
      Error: Error2,
      FunctionPrototypeSymbolHasInstance,
      ObjectDefineProperty,
      ObjectDefineProperties,
      ObjectSetPrototypeOf,
      StringPrototypeToLowerCase,
      Symbol: Symbol2,
      SymbolHasInstance
    } = require_primordials();
    module.exports = Writable;
    Writable.WritableState = WritableState;
    var { EventEmitter: EE } = require_events();
    var Stream3 = require_legacy().Stream;
    var { Buffer } = require_buffer_polyfill();
    var destroyImpl = require_destroy();
    var { addAbortSignal } = require_add_abort_signal();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
    var {
      ERR_INVALID_ARG_TYPE,
      ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK,
      ERR_STREAM_CANNOT_PIPE,
      ERR_STREAM_DESTROYED,
      ERR_STREAM_ALREADY_FINISHED,
      ERR_STREAM_NULL_VALUES,
      ERR_STREAM_WRITE_AFTER_END,
      ERR_UNKNOWN_ENCODING
    } = require_errors().codes;
    var { errorOrDestroy } = destroyImpl;
    ObjectSetPrototypeOf(Writable.prototype, Stream3.prototype);
    ObjectSetPrototypeOf(Writable, Stream3);
    function nop() {
    }
    var kOnFinished = Symbol2("kOnFinished");
    function WritableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      this.objectMode = !!(options && options.objectMode);
      if (isDuplex)
        this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
      this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      const noDecode = !!(options && options.decodeStrings === false);
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = onwrite.bind(void 0, stream);
      this.writecb = null;
      this.writelen = 0;
      this.afterWriteTickInfo = null;
      resetBuffer(this);
      this.pendingcb = 0;
      this.constructed = true;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = !options || options.emitClose !== false;
      this.autoDestroy = !options || options.autoDestroy !== false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this[kOnFinished] = [];
    }
    function resetBuffer(state) {
      state.buffered = [];
      state.bufferedIndex = 0;
      state.allBuffers = true;
      state.allNoop = true;
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
    };
    ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
      __proto__: null,
      get() {
        return this.buffered.length - this.bufferedIndex;
      }
    });
    function Writable(options) {
      const isDuplex = this instanceof require_duplex();
      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal)
          addAbortSignal(options.signal, this);
      }
      Stream3.call(this, options);
      destroyImpl.construct(this, () => {
        const state = this._writableState;
        if (!state.writing) {
          clearBuffer(this, state);
        }
        finishMaybe(this, state);
      });
    }
    ObjectDefineProperty(Writable, SymbolHasInstance, {
      __proto__: null,
      value: function(object) {
        if (FunctionPrototypeSymbolHasInstance(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function _write(stream, chunk, encoding, cb) {
      const state = stream._writableState;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = state.defaultEncoding;
      } else {
        if (!encoding)
          encoding = state.defaultEncoding;
        else if (encoding !== "buffer" && !Buffer.isEncoding(encoding))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        if (typeof cb !== "function")
          cb = nop;
      }
      if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
      } else if (!state.objectMode) {
        if (typeof chunk === "string") {
          if (state.decodeStrings !== false) {
            chunk = Buffer.from(chunk, encoding);
            encoding = "buffer";
          }
        } else if (chunk instanceof Buffer) {
          encoding = "buffer";
        } else if (Stream3._isUint8Array(chunk)) {
          chunk = Stream3._uint8ArrayToBuffer(chunk);
          encoding = "buffer";
        } else {
          throw new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      let err;
      if (state.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END();
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("write");
      }
      if (err) {
        process2.nextTick(cb, err);
        errorOrDestroy(stream, err, true);
        return err;
      }
      state.pendingcb++;
      return writeOrBuffer(stream, state, chunk, encoding, cb);
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      return _write(this, chunk, encoding, cb) === true;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      const state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = StringPrototypeToLowerCase(encoding);
      if (!Buffer.isEncoding(encoding))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function writeOrBuffer(stream, state, chunk, encoding, callback) {
      const len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      const ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked || state.errored || !state.constructed) {
        state.buffered.push({
          chunk,
          encoding,
          callback
        });
        if (state.allBuffers && encoding !== "buffer") {
          state.allBuffers = false;
        }
        if (state.allNoop && callback !== nop) {
          state.allNoop = false;
        }
      } else {
        state.writelen = len;
        state.writecb = callback;
        state.writing = true;
        state.sync = true;
        stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      return ret && !state.errored && !state.destroyed;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, er, cb) {
      --state.pendingcb;
      cb(er);
      errorBuffer(state);
      errorOrDestroy(stream, er);
    }
    function onwrite(stream, er) {
      const state = stream._writableState;
      const sync = state.sync;
      const cb = state.writecb;
      if (typeof cb !== "function") {
        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
        return;
      }
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
      if (er) {
        er.stack;
        if (!state.errored) {
          state.errored = er;
        }
        if (stream._readableState && !stream._readableState.errored) {
          stream._readableState.errored = er;
        }
        if (sync) {
          process2.nextTick(onwriteError, stream, state, er, cb);
        } else {
          onwriteError(stream, state, er, cb);
        }
      } else {
        if (state.buffered.length > state.bufferedIndex) {
          clearBuffer(stream, state);
        }
        if (sync) {
          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
            state.afterWriteTickInfo.count++;
          } else {
            state.afterWriteTickInfo = {
              count: 1,
              cb,
              stream,
              state
            };
            process2.nextTick(afterWriteTick, state.afterWriteTickInfo);
          }
        } else {
          afterWrite(stream, state, 1, cb);
        }
      }
    }
    function afterWriteTick({ stream, state, count, cb }) {
      state.afterWriteTickInfo = null;
      return afterWrite(stream, state, count, cb);
    }
    function afterWrite(stream, state, count, cb) {
      const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
      if (needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
      while (count-- > 0) {
        state.pendingcb--;
        cb();
      }
      if (state.destroyed) {
        errorBuffer(state);
      }
      finishMaybe(stream, state);
    }
    function errorBuffer(state) {
      if (state.writing) {
        return;
      }
      for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {
        var _state$errored;
        const { chunk, callback } = state.buffered[n];
        const len = state.objectMode ? 1 : chunk.length;
        state.length -= len;
        callback(
          (_state$errored = state.errored) !== null && _state$errored !== void 0 ? _state$errored : new ERR_STREAM_DESTROYED("write")
        );
      }
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        var _state$errored2;
        onfinishCallbacks[i](
          (_state$errored2 = state.errored) !== null && _state$errored2 !== void 0 ? _state$errored2 : new ERR_STREAM_DESTROYED("end")
        );
      }
      resetBuffer(state);
    }
    function clearBuffer(stream, state) {
      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
        return;
      }
      const { buffered, bufferedIndex, objectMode } = state;
      const bufferedLength = buffered.length - bufferedIndex;
      if (!bufferedLength) {
        return;
      }
      let i = bufferedIndex;
      state.bufferProcessing = true;
      if (bufferedLength > 1 && stream._writev) {
        state.pendingcb -= bufferedLength - 1;
        const callback = state.allNoop ? nop : (err) => {
          for (let n = i; n < buffered.length; ++n) {
            buffered[n].callback(err);
          }
        };
        const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
        chunks.allBuffers = state.allBuffers;
        doWrite(stream, state, true, state.length, chunks, "", callback);
        resetBuffer(state);
      } else {
        do {
          const { chunk, encoding, callback } = buffered[i];
          buffered[i++] = null;
          const len = objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, callback);
        } while (i < buffered.length && !state.writing);
        if (i === buffered.length) {
          resetBuffer(state);
        } else if (i > 256) {
          buffered.splice(0, i);
          state.bufferedIndex = 0;
        } else {
          state.bufferedIndex = i;
        }
      }
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      if (this._writev) {
        this._writev(
          [
            {
              chunk,
              encoding
            }
          ],
          cb
        );
      } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
      }
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      const state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      let err;
      if (chunk !== null && chunk !== void 0) {
        const ret = _write(this, chunk, encoding);
        if (ret instanceof Error2) {
          err = ret;
        }
      }
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (err) {
      } else if (!state.errored && !state.ending) {
        state.ending = true;
        finishMaybe(this, state, true);
        state.ended = true;
      } else if (state.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED("end");
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("end");
      }
      if (typeof cb === "function") {
        if (err || state.finished) {
          process2.nextTick(cb, err);
        } else {
          state[kOnFinished].push(cb);
        }
      }
      return this;
    };
    function needFinish(state) {
      return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
    }
    function callFinal(stream, state) {
      let called = false;
      function onFinish(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        state.pendingcb--;
        if (err) {
          const onfinishCallbacks = state[kOnFinished].splice(0);
          for (let i = 0; i < onfinishCallbacks.length; i++) {
            onfinishCallbacks[i](err);
          }
          errorOrDestroy(stream, err, state.sync);
        } else if (needFinish(state)) {
          state.prefinished = true;
          stream.emit("prefinish");
          state.pendingcb++;
          process2.nextTick(finish, stream, state);
        }
      }
      state.sync = true;
      state.pendingcb++;
      try {
        stream._final(onFinish);
      } catch (err) {
        onFinish(err);
      }
      state.sync = false;
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.finalCalled = true;
          callFinal(stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state, sync) {
      if (needFinish(state)) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          if (sync) {
            state.pendingcb++;
            process2.nextTick(
              (stream2, state2) => {
                if (needFinish(state2)) {
                  finish(stream2, state2);
                } else {
                  state2.pendingcb--;
                }
              },
              stream,
              state
            );
          } else if (needFinish(state)) {
            state.pendingcb++;
            finish(stream, state);
          }
        }
      }
    }
    function finish(stream, state) {
      state.pendingcb--;
      state.finished = true;
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i]();
      }
      stream.emit("finish");
      if (state.autoDestroy) {
        const rState = stream._readableState;
        const autoDestroy = !rState || rState.autoDestroy && // We don't expect the readable to ever 'end'
        // if readable is explicitly set to false.
        (rState.endEmitted || rState.readable === false);
        if (autoDestroy) {
          stream.destroy();
        }
      }
    }
    ObjectDefineProperties(Writable.prototype, {
      closed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.destroyed : false;
        },
        set(value) {
          if (this._writableState) {
            this._writableState.destroyed = value;
          }
        }
      },
      writable: {
        __proto__: null,
        get() {
          const w = this._writableState;
          return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
        },
        set(val) {
          if (this._writableState) {
            this._writableState.writable = !!val;
          }
        }
      },
      writableFinished: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.finished : false;
        }
      },
      writableObjectMode: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.objectMode : false;
        }
      },
      writableBuffer: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.getBuffer();
        }
      },
      writableEnded: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.ending : false;
        }
      },
      writableNeedDrain: {
        __proto__: null,
        get() {
          const wState = this._writableState;
          if (!wState)
            return false;
          return !wState.destroyed && !wState.ending && wState.needDrain;
        }
      },
      writableHighWaterMark: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.highWaterMark;
        }
      },
      writableCorked: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.corked : 0;
        }
      },
      writableLength: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.length;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._writableState ? this._writableState.errored : null;
        }
      },
      writableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
        }
      }
    });
    var destroy = destroyImpl.destroy;
    Writable.prototype.destroy = function(err, cb) {
      const state = this._writableState;
      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
        process2.nextTick(errorBuffer, state);
      }
      destroy.call(this, err, cb);
      return this;
    };
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Writable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Writable.fromWeb = function(writableStream, options) {
      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
    };
    Writable.toWeb = function(streamWritable) {
      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
    };
  }
});

// node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/duplexify.js
var require_duplexify = __commonJS({
  "node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/duplexify.js"(exports, module) {
    var import_dist159 = __toESM(require_dist());
    var process2 = require_browser();
    var bufferModule = require_buffer_polyfill();
    var {
      isReadable,
      isWritable,
      isIterable,
      isNodeStream,
      isReadableNodeStream,
      isWritableNodeStream,
      isDuplexNodeStream
    } = require_utils();
    var eos = require_end_of_stream();
    var {
      AbortError,
      codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE }
    } = require_errors();
    var { destroyer } = require_destroy();
    var Duplex = require_duplex();
    var Readable5 = require_readable();
    var { createDeferredPromise } = require_util();
    var from = require_from();
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b) {
      return b instanceof Blob2;
    } : function isBlob2(b) {
      return false;
    };
    var AbortController = globalThis.AbortController || require_browser3().AbortController;
    var { FunctionPrototypeCall } = require_primordials();
    var Duplexify = class extends Duplex {
      constructor(options) {
        super(options);
        if ((options === null || options === void 0 ? void 0 : options.readable) === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if ((options === null || options === void 0 ? void 0 : options.writable) === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      }
    };
    module.exports = function duplexify(body, name) {
      if (isDuplexNodeStream(body)) {
        return body;
      }
      if (isReadableNodeStream(body)) {
        return _duplexify({
          readable: body
        });
      }
      if (isWritableNodeStream(body)) {
        return _duplexify({
          writable: body
        });
      }
      if (isNodeStream(body)) {
        return _duplexify({
          writable: false,
          readable: false
        });
      }
      if (typeof body === "function") {
        const { value, write, final, destroy } = fromAsyncGen(body);
        if (isIterable(value)) {
          return from(Duplexify, value, {
            // TODO (ronag): highWaterMark?
            objectMode: true,
            write,
            final,
            destroy
          });
        }
        const then2 = value === null || value === void 0 ? void 0 : value.then;
        if (typeof then2 === "function") {
          let d;
          const promise = FunctionPrototypeCall(
            then2,
            value,
            (val) => {
              if (val != null) {
                throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
              }
            },
            (err) => {
              destroyer(d, err);
            }
          );
          return d = new Duplexify({
            // TODO (ronag): highWaterMark?
            objectMode: true,
            readable: false,
            write,
            final(cb) {
              final(async () => {
                try {
                  await promise;
                  process2.nextTick(cb, null);
                } catch (err) {
                  process2.nextTick(cb, err);
                }
              });
            },
            destroy
          });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
      }
      if (isBlob(body)) {
        return duplexify(body.arrayBuffer());
      }
      if (isIterable(body)) {
        return from(Duplexify, body, {
          // TODO (ronag): highWaterMark?
          objectMode: true,
          writable: false
        });
      }
      if (typeof (body === null || body === void 0 ? void 0 : body.writable) === "object" || typeof (body === null || body === void 0 ? void 0 : body.readable) === "object") {
        const readable = body !== null && body !== void 0 && body.readable ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable) ? body === null || body === void 0 ? void 0 : body.readable : duplexify(body.readable) : void 0;
        const writable = body !== null && body !== void 0 && body.writable ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable) ? body === null || body === void 0 ? void 0 : body.writable : duplexify(body.writable) : void 0;
        return _duplexify({
          readable,
          writable
        });
      }
      const then = body === null || body === void 0 ? void 0 : body.then;
      if (typeof then === "function") {
        let d;
        FunctionPrototypeCall(
          then,
          body,
          (val) => {
            if (val != null) {
              d.push(val);
            }
            d.push(null);
          },
          (err) => {
            destroyer(d, err);
          }
        );
        return d = new Duplexify({
          objectMode: true,
          writable: false,
          read() {
          }
        });
      }
      throw new ERR_INVALID_ARG_TYPE(
        name,
        [
          "Blob",
          "ReadableStream",
          "WritableStream",
          "Stream",
          "Iterable",
          "AsyncIterable",
          "Function",
          "{ readable, writable } pair",
          "Promise"
        ],
        body
      );
    };
    function fromAsyncGen(fn) {
      let { promise, resolve } = createDeferredPromise();
      const ac = new AbortController();
      const signal = ac.signal;
      const value = fn(
        async function* () {
          while (true) {
            const _promise = promise;
            promise = null;
            const { chunk, done, cb } = await _promise;
            process2.nextTick(cb);
            if (done)
              return;
            if (signal.aborted)
              throw new AbortError(void 0, {
                cause: signal.reason
              });
            ({ promise, resolve } = createDeferredPromise());
            yield chunk;
          }
        }(),
        {
          signal
        }
      );
      return {
        value,
        write(chunk, encoding, cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            chunk,
            done: false,
            cb
          });
        },
        final(cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            done: true,
            cb
          });
        },
        destroy(err, cb) {
          ac.abort();
          cb(err);
        }
      };
    }
    function _duplexify(pair) {
      const r = pair.readable && typeof pair.readable.read !== "function" ? Readable5.wrap(pair.readable) : pair.readable;
      const w = pair.writable;
      let readable = !!isReadable(r);
      let writable = !!isWritable(w);
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        }
      }
      d = new Duplexify({
        // TODO (ronag): highWaterMark?
        readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),
        writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),
        readable,
        writable
      });
      if (writable) {
        eos(w, (err) => {
          writable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        d._write = function(chunk, encoding, callback) {
          if (w.write(chunk, encoding)) {
            callback();
          } else {
            ondrain = callback;
          }
        };
        d._final = function(callback) {
          w.end();
          onfinish = callback;
        };
        w.on("drain", function() {
          if (ondrain) {
            const cb = ondrain;
            ondrain = null;
            cb();
          }
        });
        w.on("finish", function() {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        eos(r, (err) => {
          readable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        r.on("readable", function() {
          if (onreadable) {
            const cb = onreadable;
            onreadable = null;
            cb();
          }
        });
        r.on("end", function() {
          d.push(null);
        });
        d._read = function() {
          while (true) {
            const buf = r.read();
            if (buf === null) {
              onreadable = d._read;
              return;
            }
            if (!d.push(buf)) {
              return;
            }
          }
        };
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          destroyer(w, err);
          destroyer(r, err);
        }
      };
      return d;
    }
  }
});

// node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/duplex.js
var require_duplex = __commonJS({
  "node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/duplex.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var {
      ObjectDefineProperties,
      ObjectGetOwnPropertyDescriptor,
      ObjectKeys,
      ObjectSetPrototypeOf
    } = require_primordials();
    module.exports = Duplex;
    var Readable5 = require_readable();
    var Writable = require_writable();
    ObjectSetPrototypeOf(Duplex.prototype, Readable5.prototype);
    ObjectSetPrototypeOf(Duplex, Readable5);
    {
      const keys = ObjectKeys(Writable.prototype);
      for (let i = 0; i < keys.length; i++) {
        const method = keys[i];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable5.call(this, options);
      Writable.call(this, options);
      if (options) {
        this.allowHalfOpen = options.allowHalfOpen !== false;
        if (options.readable === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if (options.writable === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      } else {
        this.allowHalfOpen = true;
      }
    }
    ObjectDefineProperties(Duplex.prototype, {
      writable: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable")
      },
      writableHighWaterMark: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark")
      },
      writableObjectMode: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode")
      },
      writableBuffer: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer")
      },
      writableLength: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength")
      },
      writableFinished: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished")
      },
      writableCorked: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked")
      },
      writableEnded: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded")
      },
      writableNeedDrain: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain")
      },
      destroyed: {
        __proto__: null,
        get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set(value) {
          if (this._readableState && this._writableState) {
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
          }
        }
      }
    });
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Duplex.fromWeb = function(pair, options) {
      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
    };
    Duplex.toWeb = function(duplex) {
      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
    };
    var duplexify;
    Duplex.from = function(body) {
      if (!duplexify) {
        duplexify = require_duplexify();
      }
      return duplexify(body, "body");
    };
  }
});

// node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/transform.js
var require_transform = __commonJS({
  "node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/transform.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();
    module.exports = Transform;
    var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors().codes;
    var Duplex = require_duplex();
    var { getHighWaterMark } = require_state();
    ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
    ObjectSetPrototypeOf(Transform, Duplex);
    var kCallback = Symbol2("kCallback");
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
      if (readableHighWaterMark === 0) {
        options = {
          ...options,
          highWaterMark: null,
          readableHighWaterMark,
          // TODO (ronag): 0 is not optimal since we have
          // a "bug" where we check needDrain before calling _write and not after.
          // Refs: https://github.com/nodejs/node/pull/32887
          // Refs: https://github.com/nodejs/node/pull/35941
          writableHighWaterMark: options.writableHighWaterMark || 0
        };
      }
      Duplex.call(this, options);
      this._readableState.sync = false;
      this[kCallback] = null;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function final(cb) {
      if (typeof this._flush === "function" && !this.destroyed) {
        this._flush((er, data) => {
          if (er) {
            if (cb) {
              cb(er);
            } else {
              this.destroy(er);
            }
            return;
          }
          if (data != null) {
            this.push(data);
          }
          this.push(null);
          if (cb) {
            cb();
          }
        });
      } else {
        this.push(null);
        if (cb) {
          cb();
        }
      }
    }
    function prefinish() {
      if (this._final !== final) {
        final.call(this);
      }
    }
    Transform.prototype._final = final;
    Transform.prototype._transform = function(chunk, encoding, callback) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
    };
    Transform.prototype._write = function(chunk, encoding, callback) {
      const rState = this._readableState;
      const wState = this._writableState;
      const length = rState.length;
      this._transform(chunk, encoding, (err, val) => {
        if (err) {
          callback(err);
          return;
        }
        if (val != null) {
          this.push(val);
        }
        if (wState.ended || // Backwards compat.
        length === rState.length || // Backwards compat.
        rState.length < rState.highWaterMark) {
          callback();
        } else {
          this[kCallback] = callback;
        }
      });
    };
    Transform.prototype._read = function() {
      if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
      }
    };
  }
});

// node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/passthrough.js
var require_passthrough = __commonJS({
  "node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/passthrough.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var { ObjectSetPrototypeOf } = require_primordials();
    module.exports = PassThrough;
    var Transform = require_transform();
    ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);
    ObjectSetPrototypeOf(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
    var import_dist159 = __toESM(require_dist());
    var process2 = require_browser();
    var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator } = require_primordials();
    var eos = require_end_of_stream();
    var { once } = require_util();
    var destroyImpl = require_destroy();
    var Duplex = require_duplex();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE,
        ERR_INVALID_RETURN_VALUE,
        ERR_MISSING_ARGS,
        ERR_STREAM_DESTROYED,
        ERR_STREAM_PREMATURE_CLOSE
      },
      AbortError
    } = require_errors();
    var { validateFunction, validateAbortSignal } = require_validators();
    var {
      isIterable,
      isReadable,
      isReadableNodeStream,
      isNodeStream,
      isTransformStream,
      isWebStream,
      isReadableStream,
      isReadableEnded
    } = require_utils();
    var AbortController = globalThis.AbortController || require_browser3().AbortController;
    var PassThrough;
    var Readable5;
    function destroyer(stream, reading, writing) {
      let finished = false;
      stream.on("close", () => {
        finished = true;
      });
      const cleanup = eos(
        stream,
        {
          readable: reading,
          writable: writing
        },
        (err) => {
          finished = !err;
        }
      );
      return {
        destroy: (err) => {
          if (finished)
            return;
          finished = true;
          destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
        },
        cleanup
      };
    }
    function popCallback(streams) {
      validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
      return streams.pop();
    }
    function makeAsyncIterable(val) {
      if (isIterable(val)) {
        return val;
      } else if (isReadableNodeStream(val)) {
        return fromReadable(val);
      }
      throw new ERR_INVALID_ARG_TYPE("val", ["Readable", "Iterable", "AsyncIterable"], val);
    }
    async function* fromReadable(val) {
      if (!Readable5) {
        Readable5 = require_readable();
      }
      yield* Readable5.prototype[SymbolAsyncIterator].call(val);
    }
    async function pumpToNode(iterable, writable, finish, { end }) {
      let error;
      let onresolve = null;
      const resume = (err) => {
        if (err) {
          error = err;
        }
        if (onresolve) {
          const callback = onresolve;
          onresolve = null;
          callback();
        }
      };
      const wait = () => new Promise2((resolve, reject) => {
        if (error) {
          reject(error);
        } else {
          onresolve = () => {
            if (error) {
              reject(error);
            } else {
              resolve();
            }
          };
        }
      });
      writable.on("drain", resume);
      const cleanup = eos(
        writable,
        {
          readable: false
        },
        resume
      );
      try {
        if (writable.writableNeedDrain) {
          await wait();
        }
        for await (const chunk of iterable) {
          if (!writable.write(chunk)) {
            await wait();
          }
        }
        if (end) {
          writable.end();
        }
        await wait();
        finish();
      } catch (err) {
        finish(error !== err ? aggregateTwoErrors(error, err) : err);
      } finally {
        cleanup();
        writable.off("drain", resume);
      }
    }
    async function pumpToWeb(readable, writable, finish, { end }) {
      if (isTransformStream(writable)) {
        writable = writable.writable;
      }
      const writer = writable.getWriter();
      try {
        for await (const chunk of readable) {
          await writer.ready;
          writer.write(chunk).catch(() => {
          });
        }
        await writer.ready;
        if (end) {
          await writer.close();
        }
        finish();
      } catch (err) {
        try {
          await writer.abort(err);
          finish(err);
        } catch (err2) {
          finish(err2);
        }
      }
    }
    function pipeline(...streams) {
      return pipelineImpl(streams, once(popCallback(streams)));
    }
    function pipelineImpl(streams, callback, opts) {
      if (streams.length === 1 && ArrayIsArray(streams[0])) {
        streams = streams[0];
      }
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      const ac = new AbortController();
      const signal = ac.signal;
      const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;
      const lastStreamCleanup = [];
      validateAbortSignal(outerSignal, "options.signal");
      function abort() {
        finishImpl(new AbortError());
      }
      outerSignal === null || outerSignal === void 0 ? void 0 : outerSignal.addEventListener("abort", abort);
      let error;
      let value;
      const destroys = [];
      let finishCount = 0;
      function finish(err) {
        finishImpl(err, --finishCount === 0);
      }
      function finishImpl(err, final) {
        if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
          error = err;
        }
        if (!error && !final) {
          return;
        }
        while (destroys.length) {
          destroys.shift()(error);
        }
        outerSignal === null || outerSignal === void 0 ? void 0 : outerSignal.removeEventListener("abort", abort);
        ac.abort();
        if (final) {
          if (!error) {
            lastStreamCleanup.forEach((fn) => fn());
          }
          process2.nextTick(callback, error, value);
        }
      }
      let ret;
      for (let i = 0; i < streams.length; i++) {
        const stream = streams[i];
        const reading = i < streams.length - 1;
        const writing = i > 0;
        const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;
        const isLastStream = i === streams.length - 1;
        if (isNodeStream(stream)) {
          let onError2 = function(err) {
            if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              finish(err);
            }
          };
          var onError = onError2;
          if (end) {
            const { destroy, cleanup } = destroyer(stream, reading, writing);
            destroys.push(destroy);
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
          stream.on("error", onError2);
          if (isReadable(stream) && isLastStream) {
            lastStreamCleanup.push(() => {
              stream.removeListener("error", onError2);
            });
          }
        }
        if (i === 0) {
          if (typeof stream === "function") {
            ret = stream({
              signal
            });
            if (!isIterable(ret)) {
              throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
            }
          } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
            ret = stream;
          } else {
            ret = Duplex.from(stream);
          }
        } else if (typeof stream === "function") {
          if (isTransformStream(ret)) {
            var _ret;
            ret = makeAsyncIterable((_ret = ret) === null || _ret === void 0 ? void 0 : _ret.readable);
          } else {
            ret = makeAsyncIterable(ret);
          }
          ret = stream(ret, {
            signal
          });
          if (reading) {
            if (!isIterable(ret, true)) {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
            }
          } else {
            var _ret2;
            if (!PassThrough) {
              PassThrough = require_passthrough();
            }
            const pt = new PassThrough({
              objectMode: true
            });
            const then = (_ret2 = ret) === null || _ret2 === void 0 ? void 0 : _ret2.then;
            if (typeof then === "function") {
              finishCount++;
              then.call(
                ret,
                (val) => {
                  value = val;
                  if (val != null) {
                    pt.write(val);
                  }
                  if (end) {
                    pt.end();
                  }
                  process2.nextTick(finish);
                },
                (err) => {
                  pt.destroy(err);
                  process2.nextTick(finish, err);
                }
              );
            } else if (isIterable(ret, true)) {
              finishCount++;
              pumpToNode(ret, pt, finish, {
                end
              });
            } else if (isReadableStream(ret) || isTransformStream(ret)) {
              const toRead = ret.readable || ret;
              finishCount++;
              pumpToNode(toRead, pt, finish, {
                end
              });
            } else {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
            }
            ret = pt;
            const { destroy, cleanup } = destroyer(ret, false, true);
            destroys.push(destroy);
            if (isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
        } else if (isNodeStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount += 2;
            const cleanup = pipe(ret, stream, finish, {
              end
            });
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          } else if (isTransformStream(ret) || isReadableStream(ret)) {
            const toRead = ret.readable || ret;
            finishCount++;
            pumpToNode(toRead, stream, finish, {
              end
            });
          } else if (isIterable(ret)) {
            finishCount++;
            pumpToNode(ret, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else if (isWebStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount++;
            pumpToWeb(makeAsyncIterable(ret), stream, finish, {
              end
            });
          } else if (isReadableStream(ret) || isIterable(ret)) {
            finishCount++;
            pumpToWeb(ret, stream, finish, {
              end
            });
          } else if (isTransformStream(ret)) {
            finishCount++;
            pumpToWeb(ret.readable, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else {
          ret = Duplex.from(stream);
        }
      }
      if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted) {
        process2.nextTick(abort);
      }
      return ret;
    }
    function pipe(src, dst, finish, { end }) {
      let ended = false;
      dst.on("close", () => {
        if (!ended) {
          finish(new ERR_STREAM_PREMATURE_CLOSE());
        }
      });
      src.pipe(dst, {
        end: false
      });
      if (end) {
        let endFn2 = function() {
          ended = true;
          dst.end();
        };
        var endFn = endFn2;
        if (isReadableEnded(src)) {
          process2.nextTick(endFn2);
        } else {
          src.once("end", endFn2);
        }
      } else {
        finish();
      }
      eos(
        src,
        {
          readable: true,
          writable: false
        },
        (err) => {
          const rState = src._readableState;
          if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
            src.once("end", finish).once("error", finish);
          } else {
            finish(err);
          }
        }
      );
      return eos(
        dst,
        {
          readable: false,
          writable: true
        },
        finish
      );
    }
    module.exports = {
      pipelineImpl,
      pipeline
    };
  }
});

// node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/compose.js
var require_compose = __commonJS({
  "node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/compose.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var { pipeline } = require_pipeline();
    var Duplex = require_duplex();
    var { destroyer } = require_destroy();
    var {
      isNodeStream,
      isReadable,
      isWritable,
      isWebStream,
      isTransformStream,
      isWritableStream,
      isReadableStream
    } = require_utils();
    var {
      AbortError,
      codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
    } = require_errors();
    var eos = require_end_of_stream();
    module.exports = function compose(...streams) {
      if (streams.length === 0) {
        throw new ERR_MISSING_ARGS("streams");
      }
      if (streams.length === 1) {
        return Duplex.from(streams[0]);
      }
      const orgStreams = [...streams];
      if (typeof streams[0] === "function") {
        streams[0] = Duplex.from(streams[0]);
      }
      if (typeof streams[streams.length - 1] === "function") {
        const idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
      }
      for (let n = 0; n < streams.length; ++n) {
        if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {
          continue;
        }
        if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
        }
        if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
        }
      }
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        } else if (!readable && !writable) {
          d.destroy();
        }
      }
      const head = streams[0];
      const tail = pipeline(streams, onfinished);
      const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
      const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));
      d = new Duplex({
        // TODO (ronag): highWaterMark?
        writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),
        readableObjectMode: !!(tail !== null && tail !== void 0 && tail.writableObjectMode),
        writable,
        readable
      });
      if (writable) {
        if (isNodeStream(head)) {
          d._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding)) {
              callback();
            } else {
              ondrain = callback;
            }
          };
          d._final = function(callback) {
            head.end();
            onfinish = callback;
          };
          head.on("drain", function() {
            if (ondrain) {
              const cb = ondrain;
              ondrain = null;
              cb();
            }
          });
        } else if (isWebStream(head)) {
          const writable2 = isTransformStream(head) ? head.writable : head;
          const writer = writable2.getWriter();
          d._write = async function(chunk, encoding, callback) {
            try {
              await writer.ready;
              writer.write(chunk).catch(() => {
              });
              callback();
            } catch (err) {
              callback(err);
            }
          };
          d._final = async function(callback) {
            try {
              await writer.ready;
              writer.close().catch(() => {
              });
              onfinish = callback;
            } catch (err) {
              callback(err);
            }
          };
        }
        const toRead = isTransformStream(tail) ? tail.readable : tail;
        eos(toRead, () => {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        if (isNodeStream(tail)) {
          tail.on("readable", function() {
            if (onreadable) {
              const cb = onreadable;
              onreadable = null;
              cb();
            }
          });
          tail.on("end", function() {
            d.push(null);
          });
          d._read = function() {
            while (true) {
              const buf = tail.read();
              if (buf === null) {
                onreadable = d._read;
                return;
              }
              if (!d.push(buf)) {
                return;
              }
            }
          };
        } else if (isWebStream(tail)) {
          const readable2 = isTransformStream(tail) ? tail.readable : tail;
          const reader = readable2.getReader();
          d._read = async function() {
            while (true) {
              try {
                const { value, done } = await reader.read();
                if (!d.push(value)) {
                  return;
                }
                if (done) {
                  d.push(null);
                  return;
                }
              } catch {
                return;
              }
            }
          };
        }
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          if (isNodeStream(tail)) {
            destroyer(tail, err);
          }
        }
      };
      return d;
    };
  }
});

// node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/operators.js
var require_operators = __commonJS({
  "node_modules/@tbdex/protocol/node_modules/readable-stream/lib/internal/streams/operators.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var AbortController = globalThis.AbortController || require_browser3().AbortController;
    var {
      codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
      AbortError
    } = require_errors();
    var { validateAbortSignal, validateInteger, validateObject } = require_validators();
    var kWeakHandler = require_primordials().Symbol("kWeak");
    var { finished } = require_end_of_stream();
    var staticCompose = require_compose();
    var { addAbortSignalNoValidate } = require_add_abort_signal();
    var { isWritable, isNodeStream } = require_utils();
    var {
      ArrayPrototypePush,
      MathFloor,
      Number: Number2,
      NumberIsNaN,
      Promise: Promise2,
      PromiseReject,
      PromisePrototypeThen,
      Symbol: Symbol2
    } = require_primordials();
    var kEmpty = Symbol2("kEmpty");
    var kEof = Symbol2("kEof");
    function compose(stream, options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      if (isNodeStream(stream) && !isWritable(stream)) {
        throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
      }
      const composedStream = staticCompose(this, stream);
      if (options !== null && options !== void 0 && options.signal) {
        addAbortSignalNoValidate(options.signal, composedStream);
      }
      return composedStream;
    }
    function map(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let concurrency = 1;
      if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {
        concurrency = MathFloor(options.concurrency);
      }
      validateInteger(concurrency, "concurrency", 1);
      return (async function* map2() {
        var _options$signal, _options$signal2;
        const ac = new AbortController();
        const stream = this;
        const queue = [];
        const signal = ac.signal;
        const signalOpt = {
          signal
        };
        const abort = () => ac.abort();
        if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted) {
          abort();
        }
        options === null || options === void 0 ? void 0 : (_options$signal2 = options.signal) === null || _options$signal2 === void 0 ? void 0 : _options$signal2.addEventListener("abort", abort);
        let next;
        let resume;
        let done = false;
        function onDone() {
          done = true;
        }
        async function pump() {
          try {
            for await (let val of stream) {
              var _val;
              if (done) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              try {
                val = fn(val, signalOpt);
              } catch (err) {
                val = PromiseReject(err);
              }
              if (val === kEmpty) {
                continue;
              }
              if (typeof ((_val = val) === null || _val === void 0 ? void 0 : _val.catch) === "function") {
                val.catch(onDone);
              }
              queue.push(val);
              if (next) {
                next();
                next = null;
              }
              if (!done && queue.length && queue.length >= concurrency) {
                await new Promise2((resolve) => {
                  resume = resolve;
                });
              }
            }
            queue.push(kEof);
          } catch (err) {
            const val = PromiseReject(err);
            PromisePrototypeThen(val, void 0, onDone);
            queue.push(val);
          } finally {
            var _options$signal3;
            done = true;
            if (next) {
              next();
              next = null;
            }
            options === null || options === void 0 ? void 0 : (_options$signal3 = options.signal) === null || _options$signal3 === void 0 ? void 0 : _options$signal3.removeEventListener("abort", abort);
          }
        }
        pump();
        try {
          while (true) {
            while (queue.length > 0) {
              const val = await queue[0];
              if (val === kEof) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              if (val !== kEmpty) {
                yield val;
              }
              queue.shift();
              if (resume) {
                resume();
                resume = null;
              }
            }
            await new Promise2((resolve) => {
              next = resolve;
            });
          }
        } finally {
          ac.abort();
          done = true;
          if (resume) {
            resume();
            resume = null;
          }
        }
      }).call(this);
    }
    function asIndexedPairs(options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      return (async function* asIndexedPairs2() {
        let index = 0;
        for await (const val of this) {
          var _options$signal4;
          if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted) {
            throw new AbortError({
              cause: options.signal.reason
            });
          }
          yield [index++, val];
        }
      }).call(this);
    }
    async function some(fn, options = void 0) {
      for await (const unused of filter.call(this, fn, options)) {
        return true;
      }
      return false;
    }
    async function every(fn, options = void 0) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      return !await some.call(
        this,
        async (...args) => {
          return !await fn(...args);
        },
        options
      );
    }
    async function find(fn, options) {
      for await (const result of filter.call(this, fn, options)) {
        return result;
      }
      return void 0;
    }
    async function forEach(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      async function forEachFn(value, options2) {
        await fn(value, options2);
        return kEmpty;
      }
      for await (const unused of map.call(this, forEachFn, options))
        ;
    }
    function filter(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      async function filterFn(value, options2) {
        if (await fn(value, options2)) {
          return value;
        }
        return kEmpty;
      }
      return map.call(this, filterFn, options);
    }
    var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function reduce(reducer, initialValue, options) {
      var _options$signal5;
      if (typeof reducer !== "function") {
        throw new ERR_INVALID_ARG_TYPE("reducer", ["Function", "AsyncFunction"], reducer);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let hasInitialValue = arguments.length > 1;
      if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) {
        const err = new AbortError(void 0, {
          cause: options.signal.reason
        });
        this.once("error", () => {
        });
        await finished(this.destroy(err));
        throw err;
      }
      const ac = new AbortController();
      const signal = ac.signal;
      if (options !== null && options !== void 0 && options.signal) {
        const opts = {
          once: true,
          [kWeakHandler]: this
        };
        options.signal.addEventListener("abort", () => ac.abort(), opts);
      }
      let gotAnyItemFromStream = false;
      try {
        for await (const value of this) {
          var _options$signal6;
          gotAnyItemFromStream = true;
          if (options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted) {
            throw new AbortError();
          }
          if (!hasInitialValue) {
            initialValue = value;
            hasInitialValue = true;
          } else {
            initialValue = await reducer(initialValue, value, {
              signal
            });
          }
        }
        if (!gotAnyItemFromStream && !hasInitialValue) {
          throw new ReduceAwareErrMissingArgs();
        }
      } finally {
        ac.abort();
      }
      return initialValue;
    }
    async function toArray(options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      const result = [];
      for await (const val of this) {
        var _options$signal7;
        if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted) {
          throw new AbortError(void 0, {
            cause: options.signal.reason
          });
        }
        ArrayPrototypePush(result, val);
      }
      return result;
    }
    function flatMap(fn, options) {
      const values = map.call(this, fn, options);
      return (async function* flatMap2() {
        for await (const val of values) {
          yield* val;
        }
      }).call(this);
    }
    function toIntegerOrInfinity(number) {
      number = Number2(number);
      if (NumberIsNaN(number)) {
        return 0;
      }
      if (number < 0) {
        throw new ERR_OUT_OF_RANGE("number", ">= 0", number);
      }
      return number;
    }
    function drop(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return (async function* drop2() {
        var _options$signal8;
        if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal9;
          if (options !== null && options !== void 0 && (_options$signal9 = options.signal) !== null && _options$signal9 !== void 0 && _options$signal9.aborted) {
            throw new AbortError();
          }
          if (number-- <= 0) {
            yield val;
          }
        }
      }).call(this);
    }
    function take(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return (async function* take2() {
        var _options$signal10;
        if (options !== null && options !== void 0 && (_options$signal10 = options.signal) !== null && _options$signal10 !== void 0 && _options$signal10.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal11;
          if (options !== null && options !== void 0 && (_options$signal11 = options.signal) !== null && _options$signal11 !== void 0 && _options$signal11.aborted) {
            throw new AbortError();
          }
          if (number-- > 0) {
            yield val;
          } else {
            return;
          }
        }
      }).call(this);
    }
    module.exports.streamReturningOperators = {
      asIndexedPairs,
      drop,
      filter,
      flatMap,
      map,
      take,
      compose
    };
    module.exports.promiseReturningOperators = {
      every,
      forEach,
      reduce,
      toArray,
      some,
      find
    };
  }
});

// node_modules/@tbdex/protocol/node_modules/readable-stream/lib/stream/promises.js
var require_promises = __commonJS({
  "node_modules/@tbdex/protocol/node_modules/readable-stream/lib/stream/promises.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials();
    var { isIterable, isNodeStream, isWebStream } = require_utils();
    var { pipelineImpl: pl } = require_pipeline();
    var { finished } = require_end_of_stream();
    require_stream();
    function pipeline(...streams) {
      return new Promise2((resolve, reject) => {
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
          const options = ArrayPrototypePop(streams);
          signal = options.signal;
          end = options.end;
        }
        pl(
          streams,
          (err, value) => {
            if (err) {
              reject(err);
            } else {
              resolve(value);
            }
          },
          {
            signal,
            end
          }
        );
      });
    }
    module.exports = {
      finished,
      pipeline
    };
  }
});

// node_modules/@tbdex/protocol/node_modules/readable-stream/lib/stream.js
var require_stream = __commonJS({
  "node_modules/@tbdex/protocol/node_modules/readable-stream/lib/stream.js"(exports, module) {
    var import_dist159 = __toESM(require_dist());
    var { Buffer } = require_buffer_polyfill();
    var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials();
    var {
      promisify: { custom: customPromisify }
    } = require_util();
    var { streamReturningOperators, promiseReturningOperators } = require_operators();
    var {
      codes: { ERR_ILLEGAL_CONSTRUCTOR }
    } = require_errors();
    var compose = require_compose();
    var { pipeline } = require_pipeline();
    var { destroyer } = require_destroy();
    var eos = require_end_of_stream();
    var promises = require_promises();
    var utils = require_utils();
    var Stream3 = module.exports = require_legacy().Stream;
    Stream3.isDisturbed = utils.isDisturbed;
    Stream3.isErrored = utils.isErrored;
    Stream3.isReadable = utils.isReadable;
    Stream3.Readable = require_readable();
    for (const key of ObjectKeys(streamReturningOperators)) {
      let fn2 = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return Stream3.Readable.from(ReflectApply(op, this, args));
      };
      fn = fn2;
      const op = streamReturningOperators[key];
      ObjectDefineProperty(fn2, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn2, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream3.Readable.prototype, key, {
        __proto__: null,
        value: fn2,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    var fn;
    for (const key of ObjectKeys(promiseReturningOperators)) {
      let fn2 = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return ReflectApply(op, this, args);
      };
      fn = fn2;
      const op = promiseReturningOperators[key];
      ObjectDefineProperty(fn2, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn2, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream3.Readable.prototype, key, {
        __proto__: null,
        value: fn2,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    var fn;
    Stream3.Writable = require_writable();
    Stream3.Duplex = require_duplex();
    Stream3.Transform = require_transform();
    Stream3.PassThrough = require_passthrough();
    Stream3.pipeline = pipeline;
    var { addAbortSignal } = require_add_abort_signal();
    Stream3.addAbortSignal = addAbortSignal;
    Stream3.finished = eos;
    Stream3.destroy = destroyer;
    Stream3.compose = compose;
    ObjectDefineProperty(Stream3, "promises", {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    ObjectDefineProperty(pipeline, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.pipeline;
      }
    });
    ObjectDefineProperty(eos, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.finished;
      }
    });
    Stream3.Stream = Stream3;
    Stream3._isUint8Array = function isUint8Array(value) {
      return value instanceof Uint8Array;
    };
    Stream3._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
      return Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    };
  }
});

// node_modules/@tbdex/protocol/node_modules/readable-stream/lib/ours/browser.js
var require_browser4 = __commonJS({
  "node_modules/@tbdex/protocol/node_modules/readable-stream/lib/ours/browser.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var CustomStream = require_stream();
    var promises = require_promises();
    var originalDestroy = CustomStream.Readable.destroy;
    module.exports = CustomStream.Readable;
    module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
    module.exports._isUint8Array = CustomStream._isUint8Array;
    module.exports.isDisturbed = CustomStream.isDisturbed;
    module.exports.isErrored = CustomStream.isErrored;
    module.exports.isReadable = CustomStream.isReadable;
    module.exports.Readable = CustomStream.Readable;
    module.exports.Writable = CustomStream.Writable;
    module.exports.Duplex = CustomStream.Duplex;
    module.exports.Transform = CustomStream.Transform;
    module.exports.PassThrough = CustomStream.PassThrough;
    module.exports.addAbortSignal = CustomStream.addAbortSignal;
    module.exports.finished = CustomStream.finished;
    module.exports.destroy = CustomStream.destroy;
    module.exports.destroy = originalDestroy;
    module.exports.pipeline = CustomStream.pipeline;
    module.exports.compose = CustomStream.compose;
    Object.defineProperty(CustomStream, "promises", {
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    module.exports.Stream = CustomStream.Stream;
    module.exports.default = module.exports;
  }
});

// node_modules/@tbdex/protocol/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/@tbdex/protocol/node_modules/ms/index.js"(exports, module) {
    var import_dist159 = __toESM(require_dist());
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms4) {
      var msAbs = Math.abs(ms4);
      if (msAbs >= d) {
        return Math.round(ms4 / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms4 / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms4 / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms4 / s) + "s";
      }
      return ms4 + "ms";
    }
    function fmtLong(ms4) {
      var msAbs = Math.abs(ms4);
      if (msAbs >= d) {
        return plural(ms4, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms4, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms4, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms4, msAbs, s, "second");
      }
      return ms4 + " ms";
    }
    function plural(ms4, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms4 / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/@tbdex/http-client/node_modules/readable-stream/lib/ours/primordials.js
var require_primordials2 = __commonJS({
  "node_modules/@tbdex/http-client/node_modules/readable-stream/lib/ours/primordials.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    module.exports = {
      ArrayIsArray(self) {
        return Array.isArray(self);
      },
      ArrayPrototypeIncludes(self, el) {
        return self.includes(el);
      },
      ArrayPrototypeIndexOf(self, el) {
        return self.indexOf(el);
      },
      ArrayPrototypeJoin(self, sep) {
        return self.join(sep);
      },
      ArrayPrototypeMap(self, fn) {
        return self.map(fn);
      },
      ArrayPrototypePop(self, el) {
        return self.pop(el);
      },
      ArrayPrototypePush(self, el) {
        return self.push(el);
      },
      ArrayPrototypeSlice(self, start, end) {
        return self.slice(start, end);
      },
      Error,
      FunctionPrototypeCall(fn, thisArgs, ...args) {
        return fn.call(thisArgs, ...args);
      },
      FunctionPrototypeSymbolHasInstance(self, instance) {
        return Function.prototype[Symbol.hasInstance].call(self, instance);
      },
      MathFloor: Math.floor,
      Number,
      NumberIsInteger: Number.isInteger,
      NumberIsNaN: Number.isNaN,
      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
      NumberParseInt: Number.parseInt,
      ObjectDefineProperties(self, props) {
        return Object.defineProperties(self, props);
      },
      ObjectDefineProperty(self, name, prop) {
        return Object.defineProperty(self, name, prop);
      },
      ObjectGetOwnPropertyDescriptor(self, name) {
        return Object.getOwnPropertyDescriptor(self, name);
      },
      ObjectKeys(obj) {
        return Object.keys(obj);
      },
      ObjectSetPrototypeOf(target, proto) {
        return Object.setPrototypeOf(target, proto);
      },
      Promise,
      PromisePrototypeCatch(self, fn) {
        return self.catch(fn);
      },
      PromisePrototypeThen(self, thenFn, catchFn) {
        return self.then(thenFn, catchFn);
      },
      PromiseReject(err) {
        return Promise.reject(err);
      },
      ReflectApply: Reflect.apply,
      RegExpPrototypeTest(self, value) {
        return self.test(value);
      },
      SafeSet: Set,
      String,
      StringPrototypeSlice(self, start, end) {
        return self.slice(start, end);
      },
      StringPrototypeToLowerCase(self) {
        return self.toLowerCase();
      },
      StringPrototypeToUpperCase(self) {
        return self.toUpperCase();
      },
      StringPrototypeTrim(self) {
        return self.trim();
      },
      Symbol,
      SymbolFor: Symbol.for,
      SymbolAsyncIterator: Symbol.asyncIterator,
      SymbolHasInstance: Symbol.hasInstance,
      SymbolIterator: Symbol.iterator,
      TypedArrayPrototypeSet(self, buf, len) {
        return self.set(buf, len);
      },
      Uint8Array
    };
  }
});

// node_modules/@tbdex/http-client/node_modules/readable-stream/lib/ours/util.js
var require_util2 = __commonJS({
  "node_modules/@tbdex/http-client/node_modules/readable-stream/lib/ours/util.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var bufferModule = require_buffer_polyfill();
    var AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b) {
      return b instanceof Blob2;
    } : function isBlob2(b) {
      return false;
    };
    var AggregateError = class extends Error {
      constructor(errors) {
        if (!Array.isArray(errors)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        }
        let message2 = "";
        for (let i = 0; i < errors.length; i++) {
          message2 += `    ${errors[i].stack}
`;
        }
        super(message2);
        this.name = "AggregateError";
        this.errors = errors;
      }
    };
    module.exports = {
      AggregateError,
      kEmptyObject: Object.freeze({}),
      once(callback) {
        let called = false;
        return function(...args) {
          if (called) {
            return;
          }
          called = true;
          callback.apply(this, args);
        };
      },
      createDeferredPromise: function() {
        let resolve;
        let reject;
        const promise = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        });
        return {
          promise,
          resolve,
          reject
        };
      },
      promisify(fn) {
        return new Promise((resolve, reject) => {
          fn((err, ...args) => {
            if (err) {
              return reject(err);
            }
            return resolve(...args);
          });
        });
      },
      debuglog() {
        return function() {
        };
      },
      format(format, ...args) {
        return format.replace(/%([sdifj])/g, function(...[_unused, type]) {
          const replacement = args.shift();
          if (type === "f") {
            return replacement.toFixed(6);
          } else if (type === "j") {
            return JSON.stringify(replacement);
          } else if (type === "s" && typeof replacement === "object") {
            const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
            return `${ctor} {}`.trim();
          } else {
            return replacement.toString();
          }
        });
      },
      inspect(value) {
        switch (typeof value) {
          case "string":
            if (value.includes("'")) {
              if (!value.includes('"')) {
                return `"${value}"`;
              } else if (!value.includes("`") && !value.includes("${")) {
                return `\`${value}\``;
              }
            }
            return `'${value}'`;
          case "number":
            if (isNaN(value)) {
              return "NaN";
            } else if (Object.is(value, -0)) {
              return String(value);
            }
            return value;
          case "bigint":
            return `${String(value)}n`;
          case "boolean":
          case "undefined":
            return String(value);
          case "object":
            return "{}";
        }
      },
      types: {
        isAsyncFunction(fn) {
          return fn instanceof AsyncFunction;
        },
        isArrayBufferView(arr) {
          return ArrayBuffer.isView(arr);
        }
      },
      isBlob
    };
    module.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  }
});

// node_modules/@tbdex/http-client/node_modules/readable-stream/lib/ours/errors.js
var require_errors2 = __commonJS({
  "node_modules/@tbdex/http-client/node_modules/readable-stream/lib/ours/errors.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var { format, inspect, AggregateError: CustomAggregateError } = require_util2();
    var AggregateError = globalThis.AggregateError || CustomAggregateError;
    var kIsNodeError = Symbol("kIsNodeError");
    var kTypes = [
      "string",
      "function",
      "number",
      "object",
      // Accept 'Function' and 'Object' as alternative to the lower cased version.
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ];
    var classRegExp = /^([A-Z][a-z0-9]*)+$/;
    var nodeInternalPrefix = "__node_internal_";
    var codes = {};
    function assert(value, message2) {
      if (!value) {
        throw new codes.ERR_INTERNAL_ASSERTION(message2);
      }
    }
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function getMessage(key, msg, args) {
      if (typeof msg === "function") {
        assert(
          msg.length <= args.length,
          // Default options do not count.
          `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
        );
        return msg(...args);
      }
      const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
      assert(
        expectedLength === args.length,
        `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
      );
      if (args.length === 0) {
        return msg;
      }
      return format(msg, ...args);
    }
    function E(code, message2, Base) {
      if (!Base) {
        Base = Error;
      }
      class NodeError extends Base {
        constructor(...args) {
          super(getMessage(code, message2, args));
        }
        toString() {
          return `${this.name} [${code}]: ${this.message}`;
        }
      }
      Object.defineProperties(NodeError.prototype, {
        name: {
          value: Base.name,
          writable: true,
          enumerable: false,
          configurable: true
        },
        toString: {
          value() {
            return `${this.name} [${code}]: ${this.message}`;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      NodeError.prototype.code = code;
      NodeError.prototype[kIsNodeError] = true;
      codes[code] = NodeError;
    }
    function hideStackFrames(fn) {
      const hidden = nodeInternalPrefix + fn.name;
      Object.defineProperty(fn, "name", {
        value: hidden
      });
      return fn;
    }
    function aggregateTwoErrors(innerError, outerError) {
      if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
          outerError.errors.push(innerError);
          return outerError;
        }
        const err = new AggregateError([outerError, innerError], outerError.message);
        err.code = outerError.code;
        return err;
      }
      return innerError || outerError;
    }
    var AbortError = class extends Error {
      constructor(message2 = "The operation was aborted", options = void 0) {
        if (options !== void 0 && typeof options !== "object") {
          throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        super(message2, options);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    E("ERR_ASSERTION", "%s", Error);
    E(
      "ERR_INVALID_ARG_TYPE",
      (name, expected, actual) => {
        assert(typeof name === "string", "'name' must be a string");
        if (!Array.isArray(expected)) {
          expected = [expected];
        }
        let msg = "The ";
        if (name.endsWith(" argument")) {
          msg += `${name} `;
        } else {
          msg += `"${name}" ${name.includes(".") ? "property" : "argument"} `;
        }
        msg += "must be ";
        const types = [];
        const instances = [];
        const other = [];
        for (const value of expected) {
          assert(typeof value === "string", "All expected entries have to be of type string");
          if (kTypes.includes(value)) {
            types.push(value.toLowerCase());
          } else if (classRegExp.test(value)) {
            instances.push(value);
          } else {
            assert(value !== "object", 'The value "object" should be written as "Object"');
            other.push(value);
          }
        }
        if (instances.length > 0) {
          const pos = types.indexOf("object");
          if (pos !== -1) {
            types.splice(types, pos, 1);
            instances.push("Object");
          }
        }
        if (types.length > 0) {
          switch (types.length) {
            case 1:
              msg += `of type ${types[0]}`;
              break;
            case 2:
              msg += `one of type ${types[0]} or ${types[1]}`;
              break;
            default: {
              const last = types.pop();
              msg += `one of type ${types.join(", ")}, or ${last}`;
            }
          }
          if (instances.length > 0 || other.length > 0) {
            msg += " or ";
          }
        }
        if (instances.length > 0) {
          switch (instances.length) {
            case 1:
              msg += `an instance of ${instances[0]}`;
              break;
            case 2:
              msg += `an instance of ${instances[0]} or ${instances[1]}`;
              break;
            default: {
              const last = instances.pop();
              msg += `an instance of ${instances.join(", ")}, or ${last}`;
            }
          }
          if (other.length > 0) {
            msg += " or ";
          }
        }
        switch (other.length) {
          case 0:
            break;
          case 1:
            if (other[0].toLowerCase() !== other[0]) {
              msg += "an ";
            }
            msg += `${other[0]}`;
            break;
          case 2:
            msg += `one of ${other[0]} or ${other[1]}`;
            break;
          default: {
            const last = other.pop();
            msg += `one of ${other.join(", ")}, or ${last}`;
          }
        }
        if (actual == null) {
          msg += `. Received ${actual}`;
        } else if (typeof actual === "function" && actual.name) {
          msg += `. Received function ${actual.name}`;
        } else if (typeof actual === "object") {
          var _actual$constructor;
          if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name) {
            msg += `. Received an instance of ${actual.constructor.name}`;
          } else {
            const inspected = inspect(actual, {
              depth: -1
            });
            msg += `. Received ${inspected}`;
          }
        } else {
          let inspected = inspect(actual, {
            colors: false
          });
          if (inspected.length > 25) {
            inspected = `${inspected.slice(0, 25)}...`;
          }
          msg += `. Received type ${typeof actual} (${inspected})`;
        }
        return msg;
      },
      TypeError
    );
    E(
      "ERR_INVALID_ARG_VALUE",
      (name, value, reason = "is invalid") => {
        let inspected = inspect(value);
        if (inspected.length > 128) {
          inspected = inspected.slice(0, 128) + "...";
        }
        const type = name.includes(".") ? "property" : "argument";
        return `The ${type} '${name}' ${reason}. Received ${inspected}`;
      },
      TypeError
    );
    E(
      "ERR_INVALID_RETURN_VALUE",
      (input, name, value) => {
        var _value$constructor;
        const type = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
        return `Expected ${input} to be returned from the "${name}" function but got ${type}.`;
      },
      TypeError
    );
    E(
      "ERR_MISSING_ARGS",
      (...args) => {
        assert(args.length > 0, "At least one arg needs to be specified");
        let msg;
        const len = args.length;
        args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(" or ");
        switch (len) {
          case 1:
            msg += `The ${args[0]} argument`;
            break;
          case 2:
            msg += `The ${args[0]} and ${args[1]} arguments`;
            break;
          default:
            {
              const last = args.pop();
              msg += `The ${args.join(", ")}, and ${last} arguments`;
            }
            break;
        }
        return `${msg} must be specified`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      (str, range, input) => {
        assert(range, 'Missing "range" argument');
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > 2n ** 32n || input < -(2n ** 32n)) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        } else {
          received = inspect(input);
        }
        return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
      },
      RangeError
    );
    E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    E("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    E("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    E("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    E("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    E("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    E("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    E("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    E("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    E("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    module.exports = {
      AbortError,
      aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
      hideStackFrames,
      codes
    };
  }
});

// node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/validators.js
var require_validators2 = __commonJS({
  "node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/validators.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var {
      ArrayIsArray,
      ArrayPrototypeIncludes,
      ArrayPrototypeJoin,
      ArrayPrototypeMap,
      NumberIsInteger,
      NumberIsNaN,
      NumberMAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER,
      NumberParseInt,
      ObjectPrototypeHasOwnProperty,
      RegExpPrototypeExec,
      String: String2,
      StringPrototypeToUpperCase,
      StringPrototypeTrim
    } = require_primordials2();
    var {
      hideStackFrames,
      codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
    } = require_errors2();
    var { normalizeEncoding } = require_util2();
    var { isAsyncFunction, isArrayBufferView } = require_util2().types;
    var signals = {};
    function isInt32(value) {
      return value === (value | 0);
    }
    function isUint32(value) {
      return value === value >>> 0;
    }
    var octalReg = /^[0-7]+$/;
    var modeDesc = "must be a 32-bit unsigned integer or an octal string";
    function parseFileMode(value, name, def) {
      if (typeof value === "undefined") {
        value = def;
      }
      if (typeof value === "string") {
        if (RegExpPrototypeExec(octalReg, value) === null) {
          throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);
        }
        value = NumberParseInt(value, 8);
      }
      validateUint32(value, name);
      return value;
    }
    var validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      if (!NumberIsInteger(value))
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      if (value < min || value > max)
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    });
    var validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
      }
    });
    var validateUint32 = hideStackFrames((value, name, positive = false) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      const min = positive ? 1 : 0;
      const max = 4294967295;
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
      }
    });
    function validateString(value, name) {
      if (typeof value !== "string")
        throw new ERR_INVALID_ARG_TYPE(name, "string", value);
    }
    function validateNumber(value, name, min = void 0, max) {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value)) {
        throw new ERR_OUT_OF_RANGE(
          name,
          `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`,
          value
        );
      }
    }
    var validateOneOf = hideStackFrames((value, name, oneOf) => {
      if (!ArrayPrototypeIncludes(oneOf, value)) {
        const allowed = ArrayPrototypeJoin(
          ArrayPrototypeMap(oneOf, (v) => typeof v === "string" ? `'${v}'` : String2(v)),
          ", "
        );
        const reason = "must be one of: " + allowed;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateBoolean(value, name) {
      if (typeof value !== "boolean")
        throw new ERR_INVALID_ARG_TYPE(name, "boolean", value);
    }
    function getOwnPropertyValueOrDefault(options, key, defaultValue) {
      return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
    }
    var validateObject = hideStackFrames((value, name, options = null) => {
      const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
      const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
      const nullable = getOwnPropertyValueOrDefault(options, "nullable", false);
      if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new ERR_INVALID_ARG_TYPE(name, "Object", value);
      }
    });
    var validateDictionary = hideStackFrames((value, name) => {
      if (value != null && typeof value !== "object" && typeof value !== "function") {
        throw new ERR_INVALID_ARG_TYPE(name, "a dictionary", value);
      }
    });
    var validateArray = hideStackFrames((value, name, minLength = 0) => {
      if (!ArrayIsArray(value)) {
        throw new ERR_INVALID_ARG_TYPE(name, "Array", value);
      }
      if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateStringArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        validateString(value[i], `${name}[${i}]`);
      }
    }
    function validateBooleanArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        validateBoolean(value[i], `${name}[${i}]`);
      }
    }
    function validateSignalName(signal, name = "signal") {
      validateString(signal, name);
      if (signals[signal] === void 0) {
        if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {
          throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
        }
        throw new ERR_UNKNOWN_SIGNAL(signal);
      }
    }
    var validateBuffer = hideStackFrames((buffer, name = "buffer") => {
      if (!isArrayBufferView(buffer)) {
        throw new ERR_INVALID_ARG_TYPE(name, ["Buffer", "TypedArray", "DataView"], buffer);
      }
    });
    function validateEncoding(data, encoding) {
      const normalizedEncoding = normalizeEncoding(encoding);
      const length = data.length;
      if (normalizedEncoding === "hex" && length % 2 !== 0) {
        throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
      }
    }
    function validatePort(port, name = "Port", allowZero = true) {
      if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
        throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);
      }
      return port | 0;
    }
    var validateAbortSignal = hideStackFrames((signal, name) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    });
    var validateFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function")
        throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    });
    var validatePlainFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function" || isAsyncFunction(value))
        throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    });
    var validateUndefined = hideStackFrames((value, name) => {
      if (value !== void 0)
        throw new ERR_INVALID_ARG_TYPE(name, "undefined", value);
    });
    function validateUnion(value, name, union) {
      if (!ArrayPrototypeIncludes(union, value)) {
        throw new ERR_INVALID_ARG_TYPE(name, `('${ArrayPrototypeJoin(union, "|")}')`, value);
      }
    }
    var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function validateLinkHeaderFormat(value, name) {
      if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value)) {
        throw new ERR_INVALID_ARG_VALUE(
          name,
          value,
          'must be an array or string of format "</styles.css>; rel=preload; as=style"'
        );
      }
    }
    function validateLinkHeaderValue(hints) {
      if (typeof hints === "string") {
        validateLinkHeaderFormat(hints, "hints");
        return hints;
      } else if (ArrayIsArray(hints)) {
        const hintsLength = hints.length;
        let result = "";
        if (hintsLength === 0) {
          return result;
        }
        for (let i = 0; i < hintsLength; i++) {
          const link = hints[i];
          validateLinkHeaderFormat(link, "hints");
          result += link;
          if (i !== hintsLength - 1) {
            result += ", ";
          }
        }
        return result;
      }
      throw new ERR_INVALID_ARG_VALUE(
        "hints",
        hints,
        'must be an array or string of format "</styles.css>; rel=preload; as=style"'
      );
    }
    module.exports = {
      isInt32,
      isUint32,
      parseFileMode,
      validateArray,
      validateStringArray,
      validateBooleanArray,
      validateBoolean,
      validateBuffer,
      validateDictionary,
      validateEncoding,
      validateFunction,
      validateInt32,
      validateInteger,
      validateNumber,
      validateObject,
      validateOneOf,
      validatePlainFunction,
      validatePort,
      validateSignalName,
      validateString,
      validateUint32,
      validateUndefined,
      validateUnion,
      validateAbortSignal,
      validateLinkHeaderValue
    };
  }
});

// node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/utils.js
var require_utils2 = __commonJS({
  "node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/utils.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var { Symbol: Symbol2, SymbolAsyncIterator, SymbolIterator, SymbolFor } = require_primordials2();
    var kDestroyed = Symbol2("kDestroyed");
    var kIsErrored = Symbol2("kIsErrored");
    var kIsReadable = Symbol2("kIsReadable");
    var kIsDisturbed = Symbol2("kIsDisturbed");
    var kIsClosedPromise = SymbolFor("nodejs.webstream.isClosedPromise");
    var kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
    function isReadableNodeStream(obj, strict = false) {
      var _obj$_readableState;
      return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 ? void 0 : _obj$_readableState.readable) !== false) && // Duplex
      (!obj._writableState || obj._readableState));
    }
    function isWritableNodeStream(obj) {
      var _obj$_writableState;
      return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 ? void 0 : _obj$_writableState.writable) !== false));
    }
    function isDuplexNodeStream(obj) {
      return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
    }
    function isNodeStream(obj) {
      return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
    }
    function isReadableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
    }
    function isWritableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
    }
    function isTransformStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
    }
    function isWebStream(obj) {
      return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
    }
    function isIterable(obj, isAsync) {
      if (obj == null)
        return false;
      if (isAsync === true)
        return typeof obj[SymbolAsyncIterator] === "function";
      if (isAsync === false)
        return typeof obj[SymbolIterator] === "function";
      return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
    }
    function isDestroyed(stream) {
      if (!isNodeStream(stream))
        return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !!(stream.destroyed || stream[kDestroyed] || state !== null && state !== void 0 && state.destroyed);
    }
    function isWritableEnded(stream) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableEnded === true)
        return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored)
        return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== "boolean")
        return null;
      return wState.ended;
    }
    function isWritableFinished(stream, strict) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableFinished === true)
        return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored)
        return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== "boolean")
        return null;
      return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
    }
    function isReadableEnded(stream) {
      if (!isReadableNodeStream(stream))
        return null;
      if (stream.readableEnded === true)
        return true;
      const rState = stream._readableState;
      if (!rState || rState.errored)
        return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== "boolean")
        return null;
      return rState.ended;
    }
    function isReadableFinished(stream, strict) {
      if (!isReadableNodeStream(stream))
        return null;
      const rState = stream._readableState;
      if (rState !== null && rState !== void 0 && rState.errored)
        return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== "boolean")
        return null;
      return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
    }
    function isReadable(stream) {
      if (stream && stream[kIsReadable] != null)
        return stream[kIsReadable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
    }
    function isWritable(stream) {
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
    }
    function isFinished(stream, opts) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (isDestroyed(stream)) {
        return true;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable(stream)) {
        return false;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream)) {
        return false;
      }
      return true;
    }
    function isWritableErrored(stream) {
      var _stream$_writableStat, _stream$_writableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.writableErrored) {
        return stream.writableErrored;
      }
      return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0 ? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 ? _stream$_writableStat : null;
    }
    function isReadableErrored(stream) {
      var _stream$_readableStat, _stream$_readableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.readableErrored) {
        return stream.readableErrored;
      }
      return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0 ? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 ? _stream$_readableStat : null;
    }
    function isClosed(stream) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (typeof stream.closed === "boolean") {
        return stream.closed;
      }
      const wState = stream._writableState;
      const rState = stream._readableState;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === "boolean" || typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === "boolean") {
        return (wState === null || wState === void 0 ? void 0 : wState.closed) || (rState === null || rState === void 0 ? void 0 : rState.closed);
      }
      if (typeof stream._closed === "boolean" && isOutgoingMessage(stream)) {
        return stream._closed;
      }
      return null;
    }
    function isOutgoingMessage(stream) {
      return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
    }
    function isServerResponse(stream) {
      return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
    }
    function isServerRequest(stream) {
      var _stream$req;
      return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) === void 0;
    }
    function willEmitClose(stream) {
      if (!isNodeStream(stream))
        return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
    }
    function isDisturbed(stream) {
      var _stream$kIsDisturbed;
      return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
    }
    function isErrored(stream) {
      var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
      return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0 ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== void 0 ? _ref5 : stream.writableErrored) !== null && _ref4 !== void 0 ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0 ? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0 ? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0 ? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0 ? void 0 : _stream$_writableStat4.errored));
    }
    module.exports = {
      kDestroyed,
      isDisturbed,
      kIsDisturbed,
      isErrored,
      kIsErrored,
      isReadable,
      kIsReadable,
      kIsClosedPromise,
      kControllerErrorFunction,
      isClosed,
      isDestroyed,
      isDuplexNodeStream,
      isFinished,
      isIterable,
      isReadableNodeStream,
      isReadableStream,
      isReadableEnded,
      isReadableFinished,
      isReadableErrored,
      isNodeStream,
      isWebStream,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableEnded,
      isWritableFinished,
      isWritableErrored,
      isServerRequest,
      isServerResponse,
      willEmitClose,
      isTransformStream
    };
  }
});

// node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream2 = __commonJS({
  "node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
    var import_dist159 = __toESM(require_dist());
    var process2 = require_browser();
    var { AbortError, codes } = require_errors2();
    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes;
    var { kEmptyObject, once } = require_util2();
    var { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require_validators2();
    var { Promise: Promise2, PromisePrototypeThen } = require_primordials2();
    var {
      isClosed,
      isReadable,
      isReadableNodeStream,
      isReadableStream,
      isReadableFinished,
      isReadableErrored,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableFinished,
      isWritableErrored,
      isNodeStream,
      willEmitClose: _willEmitClose,
      kIsClosedPromise
    } = require_utils2();
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    var nop = () => {
    };
    function eos(stream, options, callback) {
      var _options$readable, _options$writable;
      if (arguments.length === 2) {
        callback = options;
        options = kEmptyObject;
      } else if (options == null) {
        options = kEmptyObject;
      } else {
        validateObject(options, "options");
      }
      validateFunction(callback, "callback");
      validateAbortSignal(options.signal, "options.signal");
      callback = once(callback);
      if (isReadableStream(stream) || isWritableStream(stream)) {
        return eosWeb(stream, options, callback);
      }
      if (!isNodeStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 ? _options$readable : isReadableNodeStream(stream);
      const writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 ? _options$writable : isWritableNodeStream(stream);
      const wState = stream._writableState;
      const rState = stream._readableState;
      const onlegacyfinish = () => {
        if (!stream.writable) {
          onfinish();
        }
      };
      let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
      let writableFinished = isWritableFinished(stream, false);
      const onfinish = () => {
        writableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.readable || readable)) {
          return;
        }
        if (!readable || readableFinished) {
          callback.call(stream);
        }
      };
      let readableFinished = isReadableFinished(stream, false);
      const onend = () => {
        readableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.writable || writable)) {
          return;
        }
        if (!writable || writableFinished) {
          callback.call(stream);
        }
      };
      const onerror = (err) => {
        callback.call(stream, err);
      };
      let closed = isClosed(stream);
      const onclose = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
          if (!isReadableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        if (writable && !writableFinished) {
          if (!isWritableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        callback.call(stream);
      };
      const onclosed = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        callback.call(stream);
      };
      const onrequest = () => {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
          stream.on("abort", onclose);
        }
        if (stream.req) {
          onrequest();
        } else {
          stream.on("request", onrequest);
        }
      } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (options.error !== false) {
        stream.on("error", onerror);
      }
      stream.on("close", onclose);
      if (closed) {
        process2.nextTick(onclose);
      } else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {
        if (!willEmitClose) {
          process2.nextTick(onclosed);
        }
      } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {
        process2.nextTick(onclosed);
      } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {
        process2.nextTick(onclosed);
      } else if (rState && stream.req && stream.aborted) {
        process2.nextTick(onclosed);
      }
      const cleanup = () => {
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
      if (options.signal && !closed) {
        const abort = () => {
          const endCallback = callback;
          cleanup();
          endCallback.call(
            stream,
            new AbortError(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process2.nextTick(abort);
        } else {
          const originalCallback = callback;
          callback = once((...args) => {
            options.signal.removeEventListener("abort", abort);
            originalCallback.apply(stream, args);
          });
          options.signal.addEventListener("abort", abort);
        }
      }
      return cleanup;
    }
    function eosWeb(stream, options, callback) {
      let isAborted = false;
      let abort = nop;
      if (options.signal) {
        abort = () => {
          isAborted = true;
          callback.call(
            stream,
            new AbortError(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process2.nextTick(abort);
        } else {
          const originalCallback = callback;
          callback = once((...args) => {
            options.signal.removeEventListener("abort", abort);
            originalCallback.apply(stream, args);
          });
          options.signal.addEventListener("abort", abort);
        }
      }
      const resolverFn = (...args) => {
        if (!isAborted) {
          process2.nextTick(() => callback.apply(stream, args));
        }
      };
      PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);
      return nop;
    }
    function finished(stream, opts) {
      var _opts;
      let autoCleanup = false;
      if (opts === null) {
        opts = kEmptyObject;
      }
      if ((_opts = opts) !== null && _opts !== void 0 && _opts.cleanup) {
        validateBoolean(opts.cleanup, "cleanup");
        autoCleanup = opts.cleanup;
      }
      return new Promise2((resolve, reject) => {
        const cleanup = eos(stream, opts, (err) => {
          if (autoCleanup) {
            cleanup();
          }
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }
    module.exports = eos;
    module.exports.finished = finished;
  }
});

// node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy2 = __commonJS({
  "node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var process2 = require_browser();
    var {
      aggregateTwoErrors,
      codes: { ERR_MULTIPLE_CALLBACK },
      AbortError
    } = require_errors2();
    var { Symbol: Symbol2 } = require_primordials2();
    var { kDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils2();
    var kDestroy = Symbol2("kDestroy");
    var kConstruct = Symbol2("kConstruct");
    function checkError(err, w, r) {
      if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
      }
    }
    function destroy(err, cb) {
      const r = this._readableState;
      const w = this._writableState;
      const s = w || r;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        if (typeof cb === "function") {
          cb();
        }
        return this;
      }
      checkError(err, w, r);
      if (w) {
        w.destroyed = true;
      }
      if (r) {
        r.destroyed = true;
      }
      if (!s.constructed) {
        this.once(kDestroy, function(er) {
          _destroy(this, aggregateTwoErrors(er, err), cb);
        });
      } else {
        _destroy(this, err, cb);
      }
      return this;
    }
    function _destroy(self, err, cb) {
      let called = false;
      function onDestroy(err2) {
        if (called) {
          return;
        }
        called = true;
        const r = self._readableState;
        const w = self._writableState;
        checkError(err2, w, r);
        if (w) {
          w.closed = true;
        }
        if (r) {
          r.closed = true;
        }
        if (typeof cb === "function") {
          cb(err2);
        }
        if (err2) {
          process2.nextTick(emitErrorCloseNT, self, err2);
        } else {
          process2.nextTick(emitCloseNT, self);
        }
      }
      try {
        self._destroy(err || null, onDestroy);
      } catch (err2) {
        onDestroy(err2);
      }
    }
    function emitErrorCloseNT(self, err) {
      emitErrorNT(self, err);
      emitCloseNT(self);
    }
    function emitCloseNT(self) {
      const r = self._readableState;
      const w = self._writableState;
      if (w) {
        w.closeEmitted = true;
      }
      if (r) {
        r.closeEmitted = true;
      }
      if (w !== null && w !== void 0 && w.emitClose || r !== null && r !== void 0 && r.emitClose) {
        self.emit("close");
      }
    }
    function emitErrorNT(self, err) {
      const r = self._readableState;
      const w = self._writableState;
      if (w !== null && w !== void 0 && w.errorEmitted || r !== null && r !== void 0 && r.errorEmitted) {
        return;
      }
      if (w) {
        w.errorEmitted = true;
      }
      if (r) {
        r.errorEmitted = true;
      }
      self.emit("error", err);
    }
    function undestroy() {
      const r = this._readableState;
      const w = this._writableState;
      if (r) {
        r.constructed = true;
        r.closed = false;
        r.closeEmitted = false;
        r.destroyed = false;
        r.errored = null;
        r.errorEmitted = false;
        r.reading = false;
        r.ended = r.readable === false;
        r.endEmitted = r.readable === false;
      }
      if (w) {
        w.constructed = true;
        w.destroyed = false;
        w.closed = false;
        w.closeEmitted = false;
        w.errored = null;
        w.errorEmitted = false;
        w.finalCalled = false;
        w.prefinished = false;
        w.ended = w.writable === false;
        w.ending = w.writable === false;
        w.finished = w.writable === false;
      }
    }
    function errorOrDestroy(stream, err, sync) {
      const r = stream._readableState;
      const w = stream._writableState;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        return this;
      }
      if (r !== null && r !== void 0 && r.autoDestroy || w !== null && w !== void 0 && w.autoDestroy)
        stream.destroy(err);
      else if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
        if (sync) {
          process2.nextTick(emitErrorNT, stream, err);
        } else {
          emitErrorNT(stream, err);
        }
      }
    }
    function construct(stream, cb) {
      if (typeof stream._construct !== "function") {
        return;
      }
      const r = stream._readableState;
      const w = stream._writableState;
      if (r) {
        r.constructed = false;
      }
      if (w) {
        w.constructed = false;
      }
      stream.once(kConstruct, cb);
      if (stream.listenerCount(kConstruct) > 1) {
        return;
      }
      process2.nextTick(constructNT, stream);
    }
    function constructNT(stream) {
      let called = false;
      function onConstruct(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        const r = stream._readableState;
        const w = stream._writableState;
        const s = w || r;
        if (r) {
          r.constructed = true;
        }
        if (w) {
          w.constructed = true;
        }
        if (s.destroyed) {
          stream.emit(kDestroy, err);
        } else if (err) {
          errorOrDestroy(stream, err, true);
        } else {
          process2.nextTick(emitConstructNT, stream);
        }
      }
      try {
        stream._construct((err) => {
          process2.nextTick(onConstruct, err);
        });
      } catch (err) {
        process2.nextTick(onConstruct, err);
      }
    }
    function emitConstructNT(stream) {
      stream.emit(kConstruct);
    }
    function isRequest(stream) {
      return (stream === null || stream === void 0 ? void 0 : stream.setHeader) && typeof stream.abort === "function";
    }
    function emitCloseLegacy(stream) {
      stream.emit("close");
    }
    function emitErrorCloseLegacy(stream, err) {
      stream.emit("error", err);
      process2.nextTick(emitCloseLegacy, stream);
    }
    function destroyer(stream, err) {
      if (!stream || isDestroyed(stream)) {
        return;
      }
      if (!err && !isFinished(stream)) {
        err = new AbortError();
      }
      if (isServerRequest(stream)) {
        stream.socket = null;
        stream.destroy(err);
      } else if (isRequest(stream)) {
        stream.abort();
      } else if (isRequest(stream.req)) {
        stream.req.abort();
      } else if (typeof stream.destroy === "function") {
        stream.destroy(err);
      } else if (typeof stream.close === "function") {
        stream.close();
      } else if (err) {
        process2.nextTick(emitErrorCloseLegacy, stream, err);
      } else {
        process2.nextTick(emitCloseLegacy, stream);
      }
      if (!stream.destroyed) {
        stream[kDestroyed] = true;
      }
    }
    module.exports = {
      construct,
      destroyer,
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/legacy.js
var require_legacy2 = __commonJS({
  "node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/legacy.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials2();
    var { EventEmitter: EE } = require_events();
    function Stream3(opts) {
      EE.call(this, opts);
    }
    ObjectSetPrototypeOf(Stream3.prototype, EE.prototype);
    ObjectSetPrototypeOf(Stream3, EE);
    Stream3.prototype.pipe = function(dest, options) {
      const source = this;
      function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
          source.pause();
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      let didOnEnd = false;
      function onend() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          this.emit("error", er);
        }
      }
      prependListener(source, "error", onerror);
      prependListener(dest, "error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (ArrayIsArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    module.exports = {
      Stream: Stream3,
      prependListener
    };
  }
});

// node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js
var require_add_abort_signal2 = __commonJS({
  "node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var { AbortError, codes } = require_errors2();
    var { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils2();
    var eos = require_end_of_stream2();
    var { ERR_INVALID_ARG_TYPE } = codes;
    var validateAbortSignal = (signal, name) => {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    };
    module.exports.addAbortSignal = function addAbortSignal(signal, stream) {
      validateAbortSignal(signal, "signal");
      if (!isNodeStream(stream) && !isWebStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      return module.exports.addAbortSignalNoValidate(signal, stream);
    };
    module.exports.addAbortSignalNoValidate = function(signal, stream) {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
      }
      const onAbort = isNodeStream(stream) ? () => {
        stream.destroy(
          new AbortError(void 0, {
            cause: signal.reason
          })
        );
      } : () => {
        stream[kControllerErrorFunction](
          new AbortError(void 0, {
            cause: signal.reason
          })
        );
      };
      if (signal.aborted) {
        onAbort();
      } else {
        signal.addEventListener("abort", onAbort);
        eos(stream, () => signal.removeEventListener("abort", onAbort));
      }
      return stream;
    };
  }
});

// node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list2 = __commonJS({
  "node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials2();
    var { Buffer } = require_buffer_polyfill();
    var { inspect } = require_util2();
    module.exports = class BufferList {
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      push(v) {
        const entry = {
          data: v,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
      unshift(v) {
        const entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        const ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
      clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
      join(s) {
        if (this.length === 0)
          return "";
        let p = this.head;
        let ret = "" + p.data;
        while ((p = p.next) !== null)
          ret += s + p.data;
        return ret;
      }
      concat(n) {
        if (this.length === 0)
          return Buffer.alloc(0);
        const ret = Buffer.allocUnsafe(n >>> 0);
        let p = this.head;
        let i = 0;
        while (p) {
          TypedArrayPrototypeSet(ret, p.data, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
      consume(n, hasStrings) {
        const data = this.head.data;
        if (n < data.length) {
          const slice = data.slice(0, n);
          this.head.data = data.slice(n);
          return slice;
        }
        if (n === data.length) {
          return this.shift();
        }
        return hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      first() {
        return this.head.data;
      }
      *[SymbolIterator]() {
        for (let p = this.head; p; p = p.next) {
          yield p.data;
        }
      }
      // Consumes a specified amount of characters from the buffered data.
      _getString(n) {
        let ret = "";
        let p = this.head;
        let c = 0;
        do {
          const str = p.data;
          if (n > str.length) {
            ret += str;
            n -= str.length;
          } else {
            if (n === str.length) {
              ret += str;
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              ret += StringPrototypeSlice(str, 0, n);
              this.head = p;
              p.data = StringPrototypeSlice(str, n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
      _getBuffer(n) {
        const ret = Buffer.allocUnsafe(n);
        const retLen = n;
        let p = this.head;
        let c = 0;
        do {
          const buf = p.data;
          if (n > buf.length) {
            TypedArrayPrototypeSet(ret, buf, retLen - n);
            n -= buf.length;
          } else {
            if (n === buf.length) {
              TypedArrayPrototypeSet(ret, buf, retLen - n);
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n), retLen - n);
              this.head = p;
              p.data = buf.slice(n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
      [Symbol.for("nodejs.util.inspect.custom")](_, options) {
        return inspect(this, {
          ...options,
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        });
      }
    };
  }
});

// node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/state.js
var require_state2 = __commonJS({
  "node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var { MathFloor, NumberIsInteger } = require_primordials2();
    var { ERR_INVALID_ARG_VALUE } = require_errors2().codes;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getDefaultHighWaterMark(objectMode) {
      return objectMode ? 16 : 16 * 1024;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!NumberIsInteger(hwm) || hwm < 0) {
          const name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
          throw new ERR_INVALID_ARG_VALUE(name, hwm);
        }
        return MathFloor(hwm);
      }
      return getDefaultHighWaterMark(state.objectMode);
    }
    module.exports = {
      getHighWaterMark,
      getDefaultHighWaterMark
    };
  }
});

// node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/from.js
var require_from2 = __commonJS({
  "node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/from.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var process2 = require_browser();
    var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials2();
    var { Buffer } = require_buffer_polyfill();
    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = require_errors2().codes;
    function from(Readable5, iterable, opts) {
      let iterator;
      if (typeof iterable === "string" || iterable instanceof Buffer) {
        return new Readable5({
          objectMode: true,
          ...opts,
          read() {
            this.push(iterable);
            this.push(null);
          }
        });
      }
      let isAsync;
      if (iterable && iterable[SymbolAsyncIterator]) {
        isAsync = true;
        iterator = iterable[SymbolAsyncIterator]();
      } else if (iterable && iterable[SymbolIterator]) {
        isAsync = false;
        iterator = iterable[SymbolIterator]();
      } else {
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      }
      const readable = new Readable5({
        objectMode: true,
        highWaterMark: 1,
        // TODO(ronag): What options should be allowed?
        ...opts
      });
      let reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      readable._destroy = function(error, cb) {
        PromisePrototypeThen(
          close2(error),
          () => process2.nextTick(cb, error),
          // nextTick is here in case cb throws
          (e) => process2.nextTick(cb, e || error)
        );
      };
      async function close2(error) {
        const hadError = error !== void 0 && error !== null;
        const hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
          const { value, done } = await iterator.throw(error);
          await value;
          if (done) {
            return;
          }
        }
        if (typeof iterator.return === "function") {
          const { value } = await iterator.return();
          await value;
        }
      }
      async function next() {
        for (; ; ) {
          try {
            const { value, done } = isAsync ? await iterator.next() : iterator.next();
            if (done) {
              readable.push(null);
            } else {
              const res = value && typeof value.then === "function" ? await value : value;
              if (res === null) {
                reading = false;
                throw new ERR_STREAM_NULL_VALUES();
              } else if (readable.push(res)) {
                continue;
              } else {
                reading = false;
              }
            }
          } catch (err) {
            readable.destroy(err);
          }
          break;
        }
      }
      return readable;
    }
    module.exports = from;
  }
});

// node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/readable.js
var require_readable2 = __commonJS({
  "node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/readable.js"(exports, module) {
    var import_dist159 = __toESM(require_dist());
    var process2 = require_browser();
    var {
      ArrayPrototypeIndexOf,
      NumberIsInteger,
      NumberIsNaN,
      NumberParseInt,
      ObjectDefineProperties,
      ObjectKeys,
      ObjectSetPrototypeOf,
      Promise: Promise2,
      SafeSet,
      SymbolAsyncIterator,
      Symbol: Symbol2
    } = require_primordials2();
    module.exports = Readable5;
    Readable5.ReadableState = ReadableState;
    var { EventEmitter: EE } = require_events();
    var { Stream: Stream3, prependListener } = require_legacy2();
    var { Buffer } = require_buffer_polyfill();
    var { addAbortSignal } = require_add_abort_signal2();
    var eos = require_end_of_stream2();
    var debug = require_util2().debuglog("stream", (fn) => {
      debug = fn;
    });
    var BufferList = require_buffer_list2();
    var destroyImpl = require_destroy2();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state2();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE,
        ERR_METHOD_NOT_IMPLEMENTED,
        ERR_OUT_OF_RANGE,
        ERR_STREAM_PUSH_AFTER_EOF,
        ERR_STREAM_UNSHIFT_AFTER_END_EVENT
      }
    } = require_errors2();
    var { validateObject } = require_validators2();
    var kPaused = Symbol2("kPaused");
    var { StringDecoder } = require_string_decoder();
    var from = require_from2();
    ObjectSetPrototypeOf(Readable5.prototype, Stream3.prototype);
    ObjectSetPrototypeOf(Readable5, Stream3);
    var nop = () => {
    };
    var { errorOrDestroy } = destroyImpl;
    function ReadableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex2();
      this.objectMode = !!(options && options.objectMode);
      if (isDuplex)
        this.objectMode = this.objectMode || !!(options && options.readableObjectMode);
      this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = [];
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.constructed = true;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this[kPaused] = null;
      this.errorEmitted = false;
      this.emitClose = !options || options.emitClose !== false;
      this.autoDestroy = !options || options.autoDestroy !== false;
      this.destroyed = false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.awaitDrainWriters = null;
      this.multiAwaitDrain = false;
      this.readingMore = false;
      this.dataEmitted = false;
      this.decoder = null;
      this.encoding = null;
      if (options && options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable5(options) {
      if (!(this instanceof Readable5))
        return new Readable5(options);
      const isDuplex = this instanceof require_duplex2();
      this._readableState = new ReadableState(options, this, isDuplex);
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal && !isDuplex)
          addAbortSignal(options.signal, this);
      }
      Stream3.call(this, options);
      destroyImpl.construct(this, () => {
        if (this._readableState.needReadable) {
          maybeReadMore(this, this._readableState);
        }
      });
    }
    Readable5.prototype.destroy = destroyImpl.destroy;
    Readable5.prototype._undestroy = destroyImpl.undestroy;
    Readable5.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable5.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    Readable5.prototype.push = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, false);
    };
    Readable5.prototype.unshift = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, true);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront) {
      debug("readableAddChunk", chunk);
      const state = stream._readableState;
      let err;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (state.encoding !== encoding) {
            if (addToFront && state.encoding) {
              chunk = Buffer.from(chunk, encoding).toString(state.encoding);
            } else {
              chunk = Buffer.from(chunk, encoding);
              encoding = "";
            }
          }
        } else if (chunk instanceof Buffer) {
          encoding = "";
        } else if (Stream3._isUint8Array(chunk)) {
          chunk = Stream3._uint8ArrayToBuffer(chunk);
          encoding = "";
        } else if (chunk != null) {
          err = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      if (err) {
        errorOrDestroy(stream, err);
      } else if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (addToFront) {
          if (state.endEmitted)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else if (state.destroyed || state.errored)
            return false;
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed || state.errored) {
          return false;
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
        if (state.multiAwaitDrain) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
        state.dataEmitted = true;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    Readable5.prototype.isPaused = function() {
      const state = this._readableState;
      return state[kPaused] === true || state.flowing === false;
    };
    Readable5.prototype.setEncoding = function(enc) {
      const decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      const buffer = this._readableState.buffer;
      let content = "";
      for (const data of buffer) {
        content += decoder.write(data);
      }
      buffer.clear();
      if (content !== "")
        buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n > MAX_HWM) {
        throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n);
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (NumberIsNaN(n)) {
        if (state.flowing && state.length)
          return state.buffer.first().length;
        return state.length;
      }
      if (n <= state.length)
        return n;
      return state.ended ? state.length : 0;
    }
    Readable5.prototype.read = function(n) {
      debug("read", n);
      if (n === void 0) {
        n = NaN;
      } else if (!NumberIsInteger(n)) {
        n = NumberParseInt(n, 10);
      }
      const state = this._readableState;
      const nOrig = n;
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      let doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
        doRead = false;
        debug("reading, ended or constructing", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        try {
          this._read(state.highWaterMark);
        } catch (err) {
          errorOrDestroy(this, err);
        }
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      let ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        if (state.multiAwaitDrain) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
        state.dataEmitted = true;
        this.emit("data", ret);
      }
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        const chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
    function emitReadable(stream) {
      const state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process2.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      const state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && !state.errored && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore && state.constructed) {
        state.readingMore = true;
        process2.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        const len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable5.prototype._read = function(n) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
    };
    Readable5.prototype.pipe = function(dest, pipeOpts) {
      const src = this;
      const state = this._readableState;
      if (state.pipes.length === 1) {
        if (!state.multiAwaitDrain) {
          state.multiAwaitDrain = true;
          state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
        }
      }
      state.pipes.push(dest);
      debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
      const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process2.stdout && dest !== process2.stderr;
      const endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process2.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      let ondrain;
      let cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        if (ondrain) {
          dest.removeListener("drain", ondrain);
        }
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      function pause() {
        if (!cleanedUp) {
          if (state.pipes.length === 1 && state.pipes[0] === dest) {
            debug("false write response, pause", 0);
            state.awaitDrainWriters = dest;
            state.multiAwaitDrain = false;
          } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
            debug("false write response, pause", state.awaitDrainWriters.size);
            state.awaitDrainWriters.add(dest);
          }
          src.pause();
        }
        if (!ondrain) {
          ondrain = pipeOnDrain(src, dest);
          dest.on("drain", ondrain);
        }
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        const ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (dest.listenerCount("error") === 0) {
          const s = dest._writableState || dest._readableState;
          if (s && !s.errorEmitted) {
            errorOrDestroy(dest, er);
          } else {
            dest.emit("error", er);
          }
        }
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (dest.writableNeedDrain === true) {
        if (state.flowing) {
          pause();
        }
      } else if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src, dest) {
      return function pipeOnDrainFunctionResult() {
        const state = src._readableState;
        if (state.awaitDrainWriters === dest) {
          debug("pipeOnDrain", 1);
          state.awaitDrainWriters = null;
        } else if (state.multiAwaitDrain) {
          debug("pipeOnDrain", state.awaitDrainWriters.size);
          state.awaitDrainWriters.delete(dest);
        }
        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data")) {
          src.resume();
        }
      };
    }
    Readable5.prototype.unpipe = function(dest) {
      const state = this._readableState;
      const unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipes.length === 0)
        return this;
      if (!dest) {
        const dests = state.pipes;
        state.pipes = [];
        this.pause();
        for (let i = 0; i < dests.length; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      const index = ArrayPrototypeIndexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      if (state.pipes.length === 0)
        this.pause();
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable5.prototype.on = function(ev, fn) {
      const res = Stream3.prototype.on.call(this, ev, fn);
      const state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process2.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable5.prototype.addListener = Readable5.prototype.on;
    Readable5.prototype.removeListener = function(ev, fn) {
      const res = Stream3.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process2.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable5.prototype.off = Readable5.prototype.removeListener;
    Readable5.prototype.removeAllListeners = function(ev) {
      const res = Stream3.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process2.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self) {
      const state = self._readableState;
      state.readableListening = self.listenerCount("readable") > 0;
      if (state.resumeScheduled && state[kPaused] === false) {
        state.flowing = true;
      } else if (self.listenerCount("data") > 0) {
        self.resume();
      } else if (!state.readableListening) {
        state.flowing = null;
      }
    }
    function nReadingNextTick(self) {
      debug("readable nexttick read 0");
      self.read(0);
    }
    Readable5.prototype.resume = function() {
      const state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state[kPaused] = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process2.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable5.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState[kPaused] = true;
      return this;
    };
    function flow(stream) {
      const state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable5.prototype.wrap = function(stream) {
      let paused = false;
      stream.on("data", (chunk) => {
        if (!this.push(chunk) && stream.pause) {
          paused = true;
          stream.pause();
        }
      });
      stream.on("end", () => {
        this.push(null);
      });
      stream.on("error", (err) => {
        errorOrDestroy(this, err);
      });
      stream.on("close", () => {
        this.destroy();
      });
      stream.on("destroy", () => {
        this.destroy();
      });
      this._read = () => {
        if (paused && stream.resume) {
          paused = false;
          stream.resume();
        }
      };
      const streamKeys = ObjectKeys(stream);
      for (let j = 1; j < streamKeys.length; j++) {
        const i = streamKeys[j];
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = stream[i].bind(stream);
        }
      }
      return this;
    };
    Readable5.prototype[SymbolAsyncIterator] = function() {
      return streamToAsyncIterator(this);
    };
    Readable5.prototype.iterator = function(options) {
      if (options !== void 0) {
        validateObject(options, "options");
      }
      return streamToAsyncIterator(this, options);
    };
    function streamToAsyncIterator(stream, options) {
      if (typeof stream.read !== "function") {
        stream = Readable5.wrap(stream, {
          objectMode: true
        });
      }
      const iter = createAsyncIterator(stream, options);
      iter.stream = stream;
      return iter;
    }
    async function* createAsyncIterator(stream, options) {
      let callback = nop;
      function next(resolve) {
        if (this === stream) {
          callback();
          callback = nop;
        } else {
          callback = resolve;
        }
      }
      stream.on("readable", next);
      let error;
      const cleanup = eos(
        stream,
        {
          writable: false
        },
        (err) => {
          error = err ? aggregateTwoErrors(error, err) : null;
          callback();
          callback = nop;
        }
      );
      try {
        while (true) {
          const chunk = stream.destroyed ? null : stream.read();
          if (chunk !== null) {
            yield chunk;
          } else if (error) {
            throw error;
          } else if (error === null) {
            return;
          } else {
            await new Promise2(next);
          }
        }
      } catch (err) {
        error = aggregateTwoErrors(error, err);
        throw error;
      } finally {
        if ((error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) && (error === void 0 || stream._readableState.autoDestroy)) {
          destroyImpl.destroyer(stream, null);
        } else {
          stream.off("readable", next);
          cleanup();
        }
      }
    }
    ObjectDefineProperties(Readable5.prototype, {
      readable: {
        __proto__: null,
        get() {
          const r = this._readableState;
          return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
        },
        set(val) {
          if (this._readableState) {
            this._readableState.readable = !!val;
          }
        }
      },
      readableDidRead: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.dataEmitted;
        }
      },
      readableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
        }
      },
      readableHighWaterMark: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.highWaterMark;
        }
      },
      readableBuffer: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState && this._readableState.buffer;
        }
      },
      readableFlowing: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.flowing;
        },
        set: function(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      },
      readableLength: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState.length;
        }
      },
      readableObjectMode: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.objectMode : false;
        }
      },
      readableEncoding: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.encoding : null;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.errored : null;
        }
      },
      closed: {
        __proto__: null,
        get() {
          return this._readableState ? this._readableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.destroyed : false;
        },
        set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      },
      readableEnded: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.endEmitted : false;
        }
      }
    });
    ObjectDefineProperties(ReadableState.prototype, {
      // Legacy getter for `pipesCount`.
      pipesCount: {
        __proto__: null,
        get() {
          return this.pipes.length;
        }
      },
      // Legacy property for `paused`.
      paused: {
        __proto__: null,
        get() {
          return this[kPaused] !== false;
        },
        set(value) {
          this[kPaused] = !!value;
        }
      }
    });
    Readable5._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      let ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      const state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process2.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.emit("end");
        if (stream.writable && stream.allowHalfOpen === false) {
          process2.nextTick(endWritableNT, stream);
        } else if (state.autoDestroy) {
          const wState = stream._writableState;
          const autoDestroy = !wState || wState.autoDestroy && // We don't expect the writable to ever 'finish'
          // if writable is explicitly set to false.
          (wState.finished || wState.writable === false);
          if (autoDestroy) {
            stream.destroy();
          }
        }
      }
    }
    function endWritableNT(stream) {
      const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
      if (writable) {
        stream.end();
      }
    }
    Readable5.from = function(iterable, opts) {
      return from(Readable5, iterable, opts);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Readable5.fromWeb = function(readableStream, options) {
      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
    };
    Readable5.toWeb = function(streamReadable, options) {
      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
    };
    Readable5.wrap = function(src, options) {
      var _ref, _src$readableObjectMo;
      return new Readable5({
        objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 ? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 ? _ref : true,
        ...options,
        destroy(err, callback) {
          destroyImpl.destroyer(src, err);
          callback(err);
        }
      }).wrap(src);
    };
  }
});

// node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/writable.js
var require_writable2 = __commonJS({
  "node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/writable.js"(exports, module) {
    var import_dist159 = __toESM(require_dist());
    var process2 = require_browser();
    var {
      ArrayPrototypeSlice,
      Error: Error2,
      FunctionPrototypeSymbolHasInstance,
      ObjectDefineProperty,
      ObjectDefineProperties,
      ObjectSetPrototypeOf,
      StringPrototypeToLowerCase,
      Symbol: Symbol2,
      SymbolHasInstance
    } = require_primordials2();
    module.exports = Writable;
    Writable.WritableState = WritableState;
    var { EventEmitter: EE } = require_events();
    var Stream3 = require_legacy2().Stream;
    var { Buffer } = require_buffer_polyfill();
    var destroyImpl = require_destroy2();
    var { addAbortSignal } = require_add_abort_signal2();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state2();
    var {
      ERR_INVALID_ARG_TYPE,
      ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK,
      ERR_STREAM_CANNOT_PIPE,
      ERR_STREAM_DESTROYED,
      ERR_STREAM_ALREADY_FINISHED,
      ERR_STREAM_NULL_VALUES,
      ERR_STREAM_WRITE_AFTER_END,
      ERR_UNKNOWN_ENCODING
    } = require_errors2().codes;
    var { errorOrDestroy } = destroyImpl;
    ObjectSetPrototypeOf(Writable.prototype, Stream3.prototype);
    ObjectSetPrototypeOf(Writable, Stream3);
    function nop() {
    }
    var kOnFinished = Symbol2("kOnFinished");
    function WritableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex2();
      this.objectMode = !!(options && options.objectMode);
      if (isDuplex)
        this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
      this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      const noDecode = !!(options && options.decodeStrings === false);
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = onwrite.bind(void 0, stream);
      this.writecb = null;
      this.writelen = 0;
      this.afterWriteTickInfo = null;
      resetBuffer(this);
      this.pendingcb = 0;
      this.constructed = true;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = !options || options.emitClose !== false;
      this.autoDestroy = !options || options.autoDestroy !== false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this[kOnFinished] = [];
    }
    function resetBuffer(state) {
      state.buffered = [];
      state.bufferedIndex = 0;
      state.allBuffers = true;
      state.allNoop = true;
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
    };
    ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
      __proto__: null,
      get() {
        return this.buffered.length - this.bufferedIndex;
      }
    });
    function Writable(options) {
      const isDuplex = this instanceof require_duplex2();
      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal)
          addAbortSignal(options.signal, this);
      }
      Stream3.call(this, options);
      destroyImpl.construct(this, () => {
        const state = this._writableState;
        if (!state.writing) {
          clearBuffer(this, state);
        }
        finishMaybe(this, state);
      });
    }
    ObjectDefineProperty(Writable, SymbolHasInstance, {
      __proto__: null,
      value: function(object) {
        if (FunctionPrototypeSymbolHasInstance(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function _write(stream, chunk, encoding, cb) {
      const state = stream._writableState;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = state.defaultEncoding;
      } else {
        if (!encoding)
          encoding = state.defaultEncoding;
        else if (encoding !== "buffer" && !Buffer.isEncoding(encoding))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        if (typeof cb !== "function")
          cb = nop;
      }
      if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
      } else if (!state.objectMode) {
        if (typeof chunk === "string") {
          if (state.decodeStrings !== false) {
            chunk = Buffer.from(chunk, encoding);
            encoding = "buffer";
          }
        } else if (chunk instanceof Buffer) {
          encoding = "buffer";
        } else if (Stream3._isUint8Array(chunk)) {
          chunk = Stream3._uint8ArrayToBuffer(chunk);
          encoding = "buffer";
        } else {
          throw new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      let err;
      if (state.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END();
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("write");
      }
      if (err) {
        process2.nextTick(cb, err);
        errorOrDestroy(stream, err, true);
        return err;
      }
      state.pendingcb++;
      return writeOrBuffer(stream, state, chunk, encoding, cb);
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      return _write(this, chunk, encoding, cb) === true;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      const state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = StringPrototypeToLowerCase(encoding);
      if (!Buffer.isEncoding(encoding))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function writeOrBuffer(stream, state, chunk, encoding, callback) {
      const len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      const ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked || state.errored || !state.constructed) {
        state.buffered.push({
          chunk,
          encoding,
          callback
        });
        if (state.allBuffers && encoding !== "buffer") {
          state.allBuffers = false;
        }
        if (state.allNoop && callback !== nop) {
          state.allNoop = false;
        }
      } else {
        state.writelen = len;
        state.writecb = callback;
        state.writing = true;
        state.sync = true;
        stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      return ret && !state.errored && !state.destroyed;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, er, cb) {
      --state.pendingcb;
      cb(er);
      errorBuffer(state);
      errorOrDestroy(stream, er);
    }
    function onwrite(stream, er) {
      const state = stream._writableState;
      const sync = state.sync;
      const cb = state.writecb;
      if (typeof cb !== "function") {
        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
        return;
      }
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
      if (er) {
        er.stack;
        if (!state.errored) {
          state.errored = er;
        }
        if (stream._readableState && !stream._readableState.errored) {
          stream._readableState.errored = er;
        }
        if (sync) {
          process2.nextTick(onwriteError, stream, state, er, cb);
        } else {
          onwriteError(stream, state, er, cb);
        }
      } else {
        if (state.buffered.length > state.bufferedIndex) {
          clearBuffer(stream, state);
        }
        if (sync) {
          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
            state.afterWriteTickInfo.count++;
          } else {
            state.afterWriteTickInfo = {
              count: 1,
              cb,
              stream,
              state
            };
            process2.nextTick(afterWriteTick, state.afterWriteTickInfo);
          }
        } else {
          afterWrite(stream, state, 1, cb);
        }
      }
    }
    function afterWriteTick({ stream, state, count, cb }) {
      state.afterWriteTickInfo = null;
      return afterWrite(stream, state, count, cb);
    }
    function afterWrite(stream, state, count, cb) {
      const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
      if (needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
      while (count-- > 0) {
        state.pendingcb--;
        cb();
      }
      if (state.destroyed) {
        errorBuffer(state);
      }
      finishMaybe(stream, state);
    }
    function errorBuffer(state) {
      if (state.writing) {
        return;
      }
      for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {
        var _state$errored;
        const { chunk, callback } = state.buffered[n];
        const len = state.objectMode ? 1 : chunk.length;
        state.length -= len;
        callback(
          (_state$errored = state.errored) !== null && _state$errored !== void 0 ? _state$errored : new ERR_STREAM_DESTROYED("write")
        );
      }
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        var _state$errored2;
        onfinishCallbacks[i](
          (_state$errored2 = state.errored) !== null && _state$errored2 !== void 0 ? _state$errored2 : new ERR_STREAM_DESTROYED("end")
        );
      }
      resetBuffer(state);
    }
    function clearBuffer(stream, state) {
      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
        return;
      }
      const { buffered, bufferedIndex, objectMode } = state;
      const bufferedLength = buffered.length - bufferedIndex;
      if (!bufferedLength) {
        return;
      }
      let i = bufferedIndex;
      state.bufferProcessing = true;
      if (bufferedLength > 1 && stream._writev) {
        state.pendingcb -= bufferedLength - 1;
        const callback = state.allNoop ? nop : (err) => {
          for (let n = i; n < buffered.length; ++n) {
            buffered[n].callback(err);
          }
        };
        const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
        chunks.allBuffers = state.allBuffers;
        doWrite(stream, state, true, state.length, chunks, "", callback);
        resetBuffer(state);
      } else {
        do {
          const { chunk, encoding, callback } = buffered[i];
          buffered[i++] = null;
          const len = objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, callback);
        } while (i < buffered.length && !state.writing);
        if (i === buffered.length) {
          resetBuffer(state);
        } else if (i > 256) {
          buffered.splice(0, i);
          state.bufferedIndex = 0;
        } else {
          state.bufferedIndex = i;
        }
      }
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      if (this._writev) {
        this._writev(
          [
            {
              chunk,
              encoding
            }
          ],
          cb
        );
      } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
      }
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      const state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      let err;
      if (chunk !== null && chunk !== void 0) {
        const ret = _write(this, chunk, encoding);
        if (ret instanceof Error2) {
          err = ret;
        }
      }
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (err) {
      } else if (!state.errored && !state.ending) {
        state.ending = true;
        finishMaybe(this, state, true);
        state.ended = true;
      } else if (state.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED("end");
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("end");
      }
      if (typeof cb === "function") {
        if (err || state.finished) {
          process2.nextTick(cb, err);
        } else {
          state[kOnFinished].push(cb);
        }
      }
      return this;
    };
    function needFinish(state) {
      return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
    }
    function callFinal(stream, state) {
      let called = false;
      function onFinish(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        state.pendingcb--;
        if (err) {
          const onfinishCallbacks = state[kOnFinished].splice(0);
          for (let i = 0; i < onfinishCallbacks.length; i++) {
            onfinishCallbacks[i](err);
          }
          errorOrDestroy(stream, err, state.sync);
        } else if (needFinish(state)) {
          state.prefinished = true;
          stream.emit("prefinish");
          state.pendingcb++;
          process2.nextTick(finish, stream, state);
        }
      }
      state.sync = true;
      state.pendingcb++;
      try {
        stream._final(onFinish);
      } catch (err) {
        onFinish(err);
      }
      state.sync = false;
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.finalCalled = true;
          callFinal(stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state, sync) {
      if (needFinish(state)) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          if (sync) {
            state.pendingcb++;
            process2.nextTick(
              (stream2, state2) => {
                if (needFinish(state2)) {
                  finish(stream2, state2);
                } else {
                  state2.pendingcb--;
                }
              },
              stream,
              state
            );
          } else if (needFinish(state)) {
            state.pendingcb++;
            finish(stream, state);
          }
        }
      }
    }
    function finish(stream, state) {
      state.pendingcb--;
      state.finished = true;
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i]();
      }
      stream.emit("finish");
      if (state.autoDestroy) {
        const rState = stream._readableState;
        const autoDestroy = !rState || rState.autoDestroy && // We don't expect the readable to ever 'end'
        // if readable is explicitly set to false.
        (rState.endEmitted || rState.readable === false);
        if (autoDestroy) {
          stream.destroy();
        }
      }
    }
    ObjectDefineProperties(Writable.prototype, {
      closed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.destroyed : false;
        },
        set(value) {
          if (this._writableState) {
            this._writableState.destroyed = value;
          }
        }
      },
      writable: {
        __proto__: null,
        get() {
          const w = this._writableState;
          return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
        },
        set(val) {
          if (this._writableState) {
            this._writableState.writable = !!val;
          }
        }
      },
      writableFinished: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.finished : false;
        }
      },
      writableObjectMode: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.objectMode : false;
        }
      },
      writableBuffer: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.getBuffer();
        }
      },
      writableEnded: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.ending : false;
        }
      },
      writableNeedDrain: {
        __proto__: null,
        get() {
          const wState = this._writableState;
          if (!wState)
            return false;
          return !wState.destroyed && !wState.ending && wState.needDrain;
        }
      },
      writableHighWaterMark: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.highWaterMark;
        }
      },
      writableCorked: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.corked : 0;
        }
      },
      writableLength: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.length;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._writableState ? this._writableState.errored : null;
        }
      },
      writableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
        }
      }
    });
    var destroy = destroyImpl.destroy;
    Writable.prototype.destroy = function(err, cb) {
      const state = this._writableState;
      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
        process2.nextTick(errorBuffer, state);
      }
      destroy.call(this, err, cb);
      return this;
    };
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Writable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Writable.fromWeb = function(writableStream, options) {
      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
    };
    Writable.toWeb = function(streamWritable) {
      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
    };
  }
});

// node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/duplexify.js
var require_duplexify2 = __commonJS({
  "node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/duplexify.js"(exports, module) {
    var import_dist159 = __toESM(require_dist());
    var process2 = require_browser();
    var bufferModule = require_buffer_polyfill();
    var {
      isReadable,
      isWritable,
      isIterable,
      isNodeStream,
      isReadableNodeStream,
      isWritableNodeStream,
      isDuplexNodeStream
    } = require_utils2();
    var eos = require_end_of_stream2();
    var {
      AbortError,
      codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE }
    } = require_errors2();
    var { destroyer } = require_destroy2();
    var Duplex = require_duplex2();
    var Readable5 = require_readable2();
    var { createDeferredPromise } = require_util2();
    var from = require_from2();
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b) {
      return b instanceof Blob2;
    } : function isBlob2(b) {
      return false;
    };
    var AbortController = globalThis.AbortController || require_browser3().AbortController;
    var { FunctionPrototypeCall } = require_primordials2();
    var Duplexify = class extends Duplex {
      constructor(options) {
        super(options);
        if ((options === null || options === void 0 ? void 0 : options.readable) === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if ((options === null || options === void 0 ? void 0 : options.writable) === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      }
    };
    module.exports = function duplexify(body, name) {
      if (isDuplexNodeStream(body)) {
        return body;
      }
      if (isReadableNodeStream(body)) {
        return _duplexify({
          readable: body
        });
      }
      if (isWritableNodeStream(body)) {
        return _duplexify({
          writable: body
        });
      }
      if (isNodeStream(body)) {
        return _duplexify({
          writable: false,
          readable: false
        });
      }
      if (typeof body === "function") {
        const { value, write, final, destroy } = fromAsyncGen(body);
        if (isIterable(value)) {
          return from(Duplexify, value, {
            // TODO (ronag): highWaterMark?
            objectMode: true,
            write,
            final,
            destroy
          });
        }
        const then2 = value === null || value === void 0 ? void 0 : value.then;
        if (typeof then2 === "function") {
          let d;
          const promise = FunctionPrototypeCall(
            then2,
            value,
            (val) => {
              if (val != null) {
                throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
              }
            },
            (err) => {
              destroyer(d, err);
            }
          );
          return d = new Duplexify({
            // TODO (ronag): highWaterMark?
            objectMode: true,
            readable: false,
            write,
            final(cb) {
              final(async () => {
                try {
                  await promise;
                  process2.nextTick(cb, null);
                } catch (err) {
                  process2.nextTick(cb, err);
                }
              });
            },
            destroy
          });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
      }
      if (isBlob(body)) {
        return duplexify(body.arrayBuffer());
      }
      if (isIterable(body)) {
        return from(Duplexify, body, {
          // TODO (ronag): highWaterMark?
          objectMode: true,
          writable: false
        });
      }
      if (typeof (body === null || body === void 0 ? void 0 : body.writable) === "object" || typeof (body === null || body === void 0 ? void 0 : body.readable) === "object") {
        const readable = body !== null && body !== void 0 && body.readable ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable) ? body === null || body === void 0 ? void 0 : body.readable : duplexify(body.readable) : void 0;
        const writable = body !== null && body !== void 0 && body.writable ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable) ? body === null || body === void 0 ? void 0 : body.writable : duplexify(body.writable) : void 0;
        return _duplexify({
          readable,
          writable
        });
      }
      const then = body === null || body === void 0 ? void 0 : body.then;
      if (typeof then === "function") {
        let d;
        FunctionPrototypeCall(
          then,
          body,
          (val) => {
            if (val != null) {
              d.push(val);
            }
            d.push(null);
          },
          (err) => {
            destroyer(d, err);
          }
        );
        return d = new Duplexify({
          objectMode: true,
          writable: false,
          read() {
          }
        });
      }
      throw new ERR_INVALID_ARG_TYPE(
        name,
        [
          "Blob",
          "ReadableStream",
          "WritableStream",
          "Stream",
          "Iterable",
          "AsyncIterable",
          "Function",
          "{ readable, writable } pair",
          "Promise"
        ],
        body
      );
    };
    function fromAsyncGen(fn) {
      let { promise, resolve } = createDeferredPromise();
      const ac = new AbortController();
      const signal = ac.signal;
      const value = fn(
        async function* () {
          while (true) {
            const _promise = promise;
            promise = null;
            const { chunk, done, cb } = await _promise;
            process2.nextTick(cb);
            if (done)
              return;
            if (signal.aborted)
              throw new AbortError(void 0, {
                cause: signal.reason
              });
            ({ promise, resolve } = createDeferredPromise());
            yield chunk;
          }
        }(),
        {
          signal
        }
      );
      return {
        value,
        write(chunk, encoding, cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            chunk,
            done: false,
            cb
          });
        },
        final(cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            done: true,
            cb
          });
        },
        destroy(err, cb) {
          ac.abort();
          cb(err);
        }
      };
    }
    function _duplexify(pair) {
      const r = pair.readable && typeof pair.readable.read !== "function" ? Readable5.wrap(pair.readable) : pair.readable;
      const w = pair.writable;
      let readable = !!isReadable(r);
      let writable = !!isWritable(w);
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        }
      }
      d = new Duplexify({
        // TODO (ronag): highWaterMark?
        readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),
        writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),
        readable,
        writable
      });
      if (writable) {
        eos(w, (err) => {
          writable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        d._write = function(chunk, encoding, callback) {
          if (w.write(chunk, encoding)) {
            callback();
          } else {
            ondrain = callback;
          }
        };
        d._final = function(callback) {
          w.end();
          onfinish = callback;
        };
        w.on("drain", function() {
          if (ondrain) {
            const cb = ondrain;
            ondrain = null;
            cb();
          }
        });
        w.on("finish", function() {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        eos(r, (err) => {
          readable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        r.on("readable", function() {
          if (onreadable) {
            const cb = onreadable;
            onreadable = null;
            cb();
          }
        });
        r.on("end", function() {
          d.push(null);
        });
        d._read = function() {
          while (true) {
            const buf = r.read();
            if (buf === null) {
              onreadable = d._read;
              return;
            }
            if (!d.push(buf)) {
              return;
            }
          }
        };
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          destroyer(w, err);
          destroyer(r, err);
        }
      };
      return d;
    }
  }
});

// node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/duplex.js
var require_duplex2 = __commonJS({
  "node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/duplex.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var {
      ObjectDefineProperties,
      ObjectGetOwnPropertyDescriptor,
      ObjectKeys,
      ObjectSetPrototypeOf
    } = require_primordials2();
    module.exports = Duplex;
    var Readable5 = require_readable2();
    var Writable = require_writable2();
    ObjectSetPrototypeOf(Duplex.prototype, Readable5.prototype);
    ObjectSetPrototypeOf(Duplex, Readable5);
    {
      const keys = ObjectKeys(Writable.prototype);
      for (let i = 0; i < keys.length; i++) {
        const method = keys[i];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable5.call(this, options);
      Writable.call(this, options);
      if (options) {
        this.allowHalfOpen = options.allowHalfOpen !== false;
        if (options.readable === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if (options.writable === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      } else {
        this.allowHalfOpen = true;
      }
    }
    ObjectDefineProperties(Duplex.prototype, {
      writable: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable")
      },
      writableHighWaterMark: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark")
      },
      writableObjectMode: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode")
      },
      writableBuffer: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer")
      },
      writableLength: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength")
      },
      writableFinished: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished")
      },
      writableCorked: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked")
      },
      writableEnded: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded")
      },
      writableNeedDrain: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain")
      },
      destroyed: {
        __proto__: null,
        get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set(value) {
          if (this._readableState && this._writableState) {
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
          }
        }
      }
    });
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Duplex.fromWeb = function(pair, options) {
      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
    };
    Duplex.toWeb = function(duplex) {
      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
    };
    var duplexify;
    Duplex.from = function(body) {
      if (!duplexify) {
        duplexify = require_duplexify2();
      }
      return duplexify(body, "body");
    };
  }
});

// node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/transform.js
var require_transform2 = __commonJS({
  "node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/transform.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials2();
    module.exports = Transform;
    var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors2().codes;
    var Duplex = require_duplex2();
    var { getHighWaterMark } = require_state2();
    ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
    ObjectSetPrototypeOf(Transform, Duplex);
    var kCallback = Symbol2("kCallback");
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
      if (readableHighWaterMark === 0) {
        options = {
          ...options,
          highWaterMark: null,
          readableHighWaterMark,
          // TODO (ronag): 0 is not optimal since we have
          // a "bug" where we check needDrain before calling _write and not after.
          // Refs: https://github.com/nodejs/node/pull/32887
          // Refs: https://github.com/nodejs/node/pull/35941
          writableHighWaterMark: options.writableHighWaterMark || 0
        };
      }
      Duplex.call(this, options);
      this._readableState.sync = false;
      this[kCallback] = null;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function final(cb) {
      if (typeof this._flush === "function" && !this.destroyed) {
        this._flush((er, data) => {
          if (er) {
            if (cb) {
              cb(er);
            } else {
              this.destroy(er);
            }
            return;
          }
          if (data != null) {
            this.push(data);
          }
          this.push(null);
          if (cb) {
            cb();
          }
        });
      } else {
        this.push(null);
        if (cb) {
          cb();
        }
      }
    }
    function prefinish() {
      if (this._final !== final) {
        final.call(this);
      }
    }
    Transform.prototype._final = final;
    Transform.prototype._transform = function(chunk, encoding, callback) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
    };
    Transform.prototype._write = function(chunk, encoding, callback) {
      const rState = this._readableState;
      const wState = this._writableState;
      const length = rState.length;
      this._transform(chunk, encoding, (err, val) => {
        if (err) {
          callback(err);
          return;
        }
        if (val != null) {
          this.push(val);
        }
        if (wState.ended || // Backwards compat.
        length === rState.length || // Backwards compat.
        rState.length < rState.highWaterMark) {
          callback();
        } else {
          this[kCallback] = callback;
        }
      });
    };
    Transform.prototype._read = function() {
      if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
      }
    };
  }
});

// node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/passthrough.js
var require_passthrough2 = __commonJS({
  "node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/passthrough.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var { ObjectSetPrototypeOf } = require_primordials2();
    module.exports = PassThrough;
    var Transform = require_transform2();
    ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);
    ObjectSetPrototypeOf(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline2 = __commonJS({
  "node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
    var import_dist159 = __toESM(require_dist());
    var process2 = require_browser();
    var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator } = require_primordials2();
    var eos = require_end_of_stream2();
    var { once } = require_util2();
    var destroyImpl = require_destroy2();
    var Duplex = require_duplex2();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE,
        ERR_INVALID_RETURN_VALUE,
        ERR_MISSING_ARGS,
        ERR_STREAM_DESTROYED,
        ERR_STREAM_PREMATURE_CLOSE
      },
      AbortError
    } = require_errors2();
    var { validateFunction, validateAbortSignal } = require_validators2();
    var {
      isIterable,
      isReadable,
      isReadableNodeStream,
      isNodeStream,
      isTransformStream,
      isWebStream,
      isReadableStream,
      isReadableEnded
    } = require_utils2();
    var AbortController = globalThis.AbortController || require_browser3().AbortController;
    var PassThrough;
    var Readable5;
    function destroyer(stream, reading, writing) {
      let finished = false;
      stream.on("close", () => {
        finished = true;
      });
      const cleanup = eos(
        stream,
        {
          readable: reading,
          writable: writing
        },
        (err) => {
          finished = !err;
        }
      );
      return {
        destroy: (err) => {
          if (finished)
            return;
          finished = true;
          destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
        },
        cleanup
      };
    }
    function popCallback(streams) {
      validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
      return streams.pop();
    }
    function makeAsyncIterable(val) {
      if (isIterable(val)) {
        return val;
      } else if (isReadableNodeStream(val)) {
        return fromReadable(val);
      }
      throw new ERR_INVALID_ARG_TYPE("val", ["Readable", "Iterable", "AsyncIterable"], val);
    }
    async function* fromReadable(val) {
      if (!Readable5) {
        Readable5 = require_readable2();
      }
      yield* Readable5.prototype[SymbolAsyncIterator].call(val);
    }
    async function pumpToNode(iterable, writable, finish, { end }) {
      let error;
      let onresolve = null;
      const resume = (err) => {
        if (err) {
          error = err;
        }
        if (onresolve) {
          const callback = onresolve;
          onresolve = null;
          callback();
        }
      };
      const wait = () => new Promise2((resolve, reject) => {
        if (error) {
          reject(error);
        } else {
          onresolve = () => {
            if (error) {
              reject(error);
            } else {
              resolve();
            }
          };
        }
      });
      writable.on("drain", resume);
      const cleanup = eos(
        writable,
        {
          readable: false
        },
        resume
      );
      try {
        if (writable.writableNeedDrain) {
          await wait();
        }
        for await (const chunk of iterable) {
          if (!writable.write(chunk)) {
            await wait();
          }
        }
        if (end) {
          writable.end();
        }
        await wait();
        finish();
      } catch (err) {
        finish(error !== err ? aggregateTwoErrors(error, err) : err);
      } finally {
        cleanup();
        writable.off("drain", resume);
      }
    }
    async function pumpToWeb(readable, writable, finish, { end }) {
      if (isTransformStream(writable)) {
        writable = writable.writable;
      }
      const writer = writable.getWriter();
      try {
        for await (const chunk of readable) {
          await writer.ready;
          writer.write(chunk).catch(() => {
          });
        }
        await writer.ready;
        if (end) {
          await writer.close();
        }
        finish();
      } catch (err) {
        try {
          await writer.abort(err);
          finish(err);
        } catch (err2) {
          finish(err2);
        }
      }
    }
    function pipeline(...streams) {
      return pipelineImpl(streams, once(popCallback(streams)));
    }
    function pipelineImpl(streams, callback, opts) {
      if (streams.length === 1 && ArrayIsArray(streams[0])) {
        streams = streams[0];
      }
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      const ac = new AbortController();
      const signal = ac.signal;
      const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;
      const lastStreamCleanup = [];
      validateAbortSignal(outerSignal, "options.signal");
      function abort() {
        finishImpl(new AbortError());
      }
      outerSignal === null || outerSignal === void 0 ? void 0 : outerSignal.addEventListener("abort", abort);
      let error;
      let value;
      const destroys = [];
      let finishCount = 0;
      function finish(err) {
        finishImpl(err, --finishCount === 0);
      }
      function finishImpl(err, final) {
        if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
          error = err;
        }
        if (!error && !final) {
          return;
        }
        while (destroys.length) {
          destroys.shift()(error);
        }
        outerSignal === null || outerSignal === void 0 ? void 0 : outerSignal.removeEventListener("abort", abort);
        ac.abort();
        if (final) {
          if (!error) {
            lastStreamCleanup.forEach((fn) => fn());
          }
          process2.nextTick(callback, error, value);
        }
      }
      let ret;
      for (let i = 0; i < streams.length; i++) {
        const stream = streams[i];
        const reading = i < streams.length - 1;
        const writing = i > 0;
        const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;
        const isLastStream = i === streams.length - 1;
        if (isNodeStream(stream)) {
          let onError2 = function(err) {
            if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              finish(err);
            }
          };
          var onError = onError2;
          if (end) {
            const { destroy, cleanup } = destroyer(stream, reading, writing);
            destroys.push(destroy);
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
          stream.on("error", onError2);
          if (isReadable(stream) && isLastStream) {
            lastStreamCleanup.push(() => {
              stream.removeListener("error", onError2);
            });
          }
        }
        if (i === 0) {
          if (typeof stream === "function") {
            ret = stream({
              signal
            });
            if (!isIterable(ret)) {
              throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
            }
          } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
            ret = stream;
          } else {
            ret = Duplex.from(stream);
          }
        } else if (typeof stream === "function") {
          if (isTransformStream(ret)) {
            var _ret;
            ret = makeAsyncIterable((_ret = ret) === null || _ret === void 0 ? void 0 : _ret.readable);
          } else {
            ret = makeAsyncIterable(ret);
          }
          ret = stream(ret, {
            signal
          });
          if (reading) {
            if (!isIterable(ret, true)) {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
            }
          } else {
            var _ret2;
            if (!PassThrough) {
              PassThrough = require_passthrough2();
            }
            const pt = new PassThrough({
              objectMode: true
            });
            const then = (_ret2 = ret) === null || _ret2 === void 0 ? void 0 : _ret2.then;
            if (typeof then === "function") {
              finishCount++;
              then.call(
                ret,
                (val) => {
                  value = val;
                  if (val != null) {
                    pt.write(val);
                  }
                  if (end) {
                    pt.end();
                  }
                  process2.nextTick(finish);
                },
                (err) => {
                  pt.destroy(err);
                  process2.nextTick(finish, err);
                }
              );
            } else if (isIterable(ret, true)) {
              finishCount++;
              pumpToNode(ret, pt, finish, {
                end
              });
            } else if (isReadableStream(ret) || isTransformStream(ret)) {
              const toRead = ret.readable || ret;
              finishCount++;
              pumpToNode(toRead, pt, finish, {
                end
              });
            } else {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
            }
            ret = pt;
            const { destroy, cleanup } = destroyer(ret, false, true);
            destroys.push(destroy);
            if (isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
        } else if (isNodeStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount += 2;
            const cleanup = pipe(ret, stream, finish, {
              end
            });
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          } else if (isTransformStream(ret) || isReadableStream(ret)) {
            const toRead = ret.readable || ret;
            finishCount++;
            pumpToNode(toRead, stream, finish, {
              end
            });
          } else if (isIterable(ret)) {
            finishCount++;
            pumpToNode(ret, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else if (isWebStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount++;
            pumpToWeb(makeAsyncIterable(ret), stream, finish, {
              end
            });
          } else if (isReadableStream(ret) || isIterable(ret)) {
            finishCount++;
            pumpToWeb(ret, stream, finish, {
              end
            });
          } else if (isTransformStream(ret)) {
            finishCount++;
            pumpToWeb(ret.readable, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else {
          ret = Duplex.from(stream);
        }
      }
      if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted) {
        process2.nextTick(abort);
      }
      return ret;
    }
    function pipe(src, dst, finish, { end }) {
      let ended = false;
      dst.on("close", () => {
        if (!ended) {
          finish(new ERR_STREAM_PREMATURE_CLOSE());
        }
      });
      src.pipe(dst, {
        end: false
      });
      if (end) {
        let endFn2 = function() {
          ended = true;
          dst.end();
        };
        var endFn = endFn2;
        if (isReadableEnded(src)) {
          process2.nextTick(endFn2);
        } else {
          src.once("end", endFn2);
        }
      } else {
        finish();
      }
      eos(
        src,
        {
          readable: true,
          writable: false
        },
        (err) => {
          const rState = src._readableState;
          if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
            src.once("end", finish).once("error", finish);
          } else {
            finish(err);
          }
        }
      );
      return eos(
        dst,
        {
          readable: false,
          writable: true
        },
        finish
      );
    }
    module.exports = {
      pipelineImpl,
      pipeline
    };
  }
});

// node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/compose.js
var require_compose2 = __commonJS({
  "node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/compose.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var { pipeline } = require_pipeline2();
    var Duplex = require_duplex2();
    var { destroyer } = require_destroy2();
    var {
      isNodeStream,
      isReadable,
      isWritable,
      isWebStream,
      isTransformStream,
      isWritableStream,
      isReadableStream
    } = require_utils2();
    var {
      AbortError,
      codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
    } = require_errors2();
    var eos = require_end_of_stream2();
    module.exports = function compose(...streams) {
      if (streams.length === 0) {
        throw new ERR_MISSING_ARGS("streams");
      }
      if (streams.length === 1) {
        return Duplex.from(streams[0]);
      }
      const orgStreams = [...streams];
      if (typeof streams[0] === "function") {
        streams[0] = Duplex.from(streams[0]);
      }
      if (typeof streams[streams.length - 1] === "function") {
        const idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
      }
      for (let n = 0; n < streams.length; ++n) {
        if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {
          continue;
        }
        if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
        }
        if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
        }
      }
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        } else if (!readable && !writable) {
          d.destroy();
        }
      }
      const head = streams[0];
      const tail = pipeline(streams, onfinished);
      const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
      const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));
      d = new Duplex({
        // TODO (ronag): highWaterMark?
        writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),
        readableObjectMode: !!(tail !== null && tail !== void 0 && tail.writableObjectMode),
        writable,
        readable
      });
      if (writable) {
        if (isNodeStream(head)) {
          d._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding)) {
              callback();
            } else {
              ondrain = callback;
            }
          };
          d._final = function(callback) {
            head.end();
            onfinish = callback;
          };
          head.on("drain", function() {
            if (ondrain) {
              const cb = ondrain;
              ondrain = null;
              cb();
            }
          });
        } else if (isWebStream(head)) {
          const writable2 = isTransformStream(head) ? head.writable : head;
          const writer = writable2.getWriter();
          d._write = async function(chunk, encoding, callback) {
            try {
              await writer.ready;
              writer.write(chunk).catch(() => {
              });
              callback();
            } catch (err) {
              callback(err);
            }
          };
          d._final = async function(callback) {
            try {
              await writer.ready;
              writer.close().catch(() => {
              });
              onfinish = callback;
            } catch (err) {
              callback(err);
            }
          };
        }
        const toRead = isTransformStream(tail) ? tail.readable : tail;
        eos(toRead, () => {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        if (isNodeStream(tail)) {
          tail.on("readable", function() {
            if (onreadable) {
              const cb = onreadable;
              onreadable = null;
              cb();
            }
          });
          tail.on("end", function() {
            d.push(null);
          });
          d._read = function() {
            while (true) {
              const buf = tail.read();
              if (buf === null) {
                onreadable = d._read;
                return;
              }
              if (!d.push(buf)) {
                return;
              }
            }
          };
        } else if (isWebStream(tail)) {
          const readable2 = isTransformStream(tail) ? tail.readable : tail;
          const reader = readable2.getReader();
          d._read = async function() {
            while (true) {
              try {
                const { value, done } = await reader.read();
                if (!d.push(value)) {
                  return;
                }
                if (done) {
                  d.push(null);
                  return;
                }
              } catch {
                return;
              }
            }
          };
        }
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          if (isNodeStream(tail)) {
            destroyer(tail, err);
          }
        }
      };
      return d;
    };
  }
});

// node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/operators.js
var require_operators2 = __commonJS({
  "node_modules/@tbdex/http-client/node_modules/readable-stream/lib/internal/streams/operators.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var AbortController = globalThis.AbortController || require_browser3().AbortController;
    var {
      codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
      AbortError
    } = require_errors2();
    var { validateAbortSignal, validateInteger, validateObject } = require_validators2();
    var kWeakHandler = require_primordials2().Symbol("kWeak");
    var { finished } = require_end_of_stream2();
    var staticCompose = require_compose2();
    var { addAbortSignalNoValidate } = require_add_abort_signal2();
    var { isWritable, isNodeStream } = require_utils2();
    var {
      ArrayPrototypePush,
      MathFloor,
      Number: Number2,
      NumberIsNaN,
      Promise: Promise2,
      PromiseReject,
      PromisePrototypeThen,
      Symbol: Symbol2
    } = require_primordials2();
    var kEmpty = Symbol2("kEmpty");
    var kEof = Symbol2("kEof");
    function compose(stream, options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      if (isNodeStream(stream) && !isWritable(stream)) {
        throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
      }
      const composedStream = staticCompose(this, stream);
      if (options !== null && options !== void 0 && options.signal) {
        addAbortSignalNoValidate(options.signal, composedStream);
      }
      return composedStream;
    }
    function map(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let concurrency = 1;
      if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {
        concurrency = MathFloor(options.concurrency);
      }
      validateInteger(concurrency, "concurrency", 1);
      return (async function* map2() {
        var _options$signal, _options$signal2;
        const ac = new AbortController();
        const stream = this;
        const queue = [];
        const signal = ac.signal;
        const signalOpt = {
          signal
        };
        const abort = () => ac.abort();
        if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted) {
          abort();
        }
        options === null || options === void 0 ? void 0 : (_options$signal2 = options.signal) === null || _options$signal2 === void 0 ? void 0 : _options$signal2.addEventListener("abort", abort);
        let next;
        let resume;
        let done = false;
        function onDone() {
          done = true;
        }
        async function pump() {
          try {
            for await (let val of stream) {
              var _val;
              if (done) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              try {
                val = fn(val, signalOpt);
              } catch (err) {
                val = PromiseReject(err);
              }
              if (val === kEmpty) {
                continue;
              }
              if (typeof ((_val = val) === null || _val === void 0 ? void 0 : _val.catch) === "function") {
                val.catch(onDone);
              }
              queue.push(val);
              if (next) {
                next();
                next = null;
              }
              if (!done && queue.length && queue.length >= concurrency) {
                await new Promise2((resolve) => {
                  resume = resolve;
                });
              }
            }
            queue.push(kEof);
          } catch (err) {
            const val = PromiseReject(err);
            PromisePrototypeThen(val, void 0, onDone);
            queue.push(val);
          } finally {
            var _options$signal3;
            done = true;
            if (next) {
              next();
              next = null;
            }
            options === null || options === void 0 ? void 0 : (_options$signal3 = options.signal) === null || _options$signal3 === void 0 ? void 0 : _options$signal3.removeEventListener("abort", abort);
          }
        }
        pump();
        try {
          while (true) {
            while (queue.length > 0) {
              const val = await queue[0];
              if (val === kEof) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              if (val !== kEmpty) {
                yield val;
              }
              queue.shift();
              if (resume) {
                resume();
                resume = null;
              }
            }
            await new Promise2((resolve) => {
              next = resolve;
            });
          }
        } finally {
          ac.abort();
          done = true;
          if (resume) {
            resume();
            resume = null;
          }
        }
      }).call(this);
    }
    function asIndexedPairs(options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      return (async function* asIndexedPairs2() {
        let index = 0;
        for await (const val of this) {
          var _options$signal4;
          if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted) {
            throw new AbortError({
              cause: options.signal.reason
            });
          }
          yield [index++, val];
        }
      }).call(this);
    }
    async function some(fn, options = void 0) {
      for await (const unused of filter.call(this, fn, options)) {
        return true;
      }
      return false;
    }
    async function every(fn, options = void 0) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      return !await some.call(
        this,
        async (...args) => {
          return !await fn(...args);
        },
        options
      );
    }
    async function find(fn, options) {
      for await (const result of filter.call(this, fn, options)) {
        return result;
      }
      return void 0;
    }
    async function forEach(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      async function forEachFn(value, options2) {
        await fn(value, options2);
        return kEmpty;
      }
      for await (const unused of map.call(this, forEachFn, options))
        ;
    }
    function filter(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      async function filterFn(value, options2) {
        if (await fn(value, options2)) {
          return value;
        }
        return kEmpty;
      }
      return map.call(this, filterFn, options);
    }
    var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function reduce(reducer, initialValue, options) {
      var _options$signal5;
      if (typeof reducer !== "function") {
        throw new ERR_INVALID_ARG_TYPE("reducer", ["Function", "AsyncFunction"], reducer);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let hasInitialValue = arguments.length > 1;
      if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) {
        const err = new AbortError(void 0, {
          cause: options.signal.reason
        });
        this.once("error", () => {
        });
        await finished(this.destroy(err));
        throw err;
      }
      const ac = new AbortController();
      const signal = ac.signal;
      if (options !== null && options !== void 0 && options.signal) {
        const opts = {
          once: true,
          [kWeakHandler]: this
        };
        options.signal.addEventListener("abort", () => ac.abort(), opts);
      }
      let gotAnyItemFromStream = false;
      try {
        for await (const value of this) {
          var _options$signal6;
          gotAnyItemFromStream = true;
          if (options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted) {
            throw new AbortError();
          }
          if (!hasInitialValue) {
            initialValue = value;
            hasInitialValue = true;
          } else {
            initialValue = await reducer(initialValue, value, {
              signal
            });
          }
        }
        if (!gotAnyItemFromStream && !hasInitialValue) {
          throw new ReduceAwareErrMissingArgs();
        }
      } finally {
        ac.abort();
      }
      return initialValue;
    }
    async function toArray(options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      const result = [];
      for await (const val of this) {
        var _options$signal7;
        if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted) {
          throw new AbortError(void 0, {
            cause: options.signal.reason
          });
        }
        ArrayPrototypePush(result, val);
      }
      return result;
    }
    function flatMap(fn, options) {
      const values = map.call(this, fn, options);
      return (async function* flatMap2() {
        for await (const val of values) {
          yield* val;
        }
      }).call(this);
    }
    function toIntegerOrInfinity(number) {
      number = Number2(number);
      if (NumberIsNaN(number)) {
        return 0;
      }
      if (number < 0) {
        throw new ERR_OUT_OF_RANGE("number", ">= 0", number);
      }
      return number;
    }
    function drop(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return (async function* drop2() {
        var _options$signal8;
        if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal9;
          if (options !== null && options !== void 0 && (_options$signal9 = options.signal) !== null && _options$signal9 !== void 0 && _options$signal9.aborted) {
            throw new AbortError();
          }
          if (number-- <= 0) {
            yield val;
          }
        }
      }).call(this);
    }
    function take(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return (async function* take2() {
        var _options$signal10;
        if (options !== null && options !== void 0 && (_options$signal10 = options.signal) !== null && _options$signal10 !== void 0 && _options$signal10.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal11;
          if (options !== null && options !== void 0 && (_options$signal11 = options.signal) !== null && _options$signal11 !== void 0 && _options$signal11.aborted) {
            throw new AbortError();
          }
          if (number-- > 0) {
            yield val;
          } else {
            return;
          }
        }
      }).call(this);
    }
    module.exports.streamReturningOperators = {
      asIndexedPairs,
      drop,
      filter,
      flatMap,
      map,
      take,
      compose
    };
    module.exports.promiseReturningOperators = {
      every,
      forEach,
      reduce,
      toArray,
      some,
      find
    };
  }
});

// node_modules/@tbdex/http-client/node_modules/readable-stream/lib/stream/promises.js
var require_promises2 = __commonJS({
  "node_modules/@tbdex/http-client/node_modules/readable-stream/lib/stream/promises.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials2();
    var { isIterable, isNodeStream, isWebStream } = require_utils2();
    var { pipelineImpl: pl } = require_pipeline2();
    var { finished } = require_end_of_stream2();
    require_stream2();
    function pipeline(...streams) {
      return new Promise2((resolve, reject) => {
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
          const options = ArrayPrototypePop(streams);
          signal = options.signal;
          end = options.end;
        }
        pl(
          streams,
          (err, value) => {
            if (err) {
              reject(err);
            } else {
              resolve(value);
            }
          },
          {
            signal,
            end
          }
        );
      });
    }
    module.exports = {
      finished,
      pipeline
    };
  }
});

// node_modules/@tbdex/http-client/node_modules/readable-stream/lib/stream.js
var require_stream2 = __commonJS({
  "node_modules/@tbdex/http-client/node_modules/readable-stream/lib/stream.js"(exports, module) {
    var import_dist159 = __toESM(require_dist());
    var { Buffer } = require_buffer_polyfill();
    var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials2();
    var {
      promisify: { custom: customPromisify }
    } = require_util2();
    var { streamReturningOperators, promiseReturningOperators } = require_operators2();
    var {
      codes: { ERR_ILLEGAL_CONSTRUCTOR }
    } = require_errors2();
    var compose = require_compose2();
    var { pipeline } = require_pipeline2();
    var { destroyer } = require_destroy2();
    var eos = require_end_of_stream2();
    var promises = require_promises2();
    var utils = require_utils2();
    var Stream3 = module.exports = require_legacy2().Stream;
    Stream3.isDisturbed = utils.isDisturbed;
    Stream3.isErrored = utils.isErrored;
    Stream3.isReadable = utils.isReadable;
    Stream3.Readable = require_readable2();
    for (const key of ObjectKeys(streamReturningOperators)) {
      let fn2 = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return Stream3.Readable.from(ReflectApply(op, this, args));
      };
      fn = fn2;
      const op = streamReturningOperators[key];
      ObjectDefineProperty(fn2, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn2, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream3.Readable.prototype, key, {
        __proto__: null,
        value: fn2,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    var fn;
    for (const key of ObjectKeys(promiseReturningOperators)) {
      let fn2 = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return ReflectApply(op, this, args);
      };
      fn = fn2;
      const op = promiseReturningOperators[key];
      ObjectDefineProperty(fn2, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn2, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream3.Readable.prototype, key, {
        __proto__: null,
        value: fn2,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    var fn;
    Stream3.Writable = require_writable2();
    Stream3.Duplex = require_duplex2();
    Stream3.Transform = require_transform2();
    Stream3.PassThrough = require_passthrough2();
    Stream3.pipeline = pipeline;
    var { addAbortSignal } = require_add_abort_signal2();
    Stream3.addAbortSignal = addAbortSignal;
    Stream3.finished = eos;
    Stream3.destroy = destroyer;
    Stream3.compose = compose;
    ObjectDefineProperty(Stream3, "promises", {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    ObjectDefineProperty(pipeline, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.pipeline;
      }
    });
    ObjectDefineProperty(eos, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.finished;
      }
    });
    Stream3.Stream = Stream3;
    Stream3._isUint8Array = function isUint8Array(value) {
      return value instanceof Uint8Array;
    };
    Stream3._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
      return Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    };
  }
});

// node_modules/@tbdex/http-client/node_modules/readable-stream/lib/ours/browser.js
var require_browser5 = __commonJS({
  "node_modules/@tbdex/http-client/node_modules/readable-stream/lib/ours/browser.js"(exports, module) {
    "use strict";
    var import_dist159 = __toESM(require_dist());
    var CustomStream = require_stream2();
    var promises = require_promises2();
    var originalDestroy = CustomStream.Readable.destroy;
    module.exports = CustomStream.Readable;
    module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
    module.exports._isUint8Array = CustomStream._isUint8Array;
    module.exports.isDisturbed = CustomStream.isDisturbed;
    module.exports.isErrored = CustomStream.isErrored;
    module.exports.isReadable = CustomStream.isReadable;
    module.exports.Readable = CustomStream.Readable;
    module.exports.Writable = CustomStream.Writable;
    module.exports.Duplex = CustomStream.Duplex;
    module.exports.Transform = CustomStream.Transform;
    module.exports.PassThrough = CustomStream.PassThrough;
    module.exports.addAbortSignal = CustomStream.addAbortSignal;
    module.exports.finished = CustomStream.finished;
    module.exports.destroy = CustomStream.destroy;
    module.exports.destroy = originalDestroy;
    module.exports.pipeline = CustomStream.pipeline;
    module.exports.compose = CustomStream.compose;
    Object.defineProperty(CustomStream, "promises", {
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    module.exports.Stream = CustomStream.Stream;
    module.exports.default = module.exports;
  }
});

// node_modules/@tbdex/http-client/node_modules/ms/index.js
var require_ms2 = __commonJS({
  "node_modules/@tbdex/http-client/node_modules/ms/index.js"(exports, module) {
    var import_dist159 = __toESM(require_dist());
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms4) {
      var msAbs = Math.abs(ms4);
      if (msAbs >= d) {
        return Math.round(ms4 / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms4 / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms4 / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms4 / s) + "s";
      }
      return ms4 + "ms";
    }
    function fmtLong(ms4) {
      var msAbs = Math.abs(ms4);
      if (msAbs >= d) {
        return plural(ms4, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms4, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms4, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms4, msAbs, s, "second");
      }
      return ms4 + " ms";
    }
    function plural(ms4, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms4 / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/@tbdex/http-client/dist/esm/src/main.js
var import_dist158 = __toESM(require_dist());

// node_modules/@tbdex/protocol/dist/esm/src/main.js
var import_dist83 = __toESM(require_dist());

// node_modules/@tbdex/protocol/dist/esm/src/resource.js
var import_dist60 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/node_modules/typeid-js/dist/index.mjs
var import_dist5 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/node_modules/typeid-js/dist/chunk-FOHWUNKU.mjs
var import_dist4 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/node_modules/typeid-js/dist/chunk-4WQUCFGE.mjs
var import_dist = __toESM(require_dist(), 1);
var alphabet = "0123456789abcdefghjkmnpqrstvwxyz";
var dec = new Uint8Array([
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  255,
  18,
  19,
  255,
  20,
  21,
  255,
  22,
  23,
  24,
  25,
  26,
  255,
  27,
  28,
  29,
  30,
  31,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255
]);
function encode2(src) {
  const dst = new Array(26).fill("");
  if (src.length !== 16) {
    throw new Error("Invalid length");
  }
  dst[0] = alphabet[(src[0] & 224) >> 5];
  dst[1] = alphabet[src[0] & 31];
  dst[2] = alphabet[(src[1] & 248) >> 3];
  dst[3] = alphabet[(src[1] & 7) << 2 | (src[2] & 192) >> 6];
  dst[4] = alphabet[(src[2] & 62) >> 1];
  dst[5] = alphabet[(src[2] & 1) << 4 | (src[3] & 240) >> 4];
  dst[6] = alphabet[(src[3] & 15) << 1 | (src[4] & 128) >> 7];
  dst[7] = alphabet[(src[4] & 124) >> 2];
  dst[8] = alphabet[(src[4] & 3) << 3 | (src[5] & 224) >> 5];
  dst[9] = alphabet[src[5] & 31];
  dst[10] = alphabet[(src[6] & 248) >> 3];
  dst[11] = alphabet[(src[6] & 7) << 2 | (src[7] & 192) >> 6];
  dst[12] = alphabet[(src[7] & 62) >> 1];
  dst[13] = alphabet[(src[7] & 1) << 4 | (src[8] & 240) >> 4];
  dst[14] = alphabet[(src[8] & 15) << 1 | (src[9] & 128) >> 7];
  dst[15] = alphabet[(src[9] & 124) >> 2];
  dst[16] = alphabet[(src[9] & 3) << 3 | (src[10] & 224) >> 5];
  dst[17] = alphabet[src[10] & 31];
  dst[18] = alphabet[(src[11] & 248) >> 3];
  dst[19] = alphabet[(src[11] & 7) << 2 | (src[12] & 192) >> 6];
  dst[20] = alphabet[(src[12] & 62) >> 1];
  dst[21] = alphabet[(src[12] & 1) << 4 | (src[13] & 240) >> 4];
  dst[22] = alphabet[(src[13] & 15) << 1 | (src[14] & 128) >> 7];
  dst[23] = alphabet[(src[14] & 124) >> 2];
  dst[24] = alphabet[(src[14] & 3) << 3 | (src[15] & 224) >> 5];
  dst[25] = alphabet[src[15] & 31];
  return dst.join("");
}
function decode2(s) {
  if (s.length !== 26) {
    throw new Error("Invalid length");
  }
  const encoder = new TextEncoder();
  const v = encoder.encode(s);
  if (dec[v[0]] === 255 || dec[v[1]] === 255 || dec[v[2]] === 255 || dec[v[3]] === 255 || dec[v[4]] === 255 || dec[v[5]] === 255 || dec[v[6]] === 255 || dec[v[7]] === 255 || dec[v[8]] === 255 || dec[v[9]] === 255 || dec[v[10]] === 255 || dec[v[11]] === 255 || dec[v[12]] === 255 || dec[v[13]] === 255 || dec[v[14]] === 255 || dec[v[15]] === 255 || dec[v[16]] === 255 || dec[v[17]] === 255 || dec[v[18]] === 255 || dec[v[19]] === 255 || dec[v[20]] === 255 || dec[v[21]] === 255 || dec[v[22]] === 255 || dec[v[23]] === 255 || dec[v[24]] === 255 || dec[v[25]] === 255) {
    throw new Error("Invalid base32 character");
  }
  const id = new Uint8Array(16);
  id[0] = dec[v[0]] << 5 | dec[v[1]];
  id[1] = dec[v[2]] << 3 | dec[v[3]] >> 2;
  id[2] = (dec[v[3]] & 3) << 6 | dec[v[4]] << 1 | dec[v[5]] >> 4;
  id[3] = (dec[v[5]] & 15) << 4 | dec[v[6]] >> 1;
  id[4] = (dec[v[6]] & 1) << 7 | dec[v[7]] << 2 | dec[v[8]] >> 3;
  id[5] = (dec[v[8]] & 7) << 5 | dec[v[9]];
  id[6] = dec[v[10]] << 3 | dec[v[11]] >> 2;
  id[7] = (dec[v[11]] & 3) << 6 | dec[v[12]] << 1 | dec[v[13]] >> 4;
  id[8] = (dec[v[13]] & 15) << 4 | dec[v[14]] >> 1;
  id[9] = (dec[v[14]] & 1) << 7 | dec[v[15]] << 2 | dec[v[16]] >> 3;
  id[10] = (dec[v[16]] & 7) << 5 | dec[v[17]];
  id[11] = dec[v[18]] << 3 | dec[v[19]] >> 2;
  id[12] = (dec[v[19]] & 3) << 6 | dec[v[20]] << 1 | dec[v[21]] >> 4;
  id[13] = (dec[v[21]] & 15) << 4 | dec[v[22]] >> 1;
  id[14] = (dec[v[22]] & 1) << 7 | dec[v[23]] << 2 | dec[v[24]] >> 3;
  id[15] = (dec[v[24]] & 7) << 5 | dec[v[25]];
  return id;
}

// node_modules/@tbdex/protocol/node_modules/typeid-js/dist/chunk-5QL2QZCM.mjs
var import_dist2 = __toESM(require_dist(), 1);
function parseUUID(uuid) {
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}

// node_modules/@tbdex/protocol/node_modules/typeid-js/dist/chunk-R5Q6Z3GN.mjs
var import_dist3 = __toESM(require_dist(), 1);
var __pow = Math.pow;

// node_modules/@tbdex/protocol/node_modules/typeid-js/dist/chunk-FOHWUNKU.mjs
var DIGITS = "0123456789abcdef";
var UUID = class {
  /** @param bytes - The 16-byte byte array representation. */
  constructor(bytes) {
    this.bytes = bytes;
    if (bytes.length !== 16) {
      throw new TypeError("not 128-bit length");
    }
  }
  /**
   * Builds a byte array from UUIDv7 field values.
   *
   * @param unixTsMs - A 48-bit `unix_ts_ms` field value.
   * @param randA - A 12-bit `rand_a` field value.
   * @param randBHi - The higher 30 bits of 62-bit `rand_b` field value.
   * @param randBLo - The lower 32 bits of 62-bit `rand_b` field value.
   */
  static fromFieldsV7(unixTsMs, randA, randBHi, randBLo) {
    if (!Number.isInteger(unixTsMs) || !Number.isInteger(randA) || !Number.isInteger(randBHi) || !Number.isInteger(randBLo) || unixTsMs < 0 || randA < 0 || randBHi < 0 || randBLo < 0 || unixTsMs > 281474976710655 || randA > 4095 || randBHi > 1073741823 || randBLo > 4294967295) {
      throw new RangeError("invalid field value");
    }
    const bytes = new Uint8Array(16);
    bytes[0] = unixTsMs / __pow(2, 40);
    bytes[1] = unixTsMs / __pow(2, 32);
    bytes[2] = unixTsMs / __pow(2, 24);
    bytes[3] = unixTsMs / __pow(2, 16);
    bytes[4] = unixTsMs / __pow(2, 8);
    bytes[5] = unixTsMs;
    bytes[6] = 112 | randA >>> 8;
    bytes[7] = randA;
    bytes[8] = 128 | randBHi >>> 24;
    bytes[9] = randBHi >>> 16;
    bytes[10] = randBHi >>> 8;
    bytes[11] = randBHi;
    bytes[12] = randBLo >>> 24;
    bytes[13] = randBLo >>> 16;
    bytes[14] = randBLo >>> 8;
    bytes[15] = randBLo;
    return new UUID(bytes);
  }
  /** @returns The 8-4-4-4-12 canonical hexadecimal string representation. */
  toString() {
    let text = "";
    for (let i = 0; i < this.bytes.length; i++) {
      text += DIGITS.charAt(this.bytes[i] >>> 4);
      text += DIGITS.charAt(this.bytes[i] & 15);
      if (i === 3 || i === 5 || i === 7 || i === 9) {
        text += "-";
      }
    }
    return text;
  }
  /** Creates an object from `this`. */
  clone() {
    return new UUID(this.bytes.slice(0));
  }
  /** Returns true if `this` is equivalent to `other`. */
  equals(other) {
    return this.compareTo(other) === 0;
  }
  /**
   * Returns a negative integer, zero, or positive integer if `this` is less
   * than, equal to, or greater than `other`, respectively.
   */
  compareTo(other) {
    for (let i = 0; i < 16; i++) {
      const diff = this.bytes[i] - other.bytes[i];
      if (diff !== 0) {
        return Math.sign(diff);
      }
    }
    return 0;
  }
};
var V7Generator = class {
  constructor() {
    this.timestamp = 0;
    this.counter = 0;
    this.random = new DefaultRandom();
  }
  /**
   * Generates a new UUIDv7 object from the current timestamp, or resets the
   * generator upon significant timestamp rollback.
   *
   * This method returns monotonically increasing UUIDs unless the up-to-date
   * timestamp is significantly (by ten seconds or more) smaller than the one
   * embedded in the immediately preceding UUID. If such a significant clock
   * rollback is detected, this method resets the generator and returns a new
   * UUID based on the current timestamp.
   */
  generate() {
    const value = this.generateOrAbort();
    if (value !== void 0) {
      return value;
    } else {
      this.timestamp = 0;
      return this.generateOrAbort();
    }
  }
  /**
   * Generates a new UUIDv7 object from the current timestamp, or returns
   * `undefined` upon significant timestamp rollback.
   *
   * This method returns monotonically increasing UUIDs unless the up-to-date
   * timestamp is significantly (by ten seconds or more) smaller than the one
   * embedded in the immediately preceding UUID. If such a significant clock
   * rollback is detected, this method aborts and returns `undefined`.
   */
  generateOrAbort() {
    const MAX_COUNTER = 4398046511103;
    const ROLLBACK_ALLOWANCE = 1e4;
    const ts = Date.now();
    if (ts > this.timestamp) {
      this.timestamp = ts;
      this.resetCounter();
    } else if (ts + ROLLBACK_ALLOWANCE > this.timestamp) {
      this.counter++;
      if (this.counter > MAX_COUNTER) {
        this.timestamp++;
        this.resetCounter();
      }
    } else {
      return void 0;
    }
    return UUID.fromFieldsV7(this.timestamp, Math.trunc(this.counter / __pow(2, 30)), this.counter & __pow(2, 30) - 1, this.random.nextUint32());
  }
  /** Initializes the counter at a 42-bit random integer. */
  resetCounter() {
    this.counter = this.random.nextUint32() * 1024 + (this.random.nextUint32() & 1023);
  }
};
var getRandomValues = (buffer) => {
  if (typeof UUIDV7_DENY_WEAK_RNG !== "undefined" && UUIDV7_DENY_WEAK_RNG) {
    throw new Error("no cryptographically strong RNG available");
  }
  for (let i = 0; i < buffer.length; i++) {
    buffer[i] = Math.trunc(Math.random() * 65536) * 65536 + Math.trunc(Math.random() * 65536);
  }
  return buffer;
};
if (typeof crypto !== "undefined" && crypto.getRandomValues) {
  getRandomValues = (buffer) => crypto.getRandomValues(buffer);
}
var DefaultRandom = class {
  constructor() {
    this.buffer = new Uint32Array(8);
    this.cursor = 99;
  }
  nextUint32() {
    if (this.cursor >= this.buffer.length) {
      getRandomValues(this.buffer);
      this.cursor = 0;
    }
    return this.buffer[this.cursor++];
  }
};
var defaultGenerator;
var uuidv7obj = () => (defaultGenerator || (defaultGenerator = new V7Generator())).generate();
function isValidPrefix(str) {
  if (str.length > 63) {
    return false;
  }
  let code;
  let i;
  let len;
  for (i = 0, len = str.length; i < len; i += 1) {
    code = str.charCodeAt(i);
    if (!(code > 96 && code < 123)) {
      return false;
    }
  }
  return true;
}
var TypeID = class {
  constructor(prefix, suffix = "") {
    this.prefix = prefix;
    this.suffix = suffix;
    if (!isValidPrefix(prefix)) {
      throw new Error("Invalid prefix. Must be at most 63 ascii letters [a-z]");
    }
    this.prefix = prefix;
    if (suffix) {
      this.suffix = suffix;
    } else {
      const uuid = uuidv7obj();
      this.suffix = encode2(uuid.bytes);
    }
    if (this.suffix.length !== 26) {
      throw new Error(`Invalid length. Suffix should have 26 characters, got ${suffix.length}`);
    }
    if (this.suffix[0] > "7") {
      throw new Error("Invalid suffix. First character must be in the range [0-7]");
    }
    const unused = decode2(this.suffix);
  }
  getType() {
    return this.prefix;
  }
  getSuffix() {
    return this.suffix;
  }
  asType(prefix) {
    const self = this;
    if (self.prefix !== prefix) {
      throw new Error(`Cannot convert TypeID of type ${self.prefix} to type ${prefix}`);
    }
    return self;
  }
  toUUIDBytes() {
    return decode2(this.suffix);
  }
  toUUID() {
    const uuid = new UUID(this.toUUIDBytes());
    return uuid.toString();
  }
  toString() {
    if (this.prefix === "") {
      return this.suffix;
    }
    return `${this.prefix}_${this.suffix}`;
  }
  static fromString(str) {
    const parts = str.split("_");
    if (parts.length === 1) {
      return new TypeID("", parts[0]);
    }
    if (parts.length === 2) {
      if (parts[0] === "") {
        throw new Error(`Invalid TypeID. Prefix cannot be empty when there's a separator: ${str}`);
      }
      return new TypeID(parts[0], parts[1]);
    }
    throw new Error(`Invalid TypeID string: ${str}`);
  }
  static fromUUIDBytes(prefix, bytes) {
    const suffix = encode2(bytes);
    return new TypeID(prefix, suffix);
  }
  static fromUUID(prefix, uuid) {
    const suffix = encode2(parseUUID(uuid));
    return new TypeID(prefix, suffix);
  }
};
function typeid(prefix = "", suffix = "") {
  return new TypeID(prefix, suffix);
}

// node_modules/@tbdex/protocol/dist/esm/src/crypto.js
var import_dist57 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/node_modules/@web5/common/dist/esm/index.js
var import_dist14 = __toESM(require_dist());

// node_modules/@tbdex/protocol/node_modules/@web5/common/dist/esm/cache.js
var import_dist6 = __toESM(require_dist(), 1);
var import_ttlcache = __toESM(require_ttlcache(), 1);

// node_modules/@tbdex/protocol/node_modules/@web5/common/dist/esm/convert.js
var import_dist8 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/node_modules/@web5/common/dist/esm/type-utils.js
var import_dist7 = __toESM(require_dist(), 1);
function isArrayBufferSlice(arrayBufferView) {
  return arrayBufferView.byteOffset !== 0 || arrayBufferView.byteLength !== arrayBufferView.buffer.byteLength;
}
function isAsyncIterable(obj) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  return typeof obj[Symbol.asyncIterator] === "function";
}
function universalTypeOf(value) {
  const typeString = Object.prototype.toString.call(value);
  const match = typeString.match(/\s([a-zA-Z0-9]+)/);
  const [_, type] = match;
  return type;
}

// node_modules/@tbdex/protocol/node_modules/@web5/common/dist/esm/convert.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __asyncValues = function(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
};
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder();
var Convert = class _Convert {
  constructor(data, format) {
    this.data = data;
    this.format = format;
  }
  static arrayBuffer(data) {
    return new _Convert(data, "ArrayBuffer");
  }
  static asyncIterable(data) {
    if (!isAsyncIterable(data)) {
      throw new TypeError("Input must be of type AsyncIterable.");
    }
    return new _Convert(data, "AsyncIterable");
  }
  static base32Z(data) {
    return new _Convert(data, "Base32Z");
  }
  static base58Btc(data) {
    return new _Convert(data, "Base58Btc");
  }
  static base64Url(data) {
    return new _Convert(data, "Base64Url");
  }
  /**
   * Reference:
   * The BufferSource type is a TypeScript type that represents an ArrayBuffer
   * or one of the ArrayBufferView types, such a TypedArray (e.g., Uint8Array)
   * or a DataView.
   */
  static bufferSource(data) {
    return new _Convert(data, "BufferSource");
  }
  static hex(data) {
    if (typeof data !== "string") {
      throw new TypeError("Hex input must be a string.");
    }
    if (data.length % 2 !== 0) {
      throw new TypeError("Hex input must have an even number of characters.");
    }
    return new _Convert(data, "Hex");
  }
  static multibase(data) {
    return new _Convert(data, "Multibase");
  }
  static object(data) {
    return new _Convert(data, "Object");
  }
  static string(data) {
    return new _Convert(data, "String");
  }
  static uint8Array(data) {
    return new _Convert(data, "Uint8Array");
  }
  toArrayBuffer() {
    switch (this.format) {
      case "Base58Btc": {
        return base58btc.baseDecode(this.data).buffer;
      }
      case "Base64Url": {
        return base64url.baseDecode(this.data).buffer;
      }
      case "BufferSource": {
        const dataType = universalTypeOf(this.data);
        if (dataType === "ArrayBuffer") {
          return this.data;
        } else if (ArrayBuffer.isView(this.data)) {
          if (isArrayBufferSlice(this.data)) {
            return this.data.buffer.slice(this.data.byteOffset, this.data.byteOffset + this.data.byteLength);
          } else {
            return this.data.buffer;
          }
        } else {
          throw new TypeError(`${this.format} value is not of type: ArrayBuffer, DataView, or TypedArray.`);
        }
      }
      case "Hex": {
        return this.toUint8Array().buffer;
      }
      case "String": {
        return this.toUint8Array().buffer;
      }
      case "Uint8Array": {
        return this.data.buffer;
      }
      default:
        throw new TypeError(`Conversion from ${this.format} to ArrayBuffer is not supported.`);
    }
  }
  toArrayBufferAsync() {
    return __awaiter(this, void 0, void 0, function* () {
      switch (this.format) {
        case "AsyncIterable": {
          const blob = yield this.toBlobAsync();
          return yield blob.arrayBuffer();
        }
        default:
          throw new TypeError(`Asynchronous conversion from ${this.format} to ArrayBuffer is not supported.`);
      }
    });
  }
  toBase32Z() {
    switch (this.format) {
      case "Uint8Array": {
        return base32z.baseEncode(this.data);
      }
      default:
        throw new TypeError(`Conversion from ${this.format} to Base64Z is not supported.`);
    }
  }
  toBase58Btc() {
    switch (this.format) {
      case "ArrayBuffer": {
        const u8a = new Uint8Array(this.data);
        return base58btc.baseEncode(u8a);
      }
      case "Multibase": {
        return this.data.substring(1);
      }
      case "Uint8Array": {
        return base58btc.baseEncode(this.data);
      }
      default:
        throw new TypeError(`Conversion from ${this.format} to Base58Btc is not supported.`);
    }
  }
  toBase64Url() {
    switch (this.format) {
      case "ArrayBuffer": {
        const u8a = new Uint8Array(this.data);
        return base64url.baseEncode(u8a);
      }
      case "BufferSource": {
        const u8a = this.toUint8Array();
        return base64url.baseEncode(u8a);
      }
      case "Object": {
        const string = JSON.stringify(this.data);
        const u8a = textEncoder.encode(string);
        return base64url.baseEncode(u8a);
      }
      case "String": {
        const u8a = textEncoder.encode(this.data);
        return base64url.baseEncode(u8a);
      }
      case "Uint8Array": {
        return base64url.baseEncode(this.data);
      }
      default:
        throw new TypeError(`Conversion from ${this.format} to Base64Url is not supported.`);
    }
  }
  toBlobAsync() {
    var _a, e_1, _b, _c;
    return __awaiter(this, void 0, void 0, function* () {
      switch (this.format) {
        case "AsyncIterable": {
          const chunks = [];
          try {
            for (var _d = true, _e = __asyncValues(this.data), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
              _c = _f.value;
              _d = false;
              const chunk = _c;
              chunks.push(chunk);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (!_d && !_a && (_b = _e.return))
                yield _b.call(_e);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          const blob = new Blob(chunks);
          return blob;
        }
        default:
          throw new TypeError(`Asynchronous conversion from ${this.format} to Blob is not supported.`);
      }
    });
  }
  toHex() {
    const hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
    switch (this.format) {
      case "ArrayBuffer": {
        const u8a = this.toUint8Array();
        return _Convert.uint8Array(u8a).toHex();
      }
      case "Base64Url": {
        const u8a = this.toUint8Array();
        return _Convert.uint8Array(u8a).toHex();
      }
      case "Uint8Array": {
        let hex = "";
        for (let i = 0; i < this.data.length; i++) {
          hex += hexes[this.data[i]];
        }
        return hex;
      }
      default:
        throw new TypeError(`Conversion from ${this.format} to Hex is not supported.`);
    }
  }
  toMultibase() {
    switch (this.format) {
      case "Base58Btc": {
        return `z${this.data}`;
      }
      default:
        throw new TypeError(`Conversion from ${this.format} to Multibase is not supported.`);
    }
  }
  toObject() {
    switch (this.format) {
      case "Base64Url": {
        const u8a = base64url.baseDecode(this.data);
        const text = textDecoder.decode(u8a);
        return JSON.parse(text);
      }
      case "String": {
        return JSON.parse(this.data);
      }
      case "Uint8Array": {
        const text = textDecoder.decode(this.data);
        return JSON.parse(text);
      }
      default:
        throw new TypeError(`Conversion from ${this.format} to Object is not supported.`);
    }
  }
  toObjectAsync() {
    return __awaiter(this, void 0, void 0, function* () {
      switch (this.format) {
        case "AsyncIterable": {
          const text = yield this.toStringAsync();
          const json = JSON.parse(text);
          return json;
        }
        default:
          throw new TypeError(`Asynchronous conversion from ${this.format} to Object is not supported.`);
      }
    });
  }
  toString() {
    switch (this.format) {
      case "ArrayBuffer": {
        return textDecoder.decode(this.data);
      }
      case "Base64Url": {
        const u8a = base64url.baseDecode(this.data);
        return textDecoder.decode(u8a);
      }
      case "Object": {
        return JSON.stringify(this.data);
      }
      case "Uint8Array": {
        return textDecoder.decode(this.data);
      }
      default:
        throw new TypeError(`Conversion from ${this.format} to String is not supported.`);
    }
  }
  toStringAsync() {
    var _a, e_2, _b, _c;
    return __awaiter(this, void 0, void 0, function* () {
      switch (this.format) {
        case "AsyncIterable": {
          let str = "";
          try {
            for (var _d = true, _e = __asyncValues(this.data), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
              _c = _f.value;
              _d = false;
              const chunk = _c;
              if (typeof chunk === "string")
                str += chunk;
              else
                str += textDecoder.decode(chunk, { stream: true });
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (!_d && !_a && (_b = _e.return))
                yield _b.call(_e);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
          str += textDecoder.decode(void 0, { stream: false });
          return str;
        }
        default:
          throw new TypeError(`Asynchronous conversion from ${this.format} to String is not supported.`);
      }
    });
  }
  toUint8Array() {
    switch (this.format) {
      case "ArrayBuffer": {
        return new Uint8Array(this.data);
      }
      case "Base32Z": {
        return base32z.baseDecode(this.data);
      }
      case "Base58Btc": {
        return base58btc.baseDecode(this.data);
      }
      case "Base64Url": {
        return base64url.baseDecode(this.data);
      }
      case "BufferSource": {
        const dataType = universalTypeOf(this.data);
        if (dataType === "Uint8Array") {
          return this.data;
        } else if (dataType === "ArrayBuffer") {
          return new Uint8Array(this.data);
        } else if (ArrayBuffer.isView(this.data)) {
          return new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);
        } else {
          throw new TypeError(`${this.format} value is not of type: ArrayBuffer, DataView, or TypedArray.`);
        }
      }
      case "Hex": {
        const u8a = new Uint8Array(this.data.length / 2);
        for (let i = 0; i < this.data.length; i += 2) {
          const byteValue = parseInt(this.data.substring(i, i + 2), 16);
          if (isNaN(byteValue)) {
            throw new TypeError("Input is not a valid hexadecimal string.");
          }
          u8a[i / 2] = byteValue;
        }
        return u8a;
      }
      case "Object": {
        const string = JSON.stringify(this.data);
        return textEncoder.encode(string);
      }
      case "String": {
        return textEncoder.encode(this.data);
      }
      default:
        throw new TypeError(`Conversion from ${this.format} to Uint8Array is not supported.`);
    }
  }
  toUint8ArrayAsync() {
    return __awaiter(this, void 0, void 0, function* () {
      switch (this.format) {
        case "AsyncIterable": {
          const arrayBuffer = yield this.toArrayBufferAsync();
          return new Uint8Array(arrayBuffer);
        }
        default:
          throw new TypeError(`Asynchronous conversion from ${this.format} to Uint8Array is not supported.`);
      }
    });
  }
};

// node_modules/@tbdex/protocol/node_modules/@web5/common/dist/esm/multicodec.js
var import_dist9 = __toESM(require_dist(), 1);
var Multicodec = class _Multicodec {
  /**
   * Adds a multicodec prefix to input data.
   *
   * @param options - The options for adding a prefix.
   * @param options.code - The codec code. Either the code or name must be provided.
   * @param options.name - The codec name. Either the code or name must be provided.
   * @param options.data - The data to be prefixed.
   * @returns The data with the added prefix as a Uint8Array.
   */
  static addPrefix(options) {
    var _a;
    let { code, data, name } = options;
    if (!(name ? !code : code)) {
      throw new Error(`Either 'name' or 'code' must be defined, but not both.`);
    }
    code = _Multicodec.codeToName.has(code) ? code : _Multicodec.nameToCode.get(name);
    if (code === void 0) {
      throw new Error(`Unsupported multicodec: ${(_a = options.name) !== null && _a !== void 0 ? _a : options.code}`);
    }
    const prefixLength = varint_exports.encodingLength(code);
    const dataWithPrefix = new Uint8Array(prefixLength + data.byteLength);
    dataWithPrefix.set(data, prefixLength);
    varint_exports.encodeTo(code, dataWithPrefix);
    return dataWithPrefix;
  }
  /**
   * Get the Multicodec code from given prefixed data.
   *
   * @param options - The options for getting the codec code.
   * @param options.prefixedData - The data to extract the codec code from.
   * @returns - The Multicodec code as a number.
   */
  static getCodeFromData(options) {
    const { prefixedData } = options;
    const [code, _] = varint_exports.decode(prefixedData);
    return code;
  }
  /**
   * Get the Multicodec code from given Multicodec name.
   *
   * @param options - The options for getting the codec code.
   * @param options.name - The name to lookup.
   * @returns - The Multicodec code as a number.
   */
  static getCodeFromName(options) {
    const { name } = options;
    const code = _Multicodec.nameToCode.get(name);
    if (code === void 0) {
      throw new Error(`Unsupported multicodec: ${name}`);
    }
    return code;
  }
  /**
   * Get the Multicodec name from given Multicodec code.
   *
   * @param options - The options for getting the codec name.
   * @param options.name - The code to lookup.
   * @returns - The Multicodec name as a string.
   */
  static getNameFromCode(options) {
    const { code } = options;
    const name = _Multicodec.codeToName.get(code);
    if (name === void 0) {
      throw new Error(`Unsupported multicodec: ${code}`);
    }
    return name;
  }
  /**
   * Registers a new codec in the Multicodec class.
   *
   * @param codec - The codec to be registered.
   */
  static registerCodec(codec) {
    _Multicodec.codeToName.set(codec.code, codec.name);
    _Multicodec.nameToCode.set(codec.name, codec.code);
  }
  /**
   * Returns the data with the Multicodec prefix removed.
   *
   * @param refixedData - The data to extract the codec code from.
   * @returns {Uint8Array}
   */
  static removePrefix(options) {
    const { prefixedData } = options;
    const [code, codeByteLength] = varint_exports.decode(prefixedData);
    const name = _Multicodec.codeToName.get(code);
    if (name === void 0) {
      throw new Error(`Unsupported multicodec: ${code}`);
    }
    return { code, data: prefixedData.slice(codeByteLength), name };
  }
};
Multicodec.codeToName = /* @__PURE__ */ new Map();
Multicodec.nameToCode = /* @__PURE__ */ new Map();
Multicodec.registerCodec({ code: 237, name: "ed25519-pub" });
Multicodec.registerCodec({ code: 4864, name: "ed25519-priv" });
Multicodec.registerCodec({ code: 236, name: "x25519-pub" });
Multicodec.registerCodec({ code: 4866, name: "x25519-priv" });
Multicodec.registerCodec({ code: 231, name: "secp256k1-pub" });
Multicodec.registerCodec({ code: 4865, name: "secp256k1-priv" });

// node_modules/@tbdex/protocol/node_modules/@web5/common/dist/esm/object.js
var import_dist10 = __toESM(require_dist(), 1);
function removeUndefinedProperties(obj) {
  Object.keys(obj).forEach((key) => {
    if (obj[key] === void 0) {
      delete obj[key];
    } else if (typeof obj[key] === "object") {
      removeUndefinedProperties(obj[key]);
    }
  });
}

// node_modules/@tbdex/protocol/node_modules/@web5/common/dist/esm/stores.js
var import_dist11 = __toESM(require_dist(), 1);
var import_level = __toESM(require_browser2(), 1);
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MemoryStore = class {
  constructor() {
    this.store = /* @__PURE__ */ new Map();
  }
  /**
   * Clears all entries in the key-value store.
   *
   * @returns A Promise that resolves when the operation is complete.
   */
  clear() {
    return __awaiter2(this, void 0, void 0, function* () {
      this.store.clear();
    });
  }
  /**
   * This operation is no-op for `MemoryStore`
   * and will log a warning if called.
   */
  close() {
    return __awaiter2(this, void 0, void 0, function* () {
    });
  }
  /**
   * Deletes an entry from the key-value store by its key.
   *
   * @param id - The key of the entry to delete.
   * @returns A Promise that resolves to a boolean indicating whether the entry was successfully deleted.
   */
  delete(id) {
    return __awaiter2(this, void 0, void 0, function* () {
      return this.store.delete(id);
    });
  }
  /**
   * Retrieves the value of an entry by its key.
   *
   * @param id - The key of the entry to retrieve.
   * @returns A Promise that resolves to the value of the entry, or `undefined` if the entry does not exist.
   */
  get(id) {
    return __awaiter2(this, void 0, void 0, function* () {
      return this.store.get(id);
    });
  }
  /**
   * Checks for the presence of an entry by key.
   *
   * @param id - The key to check for the existence of.
   * @returns A Promise that resolves to a boolean indicating whether an element with the specified key exists or not.
   */
  has(id) {
    return __awaiter2(this, void 0, void 0, function* () {
      return this.store.has(id);
    });
  }
  /**
   * Retrieves all values in the key-value store.
   *
   * @returns A Promise that resolves to an array of all values in the store.
   */
  list() {
    return __awaiter2(this, void 0, void 0, function* () {
      return Array.from(this.store.values());
    });
  }
  /**
   * Sets the value of an entry in the key-value store.
   *
   * @param id - The key of the entry to set.
   * @param key - The new value for the entry.
   * @returns A Promise that resolves when the operation is complete.
   */
  set(id, key) {
    return __awaiter2(this, void 0, void 0, function* () {
      this.store.set(id, key);
    });
  }
};

// node_modules/@tbdex/protocol/node_modules/@web5/common/dist/esm/stream.js
var import_dist12 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/node_modules/@web5/common/dist/esm/stream-node.js
var import_dist13 = __toESM(require_dist(), 1);
var import_readable_stream = __toESM(require_browser4(), 1);
var import_readable_stream2 = __toESM(require_browser4(), 1);

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/index.js
var import_dist39 = __toESM(require_dist());

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/local-key-manager.js
var import_dist25 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/algorithms/sha-2.js
var import_dist17 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/primitives/sha256.js
var import_dist15 = __toESM(require_dist(), 1);
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Sha256 = class {
  /**
   * Generates a SHA-256 hash digest for the given data.
   *
   * @remarks
   * This method produces a hash digest using the SHA-256 algorithm. The resultant digest
   * is deterministic, meaning the same data will always produce the same hash, but
   * is computationally infeasible to regenerate the original data from the hash.
   *
   * @example
   * ```ts
   * const data = new Uint8Array([...]);
   * const hash = await Sha256.digest({ data });
   * ```
   *
   * @param params - The parameters for the hashing operation.
   * @param params.data - The data to hash, represented as a Uint8Array.
   *
   * @returns A Promise that resolves to the SHA-256 hash digest of the provided data as a Uint8Array.
   */
  static digest({ data }) {
    return __awaiter3(this, void 0, void 0, function* () {
      const hash = sha256(data);
      return hash;
    });
  }
};

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/algorithms/crypto-algorithm.js
var import_dist16 = __toESM(require_dist(), 1);
var CryptoAlgorithm = class {
};

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/algorithms/sha-2.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Sha2Algorithm = class extends CryptoAlgorithm {
  /**
   * Generates a hash digest of the provided data.
   *
   * @remarks
   * A digest is the output of the hash function. It's a fixed-size string of bytes
   * that uniquely represents the data input into the hash function. The digest is often used for
   * data integrity checks, as any alteration in the input data results in a significantly
   * different digest.
   *
   * It takes the algorithm identifier of the hash function and data to digest as input and returns
   * the digest of the data.
   *
   * @example
   * ```ts
   * const sha2 = new Sha2Algorithm();
   * const data = new TextEncoder().encode('Messsage');
   * const digest = await sha2.digest({ data });
   * ```
   *
   * @param params - The parameters for the digest operation.
   * @param params.algorithm - The name of hash function to use.
   * @param params.data - The data to digest.
   *
   * @returns A Promise which will be fulfilled with the hash digest.
   */
  digest({ algorithm, data }) {
    return __awaiter4(this, void 0, void 0, function* () {
      switch (algorithm) {
        case "SHA-256": {
          const hash = yield Sha256.digest({ data });
          return hash;
        }
      }
    });
  }
};

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/algorithms/ecdsa.js
var import_dist22 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/primitives/secp256k1.js
var import_dist20 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/jose/jwk.js
var import_dist19 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/jose/utils.js
var import_dist18 = __toESM(require_dist(), 1);
function canonicalize(obj) {
  const sortObjKeys = (obj2) => {
    if (obj2 !== null && typeof obj2 === "object" && !Array.isArray(obj2)) {
      const sortedKeys = Object.keys(obj2).sort();
      const sortedObj2 = {};
      for (const key of sortedKeys) {
        sortedObj2[key] = sortObjKeys(obj2[key]);
      }
      return sortedObj2;
    }
    return obj2;
  };
  const sortedObj = sortObjKeys(obj);
  return JSON.stringify(sortedObj);
}

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/jose/jwk.js
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var KEY_URI_PREFIX_JWK = "urn:jwk:";
function computeJwkThumbprint({ jwk }) {
  return __awaiter5(this, void 0, void 0, function* () {
    const keyType = jwk.kty;
    let normalizedJwk;
    if (keyType === "EC") {
      normalizedJwk = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };
    } else if (keyType === "oct") {
      normalizedJwk = { k: jwk.k, kty: jwk.kty };
    } else if (keyType === "OKP") {
      normalizedJwk = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };
    } else if (keyType === "RSA") {
      normalizedJwk = { e: jwk.e, kty: jwk.kty, n: jwk.n };
    } else {
      throw new Error(`Unsupported key type: ${keyType}`);
    }
    removeUndefinedProperties(normalizedJwk);
    const serializedJwk = canonicalize(normalizedJwk);
    const utf8Bytes = Convert.string(serializedJwk).toUint8Array();
    const digest = yield Sha256.digest({ data: utf8Bytes });
    const thumbprint = Convert.uint8Array(digest).toBase64Url();
    return thumbprint;
  });
}
function isEcPrivateJwk(obj) {
  if (!obj || typeof obj !== "object")
    return false;
  if (!("kty" in obj && "crv" in obj && "x" in obj && "d" in obj))
    return false;
  if (obj.kty !== "EC")
    return false;
  if (typeof obj.d !== "string")
    return false;
  if (typeof obj.x !== "string")
    return false;
  return true;
}
function isEcPublicJwk(obj) {
  if (!obj || typeof obj !== "object")
    return false;
  if (!("kty" in obj && "crv" in obj && "x" in obj))
    return false;
  if ("d" in obj)
    return false;
  if (obj.kty !== "EC")
    return false;
  if (typeof obj.x !== "string")
    return false;
  return true;
}
function isOkpPrivateJwk(obj) {
  if (!obj || typeof obj !== "object")
    return false;
  if (!("kty" in obj && "crv" in obj && "x" in obj && "d" in obj))
    return false;
  if (obj.kty !== "OKP")
    return false;
  if (typeof obj.d !== "string")
    return false;
  if (typeof obj.x !== "string")
    return false;
  return true;
}
function isOkpPublicJwk(obj) {
  if (!obj || typeof obj !== "object")
    return false;
  if ("d" in obj)
    return false;
  if (!("kty" in obj && "crv" in obj && "x" in obj))
    return false;
  if (obj.kty !== "OKP")
    return false;
  if (typeof obj.x !== "string")
    return false;
  return true;
}
function isPrivateJwk(obj) {
  if (!obj || typeof obj !== "object")
    return false;
  const kty = obj.kty;
  switch (kty) {
    case "EC":
    case "OKP":
    case "RSA":
      return "d" in obj;
    case "oct":
      return "k" in obj;
    default:
      return false;
  }
}

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/primitives/secp256k1.js
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Secp256k1 = class _Secp256k1 {
  /**
   * Adjusts an ECDSA signature to a normalized, low-S form.
   *
   * @remarks
   * All ECDSA signatures, regardless of the curve, consist of two components, `r` and `s`, both of
   * which are integers. The curve's order (the total number of points on the curve) is denoted by
   * `n`. In a valid ECDSA signature, both `r` and `s` must be in the range [1, n-1]. However, due
   * to the mathematical properties of ECDSA, if `(r, s)` is a valid signature, then `(r, n - s)` is
   * also a valid signature for the same message and public key. In other words, for every
   * signature, there's a "mirror" signature that's equally valid. For these elliptic curves:
   *
   * - Low S Signature: A signature where the `s` component is in the lower half of the range,
   *                    specifically less than or equal to `n/2`.
   *
   * - High S Signature: This is where the `s` component is in the upper half of the range, greater
   *                     than `n/2`.
   *
   * The practical implication is that a third-party can forge a second valid signature for the same
   * message by negating the `s` component of the original signature, without any knowledge of the
   * private key. This is known as a "signature malleability" attack.
   *
   * This type of forgery is not a problem in all systems, but it can be an issue in systems that
   * rely on digital signature uniqueness to ensure transaction integrity. For example, in Bitcoin,
   * transaction malleability is an issue because it allows for the modification of transaction
   * identifiers (and potentially, transactions themselves) after they're signed but before they're
   * confirmed in a block. By enforcing low `s` values, the Bitcoin network reduces the likelihood of
   * this occurring, making the system more secure and predictable.
   *
   * For this reason, it's common practice to normalize ECDSA signatures to a low-S form. This
   * form is considered standard and preferable in some systems and is known as the "normalized"
   * form of the signature.
   *
   * This method takes a signature, and if it's high-S, returns the normalized low-S form. If the
   * signature is already low-S, it's returned unmodified. It's important to note that this
   * method does not change the validity of the signature but makes it compliant with systems that
   * enforce low-S signatures.
   *
   * @example
   * ```ts
   * const signature = new Uint8Array([...]); // Your ECDSA signature
   * const adjustedSignature = await Secp256k1.adjustSignatureToLowS({ signature });
   * // Now 'adjustedSignature' is in the low-S form.
   * ```
   *
   * @param params - The parameters for the signature adjustment.
   * @param params.signature - The ECDSA signature as a `Uint8Array`.
   *
   * @returns A Promise that resolves to the adjusted signature in low-S form as a `Uint8Array`.
   */
  static adjustSignatureToLowS({ signature }) {
    return __awaiter6(this, void 0, void 0, function* () {
      const signatureObject = secp256k1.Signature.fromCompact(signature);
      if (signatureObject.hasHighS()) {
        const adjustedSignatureObject = signatureObject.normalizeS();
        const adjustedSignature = adjustedSignatureObject.toCompactRawBytes();
        return adjustedSignature;
      } else {
        return signature;
      }
    });
  }
  /**
   * Converts a raw private key in bytes to its corresponding JSON Web Key (JWK) format.
   *
   * @remarks
   * This method takes a private key represented as a byte array (Uint8Array) and
   * converts it into a JWK object. The conversion involves extracting the
   * elliptic curve point (x and y coordinates) from the private key and encoding
   * them into base64url format, alongside other JWK parameters.
   *
   * The resulting JWK object includes the following properties:
   * - `kty`: Key Type, set to 'EC' for Elliptic Curve.
   * - `crv`: Curve Name, set to 'secp256k1'.
   * - `d`: The private key component, base64url-encoded.
   * - `x`: The x-coordinate of the public key point, base64url-encoded.
   * - `y`: The y-coordinate of the public key point, base64url-encoded.
   *
   * This method is useful for converting raw public keys into a standardized
   * JSON format, facilitating their use in cryptographic operations and making
   * them easy to share and store.
   *
   * @example
   * ```ts
   * const privateKeyBytes = new Uint8Array([...]); // Replace with actual private key bytes
   * const privateKey = await Secp256k1.bytesToPrivateKey({ privateKeyBytes });
   * ```
   *
   * @param params - The parameters for the private key conversion.
   * @param params.privateKeyBytes - The raw private key as a Uint8Array.
   *
   * @returns A Promise that resolves to the private key in JWK format.
   */
  static bytesToPrivateKey({ privateKeyBytes }) {
    return __awaiter6(this, void 0, void 0, function* () {
      const point = yield _Secp256k1.getCurvePoint({ keyBytes: privateKeyBytes });
      const privateKey = {
        kty: "EC",
        crv: "secp256k1",
        d: Convert.uint8Array(privateKeyBytes).toBase64Url(),
        x: Convert.uint8Array(point.x).toBase64Url(),
        y: Convert.uint8Array(point.y).toBase64Url()
      };
      privateKey.kid = yield computeJwkThumbprint({ jwk: privateKey });
      return privateKey;
    });
  }
  /**
   * Converts a raw public key in bytes to its corresponding JSON Web Key (JWK) format.
   *
   * @remarks
   * This method accepts a public key in a byte array (Uint8Array) format and
   * transforms it to a JWK object. It involves decoding the elliptic curve point
   * (x and y coordinates) from the raw public key bytes and encoding them into
   * base64url format, along with setting appropriate JWK parameters.
   *
   * The resulting JWK object includes the following properties:
   * - `kty`: Key Type, set to 'EC' for Elliptic Curve.
   * - `crv`: Curve Name, set to 'secp256k1'.
   * - `x`: The x-coordinate of the public key point, base64url-encoded.
   * - `y`: The y-coordinate of the public key point, base64url-encoded.
   *
   * This method is useful for converting raw public keys into a standardized
   * JSON format, facilitating their use in cryptographic operations and making
   * them easy to share and store.
   *
   * @example
   * ```ts
   * const publicKeyBytes = new Uint8Array([...]); // Replace with actual public key bytes
   * const publicKey = await Secp256k1.bytesToPublicKey({ publicKeyBytes });
   * ```
   *
   * @param params - The parameters for the public key conversion.
   * @param params.publicKeyBytes - The raw public key as a Uint8Array.
   *
   * @returns A Promise that resolves to the public key in JWK format.
   */
  static bytesToPublicKey({ publicKeyBytes }) {
    return __awaiter6(this, void 0, void 0, function* () {
      const point = yield _Secp256k1.getCurvePoint({ keyBytes: publicKeyBytes });
      const publicKey = {
        kty: "EC",
        crv: "secp256k1",
        x: Convert.uint8Array(point.x).toBase64Url(),
        y: Convert.uint8Array(point.y).toBase64Url()
      };
      publicKey.kid = yield computeJwkThumbprint({ jwk: publicKey });
      return publicKey;
    });
  }
  /**
   * Converts a public key to its compressed form.
   *
   * @remarks
   * This method takes a public key represented as a byte array and compresses it. Public key
   * compression is a process that reduces the size of the public key by removing the y-coordinate,
   * making it more efficient for storage and transmission. The compressed key retains the same
   * level of security as the uncompressed key.
   *
   * @example
   * ```ts
   * const uncompressedPublicKeyBytes = new Uint8Array([...]); // Replace with actual uncompressed public key bytes
   * const compressedPublicKey = await Secp256k1.compressPublicKey({
   *   publicKeyBytes: uncompressedPublicKeyBytes
   * });
   * ```
   *
   * @param params - The parameters for the public key compression.
   * @param params.publicKeyBytes - The public key as a Uint8Array.
   *
   * @returns A Promise that resolves to the compressed public key as a Uint8Array.
   */
  static compressPublicKey({ publicKeyBytes }) {
    return __awaiter6(this, void 0, void 0, function* () {
      const point = secp256k1.ProjectivePoint.fromHex(publicKeyBytes);
      return point.toRawBytes(true);
    });
  }
  /**
   * Derives the public key in JWK format from a given private key.
   *
   * @remarks
   * This method takes a private key in JWK format and derives its corresponding public key,
   * also in JWK format. The derivation process involves converting the private key to a raw
   * byte array, then computing the elliptic curve point (x and y coordinates) from this private
   * key. These coordinates are then encoded into base64url format to construct the public key in
   * JWK format.
   *
   * The process ensures that the derived public key correctly corresponds to the given private key,
   * adhering to the secp256k1 elliptic curve standards. This method is useful in cryptographic
   * operations where a public key is needed for operations like signature verification, but only
   * the private key is available.
   *
   * @example
   * ```ts
   * const privateKey = { ... }; // A Jwk object representing a secp256k1 private key
   * const publicKey = await Secp256k1.computePublicKey({ key: privateKey });
   * ```
   *
   * @param params - The parameters for the public key derivation.
   * @param params.key - The private key in JWK format from which to derive the public key.
   *
   * @returns A Promise that resolves to the derived public key in JWK format.
   */
  static computePublicKey({ key }) {
    return __awaiter6(this, void 0, void 0, function* () {
      const privateKeyBytes = yield _Secp256k1.privateKeyToBytes({ privateKey: key });
      const point = yield _Secp256k1.getCurvePoint({ keyBytes: privateKeyBytes });
      const publicKey = {
        kty: "EC",
        crv: "secp256k1",
        x: Convert.uint8Array(point.x).toBase64Url(),
        y: Convert.uint8Array(point.y).toBase64Url()
      };
      publicKey.kid = yield computeJwkThumbprint({ jwk: publicKey });
      return publicKey;
    });
  }
  /**
   * Converts an ASN.1 DER encoded ECDSA signature to a compact R+S format.
   *
   * @remarks
   * This method is used for converting an ECDSA signature from the ASN.1 DER encoding to the more
   * compact R+S format. This conversion is often required when dealing with ECDSA signatures in
   * certain cryptographic standards such as JWS (JSON Web Signature).
   *
   * The method decodes the DER-encoded signature, extracts the R and S values, and concatenates
   * them into a single byte array. This process involves handling the ASN.1 structure to correctly
   * parse the R and S values, considering padding and integer encoding specifics of DER.
   *
   * @example
   * ```ts
   * const derSignature = new Uint8Array([...]); // Replace with your DER-encoded signature
   * const signature = await Secp256k1.convertDerToCompactSignature({ derSignature });
   * ```
   *
   * @param params - The parameters for the signature conversion.
   * @param params.derSignature - The signature in ASN.1 DER format as a `Uint8Array`.
   *
   * @returns A Promise that resolves to the signature in compact R+S format as a `Uint8Array`.
   */
  static convertDerToCompactSignature({ derSignature }) {
    return __awaiter6(this, void 0, void 0, function* () {
      const signatureObject = secp256k1.Signature.fromDER(derSignature);
      const compactSignature = signatureObject.toCompactRawBytes();
      return compactSignature;
    });
  }
  /**
   * Converts a public key to its uncompressed form.
   *
   * @remarks
   * This method takes a compressed public key represented as a byte array and decompresses it.
   * Public key decompression involves reconstructing the y-coordinate from the x-coordinate,
   * resulting in the full public key. This method is used when the uncompressed key format is
   * required for certain cryptographic operations or interoperability.
   *
   * @example
   * ```ts
   * const compressedPublicKeyBytes = new Uint8Array([...]); // Replace with actual compressed public key bytes
   * const decompressedPublicKey = await Secp256k1.decompressPublicKey({
   *   publicKeyBytes: compressedPublicKeyBytes
   * });
   * ```
   *
   * @param params - The parameters for the public key decompression.
   * @param params.publicKeyBytes - The public key as a Uint8Array.
   *
   * @returns A Promise that resolves to the uncompressed public key as a Uint8Array.
   */
  static decompressPublicKey({ publicKeyBytes }) {
    return __awaiter6(this, void 0, void 0, function* () {
      const point = secp256k1.ProjectivePoint.fromHex(publicKeyBytes);
      return point.toRawBytes(false);
    });
  }
  /**
   * Generates a secp256k1 private key in JSON Web Key (JWK) format.
   *
   * @remarks
   * This method creates a new private key suitable for use with the secp256k1
   * elliptic curve. The key is generated using cryptographically secure random
   * number generation to ensure its uniqueness and security. The resulting
   * private key adheres to the JWK format, specifically tailored for secp256k1,
   * making it compatible with common cryptographic standards and easy to use in
   * various cryptographic processes.
   *
   * The private key generated by this method includes the following components:
   * - `kty`: Key Type, set to 'EC' for Elliptic Curve.
   * - `crv`: Curve Name, set to 'secp256k1'.
   * - `d`: The private key component, base64url-encoded.
   * - `x`: The x-coordinate of the public key point, derived from the private key, base64url-encoded.
   * - `y`: The y-coordinate of the public key point, derived from the private key, base64url-encoded.
   *
   * The key is returned in a format suitable for direct use in signin and key agreement operations.
   *
   * @example
   * ```ts
   * const privateKey = await Secp256k1.generateKey();
   * ```
   *
   * @returns A Promise that resolves to the generated private key in JWK format.
   */
  static generateKey() {
    return __awaiter6(this, void 0, void 0, function* () {
      const privateKeyBytes = secp256k1.utils.randomPrivateKey();
      const privateKey = yield _Secp256k1.bytesToPrivateKey({ privateKeyBytes });
      privateKey.kid = yield computeJwkThumbprint({ jwk: privateKey });
      return privateKey;
    });
  }
  /**
   * Retrieves the public key properties from a given private key in JWK format.
   *
   * @remarks
   * This method extracts the public key portion from a secp256k1 private key in JWK format. It does
   * so by removing the private key property 'd' and making a shallow copy, effectively yielding the
   * public key. The method sets the 'kid' (key ID) property using the JWK thumbprint if it is not
   * already defined. This approach is used under the assumption that a private key in JWK format
   * always contains the corresponding public key properties.
   *
   * Note: This method offers a significant performance advantage, being about 200 times faster
   * than `computePublicKey()`. However, it does not mathematically validate the private key, nor
   * does it derive the public key from the private key. It simply extracts existing public key
   * properties from the private key object. This makes it suitable for scenarios where speed is
   * critical and the private key's integrity is already assured.
   *
   * @example
   * ```ts
   * const privateKey = { ... }; // A Jwk object representing a secp256k1 private key
   * const publicKey = await Secp256k1.getPublicKey({ key: privateKey });
   * ```
   *
   * @param params - The parameters for retrieving the public key properties.
   * @param params.key - The private key in JWK format.
   *
   * @returns A Promise that resolves to the public key in JWK format.
   */
  static getPublicKey({ key }) {
    var _a;
    return __awaiter6(this, void 0, void 0, function* () {
      if (!(isEcPrivateJwk(key) && key.crv === "secp256k1")) {
        throw new Error(`Secp256k1: The provided key is not a secp256k1 private JWK.`);
      }
      let { d } = key, publicKey = __rest(key, ["d"]);
      (_a = publicKey.kid) !== null && _a !== void 0 ? _a : publicKey.kid = yield computeJwkThumbprint({ jwk: publicKey });
      return publicKey;
    });
  }
  /**
   * Converts a private key from JSON Web Key (JWK) format to a raw byte array (Uint8Array).
   *
   * @remarks
   * This method takes a private key in JWK format and extracts its raw byte representation.
   * It specifically focuses on the 'd' parameter of the JWK, which represents the private
   * key component in base64url encoding. The method decodes this value into a byte array.
   *
   * This conversion is essential for operations that require the private key in its raw
   * binary form, such as certain low-level cryptographic operations or when interfacing
   * with systems and libraries that expect keys in a byte array format.
   *
   * @example
   * ```ts
   * const privateKey = { ... }; // An X25519 private key in JWK format
   * const privateKeyBytes = await Secp256k1.privateKeyToBytes({ privateKey });
   * ```
   *
   * @param params - The parameters for the private key conversion.
   * @param params.privateKey - The private key in JWK format.
   *
   * @returns A Promise that resolves to the private key as a Uint8Array.
   */
  static privateKeyToBytes({ privateKey }) {
    return __awaiter6(this, void 0, void 0, function* () {
      if (!isEcPrivateJwk(privateKey)) {
        throw new Error(`Secp256k1: The provided key is not a valid EC private key.`);
      }
      const privateKeyBytes = Convert.base64Url(privateKey.d).toUint8Array();
      return privateKeyBytes;
    });
  }
  /**
   * Converts a public key from JSON Web Key (JWK) format to a raw byte array (Uint8Array).
   *
   * @remarks
   * This method accepts a public key in JWK format and converts it into its raw binary
   * form. The conversion process involves decoding the 'x' and 'y' parameters of the JWK
   * (which represent the x and y coordinates of the elliptic curve point, respectively)
   * from base64url format into a byte array. The method then concatenates these values,
   * along with a prefix indicating the key format, to form the full public key.
   *
   * This function is particularly useful for use cases where the public key is needed
   * in its raw byte format, such as for certain cryptographic operations or when
   * interfacing with systems that require raw key formats.
   *
   * @example
   * ```ts
   * const publicKey = { ... }; // A Jwk public key object
   * const publicKeyBytes = await Secp256k1.publicKeyToBytes({ publicKey });
   * ```
   *
   * @param params - The parameters for the public key conversion.
   * @param params.publicKey - The public key in JWK format.
   *
   * @returns A Promise that resolves to the public key as a Uint8Array.
   */
  static publicKeyToBytes({ publicKey }) {
    return __awaiter6(this, void 0, void 0, function* () {
      if (!(isEcPublicJwk(publicKey) && publicKey.y)) {
        throw new Error(`Secp256k1: The provided key is not a valid EC public key.`);
      }
      const prefix = new Uint8Array([4]);
      const x = Convert.base64Url(publicKey.x).toUint8Array();
      const y = Convert.base64Url(publicKey.y).toUint8Array();
      const publicKeyBytes = new Uint8Array([...prefix, ...x, ...y]);
      return publicKeyBytes;
    });
  }
  /**
   * Computes an RFC6090-compliant Elliptic Curve Diffie-Hellman (ECDH) shared secret
   * using secp256k1 private and public keys in JSON Web Key (JWK) format.
   *
   * @remarks
   * This method facilitates the ECDH key agreement protocol, which is a method of securely
   * deriving a shared secret between two parties based on their private and public keys.
   * It takes the private key of one party (privateKeyA) and the public key of another
   * party (publicKeyB) to compute a shared secret. The shared secret is derived from the
   * x-coordinate of the elliptic curve point resulting from the multiplication of the
   * public key with the private key.
   *
   * Note: When performing Elliptic Curve Diffie-Hellman (ECDH) key agreement,
   * the resulting shared secret is a point on the elliptic curve, which
   * consists of an x-coordinate and a y-coordinate. With a 256-bit curve like
   * secp256k1, each of these coordinates is 32 bytes (256 bits) long. However,
   * in the ECDH process, it's standard practice to use only the x-coordinate
   * of the shared secret point as the resulting shared key. This is because
   * the y-coordinate does not add to the entropy of the key, and both parties
   * can independently compute the x-coordinate.  Consquently, this implementation
   * omits the y-coordinate for simplicity and standard compliance.
   *
   * @example
   * ```ts
   * const privateKeyA = { ... }; // A Jwk private key object for party A
   * const publicKeyB = { ... }; // A Jwk public key object for party B
   * const sharedSecret = await Secp256k1.sharedSecret({
   *   privateKeyA,
   *   publicKeyB
   * });
   * ```
   *
   * @param params - The parameters for the shared secret computation.
   * @param params.privateKeyA - The private key in JWK format of one party.
   * @param params.publicKeyB - The public key in JWK format of the other party.
   *
   * @returns A Promise that resolves to the computed shared secret as a Uint8Array.
   */
  static sharedSecret({ privateKeyA, publicKeyB }) {
    return __awaiter6(this, void 0, void 0, function* () {
      if ("x" in privateKeyA && "x" in publicKeyB && privateKeyA.x === publicKeyB.x) {
        throw new Error(`Secp256k1: ECDH shared secret cannot be computed from a single key pair's public and private keys.`);
      }
      const privateKeyABytes = yield _Secp256k1.privateKeyToBytes({ privateKey: privateKeyA });
      const publicKeyBBytes = yield _Secp256k1.publicKeyToBytes({ publicKey: publicKeyB });
      const sharedSecret = secp256k1.getSharedSecret(privateKeyABytes, publicKeyBBytes, true);
      return sharedSecret.slice(1);
    });
  }
  /**
   * Generates an RFC6979-compliant ECDSA signature of given data using a secp256k1 private key.
   *
   * @remarks
   * This method signs the provided data with a specified private key using the ECDSA
   * (Elliptic Curve Digital Signature Algorithm) signature algorithm, as defined in RFC6979.
   * The data to be signed is first hashed using the SHA-256 algorithm, and this hash is then
   * signed using the private key. The output is a digital signature in the form of a
   * Uint8Array, which uniquely corresponds to both the data and the private key used for signing.
   *
   * This method is commonly used in cryptographic applications to ensure data integrity and
   * authenticity. The signature can later be verified by parties with access to the corresponding
   * public key, ensuring that the data has not been tampered with and was indeed signed by the
   * holder of the private key.
   *
   * @example
   * ```ts
   * const data = new TextEncoder().encode('Messsage'); // Data to be signed
   * const privateKey = { ... }; // A Jwk object representing a secp256k1 private key
   * const signature = await Secp256k1.sign({
   *   key: privateKey,
   *   data
   * });
   * ```
   *
   * @param params - The parameters for the signing operation.
   * @param params.key - The private key to use for signing, represented in JWK format.
   * @param params.data - The data to sign, represented as a Uint8Array.
   *
   * @returns A Promise that resolves to the signature as a Uint8Array.
   */
  static sign({ data, key }) {
    return __awaiter6(this, void 0, void 0, function* () {
      const privateKeyBytes = yield _Secp256k1.privateKeyToBytes({ privateKey: key });
      const digest = sha256(data);
      const signatureObject = secp256k1.sign(digest, privateKeyBytes);
      const signature = signatureObject.toCompactRawBytes();
      return signature;
    });
  }
  /**
   * Validates a given private key to ensure its compliance with the secp256k1 curve standards.
   *
   * @remarks
   * This method checks whether a provided private key is a valid 32-byte number and falls within
   * the range defined by the secp256k1 curve's order. It is essential for ensuring the private
   * key's mathematical correctness in the context of secp256k1-based cryptographic operations.
   *
   * Note that this validation strictly pertains to the key's format and numerical validity; it does
   * not assess whether the key corresponds to a known entity or its security status (e.g., whether
   * it has been compromised).
   *
   * @example
   * ```ts
   * const privateKeyBytes = new Uint8Array([...]); // A 32-byte private key
   * const isValid = await Secp256k1.validatePrivateKey({ privateKeyBytes });
   * console.log(isValid); // true or false based on the key's validity
   * ```
   *
   * @param params - The parameters for the key validation.
   * @param params.privateKeyBytes - The private key to validate, represented as a Uint8Array.
   *
   * @returns A Promise that resolves to a boolean indicating whether the private key is valid.
   */
  static validatePrivateKey({ privateKeyBytes }) {
    return __awaiter6(this, void 0, void 0, function* () {
      return secp256k1.utils.isValidPrivateKey(privateKeyBytes);
    });
  }
  /**
   * Validates a given public key to confirm its mathematical correctness on the secp256k1 curve.
   *
   * @remarks
   * This method checks if the provided public key represents a valid point on the secp256k1 curve.
   * It decodes the key's Weierstrass points (x and y coordinates) and verifies their validity
   * against the curve's parameters. A valid point must lie on the curve and meet specific
   * mathematical criteria defined by the curve's equation.
   *
   * It's important to note that this method does not verify the key's ownership or whether it has
   * been compromised; it solely focuses on the key's adherence to the curve's mathematical
   * principles.
   *
   * @example
   * ```ts
   * const publicKeyBytes = new Uint8Array([...]); // A public key in byte format
   * const isValid = await Secp256k1.validatePublicKey({ publicKeyBytes });
   * console.log(isValid); // true if the key is valid on the secp256k1 curve, false otherwise
   * ```
   *
   * @param params - The parameters for the key validation.
   * @param params.publicKeyBytes - The public key to validate, represented as a Uint8Array.
   *
   * @returns A Promise that resolves to a boolean indicating the public key's validity on
   *          the secp256k1 curve.
   */
  static validatePublicKey({ publicKeyBytes }) {
    return __awaiter6(this, void 0, void 0, function* () {
      try {
        const point = secp256k1.ProjectivePoint.fromHex(publicKeyBytes);
        point.assertValidity();
      } catch (error) {
        return false;
      }
      return true;
    });
  }
  /**
   * Verifies an RFC6979-compliant ECDSA signature against given data and a secp256k1 public key.
   *
   * @remarks
   * This method validates a digital signature to ensure that it was generated by the holder of the
   * corresponding private key and that the signed data has not been altered. The signature
   * verification is performed using the ECDSA (Elliptic Curve Digital Signature Algorithm) as
   * specified in RFC6979. The data to be verified is first hashed using the SHA-256 algorithm, and
   * this hash is then used along with the public key to verify the signature.
   *
   * The method returns a boolean value indicating whether the signature is valid. A valid signature
   * proves that the signed data was indeed signed by the owner of the private key corresponding to
   * the provided public key and that the data has not been tampered with since it was signed.
   *
   * Note: The verification process does not consider the malleability of low-s signatures, which
   * may be relevant in certain contexts, such as Bitcoin transactions.
   *
   * @example
   * ```ts
   * const data = new TextEncoder().encode('Messsage'); // Data that was signed
   * const publicKey = { ... }; // Public key in JWK format corresponding to the private key that signed the data
   * const signature = new Uint8Array([...]); // Signature to verify
   * const isSignatureValid = await Secp256k1.verify({
   *   key: publicKey,
   *   signature,
   *   data
   * });
   * console.log(isSignatureValid); // true if the signature is valid, false otherwise
   * ```
   *
   * @param params - The parameters for the signature verification.
   * @param params.key - The public key used for verification, represented in JWK format.
   * @param params.signature - The signature to verify, represented as a Uint8Array.
   * @param params.data - The data that was signed, represented as a Uint8Array.
   *
   * @returns A Promise that resolves to a boolean indicating whether the signature is valid.
   */
  static verify({ key, signature, data }) {
    return __awaiter6(this, void 0, void 0, function* () {
      const publicKeyBytes = yield _Secp256k1.publicKeyToBytes({ publicKey: key });
      const digest = sha256(data);
      const isValid3 = secp256k1.verify(signature, digest, publicKeyBytes, { lowS: false });
      return isValid3;
    });
  }
  /**
   * Returns the elliptic curve point (x and y coordinates) for a given secp256k1 key.
   *
   * @remarks
   * This method extracts the elliptic curve point from a given secp256k1 key, whether
   * it's a private or a public key. For a private key, the method first computes the
   * corresponding public key and then extracts the x and y coordinates. For a public key,
   * it directly returns these coordinates. The coordinates are represented as Uint8Array.
   *
   * The x and y coordinates represent the key's position on the elliptic curve and can be
   * used in various cryptographic operations, such as digital signatures or key agreement
   * protocols.
   *
   * @example
   * ```ts
   * // For a private key
   * const privateKey = new Uint8Array([...]); // A 32-byte private key
   * const { x: xFromPrivateKey, y: yFromPrivateKey } = await Secp256k1.getCurvePoint({ keyBytes: privateKey });
   *
   * // For a public key
   * const publicKey = new Uint8Array([...]); // A 33-byte or 65-byte public key
   * const { x: xFromPublicKey, y: yFromPublicKey } = await Secp256k1.getCurvePoint({ keyBytes: publicKey });
   * ```
   *
   * @param params - The parameters for the curve point decoding operation.
   * @param params.keyBytes - The key for which to get the elliptic curve point.
   *                          Can be either a private key or a public key.
   *                          The key should be passed as a `Uint8Array`.
   *
   * @returns A Promise that resolves to an object with properties 'x' and 'y',
   *          each being a Uint8Array representing the x and y coordinates of the key point on the
   *          elliptic curve.
   */
  static getCurvePoint({ keyBytes }) {
    return __awaiter6(this, void 0, void 0, function* () {
      if (keyBytes.byteLength === 32) {
        keyBytes = secp256k1.getPublicKey(keyBytes);
      }
      const point = secp256k1.ProjectivePoint.fromHex(keyBytes);
      const x = numberToBytesBE(point.x, 32);
      const y = numberToBytesBE(point.y, 32);
      return { x, y };
    });
  }
};

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/primitives/secp256r1.js
var import_dist21 = __toESM(require_dist(), 1);
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest2 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Secp256r1 = class _Secp256r1 {
  /**
     * Adjusts an ECDSA signature to a normalized, low-S form.
     *
     * @remarks
     * All ECDSA signatures, regardless of the curve, consist of two components, `r` and `s`, both of
     * which are integers. The curve's order (the total number of points on the curve) is denoted by
     * `n`. In a valid ECDSA signature, both `r` and `s` must be in the range [1, n-1]. However, due
     * to the mathematical properties of ECDSA, if `(r, s)` is a valid signature, then `(r, n - s)` is
     * also a valid signature for the same message and public key. In other words, for every
     * signature, there's a "mirror" signature that's equally valid. For these elliptic curves:
     *
     * - Low S Signature: A signature where the `s` component is in the lower half of the range,
     *                    specifically less than or equal to `n/2`.
     *
     * - High S Signature: This is where the `s` component is in the upper half of the range, greater
     *                     than `n/2`.
     *
     * The practical implication is that a third-party can forge a second valid signature for the same
     * message by negating the `s` component of the original signature, without any knowledge of the
     * private key. This is known as a "signature malleability" attack.
     *
     * This type of forgery is not a problem in all systems, but it can be an issue in systems that
     * rely on digital signature uniqueness to ensure transaction integrity. For example, in Bitcoin,
     * transaction malleability is an issue because it allows for the modification of transaction
     * identifiers (and potentially, transactions themselves) after they're signed but before they're
     * confirmed in a block. By enforcing low `s` values, the Bitcoin network reduces the likelihood of
     * this occurring, making the system more secure and predictable.
     *
     * For this reason, it's common practice to normalize ECDSA signatures to a low-S form. This
     * form is considered standard and preferable in some systems and is known as the "normalized"
     * form of the signature.
     *
     * This method takes a signature, and if it's high-S, returns the normalized low-S form. If the
     * signature is already low-S, it's returned unmodified. It's important to note that this
     * method does not change the validity of the signature but makes it compliant with systems that
     * enforce low-S signatures.
     *
     * @example
     * ```ts
     * const signature = new Uint8Array([...]); // Your ECDSA signature
     * const adjustedSignature = await Secp256r1.adjustSignatureToLowS({ signature });
     * // Now 'adjustedSignature' is in the low-S form.
     * ```
     *
     * @param params - The parameters for the signature adjustment.
     * @param params.signature - The ECDSA signature as a `Uint8Array`.
     *
     * @returns A Promise that resolves to the adjusted signature in low-S form as a `Uint8Array`.
     */
  static adjustSignatureToLowS({ signature }) {
    return __awaiter7(this, void 0, void 0, function* () {
      const signatureObject = secp256r1.Signature.fromCompact(signature);
      if (signatureObject.hasHighS()) {
        const adjustedSignatureObject = signatureObject.normalizeS();
        const adjustedSignature = adjustedSignatureObject.toCompactRawBytes();
        return adjustedSignature;
      } else {
        return signature;
      }
    });
  }
  /**
   * Converts a raw private key in bytes to its corresponding JSON Web Key (JWK) format.
   *
   * @remarks
   * This method takes a private key represented as a byte array (Uint8Array) and
   * converts it into a JWK object. The conversion involves extracting the
   * elliptic curve point (x and y coordinates) from the private key and encoding
   * them into base64url format, alongside other JWK parameters.
   *
   * The resulting JWK object includes the following properties:
   * - `kty`: Key Type, set to 'EC' for Elliptic Curve.
   * - `crv`: Curve Name, set to 'P-256'.
   * - `d`: The private key component, base64url-encoded.
   * - `x`: The x-coordinate of the public key point, base64url-encoded.
   * - `y`: The y-coordinate of the public key point, base64url-encoded.
   *
   * This method is useful for converting raw public keys into a standardized
   * JSON format, facilitating their use in cryptographic operations and making
   * them easy to share and store.
   *
   * @example
   * ```ts
   * const privateKeyBytes = new Uint8Array([...]); // Replace with actual private key bytes
   * const privateKey = await Secp256r1.bytesToPrivateKey({ privateKeyBytes });
   * ```
   *
   * @param params - The parameters for the private key conversion.
   * @param params.privateKeyBytes - The raw private key as a Uint8Array.
   *
   * @returns A Promise that resolves to the private key in JWK format.
   */
  static bytesToPrivateKey({ privateKeyBytes }) {
    return __awaiter7(this, void 0, void 0, function* () {
      const point = yield _Secp256r1.getCurvePoint({ keyBytes: privateKeyBytes });
      const privateKey = {
        kty: "EC",
        crv: "P-256",
        d: Convert.uint8Array(privateKeyBytes).toBase64Url(),
        x: Convert.uint8Array(point.x).toBase64Url(),
        y: Convert.uint8Array(point.y).toBase64Url()
      };
      privateKey.kid = yield computeJwkThumbprint({ jwk: privateKey });
      return privateKey;
    });
  }
  /**
   * Converts a raw public key in bytes to its corresponding JSON Web Key (JWK) format.
   *
   * @remarks
   * This method accepts a public key in a byte array (Uint8Array) format and
   * transforms it to a JWK object. It involves decoding the elliptic curve point
   * (x and y coordinates) from the raw public key bytes and encoding them into
   * base64url format, along with setting appropriate JWK parameters.
   *
   * The resulting JWK object includes the following properties:
   * - `kty`: Key Type, set to 'EC' for Elliptic Curve.
   * - `crv`: Curve Name, set to 'P-256'.
   * - `x`: The x-coordinate of the public key point, base64url-encoded.
   * - `y`: The y-coordinate of the public key point, base64url-encoded.
   *
   * This method is useful for converting raw public keys into a standardized
   * JSON format, facilitating their use in cryptographic operations and making
   * them easy to share and store.
   *
   * @example
   * ```ts
   * const publicKeyBytes = new Uint8Array([...]); // Replace with actual public key bytes
   * const publicKey = await Secp256r1.bytesToPublicKey({ publicKeyBytes });
   * ```
   *
   * @param params - The parameters for the public key conversion.
   * @param params.publicKeyBytes - The raw public key as a Uint8Array.
   *
   * @returns A Promise that resolves to the public key in JWK format.
   */
  static bytesToPublicKey({ publicKeyBytes }) {
    return __awaiter7(this, void 0, void 0, function* () {
      const point = yield _Secp256r1.getCurvePoint({ keyBytes: publicKeyBytes });
      const publicKey = {
        kty: "EC",
        crv: "P-256",
        x: Convert.uint8Array(point.x).toBase64Url(),
        y: Convert.uint8Array(point.y).toBase64Url()
      };
      publicKey.kid = yield computeJwkThumbprint({ jwk: publicKey });
      return publicKey;
    });
  }
  /**
   * Converts a public key to its compressed form.
   *
   * @remarks
   * This method takes a public key represented as a byte array and compresses it. Public key
   * compression is a process that reduces the size of the public key by removing the y-coordinate,
   * making it more efficient for storage and transmission. The compressed key retains the same
   * level of security as the uncompressed key.
   *
   * @example
   * ```ts
   * const uncompressedPublicKeyBytes = new Uint8Array([...]); // Replace with actual uncompressed public key bytes
   * const compressedPublicKey = await Secp256r1.compressPublicKey({
   *   publicKeyBytes: uncompressedPublicKeyBytes
   * });
   * ```
   *
   * @param params - The parameters for the public key compression.
   * @param params.publicKeyBytes - The public key as a Uint8Array.
   *
   * @returns A Promise that resolves to the compressed public key as a Uint8Array.
   */
  static compressPublicKey({ publicKeyBytes }) {
    return __awaiter7(this, void 0, void 0, function* () {
      const point = secp256r1.ProjectivePoint.fromHex(publicKeyBytes);
      return point.toRawBytes(true);
    });
  }
  /**
   * Derives the public key in JWK format from a given private key.
   *
   * @remarks
   * This method takes a private key in JWK format and derives its corresponding public key,
   * also in JWK format. The derivation process involves converting the private key to a raw
   * byte array, then computing the elliptic curve point (x and y coordinates) from this private
   * key. These coordinates are then encoded into base64url format to construct the public key in
   * JWK format.
   *
   * The process ensures that the derived public key correctly corresponds to the given private key,
   * adhering to the secp256r1 elliptic curve standards. This method is useful in cryptographic
   * operations where a public key is needed for operations like signature verification, but only
   * the private key is available.
   *
   * @example
   * ```ts
   * const privateKey = { ... }; // A Jwk object representing a secp256r1 private key
   * const publicKey = await Secp256r1.computePublicKey({ key: privateKey });
   * ```
   *
   * @param params - The parameters for the public key derivation.
   * @param params.key - The private key in JWK format from which to derive the public key.
   *
   * @returns A Promise that resolves to the derived public key in JWK format.
   */
  static computePublicKey({ key }) {
    return __awaiter7(this, void 0, void 0, function* () {
      const privateKeyBytes = yield _Secp256r1.privateKeyToBytes({ privateKey: key });
      const point = yield _Secp256r1.getCurvePoint({ keyBytes: privateKeyBytes });
      const publicKey = {
        kty: "EC",
        crv: "P-256",
        x: Convert.uint8Array(point.x).toBase64Url(),
        y: Convert.uint8Array(point.y).toBase64Url()
      };
      publicKey.kid = yield computeJwkThumbprint({ jwk: publicKey });
      return publicKey;
    });
  }
  /**
   * Converts an ASN.1 DER encoded ECDSA signature to a compact R+S format.
   *
   * @remarks
   * This method is used for converting an ECDSA signature from the ASN.1 DER encoding to the more
   * compact R+S format. This conversion is often required when dealing with ECDSA signatures in
   * certain cryptographic standards such as JWS (JSON Web Signature).
   *
   * The method decodes the DER-encoded signature, extracts the R and S values, and concatenates
   * them into a single byte array. This process involves handling the ASN.1 structure to correctly
   * parse the R and S values, considering padding and integer encoding specifics of DER.
   *
   * @example
   * ```ts
   * const derSignature = new Uint8Array([...]); // Replace with your DER-encoded signature
   * const signature = await Secp256r1.convertDerToCompactSignature({ derSignature });
   * ```
   *
   * @param params - The parameters for the signature conversion.
   * @param params.derSignature - The signature in ASN.1 DER format as a `Uint8Array`.
   *
   * @returns A Promise that resolves to the signature in compact R+S format as a `Uint8Array`.
   */
  static convertDerToCompactSignature({ derSignature }) {
    return __awaiter7(this, void 0, void 0, function* () {
      const signatureObject = secp256r1.Signature.fromDER(derSignature);
      const compactSignature = signatureObject.toCompactRawBytes();
      return compactSignature;
    });
  }
  /**
   * Converts a public key to its uncompressed form.
   *
   * @remarks
   * This method takes a compressed public key represented as a byte array and decompresses it.
   * Public key decompression involves reconstructing the y-coordinate from the x-coordinate,
   * resulting in the full public key. This method is used when the uncompressed key format is
   * required for certain cryptographic operations or interoperability.
   *
   * @example
   * ```ts
   * const compressedPublicKeyBytes = new Uint8Array([...]); // Replace with actual compressed public key bytes
   * const decompressedPublicKey = await Secp256r1.decompressPublicKey({
   *   publicKeyBytes: compressedPublicKeyBytes
   * });
   * ```
   *
   * @param params - The parameters for the public key decompression.
   * @param params.publicKeyBytes - The public key as a Uint8Array.
   *
   * @returns A Promise that resolves to the uncompressed public key as a Uint8Array.
   */
  static decompressPublicKey({ publicKeyBytes }) {
    return __awaiter7(this, void 0, void 0, function* () {
      const point = secp256r1.ProjectivePoint.fromHex(publicKeyBytes);
      return point.toRawBytes(false);
    });
  }
  /**
   * Generates a secp256r1 private key in JSON Web Key (JWK) format.
   *
   * @remarks
   * This method creates a new private key suitable for use with the secp256r1
   * elliptic curve. The key is generated using cryptographically secure random
   * number generation to ensure its uniqueness and security. The resulting
   * private key adheres to the JWK format, specifically tailored for secp256r1,
   * making it compatible with common cryptographic standards and easy to use in
   * various cryptographic processes.
   *
   * The private key generated by this method includes the following components:
   * - `kty`: Key Type, set to 'EC' for Elliptic Curve.
   * - `crv`: Curve Name, set to 'P-256'.
   * - `d`: The private key component, base64url-encoded.
   * - `x`: The x-coordinate of the public key point, derived from the private key, base64url-encoded.
   * - `y`: The y-coordinate of the public key point, derived from the private key, base64url-encoded.
   *
   * The key is returned in a format suitable for direct use in signin and key agreement operations.
   *
   * @example
   * ```ts
   * const privateKey = await Secp256r1.generateKey();
   * ```
   *
   * @returns A Promise that resolves to the generated private key in JWK format.
   */
  static generateKey() {
    return __awaiter7(this, void 0, void 0, function* () {
      const privateKeyBytes = secp256r1.utils.randomPrivateKey();
      const privateKey = yield _Secp256r1.bytesToPrivateKey({ privateKeyBytes });
      privateKey.kid = yield computeJwkThumbprint({ jwk: privateKey });
      return privateKey;
    });
  }
  /**
   * Retrieves the public key properties from a given private key in JWK format.
   *
   * @remarks
   * This method extracts the public key portion from a secp256r1 private key in JWK format. It does
   * so by removing the private key property 'd' and making a shallow copy, effectively yielding the
   * public key. The method sets the 'kid' (key ID) property using the JWK thumbprint if it is not
   * already defined. This approach is used under the assumption that a private key in JWK format
   * always contains the corresponding public key properties.
   *
   * Note: This method offers a significant performance advantage, being about 200 times faster
   * than `computePublicKey()`. However, it does not mathematically validate the private key, nor
   * does it derive the public key from the private key. It simply extracts existing public key
   * properties from the private key object. This makes it suitable for scenarios where speed is
   * critical and the private key's integrity is already assured.
   *
   * @example
   * ```ts
   * const privateKey = { ... }; // A Jwk object representing a secp256r1 private key
   * const publicKey = await Secp256r1.getPublicKey({ key: privateKey });
   * ```
   *
   * @param params - The parameters for retrieving the public key properties.
   * @param params.key - The private key in JWK format.
   *
   * @returns A Promise that resolves to the public key in JWK format.
   */
  static getPublicKey({ key }) {
    var _a;
    return __awaiter7(this, void 0, void 0, function* () {
      if (!(isEcPrivateJwk(key) && key.crv === "P-256")) {
        throw new Error(`Secp256r1: The provided key is not a 'P-256' private JWK.`);
      }
      let { d } = key, publicKey = __rest2(key, ["d"]);
      (_a = publicKey.kid) !== null && _a !== void 0 ? _a : publicKey.kid = yield computeJwkThumbprint({ jwk: publicKey });
      return publicKey;
    });
  }
  /**
   * Converts a private key from JSON Web Key (JWK) format to a raw byte array (Uint8Array).
   *
   * @remarks
   * This method takes a private key in JWK format and extracts its raw byte representation.
   * It specifically focuses on the 'd' parameter of the JWK, which represents the private
   * key component in base64url encoding. The method decodes this value into a byte array.
   *
   * This conversion is essential for operations that require the private key in its raw
   * binary form, such as certain low-level cryptographic operations or when interfacing
   * with systems and libraries that expect keys in a byte array format.
   *
   * @example
   * ```ts
   * const privateKey = { ... }; // An X25519 private key in JWK format
   * const privateKeyBytes = await Secp256r1.privateKeyToBytes({ privateKey });
   * ```
   *
   * @param params - The parameters for the private key conversion.
   * @param params.privateKey - The private key in JWK format.
   *
   * @returns A Promise that resolves to the private key as a Uint8Array.
   */
  static privateKeyToBytes({ privateKey }) {
    return __awaiter7(this, void 0, void 0, function* () {
      if (!isEcPrivateJwk(privateKey)) {
        throw new Error(`Secp256r1: The provided key is not a valid EC private key.`);
      }
      const privateKeyBytes = Convert.base64Url(privateKey.d).toUint8Array();
      return privateKeyBytes;
    });
  }
  /**
   * Converts a public key from JSON Web Key (JWK) format to a raw byte array (Uint8Array).
   *
   * @remarks
   * This method accepts a public key in JWK format and converts it into its raw binary
   * form. The conversion process involves decoding the 'x' and 'y' parameters of the JWK
   * (which represent the x and y coordinates of the elliptic curve point, respectively)
   * from base64url format into a byte array. The method then concatenates these values,
   * along with a prefix indicating the key format, to form the full public key.
   *
   * This function is particularly useful for use cases where the public key is needed
   * in its raw byte format, such as for certain cryptographic operations or when
   * interfacing with systems that require raw key formats.
   *
   * @example
   * ```ts
   * const publicKey = { ... }; // A Jwk public key object
   * const publicKeyBytes = await Secp256r1.publicKeyToBytes({ publicKey });
   * ```
   *
   * @param params - The parameters for the public key conversion.
   * @param params.publicKey - The public key in JWK format.
   *
   * @returns A Promise that resolves to the public key as a Uint8Array.
   */
  static publicKeyToBytes({ publicKey }) {
    return __awaiter7(this, void 0, void 0, function* () {
      if (!(isEcPublicJwk(publicKey) && publicKey.y)) {
        throw new Error(`Secp256r1: The provided key is not a valid EC public key.`);
      }
      const prefix = new Uint8Array([4]);
      const x = Convert.base64Url(publicKey.x).toUint8Array();
      const y = Convert.base64Url(publicKey.y).toUint8Array();
      const publicKeyBytes = new Uint8Array([...prefix, ...x, ...y]);
      return publicKeyBytes;
    });
  }
  /**
   * Computes an RFC6090-compliant Elliptic Curve Diffie-Hellman (ECDH) shared secret
   * using secp256r1 private and public keys in JSON Web Key (JWK) format.
   *
   * @remarks
   * This method facilitates the ECDH key agreement protocol, which is a method of securely
   * deriving a shared secret between two parties based on their private and public keys.
   * It takes the private key of one party (privateKeyA) and the public key of another
   * party (publicKeyB) to compute a shared secret. The shared secret is derived from the
   * x-coordinate of the elliptic curve point resulting from the multiplication of the
   * public key with the private key.
   *
   * Note: When performing Elliptic Curve Diffie-Hellman (ECDH) key agreement,
   * the resulting shared secret is a point on the elliptic curve, which
   * consists of an x-coordinate and a y-coordinate. With a 256-bit curve like
   * secp256r1, each of these coordinates is 32 bytes (256 bits) long. However,
   * in the ECDH process, it's standard practice to use only the x-coordinate
   * of the shared secret point as the resulting shared key. This is because
   * the y-coordinate does not add to the entropy of the key, and both parties
   * can independently compute the x-coordinate.  Consquently, this implementation
   * omits the y-coordinate for simplicity and standard compliance.
   *
   * @example
   * ```ts
   * const privateKeyA = { ... }; // A Jwk private key object for party A
   * const publicKeyB = { ... }; // A Jwk public key object for party B
   * const sharedSecret = await Secp256r1.sharedSecret({
   *   privateKeyA,
   *   publicKeyB
   * });
   * ```
   *
   * @param params - The parameters for the shared secret computation.
   * @param params.privateKeyA - The private key in JWK format of one party.
   * @param params.publicKeyB - The public key in JWK format of the other party.
   *
   * @returns A Promise that resolves to the computed shared secret as a Uint8Array.
   */
  static sharedSecret({ privateKeyA, publicKeyB }) {
    return __awaiter7(this, void 0, void 0, function* () {
      if ("x" in privateKeyA && "x" in publicKeyB && privateKeyA.x === publicKeyB.x) {
        throw new Error(`Secp256r1: ECDH shared secret cannot be computed from a single key pair's public and private keys.`);
      }
      const privateKeyABytes = yield _Secp256r1.privateKeyToBytes({ privateKey: privateKeyA });
      const publicKeyBBytes = yield _Secp256r1.publicKeyToBytes({ publicKey: publicKeyB });
      const sharedSecret = secp256r1.getSharedSecret(privateKeyABytes, publicKeyBBytes, true);
      return sharedSecret.slice(1);
    });
  }
  /**
   * Generates an RFC6979-compliant ECDSA signature of given data using a secp256r1 private key.
   *
   * @remarks
   * This method signs the provided data with a specified private key using the ECDSA
   * (Elliptic Curve Digital Signature Algorithm) signature algorithm, as defined in RFC6979.
   * The data to be signed is first hashed using the SHA-256 algorithm, and this hash is then
   * signed using the private key. The output is a digital signature in the form of a
   * Uint8Array, which uniquely corresponds to both the data and the private key used for signing.
   *
   * This method is commonly used in cryptographic applications to ensure data integrity and
   * authenticity. The signature can later be verified by parties with access to the corresponding
   * public key, ensuring that the data has not been tampered with and was indeed signed by the
   * holder of the private key.
   *
   * @example
   * ```ts
   * const data = new TextEncoder().encode('Messsage'); // Data to be signed
   * const privateKey = { ... }; // A Jwk object representing a secp256r1 private key
   * const signature = await Secp256r1.sign({
   *   key: privateKey,
   *   data
   * });
   * ```
   *
   * @param params - The parameters for the signing operation.
   * @param params.key - The private key to use for signing, represented in JWK format.
   * @param params.data - The data to sign, represented as a Uint8Array.
   *
   * @returns A Promise that resolves to the signature as a Uint8Array.
   */
  static sign({ data, key }) {
    return __awaiter7(this, void 0, void 0, function* () {
      const privateKeyBytes = yield _Secp256r1.privateKeyToBytes({ privateKey: key });
      const digest = sha256(data);
      const signatureObject = secp256r1.sign(digest, privateKeyBytes);
      const signature = signatureObject.toCompactRawBytes();
      return signature;
    });
  }
  /**
   * Validates a given private key to ensure its compliance with the secp256r1 curve standards.
   *
   * @remarks
   * This method checks whether a provided private key is a valid 32-byte number and falls within
   * the range defined by the secp256r1 curve's order. It is essential for ensuring the private
   * key's mathematical correctness in the context of secp256r1-based cryptographic operations.
   *
   * Note that this validation strictly pertains to the key's format and numerical validity; it does
   * not assess whether the key corresponds to a known entity or its security status (e.g., whether
   * it has been compromised).
   *
   * @example
   * ```ts
   * const privateKeyBytes = new Uint8Array([...]); // A 32-byte private key
   * const isValid = await Secp256r1.validatePrivateKey({ privateKeyBytes });
   * console.log(isValid); // true or false based on the key's validity
   * ```
   *
   * @param params - The parameters for the key validation.
   * @param params.privateKeyBytes - The private key to validate, represented as a Uint8Array.
   *
   * @returns A Promise that resolves to a boolean indicating whether the private key is valid.
   */
  static validatePrivateKey({ privateKeyBytes }) {
    return __awaiter7(this, void 0, void 0, function* () {
      return secp256r1.utils.isValidPrivateKey(privateKeyBytes);
    });
  }
  /**
   * Validates a given public key to confirm its mathematical correctness on the secp256r1 curve.
   *
   * @remarks
   * This method checks if the provided public key represents a valid point on the secp256r1 curve.
   * It decodes the key's Weierstrass points (x and y coordinates) and verifies their validity
   * against the curve's parameters. A valid point must lie on the curve and meet specific
   * mathematical criteria defined by the curve's equation.
   *
   * It's important to note that this method does not verify the key's ownership or whether it has
   * been compromised; it solely focuses on the key's adherence to the curve's mathematical
   * principles.
   *
   * @example
   * ```ts
   * const publicKeyBytes = new Uint8Array([...]); // A public key in byte format
   * const isValid = await Secp256r1.validatePublicKey({ publicKeyBytes });
   * console.log(isValid); // true if the key is valid on the secp256r1 curve, false otherwise
   * ```
   *
   * @param params - The parameters for the key validation.
   * @param params.publicKeyBytes - The public key to validate, represented as a Uint8Array.
   *
   * @returns A Promise that resolves to a boolean indicating the public key's validity on
   *          the secp256r1 curve.
   */
  static validatePublicKey({ publicKeyBytes }) {
    return __awaiter7(this, void 0, void 0, function* () {
      try {
        const point = secp256r1.ProjectivePoint.fromHex(publicKeyBytes);
        point.assertValidity();
      } catch (error) {
        return false;
      }
      return true;
    });
  }
  /**
   * Verifies an RFC6979-compliant ECDSA signature against given data and a secp256r1 public key.
   *
   * @remarks
   * This method validates a digital signature to ensure that it was generated by the holder of the
   * corresponding private key and that the signed data has not been altered. The signature
   * verification is performed using the ECDSA (Elliptic Curve Digital Signature Algorithm) as
   * specified in RFC6979. The data to be verified is first hashed using the SHA-256 algorithm, and
   * this hash is then used along with the public key to verify the signature.
   *
   * The method returns a boolean value indicating whether the signature is valid. A valid signature
   * proves that the signed data was indeed signed by the owner of the private key corresponding to
   * the provided public key and that the data has not been tampered with since it was signed.
   *
   * Note: The verification process does not consider the malleability of low-s signatures, which
   * may be relevant in certain contexts, such as Bitcoin transactions.
   *
   * @example
   * ```ts
   * const data = new TextEncoder().encode('Messsage'); // Data that was signed
   * const publicKey = { ... }; // Public key in JWK format corresponding to the private key that signed the data
   * const signature = new Uint8Array([...]); // Signature to verify
   * const isSignatureValid = await Secp256r1.verify({
   *   key: publicKey,
   *   signature,
   *   data
   * });
   * console.log(isSignatureValid); // true if the signature is valid, false otherwise
   * ```
   *
   * @param params - The parameters for the signature verification.
   * @param params.key - The public key used for verification, represented in JWK format.
   * @param params.signature - The signature to verify, represented as a Uint8Array.
   * @param params.data - The data that was signed, represented as a Uint8Array.
   *
   * @returns A Promise that resolves to a boolean indicating whether the signature is valid.
   */
  static verify({ key, signature, data }) {
    return __awaiter7(this, void 0, void 0, function* () {
      const publicKeyBytes = yield _Secp256r1.publicKeyToBytes({ publicKey: key });
      const digest = sha256(data);
      const isValid3 = secp256r1.verify(signature, digest, publicKeyBytes, { lowS: false });
      return isValid3;
    });
  }
  /**
   * Returns the elliptic curve point (x and y coordinates) for a given secp256r1 key.
   *
   * @remarks
   * This method extracts the elliptic curve point from a given secp256r1 key, whether
   * it's a private or a public key. For a private key, the method first computes the
   * corresponding public key and then extracts the x and y coordinates. For a public key,
   * it directly returns these coordinates. The coordinates are represented as Uint8Array.
   *
   * The x and y coordinates represent the key's position on the elliptic curve and can be
   * used in various cryptographic operations, such as digital signatures or key agreement
   * protocols.
   *
   * @example
   * ```ts
   * // For a private key
   * const privateKey = new Uint8Array([...]); // A 32-byte private key
   * const { x: xFromPrivateKey, y: yFromPrivateKey } = await Secp256r1.getCurvePoint({ keyBytes: privateKey });
   *
   * // For a public key
   * const publicKey = new Uint8Array([...]); // A 33-byte or 65-byte public key
   * const { x: xFromPublicKey, y: yFromPublicKey } = await Secp256r1.getCurvePoint({ keyBytes: publicKey });
   * ```
   *
   * @param params - The parameters for the curve point decoding operation.
   * @param params.keyBytes - The key for which to get the elliptic curve point.
   *                          Can be either a private key or a public key.
   *                          The key should be passed as a `Uint8Array`.
   *
   * @returns A Promise that resolves to an object with properties 'x' and 'y',
   *          each being a Uint8Array representing the x and y coordinates of the key point on the
   *          elliptic curve.
   */
  static getCurvePoint({ keyBytes }) {
    return __awaiter7(this, void 0, void 0, function* () {
      if (keyBytes.byteLength === 32) {
        keyBytes = secp256r1.getPublicKey(keyBytes);
      }
      const point = secp256r1.ProjectivePoint.fromHex(keyBytes);
      const x = numberToBytesBE(point.x, 32);
      const y = numberToBytesBE(point.y, 32);
      return { x, y };
    });
  }
};

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/algorithms/ecdsa.js
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var EcdsaAlgorithm = class extends CryptoAlgorithm {
  /**
   * Derives the public key in JWK format from a given private key.
   *
   * @remarks
   * This method takes a private key in JWK format and derives its corresponding public key,
   * also in JWK format. The process ensures that the derived public key correctly corresponds to
   * the given private key.
   *
   * @example
   * ```ts
   * const ecdsa = new EcdsaAlgorithm();
   * const privateKey = { ... }; // A Jwk object representing a private key
   * const publicKey = await ecdsa.computePublicKey({ key: privateKey });
   * ```
   *
   * @param params - The parameters for the public key derivation.
   * @param params.key - The private key in JWK format from which to derive the public key.
   *
   * @returns A Promise that resolves to the derived public key in JWK format.
   */
  computePublicKey({ key }) {
    return __awaiter8(this, void 0, void 0, function* () {
      if (!isEcPrivateJwk(key))
        throw new TypeError("Invalid key provided. Must be an elliptic curve (EC) private key.");
      switch (key.crv) {
        case "secp256k1": {
          const publicKey = yield Secp256k1.computePublicKey({ key });
          publicKey.alg = "ES256K";
          return publicKey;
        }
        case "P-256": {
          const publicKey = yield Secp256r1.computePublicKey({ key });
          publicKey.alg = "ES256";
          return publicKey;
        }
        default: {
          throw new Error(`Unsupported curve: ${key.crv}`);
        }
      }
    });
  }
  /**
   * Generates a new private key with the specified algorithm in JSON Web Key (JWK) format.
   *
   * @example
   * ```ts
   * const ecdsa = new EcdsaAlgorithm();
   * const privateKey = await ecdsa.generateKey({ algorithm: 'ES256K' });
   * ```
   *
   * @param params - The parameters for key generation.
   * @param params.algorithm - The algorithm to use for key generation.
   *
   * @returns A Promise that resolves to the generated private key in JWK format.
   */
  generateKey({ algorithm }) {
    return __awaiter8(this, void 0, void 0, function* () {
      switch (algorithm) {
        case "ES256K":
        case "secp256k1": {
          const privateKey = yield Secp256k1.generateKey();
          privateKey.alg = "ES256K";
          return privateKey;
        }
        case "ES256":
        case "secp256r1": {
          const privateKey = yield Secp256r1.generateKey();
          privateKey.alg = "ES256";
          return privateKey;
        }
      }
    });
  }
  /**
   * Retrieves the public key properties from a given private key in JWK format.
   *
   * @remarks
   * This method extracts the public key portion from an ECDSA private key in JWK format. It does
   * so by removing the private key property 'd' and making a shallow copy, effectively yielding the
   * public key.
   *
   * Note: This method offers a significant performance advantage, being about 200 times faster
   * than `computePublicKey()`. However, it does not mathematically validate the private key, nor
   * does it derive the public key from the private key. It simply extracts existing public key
   * properties from the private key object. This makes it suitable for scenarios where speed is
   * critical and the private key's integrity is already assured.
   *
   * @example
   * ```ts
   * const ecdsa = new EcdsaAlgorithm();
   * const privateKey = { ... }; // A Jwk object representing a private key
   * const publicKey = await ecdsa.getPublicKey({ key: privateKey });
   * ```
   *
   * @param params - The parameters for retrieving the public key properties.
   * @param params.key - The private key in JWK format.
   *
   * @returns A Promise that resolves to the public key in JWK format.
   */
  getPublicKey({ key }) {
    return __awaiter8(this, void 0, void 0, function* () {
      if (!isEcPrivateJwk(key))
        throw new TypeError("Invalid key provided. Must be an elliptic curve (EC) private key.");
      switch (key.crv) {
        case "secp256k1": {
          const publicKey = yield Secp256k1.getPublicKey({ key });
          publicKey.alg = "ES256K";
          return publicKey;
        }
        case "P-256": {
          const publicKey = yield Secp256r1.getPublicKey({ key });
          publicKey.alg = "ES256";
          return publicKey;
        }
        default: {
          throw new Error(`Unsupported curve: ${key.crv}`);
        }
      }
    });
  }
  /**
   * Generates an ECDSA signature of given data using a private key.
   *
   * @remarks
   * This method uses the signature algorithm determined by the given `algorithm` to sign the
   * provided data.
   *
   * The signature can later be verified by parties with access to the corresponding
   * public key, ensuring that the data has not been tampered with and was indeed signed by the
   * holder of the private key.
   *
   * @example
   * ```ts
   * const ecdsa = new EcdsaAlgorithm();
   * const data = new TextEncoder().encode('Message');
   * const privateKey = { ... }; // A Jwk object representing a private key
   * const signature = await ecdsa.sign({
   *   key: privateKey,
   *   data
   * });
   * ```
   *
   * @param params - The parameters for the signing operation.
   * @param params.key - The private key to use for signing, represented in JWK format.
   * @param params.data - The data to sign.
   *
   * @returns A Promise resolving to the digital signature as a `Uint8Array`.
   */
  sign({ key, data }) {
    return __awaiter8(this, void 0, void 0, function* () {
      if (!isEcPrivateJwk(key))
        throw new TypeError("Invalid key provided. Must be an elliptic curve (EC) private key.");
      switch (key.crv) {
        case "secp256k1": {
          return yield Secp256k1.sign({ key, data });
        }
        case "P-256": {
          return yield Secp256r1.sign({ key, data });
        }
        default: {
          throw new Error(`Unsupported curve: ${key.crv}`);
        }
      }
    });
  }
  /**
   * Verifies an ECDSA signature associated with the provided data using the provided key.
   *
   * @remarks
   * This method uses the signature algorithm determined by the `crv` property of the provided key
   * to check the validity of a digital signature against the original data. It confirms whether the
   * signature was created by the holder of the corresponding private key and that the data has not
   * been tampered with.
   *s
   * @example
   * ```ts
   * const ecdsa = new EcdsaAlgorithm();
   * const publicKey = { ... }; // Public key in JWK format corresponding to the private key that signed the data
   * const signature = new Uint8Array([...]); // Signature to verify
   * const data = new TextEncoder().encode('Message');
   * const isValid = await ecdsa.verify({
   *   key: publicKey,
   *   signature,
   *   data
   * });
   * ```
   *
   * @param params - The parameters for the verification operation.
   * @param params.key - The key to use for verification.
   * @param params.signature - The signature to verify.
   * @param params.data - The data to verify.
   *
   * @returns A Promise resolving to a boolean indicating whether the signature is valid.
   */
  verify({ key, signature, data }) {
    return __awaiter8(this, void 0, void 0, function* () {
      if (!isEcPublicJwk(key))
        throw new TypeError("Invalid key provided. Must be an elliptic curve (EC) public key.");
      switch (key.crv) {
        case "secp256k1": {
          return yield Secp256k1.verify({ key, signature, data });
        }
        case "P-256": {
          return yield Secp256r1.verify({ key, signature, data });
        }
        default: {
          throw new Error(`Unsupported curve: ${key.crv}`);
        }
      }
    });
  }
};

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/algorithms/eddsa.js
var import_dist24 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/primitives/ed25519.js
var import_dist23 = __toESM(require_dist(), 1);
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest3 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Ed25519 = class _Ed25519 {
  /**
   * Converts a raw private key in bytes to its corresponding JSON Web Key (JWK) format.
   *
   * @remarks
   * This method accepts a private key as a byte array (Uint8Array) for the Curve25519 curve in
   * Twisted Edwards form and transforms it into a JWK object. The process involves first deriving
   * the public key from the private key, then encoding both the private and public keys into
   * base64url format.
   *
   * The resulting JWK object includes the following properties:
   * - `kty`: Key Type, set to 'OKP' for Octet Key Pair.
   * - `crv`: Curve Name, set to 'Ed25519'.
   * - `d`: The private key component, base64url-encoded.
   * - `x`: The computed public key, base64url-encoded.
   *
   * @example
   * ```ts
   * const privateKeyBytes = new Uint8Array([...]); // Replace with actual private key bytes
   * const privateKey = await Ed25519.bytesToPrivateKey({ privateKeyBytes });
   * ```
   *
   * @param params - The parameters for the private key conversion.
   * @param params.privateKeyBytes - The raw private key as a Uint8Array.
   *
   * @returns A Promise that resolves to the private key in JWK format.
   */
  static bytesToPrivateKey({ privateKeyBytes }) {
    return __awaiter9(this, void 0, void 0, function* () {
      const publicKeyBytes = ed25519.getPublicKey(privateKeyBytes);
      const privateKey = {
        crv: "Ed25519",
        d: Convert.uint8Array(privateKeyBytes).toBase64Url(),
        kty: "OKP",
        x: Convert.uint8Array(publicKeyBytes).toBase64Url()
      };
      privateKey.kid = yield computeJwkThumbprint({ jwk: privateKey });
      return privateKey;
    });
  }
  /**
   * Converts a raw private key in bytes to its corresponding JSON Web Key (JWK) format.
   *
   * @remarks
   * This method accepts a public key as a byte array (Uint8Array) for the Curve25519 curve in
   * Twisted Edwards form and transforms it into a JWK object. The process involves encoding the
   * public key bytes into base64url format.
   *
   * The resulting JWK object includes the following properties:
   * - `kty`: Key Type, set to 'OKP' for Octet Key Pair.
   * - `crv`: Curve Name, set to 'X25519'.
   * - `x`: The public key, base64url-encoded.
   *
   * @example
   * ```ts
   * const publicKeyBytes = new Uint8Array([...]); // Replace with actual public key bytes
   * const publicKey = await X25519.bytesToPublicKey({ publicKeyBytes });
   * ```
   *
   * @param params - The parameters for the public key conversion.
   * @param params.publicKeyBytes - The raw public key as a `Uint8Array`.
   *
   * @returns A Promise that resolves to the public key in JWK format.
   */
  static bytesToPublicKey({ publicKeyBytes }) {
    return __awaiter9(this, void 0, void 0, function* () {
      const publicKey = {
        kty: "OKP",
        crv: "Ed25519",
        x: Convert.uint8Array(publicKeyBytes).toBase64Url()
      };
      publicKey.kid = yield computeJwkThumbprint({ jwk: publicKey });
      return publicKey;
    });
  }
  /**
   * Derives the public key in JWK format from a given Ed25519 private key.
   *
   * @remarks
   * This method takes a private key in JWK format and derives its corresponding public key,
   * also in JWK format.  The derivation process involves converting the private key to a
   * raw byte array and then computing the corresponding public key on the Curve25519 curve in
   * Twisted Edwards form. The public key is then encoded into base64url format to construct
   * a JWK representation.
   *
   * @example
   * ```ts
   * const privateKey = { ... }; // A Jwk object representing an Ed25519 private key
   * const publicKey = await Ed25519.computePublicKey({ key: privateKey });
   * ```
   *
   * @param params - The parameters for the public key derivation.
   * @param params.key - The private key in JWK format from which to derive the public key.
   *
   * @returns A Promise that resolves to the computed public key in JWK format.
   */
  static computePublicKey({ key }) {
    return __awaiter9(this, void 0, void 0, function* () {
      const privateKeyBytes = yield _Ed25519.privateKeyToBytes({ privateKey: key });
      const publicKeyBytes = ed25519.getPublicKey(privateKeyBytes);
      const publicKey = {
        kty: "OKP",
        crv: "Ed25519",
        x: Convert.uint8Array(publicKeyBytes).toBase64Url()
      };
      publicKey.kid = yield computeJwkThumbprint({ jwk: publicKey });
      return publicKey;
    });
  }
  /**
   * Converts an Ed25519 private key to its X25519 counterpart.
   *
   * @remarks
   * This method enables the use of the same key pair for both digital signature (Ed25519)
   * and key exchange (X25519) operations. It takes an Ed25519 private key and converts it
   * to the corresponding X25519 format, facilitating interoperability between signing
   * and encryption protocols.
   *
   * @example
   * ```ts
   * const ed25519PrivateKey = { ... }; // An Ed25519 private key in JWK format
   * const x25519PrivateKey = await Ed25519.convertPrivateKeyToX25519({
   *   privateKey: ed25519PrivateKey
   * });
   * ```
   *
   * @param params - The parameters for the private key conversion.
   * @param params.privateKey - The Ed25519 private key to convert, in JWK format.
   *
   * @returns A Promise that resolves to the X25519 private key in JWK format.
   */
  static convertPrivateKeyToX25519({ privateKey }) {
    return __awaiter9(this, void 0, void 0, function* () {
      const ed25519PrivateKeyBytes = yield _Ed25519.privateKeyToBytes({ privateKey });
      const x25519PrivateKeyBytes = edwardsToMontgomeryPriv(ed25519PrivateKeyBytes);
      const x25519PublicKeyBytes = x25519.getPublicKey(x25519PrivateKeyBytes);
      const x25519PrivateKey = {
        kty: "OKP",
        crv: "X25519",
        d: Convert.uint8Array(x25519PrivateKeyBytes).toBase64Url(),
        x: Convert.uint8Array(x25519PublicKeyBytes).toBase64Url()
      };
      x25519PrivateKey.kid = yield computeJwkThumbprint({ jwk: x25519PrivateKey });
      return x25519PrivateKey;
    });
  }
  /**
   * Converts an Ed25519 public key to its X25519 counterpart.
   *
   * @remarks
   * This method enables the use of the same key pair for both digital signature (Ed25519)
   * and key exchange (X25519) operations. It takes an Ed25519 public key and converts it
   * to the corresponding X25519 format, facilitating interoperability between signing
   * and encryption protocols.
   *
   * @example
   * ```ts
   * const ed25519PublicKey = { ... }; // An Ed25519 public key in JWK format
   * const x25519PublicKey = await Ed25519.convertPublicKeyToX25519({
   *   publicKey: ed25519PublicKey
   * });
   * ```
   *
   * @param params - The parameters for the public key conversion.
   * @param params.publicKey - The Ed25519 public key to convert, in JWK format.
   *
   * @returns A Promise that resolves to the X25519 public key in JWK format.
   */
  static convertPublicKeyToX25519({ publicKey }) {
    return __awaiter9(this, void 0, void 0, function* () {
      const ed25519PublicKeyBytes = yield _Ed25519.publicKeyToBytes({ publicKey });
      const isValid3 = yield _Ed25519.validatePublicKey({ publicKeyBytes: ed25519PublicKeyBytes });
      if (!isValid3) {
        throw new Error("Ed25519: Invalid public key.");
      }
      const x25519PublicKeyBytes = edwardsToMontgomeryPub(ed25519PublicKeyBytes);
      const x25519PublicKey = {
        kty: "OKP",
        crv: "X25519",
        x: Convert.uint8Array(x25519PublicKeyBytes).toBase64Url()
      };
      x25519PublicKey.kid = yield computeJwkThumbprint({ jwk: x25519PublicKey });
      return x25519PublicKey;
    });
  }
  /**
   * Generates an Ed25519 private key in JSON Web Key (JWK) format.
   *
   * @remarks
   * This method creates a new private key suitable for use with the Curve25519 elliptic curve in
   * Twisted Edwards form. The key generation process involves using cryptographically secure
   * random number generation to ensure the uniqueness and security of the key. The resulting
   * private key adheres to the JWK format making it compatible with common cryptographic
   * standards and easy to use in various cryptographic processes.
   *
   * The generated private key in JWK format includes the following components:
   * - `kty`: Key Type, set to 'OKP' for Octet Key Pair.
   * - `crv`: Curve Name, set to 'Ed25519'.
   * - `d`: The private key component, base64url-encoded.
   * - `x`: The derived public key, base64url-encoded.
   *
   * @example
   * ```ts
   * const privateKey = await Ed25519.generateKey();
   * ```
   *
   * @returns A Promise that resolves to the generated private key in JWK format.
   */
  static generateKey() {
    return __awaiter9(this, void 0, void 0, function* () {
      const privateKeyBytes = ed25519.utils.randomPrivateKey();
      const privateKey = yield _Ed25519.bytesToPrivateKey({ privateKeyBytes });
      privateKey.kid = yield computeJwkThumbprint({ jwk: privateKey });
      return privateKey;
    });
  }
  /**
   * Retrieves the public key properties from a given private key in JWK format.
   *
   * @remarks
   * This method extracts the public key portion from an Ed25519 private key in JWK format. It does
   * so by removing the private key property 'd' and making a shallow copy, effectively yielding the
   * public key. The method sets the 'kid' (key ID) property using the JWK thumbprint if it is not
   * already defined. This approach is used under the assumption that a private key in JWK format
   * always contains the corresponding public key properties.
   *
   * Note: This method offers a significant performance advantage, being about 100 times faster
   * than `computePublicKey()`. However, it does not mathematically validate the private key, nor
   * does it derive the public key from the private key. It simply extracts existing public key
   * properties from the private key object. This makes it suitable for scenarios where speed is
   * critical and the private key's integrity is already assured.
   *
   * @example
   * ```ts
   * const privateKey = { ... }; // A Jwk object representing an Ed25519 private key
   * const publicKey = await Ed25519.getPublicKey({ key: privateKey });
   * ```
   *
   * @param params - The parameters for retrieving the public key properties.
   * @param params.key - The private key in JWK format.
   *
   * @returns A Promise that resolves to the public key in JWK format.
   */
  static getPublicKey({ key }) {
    var _a;
    return __awaiter9(this, void 0, void 0, function* () {
      if (!(isOkpPrivateJwk(key) && key.crv === "Ed25519")) {
        throw new Error(`Ed25519: The provided key is not an Ed25519 private JWK.`);
      }
      let { d } = key, publicKey = __rest3(key, ["d"]);
      (_a = publicKey.kid) !== null && _a !== void 0 ? _a : publicKey.kid = yield computeJwkThumbprint({ jwk: publicKey });
      return publicKey;
    });
  }
  /**
   * Converts a private key from JSON Web Key (JWK) format to a raw byte array (Uint8Array).
   *
   * @remarks
   * This method accepts a private key in JWK format and extracts its raw byte representation.
   *
   * This method accepts a public key in JWK format and converts it into its raw binary
   * form. The conversion process involves decoding the 'd' parameter of the JWK
   * from base64url format into a byte array.
   *
   * @example
   * ```ts
   * const privateKey = { ... }; // An Ed25519 private key in JWK format
   * const privateKeyBytes = await Ed25519.privateKeyToBytes({ privateKey });
   * ```
   *
   * @param params - The parameters for the private key conversion.
   * @param params.privateKey - The private key in JWK format.
   *
   * @returns A Promise that resolves to the private key as a Uint8Array.
   */
  static privateKeyToBytes({ privateKey }) {
    return __awaiter9(this, void 0, void 0, function* () {
      if (!isOkpPrivateJwk(privateKey)) {
        throw new Error(`Ed25519: The provided key is not a valid OKP private key.`);
      }
      const privateKeyBytes = Convert.base64Url(privateKey.d).toUint8Array();
      return privateKeyBytes;
    });
  }
  /**
   * Converts a public key from JSON Web Key (JWK) format to a raw byte array (Uint8Array).
   *
   * @remarks
   * This method accepts a public key in JWK format and converts it into its raw binary form.
   * The conversion process involves decoding the 'x' parameter of the JWK (which represent the
   * x coordinate of the elliptic curve point) from base64url format into a byte array.
   *
   * @example
   * ```ts
   * const publicKey = { ... }; // An Ed25519 public key in JWK format
   * const publicKeyBytes = await Ed25519.publicKeyToBytes({ publicKey });
   * ```
   *
   * @param params - The parameters for the public key conversion.
   * @param params.publicKey - The public key in JWK format.
   *
   * @returns A Promise that resolves to the public key as a Uint8Array.
   */
  static publicKeyToBytes({ publicKey }) {
    return __awaiter9(this, void 0, void 0, function* () {
      if (!isOkpPublicJwk(publicKey)) {
        throw new Error(`Ed25519: The provided key is not a valid OKP public key.`);
      }
      const publicKeyBytes = Convert.base64Url(publicKey.x).toUint8Array();
      return publicKeyBytes;
    });
  }
  /**
   * Generates an RFC8032-compliant EdDSA signature of given data using an Ed25519 private key.
   *
   * @remarks
   * This method signs the provided data with a specified private key using the EdDSA
   * (Edwards-curve Digital Signature Algorithm) as defined in RFC8032. It
   * involves converting the private key from JWK format to a byte array and then employing
   * the Ed25519 algorithm to sign the data. The output is a digital signature in the form
   * of a Uint8Array, uniquely corresponding to both the data and the private key used for
   * signing.
   *
   * @example
   * ```ts
   * const data = new TextEncoder().encode('Messsage'); // Data to be signed
   * const privateKey = { ... }; // A Jwk object representing an Ed25519 private key
   * const signature = await Ed25519.sign({ key: privateKey, data });
   * ```
   *
   * @param params - The parameters for the signing operation.
   * @param params.key - The private key to use for signing, represented in JWK format.
   * @param params.data - The data to sign, represented as a Uint8Array.
   *
   * @returns A Promise that resolves to the signature as a Uint8Array.
   */
  static sign({ key, data }) {
    return __awaiter9(this, void 0, void 0, function* () {
      const privateKeyBytes = yield _Ed25519.privateKeyToBytes({ privateKey: key });
      const signature = ed25519.sign(data, privateKeyBytes);
      return signature;
    });
  }
  /**
   * Validates a given public key to confirm its mathematical correctness on the Edwards curve.
   *
   * @remarks
   * This method decodes the Edwards points from the key bytes and asserts their validity on the
   * Curve25519 curve in Twisted Edwards form. If the points are not valid, the method returns
   * false. If the points are valid, the method returns true.
   *
   * Note that this validation strictly pertains to the key's format and numerical validity; it does
   * not assess whether the key corresponds to a known entity or its security status (e.g., whether
   * it has been compromised).
   *
   * @example
   * ```ts
   * const publicKeyBytes = new Uint8Array([...]); // A public key in byte format
   * const isValid = await Ed25519.validatePublicKey({ publicKeyBytes });
   * console.log(isValid); // true if the key is valid on the Edwards curve, false otherwise
   * ```
   *
   * @param params - The parameters for the public key validation.
   * @param params.publicKeyBytes - The public key to validate, represented as a Uint8Array.
   *
   * @returns A Promise that resolves to a boolean indicating whether the key
   *          corresponds to a valid point on the Edwards curve.
   */
  static validatePublicKey({ publicKeyBytes }) {
    return __awaiter9(this, void 0, void 0, function* () {
      try {
        const point = ed25519.ExtendedPoint.fromHex(publicKeyBytes);
        point.assertValidity();
      } catch (error) {
        return false;
      }
      return true;
    });
  }
  /**
   * Verifies an RFC8032-compliant EdDSA signature against given data using an Ed25519 public key.
   *
   * @remarks
   * This method validates a digital signature to ensure its authenticity and integrity.
   * It uses the EdDSA (Edwards-curve Digital Signature Algorithm) as specified in RFC8032.
   * The verification process involves converting the public key from JWK format to a raw
   * byte array and using the Ed25519 algorithm to validate the signature against the provided data.
   *
   * @example
   * ```ts
   * const data = new TextEncoder().encode('Messsage'); // Data that was signed
   * const publicKey = { ... }; // A Jwk object representing an Ed25519 public key
   * const signature = new Uint8Array([...]); // Signature to verify
   * const isValid = await Ed25519.verify({ key: publicKey, signature, data });
   * console.log(isValid); // true if the signature is valid, false otherwise
   * ```
   *
   * @param params - The parameters for the signature verification.
   * @param params.key - The public key in JWK format used for verification.
   * @param params.signature - The signature to verify, represented as a Uint8Array.
   * @param params.data - The data that was signed, represented as a Uint8Array.
   *
   * @returns A Promise that resolves to a boolean indicating whether the signature is valid.
   */
  static verify({ key, signature, data }) {
    return __awaiter9(this, void 0, void 0, function* () {
      const publicKeyBytes = yield _Ed25519.publicKeyToBytes({ publicKey: key });
      const isValid3 = ed25519.verify(signature, data, publicKeyBytes);
      return isValid3;
    });
  }
};

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/algorithms/eddsa.js
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var EdDsaAlgorithm = class extends CryptoAlgorithm {
  /**
   * Derives the public key in JWK format from a given private key.
   *
   * @remarks
   * This method takes a private key in JWK format and derives its corresponding public key,
   * also in JWK format. The process ensures that the derived public key correctly corresponds to
   * the given private key.
   *
   * @example
   * ```ts
   * const eddsa = new EdDsaAlgorithm();
   * const privateKey = { ... }; // A Jwk object representing a private key
   * const publicKey = await eddsa.computePublicKey({ key: privateKey });
   * ```
   *
   * @param params - The parameters for the public key derivation.
   * @param params.key - The private key in JWK format from which to derive the public key.
   *
   * @returns A Promise that resolves to the derived public key in JWK format.
   */
  computePublicKey({ key }) {
    return __awaiter10(this, void 0, void 0, function* () {
      if (!isOkpPrivateJwk(key))
        throw new TypeError("Invalid key provided. Must be an octet key pair (OKP) private key.");
      switch (key.crv) {
        case "Ed25519": {
          const publicKey = yield Ed25519.computePublicKey({ key });
          publicKey.alg = "EdDSA";
          return publicKey;
        }
        default: {
          throw new Error(`Unsupported curve: ${key.crv}`);
        }
      }
    });
  }
  /**
   * Generates a new private key with the specified algorithm in JSON Web Key (JWK) format.
   *
   * @example
   * ```ts
   * const eddsa = new EdDsaAlgorithm();
   * const privateKey = await eddsa.generateKey({ algorithm: 'Ed25519' });
   * ```
   *
   * @param params - The parameters for key generation.
   * @param params.algorithm - The algorithm to use for key generation.
   *
   * @returns A Promise that resolves to the generated private key in JWK format.
   */
  generateKey({ algorithm }) {
    return __awaiter10(this, void 0, void 0, function* () {
      switch (algorithm) {
        case "Ed25519": {
          const privateKey = yield Ed25519.generateKey();
          privateKey.alg = "EdDSA";
          return privateKey;
        }
      }
    });
  }
  /**
   * Retrieves the public key properties from a given private key in JWK format.
   *
   * @remarks
   * This method extracts the public key portion from an EdDSA private key in JWK format. It does
   * so by removing the private key property 'd' and making a shallow copy, effectively yielding the
   * public key.
   *
   * Note: This method offers a significant performance advantage, being about 100 times faster
   * than `computePublicKey()`. However, it does not mathematically validate the private key, nor
   * does it derive the public key from the private key. It simply extracts existing public key
   * properties from the private key object. This makes it suitable for scenarios where speed is
   * critical and the private key's integrity is already assured.
   *
   * @example
   * ```ts
   * const eddsa = new EdDsaAlgorithm();
   * const privateKey = { ... }; // A Jwk object representing a private key
   * const publicKey = await eddsa.getPublicKey({ key: privateKey });
   * ```
   *
   * @param params - The parameters for retrieving the public key properties.
   * @param params.key - The private key in JWK format.
   *
   * @returns A Promise that resolves to the public key in JWK format.
   */
  getPublicKey({ key }) {
    return __awaiter10(this, void 0, void 0, function* () {
      if (!isOkpPrivateJwk(key))
        throw new TypeError("Invalid key provided. Must be an octet key pair (OKP) private key.");
      switch (key.crv) {
        case "Ed25519": {
          const publicKey = yield Ed25519.getPublicKey({ key });
          publicKey.alg = "EdDSA";
          return publicKey;
        }
        default: {
          throw new Error(`Unsupported curve: ${key.crv}`);
        }
      }
    });
  }
  /**
   * Generates an EdDSA signature of given data using a private key.
   *
   * @remarks
   * This method uses the signature algorithm determined by the given `algorithm` to sign the
   * provided data.
   *
   * The signature can later be verified by parties with access to the corresponding
   * public key, ensuring that the data has not been tampered with and was indeed signed by the
   * holder of the private key.
   *
   * @example
   * ```ts
   * const eddsa = new EdDsaAlgorithm();
   * const data = new TextEncoder().encode('Message');
   * const privateKey = { ... }; // A Jwk object representing a private key
   * const signature = await eddsa.sign({
   *   key: privateKey,
   *   data
   * });
   * ```
   *
   * @param params - The parameters for the signing operation.
   * @param params.key - The private key to use for signing, represented in JWK format.
   * @param params.data - The data to sign.
   *
   * @returns A Promise resolving to the digital signature as a `Uint8Array`.
   */
  sign({ key, data }) {
    return __awaiter10(this, void 0, void 0, function* () {
      if (!isOkpPrivateJwk(key))
        throw new TypeError("Invalid key provided. Must be an octet key pair (OKP) private key.");
      switch (key.crv) {
        case "Ed25519": {
          return yield Ed25519.sign({ key, data });
        }
        default: {
          throw new Error(`Unsupported curve: ${key.crv}`);
        }
      }
    });
  }
  /**
   * Verifies an EdDSA signature associated with the provided data using the provided key.
   *
   * @remarks
   * This method uses the signature algorithm determined by the `crv` property of the provided key
   * to check the validity of a digital signature against the original data. It confirms whether the
   * signature was created by the holder of the corresponding private key and that the data has not
   * been tampered with.
   *s
   * @example
   * ```ts
   * const eddsa = new EdDsaAlgorithm();
   * const publicKey = { ... }; // Public key in JWK format corresponding to the private key that signed the data
   * const signature = new Uint8Array([...]); // Signature to verify
   * const data = new TextEncoder().encode('Message');
   * const isValid = await eddsa.verify({
   *   key: publicKey,
   *   signature,
   *   data
   * });
   * ```
   *
   * @param params - The parameters for the verification operation.
   * @param params.key - The key to use for verification.
   * @param params.signature - The signature to verify.
   * @param params.data - The data to verify.
   *
   * @returns A Promise resolving to a boolean indicating whether the signature is valid.
   */
  verify({ key, signature, data }) {
    return __awaiter10(this, void 0, void 0, function* () {
      if (!isOkpPublicJwk(key))
        throw new TypeError("Invalid key provided. Must be an octet key pair (OKP) public key.");
      switch (key.crv) {
        case "Ed25519": {
          return yield Ed25519.verify({ key, signature, data });
        }
        default: {
          throw new Error(`Unsupported curve: ${key.crv}`);
        }
      }
    });
  }
};

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/local-key-manager.js
var __awaiter11 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var supportedAlgorithms = {
  "Ed25519": {
    implementation: EdDsaAlgorithm,
    names: ["Ed25519"]
  },
  "secp256k1": {
    implementation: EcdsaAlgorithm,
    names: ["ES256K", "secp256k1"]
  },
  "secp256r1": {
    implementation: EcdsaAlgorithm,
    names: ["ES256", "secp256r1"]
  },
  "SHA-256": {
    implementation: Sha2Algorithm,
    names: ["SHA-256"]
  }
};
var LocalKeyManager = class {
  constructor(params) {
    var _a;
    this._algorithmInstances = /* @__PURE__ */ new Map();
    this._keyStore = (_a = params === null || params === void 0 ? void 0 : params.keyStore) !== null && _a !== void 0 ? _a : new MemoryStore();
  }
  /**
   * Generates a hash digest of the provided data.
   *
   * @remarks
   * A digest is the output of the hash function. It's a fixed-size string of bytes
   * that uniquely represents the data input into the hash function. The digest is often used for
   * data integrity checks, as any alteration in the input data results in a significantly
   * different digest.
   *
   * It takes the algorithm identifier of the hash function and data to digest as input and returns
   * the digest of the data.
   *
   * @example
   * ```ts
   * const keyManager = new LocalKeyManager();
   * const data = new Uint8Array([...]);
   * const digest = await keyManager.digest({ algorithm: 'SHA-256', data });
   * ```
   *
   * @param params - The parameters for the digest operation.
   * @param params.algorithm - The name of hash function to use.
   * @param params.data - The data to digest.
   *
   * @returns A Promise which will be fulfilled with the hash digest.
   */
  digest({ algorithm, data }) {
    return __awaiter11(this, void 0, void 0, function* () {
      const hasher = this.getAlgorithm({ algorithm });
      const hash = yield hasher.digest({ algorithm, data });
      return hash;
    });
  }
  /**
   * Exports a private key identified by the provided key URI from the local KMS.
   *
   * @remarks
   * This method retrieves the key from the key store and returns it. It is primarily used
   * for extracting keys for backup or transfer purposes.
   *
   * @example
   * ```ts
   * const keyManager = new LocalKeyManager();
   * const keyUri = await keyManager.generateKey({ algorithm: 'Ed25519' });
   * const privateKey = await keyManager.exportKey({ keyUri });
   * ```
   *
   * @param params - Parameters for exporting the key.
   * @param params.keyUri - The key URI identifying the key to export.
   *
   * @returns A Promise resolving to the JWK representation of the exported key.
   */
  exportKey({ keyUri }) {
    return __awaiter11(this, void 0, void 0, function* () {
      const privateKey = yield this.getPrivateKey({ keyUri });
      return privateKey;
    });
  }
  /**
   * Generates a new cryptographic key in the local KMS with the specified algorithm and returns a
   * unique key URI which can be used to reference the key in subsequent operations.
   *
   * @example
   * ```ts
   * const keyManager = new LocalKeyManager();
   * const keyUri = await keyManager.generateKey({ algorithm: 'Ed25519' });
   * console.log(keyUri); // Outputs the key URI
   * ```
   *
   * @param params - The parameters for key generation.
   * @param params.algorithm - The algorithm to use for key generation, defined in `SupportedAlgorithm`.
   *
   * @returns A Promise that resolves to the key URI, a unique identifier for the generated key.
   */
  generateKey({ algorithm }) {
    return __awaiter11(this, void 0, void 0, function* () {
      const keyGenerator = this.getAlgorithm({ algorithm });
      const key = yield keyGenerator.generateKey({ algorithm });
      if ((key === null || key === void 0 ? void 0 : key.kid) === void 0) {
        throw new Error("Generated key is missing a required property: kid");
      }
      const keyUri = `${KEY_URI_PREFIX_JWK}${key.kid}`;
      yield this._keyStore.set(keyUri, key);
      return keyUri;
    });
  }
  /**
   * Computes the Key URI for a given public JWK (JSON Web Key).
   *
   * @remarks
   * This method generates a {@link https://datatracker.ietf.org/doc/html/rfc3986 | URI}
   * (Uniform Resource Identifier) for the given JWK, which uniquely identifies the key across all
   * `CryptoApi` implementations. The key URI is constructed by appending the
   * {@link https://datatracker.ietf.org/doc/html/rfc7638 | JWK thumbprint} to the prefix
   * `urn:jwk:`. The JWK thumbprint is deterministically computed from the JWK and is consistent
   * regardless of property order or optional property inclusion in the JWK. This ensures that the
   * same key material represented as a JWK will always yield the same thumbprint, and therefore,
   * the same key URI.
   *
   * @example
   * ```ts
   * const keyManager = new LocalKeyManager();
   * const keyUri = await keyManager.generateKey({ algorithm: 'Ed25519' });
   * const publicKey = await keyManager.getPublicKey({ keyUri });
   * const keyUriFromPublicKey = await keyManager.getKeyUri({ key: publicKey });
   * console.log(keyUri === keyUriFromPublicKey); // Outputs `true`
   * ```
   *
   * @param params - The parameters for getting the key URI.
   * @param params.key - The JWK for which to compute the key URI.
   *
   * @returns A Promise that resolves to the key URI as a string.
   */
  getKeyUri({ key }) {
    return __awaiter11(this, void 0, void 0, function* () {
      const jwkThumbprint = yield computeJwkThumbprint({ jwk: key });
      const keyUri = `${KEY_URI_PREFIX_JWK}${jwkThumbprint}`;
      return keyUri;
    });
  }
  /**
   * Retrieves the public key associated with a previously generated private key, identified by
   * the provided key URI.
   *
   * @example
   * ```ts
   * const keyManager = new LocalKeyManager();
   * const keyUri = await keyManager.generateKey({ algorithm: 'Ed25519' });
   * const publicKey = await keyManager.getPublicKey({ keyUri });
   * ```
   *
   * @param params - The parameters for retrieving the public key.
   * @param params.keyUri - The key URI of the private key to retrieve the public key for.
   *
   * @returns A Promise that resolves to the public key in JWK format.
   */
  getPublicKey({ keyUri }) {
    return __awaiter11(this, void 0, void 0, function* () {
      const privateKey = yield this.getPrivateKey({ keyUri });
      const algorithm = this.getAlgorithmName({ key: privateKey });
      const keyGenerator = this.getAlgorithm({ algorithm });
      const publicKey = yield keyGenerator.getPublicKey({ key: privateKey });
      return publicKey;
    });
  }
  /**
   * Imports a private key into the local KMS.
   *
   * @remarks
   * This method stores the provided JWK in the key store, making it available for subsequent
   * cryptographic operations. It is particularly useful for initializing the KMS with pre-existing
   * keys or for restoring keys from backups.
   *
   * Note that, if defined, the `kid` (key ID) property of the JWK is used as the key URI for the
   * imported key. If the `kid` property is not provided, the key URI is computed from the JWK
   * thumbprint of the key.
   *
   * @example
   * ```ts
   * const keyManager = new LocalKeyManager();
   * const privateKey = { ... } // A private key in JWK format
   * const keyUri = await keyManager.importKey({ key: privateKey });
   * ```
   *
   * @param params - Parameters for importing the key.
   * @param params.key - The private key to import to in JWK format.
   *
   * @returns A Promise resolving to the key URI, uniquely identifying the imported key.
   */
  importKey({ key }) {
    var _a;
    return __awaiter11(this, void 0, void 0, function* () {
      if (!isPrivateJwk(key))
        throw new TypeError("Invalid key provided. Must be a private key in JWK format.");
      const privateKey = structuredClone(key);
      (_a = privateKey.kid) !== null && _a !== void 0 ? _a : privateKey.kid = yield computeJwkThumbprint({ jwk: privateKey });
      const keyUri = yield this.getKeyUri({ key: privateKey });
      yield this._keyStore.set(keyUri, privateKey);
      return keyUri;
    });
  }
  /**
   * Signs the provided data using the private key identified by the provided key URI.
   *
   * @remarks
   * This method uses the signature algorithm determined by the `alg` and/or `crv` properties of the
   * private key identified by the provided key URI to sign the provided data. The signature can
   * later be verified by parties with access to the corresponding public key, ensuring that the
   * data has not been tampered with and was indeed signed by the holder of the private key.
   *
   * @example
   * ```ts
   * const keyManager = new LocalKeyManager();
   * const keyUri = await keyManager.generateKey({ algorithm: 'Ed25519' });
   * const data = new TextEncoder().encode('Message to sign');
   * const signature = await keyManager.sign({ keyUri, data });
   * ```
   *
   * @param params - The parameters for the signing operation.
   * @param params.keyUri - The key URI of the private key to use for signing.
   * @param params.data - The data to sign.
   *
   * @returns A Promise resolving to the digital signature as a `Uint8Array`.
   */
  sign({ keyUri, data }) {
    return __awaiter11(this, void 0, void 0, function* () {
      const privateKey = yield this.getPrivateKey({ keyUri });
      const algorithm = this.getAlgorithmName({ key: privateKey });
      const signer = this.getAlgorithm({ algorithm });
      const signature = signer.sign({ data, key: privateKey });
      return signature;
    });
  }
  /**
   * Verifies a digital signature associated the provided data using the provided key.
   *
   * @remarks
   * This method uses the signature algorithm determined by the `alg` and/or `crv` properties of the
   * provided key to check the validity of a digital signature against the original data. It
   * confirms whether the signature was created by the holder of the corresponding private key and
   * that the data has not been tampered with.
   *
   * @example
   * ```ts
   * const keyManager = new LocalKeyManager();
   * const keyUri = await keyManager.generateKey({ algorithm: 'Ed25519' });
   * const data = new TextEncoder().encode('Message to sign');
   * const signature = await keyManager.sign({ keyUri, data });
   * const isSignatureValid = await keyManager.verify({ keyUri, data, signature });
   * ```
   *
   * @param params - The parameters for the verification operation.
   * @param params.key - The key to use for verification.
   * @param params.signature - The signature to verify.
   * @param params.data - The data to verify.
   *
   * @returns A Promise resolving to a boolean indicating whether the signature is valid.
   */
  verify({ key, signature, data }) {
    return __awaiter11(this, void 0, void 0, function* () {
      const algorithm = this.getAlgorithmName({ key });
      const signer = this.getAlgorithm({ algorithm });
      const isSignatureValid = signer.verify({ key, signature, data });
      return isSignatureValid;
    });
  }
  /**
   * Retrieves an algorithm implementation instance based on the provided algorithm name.
   *
   * @remarks
   * This method checks if the requested algorithm is supported and returns a cached instance
   * if available. If an instance does not exist, it creates and caches a new one. This approach
   * optimizes performance by reusing algorithm instances across cryptographic operations.
   *
   * @example
   * ```ts
   * const signer = this.getAlgorithm({ algorithm: 'Ed25519' });
   * ```
   *
   * @param params - The parameters for retrieving the algorithm implementation.
   * @param params.algorithm - The name of the algorithm to retrieve.
   *
   * @returns An instance of the requested algorithm implementation.
   *
   * @throws Error if the requested algorithm is not supported.
   */
  getAlgorithm({ algorithm }) {
    var _a;
    const AlgorithmImplementation = (_a = supportedAlgorithms[algorithm]) === null || _a === void 0 ? void 0 : _a["implementation"];
    if (!AlgorithmImplementation) {
      throw new Error(`Algorithm not supported: ${algorithm}`);
    }
    if (!this._algorithmInstances.has(AlgorithmImplementation)) {
      this._algorithmInstances.set(AlgorithmImplementation, new AlgorithmImplementation());
    }
    return this._algorithmInstances.get(AlgorithmImplementation);
  }
  /**
   * Determines the name of the algorithm based on the key's properties.
   *
   * @remarks
   * This method facilitates the identification of the correct algorithm for cryptographic
   * operations based on the `alg` or `crv` properties of a {@link Jwk | JWK}.
   *
   * @example
   * ```ts
   * const publicKey = { ... }; // Public key in JWK format
   * const algorithm = this.getAlgorithmName({ key: publicKey });
   * ```
   *
   * @param params - The parameters for determining the algorithm name.
   * @param params.key - A JWK containing the `alg` or `crv` properties.
   *
   * @returns The name of the algorithm associated with the key.
   *
   * @throws Error if the algorithm cannot be determined from the provided input.
   */
  getAlgorithmName({ key }) {
    const algProperty = key.alg;
    const crvProperty = key.crv;
    for (const algName in supportedAlgorithms) {
      const algorithmInfo = supportedAlgorithms[algName];
      if (algProperty && algorithmInfo.names.includes(algProperty)) {
        return algName;
      } else if (crvProperty && algorithmInfo.names.includes(crvProperty)) {
        return algName;
      }
    }
    throw new Error(`Unable to determine algorithm based on provided input: alg=${algProperty}, crv=${crvProperty}`);
  }
  /**
   * Retrieves a private key from the key store based on the provided key URI.
   *
   * @example
   * ```ts
   * const privateKey = this.getPrivateKey({ keyUri: 'urn:jwk:...' });
   * ```
   *
   * @param params - Parameters for retrieving the private key.
   * @param params.keyUri - The key URI identifying the private key to retrieve.
   *
   * @returns A Promise resolving to the JWK representation of the private key.
   *
   * @throws Error if the key is not found in the key store.
   */
  getPrivateKey({ keyUri }) {
    return __awaiter11(this, void 0, void 0, function* () {
      const privateKey = yield this._keyStore.get(keyUri);
      if (!privateKey) {
        throw new Error(`Key not found: ${keyUri}`);
      }
      return privateKey;
    });
  }
};

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/utils.js
var utils_exports = {};
__export(utils_exports, {
  checkRequiredProperty: () => checkRequiredProperty,
  checkValidProperty: () => checkValidProperty,
  getJoseSignatureAlgorithmFromPublicKey: () => getJoseSignatureAlgorithmFromPublicKey,
  isWebCryptoSupported: () => isWebCryptoSupported,
  randomBytes: () => randomBytes2,
  randomUuid: () => randomUuid
});
var import_dist26 = __toESM(require_dist(), 1);
function checkRequiredProperty(params) {
  if (!params || params.property === void 0 || params.inObject === void 0) {
    throw new TypeError(`One or more required parameters missing: 'property, properties'`);
  }
  const { property, inObject } = params;
  if (!(property in inObject)) {
    throw new TypeError(`Required parameter missing: '${property}'`);
  }
}
function checkValidProperty(params) {
  if (!params || params.property === void 0 || params.allowedProperties === void 0) {
    throw new TypeError(`One or more required parameters missing: 'property, allowedProperties'`);
  }
  const { property, allowedProperties } = params;
  if (Array.isArray(allowedProperties) && !allowedProperties.includes(property) || allowedProperties instanceof Set && !allowedProperties.has(property) || allowedProperties instanceof Map && !allowedProperties.has(property)) {
    const validProperties = Array.from(allowedProperties instanceof Map ? allowedProperties.keys() : allowedProperties).join(", ");
    throw new TypeError(`Out of range: '${property}'. Must be one of '${validProperties}'`);
  }
}
function getJoseSignatureAlgorithmFromPublicKey(publicKey) {
  const curveToJoseAlgorithm = {
    "Ed25519": "EdDSA",
    "P-256": "ES256",
    "P-384": "ES384",
    "P-521": "ES512",
    "secp256k1": "ES256K"
  };
  if (publicKey.alg && Object.values(curveToJoseAlgorithm).includes(publicKey.alg)) {
    return publicKey.alg;
  }
  if (publicKey.crv && Object.keys(curveToJoseAlgorithm).includes(publicKey.crv)) {
    return curveToJoseAlgorithm[publicKey.crv];
  }
  throw new Error(`Unable to determine algorithm based on provided input: alg=${publicKey.alg}, crv=${publicKey.crv}. Supported 'alg' values: ${Object.values(curveToJoseAlgorithm).join(", ")}. Supported 'crv' values: ${Object.keys(curveToJoseAlgorithm).join(", ")}.`);
}
function isWebCryptoSupported() {
  if (globalThis.crypto && globalThis.crypto.subtle) {
    return true;
  } else {
    return false;
  }
}
function randomBytes2(bytesLength) {
  return randomBytes(bytesLength);
}
function randomUuid() {
  const uuid = crypto2.randomUUID();
  return uuid;
}

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/algorithms/aes-ctr.js
var import_dist28 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/primitives/aes-ctr.js
var import_dist27 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/algorithms/aes-gcm.js
var import_dist30 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/primitives/aes-gcm.js
var import_dist29 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/jose/jwe.js
var import_dist31 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/jose/jws.js
var import_dist32 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/jose/jwt.js
var import_dist33 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/primitives/concat-kdf.js
var import_dist34 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/primitives/pbkdf2.js
var import_dist35 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/primitives/x25519.js
var import_dist36 = __toESM(require_dist(), 1);
var __awaiter12 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest4 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var X25519 = class _X25519 {
  /**
   * Converts a raw private key in bytes to its corresponding JSON Web Key (JWK) format.
   *
   * @remarks
   * This method accepts a private key as a byte array (Uint8Array) for the X25519 elliptic curve
   * and transforms it into a JWK object. The process involves first deriving the public key from
   * the private key, then encoding both the private and public keys into base64url format.
   *
   * The resulting JWK object includes the following properties:
   * - `kty`: Key Type, set to 'OKP' for Octet Key Pair.
   * - `crv`: Curve Name, set to 'X25519'.
   * - `d`: The private key component, base64url-encoded.
   * - `x`: The derived public key, base64url-encoded.
   *
   * This method is useful for converting raw public keys into a standardized
   * JSON format, facilitating their use in cryptographic operations and making
   * them easy to share and store.
   *
   * @example
   * ```ts
   * const privateKeyBytes = new Uint8Array([...]); // Replace with actual private key bytes
   * const privateKey = await X25519.bytesToPrivateKey({ privateKeyBytes });
   * ```
   *
   * @param params - The parameters for the private key conversion.
   * @param params.privateKeyBytes - The raw private key as a Uint8Array.
   *
   * @returns A Promise that resolves to the private key in JWK format.
   */
  static bytesToPrivateKey({ privateKeyBytes }) {
    return __awaiter12(this, void 0, void 0, function* () {
      const publicKeyBytes = x25519.getPublicKey(privateKeyBytes);
      const privateKey = {
        kty: "OKP",
        crv: "X25519",
        d: Convert.uint8Array(privateKeyBytes).toBase64Url(),
        x: Convert.uint8Array(publicKeyBytes).toBase64Url()
      };
      privateKey.kid = yield computeJwkThumbprint({ jwk: privateKey });
      return privateKey;
    });
  }
  /**
   * Converts a raw public key in bytes to its corresponding JSON Web Key (JWK) format.
   *
   * @remarks
   * This method accepts a public key as a byte array (Uint8Array) for the X25519 elliptic curve
   * and transforms it into a JWK object. The conversion process involves encoding the public
   * key bytes into base64url format.
   *
   * The resulting JWK object includes the following properties:
   * - `kty`: Key Type, set to 'OKP' for Octet Key Pair.
   * - `crv`: Curve Name, set to 'X25519'.
   * - `x`: The public key, base64url-encoded.
   *
   * This method is useful for converting raw public keys into a standardized
   * JSON format, facilitating their use in cryptographic operations and making
   * them easy to share and store.
   *
   * @example
   * ```ts
   * const publicKeyBytes = new Uint8Array([...]); // Replace with actual public key bytes
   * const publicKey = await X25519.bytesToPublicKey({ publicKeyBytes });
   * ```
   *
   * @param params - The parameters for the public key conversion.
   * @param params.publicKeyBytes - The raw public key as a Uint8Array.
   *
   * @returns A Promise that resolves to the public key in JWK format.
   */
  static bytesToPublicKey({ publicKeyBytes }) {
    return __awaiter12(this, void 0, void 0, function* () {
      const publicKey = {
        kty: "OKP",
        crv: "X25519",
        x: Convert.uint8Array(publicKeyBytes).toBase64Url()
      };
      publicKey.kid = yield computeJwkThumbprint({ jwk: publicKey });
      return publicKey;
    });
  }
  /**
   * Derives the public key in JWK format from a given X25519 private key.
   *
   * @remarks
   * This method takes a private key in JWK format and derives its corresponding public key,
   * also in JWK format.  The derivation process involves converting the private key to a
   * raw byte array and then computing the corresponding public key on the Curve25519 curve.
   * The public key is then encoded into base64url format to construct a JWK representation.
   *
   * The process ensures that the derived public key correctly corresponds to the given private key,
   * adhering to the Curve25519 elliptic curve in Twisted Edwards form standards. This method is
   * useful in cryptographic operations where a public key is needed for operations like signature
   * verification, but only the private key is available.
   *
   * @example
   * ```ts
   * const privateKey = { ... }; // A Jwk object representing an X25519 private key
   * const publicKey = await X25519.computePublicKey({ key: privateKey });
   * ```
   *
   * @param params - The parameters for the public key derivation.
   * @param params.key - The private key in JWK format from which to derive the public key.
   *
   * @returns A Promise that resolves to the derived public key in JWK format.
   */
  static computePublicKey({ key }) {
    return __awaiter12(this, void 0, void 0, function* () {
      const privateKeyBytes = yield _X25519.privateKeyToBytes({ privateKey: key });
      const publicKeyBytes = x25519.getPublicKey(privateKeyBytes);
      const publicKey = {
        kty: "OKP",
        crv: "X25519",
        x: Convert.uint8Array(publicKeyBytes).toBase64Url()
      };
      publicKey.kid = yield computeJwkThumbprint({ jwk: publicKey });
      return publicKey;
    });
  }
  /**
   * Generates an X25519 private key in JSON Web Key (JWK) format.
   *
   * @remarks
   * This method creates a new private key suitable for use with the X25519 elliptic curve.
   * The key generation process involves using cryptographically secure random number generation
   * to ensure the uniqueness and security of the key. The resulting private key adheres to the
   * JWK format making it compatible with common cryptographic standards and easy to use in various
   * cryptographic processes.
   *
   * The generated private key in JWK format includes the following components:
   * - `kty`: Key Type, set to 'OKP' for Octet Key Pair.
   * - `crv`: Curve Name, set to 'X25519'.
   * - `d`: The private key component, base64url-encoded.
   * - `x`: The derived public key, base64url-encoded.
   *
   * The key is returned in a format suitable for direct use in key agreement operations.
   *
   * @example
   * ```ts
   * const privateKey = await X25519.generateKey();
   * ```
   *
   * @returns A Promise that resolves to the generated private key in JWK format.
   */
  static generateKey() {
    return __awaiter12(this, void 0, void 0, function* () {
      const privateKeyBytes = x25519.utils.randomPrivateKey();
      const privateKey = yield _X25519.bytesToPrivateKey({ privateKeyBytes });
      privateKey.kid = yield computeJwkThumbprint({ jwk: privateKey });
      return privateKey;
    });
  }
  /**
   * Retrieves the public key properties from a given private key in JWK format.
   *
   * @remarks
   * This method extracts the public key portion from an X25519 private key in JWK format. It does
   * so by removing the private key property 'd' and making a shallow copy, effectively yielding the
   * public key. The method sets the 'kid' (key ID) property using the JWK thumbprint if it is not
   * already defined. This approach is used under the assumption that a private key in JWK format
   * always contains the corresponding public key properties.
   *
   * Note: This method offers a significant performance advantage, being about 500 times faster
   * than `computePublicKey()`. However, it does not mathematically validate the private key, nor
   * does it derive the public key from the private key. It simply extracts existing public key
   * properties from the private key object. This makes it suitable for scenarios where speed is
   * critical and the private key's integrity is already assured.
   *
   * @example
   * ```ts
   * const privateKey = { ... }; // A Jwk object representing an X25519 private key
   * const publicKey = await X25519.getPublicKey({ key: privateKey });
   * ```
   *
   * @param params - The parameters for retrieving the public key properties.
   * @param params.key - The private key in JWK format.
   *
   * @returns A Promise that resolves to the public key in JWK format.
   */
  static getPublicKey({ key }) {
    var _a;
    return __awaiter12(this, void 0, void 0, function* () {
      if (!(isOkpPrivateJwk(key) && key.crv === "X25519")) {
        throw new Error(`X25519: The provided key is not an X25519 private JWK.`);
      }
      let { d } = key, publicKey = __rest4(key, ["d"]);
      (_a = publicKey.kid) !== null && _a !== void 0 ? _a : publicKey.kid = yield computeJwkThumbprint({ jwk: publicKey });
      return publicKey;
    });
  }
  /**
   * Converts a private key from JSON Web Key (JWK) format to a raw byte array (Uint8Array).
   *
   * @remarks
   * This method accepts a private key in JWK format and extracts its raw byte representation.
   *
   * This method accepts a public key in JWK format and converts it into its raw binary
   * form. The conversion process involves decoding the 'd' parameter of the JWK
   * from base64url format into a byte array.
   *
   * This conversion is essential for operations that require the private key in its raw
   * binary form, such as certain low-level cryptographic operations or when interfacing
   * with systems and libraries that expect keys in a byte array format.
   *
   * @example
   * ```ts
   * const privateKey = { ... }; // An X25519 private key in JWK format
   * const privateKeyBytes = await X25519.privateKeyToBytes({ privateKey });
   * ```
   *
   * @param params - The parameters for the private key conversion.
   * @param params.privateKey - The private key in JWK format.
   *
   * @returns A Promise that resolves to the private key as a Uint8Array.
   */
  static privateKeyToBytes({ privateKey }) {
    return __awaiter12(this, void 0, void 0, function* () {
      if (!isOkpPrivateJwk(privateKey)) {
        throw new Error(`X25519: The provided key is not a valid OKP private key.`);
      }
      const privateKeyBytes = Convert.base64Url(privateKey.d).toUint8Array();
      return privateKeyBytes;
    });
  }
  /**
   * Converts a public key from JSON Web Key (JWK) format to a raw byte array (Uint8Array).
   *
   * @remarks
   * This method accepts a public key in JWK format and converts it into its raw binary form.
   * The conversion process involves decoding the 'x' parameter of the JWK (which represent the
   * x coordinate of the elliptic curve point) from base64url format into a byte array.
   *
   * This conversion is essential for operations that require the public key in its raw
   * binary form, such as certain low-level cryptographic operations or when interfacing
   * with systems and libraries that expect keys in a byte array format.
   *
   * @example
   * ```ts
   * const publicKey = { ... }; // An X25519 public key in JWK format
   * const publicKeyBytes = await X25519.publicKeyToBytes({ publicKey });
   * ```
   *
   * @param params - The parameters for the public key conversion.
   * @param params.publicKey - The public key in JWK format.
   *
   * @returns A Promise that resolves to the public key as a Uint8Array.
   */
  static publicKeyToBytes({ publicKey }) {
    return __awaiter12(this, void 0, void 0, function* () {
      if (!isOkpPublicJwk(publicKey)) {
        throw new Error(`X25519: The provided key is not a valid OKP public key.`);
      }
      const publicKeyBytes = Convert.base64Url(publicKey.x).toUint8Array();
      return publicKeyBytes;
    });
  }
  /**
   * Computes an RFC6090-compliant Elliptic Curve Diffie-Hellman (ECDH) shared secret
   * using secp256k1 private and public keys in JSON Web Key (JWK) format.
   *
   * @remarks
   * This method facilitates the ECDH key agreement protocol, which is a method of securely
   * deriving a shared secret between two parties based on their private and public keys.
   * It takes the private key of one party (privateKeyA) and the public key of another
   * party (publicKeyB) to compute a shared secret. The shared secret is derived from the
   * x-coordinate of the elliptic curve point resulting from the multiplication of the
   * public key with the private key.
   *
   * Note: When performing Elliptic Curve Diffie-Hellman (ECDH) key agreement,
   * the resulting shared secret is a point on the elliptic curve, which
   * consists of an x-coordinate and a y-coordinate. With a 256-bit curve like
   * secp256k1, each of these coordinates is 32 bytes (256 bits) long. However,
   * in the ECDH process, it's standard practice to use only the x-coordinate
   * of the shared secret point as the resulting shared key. This is because
   * the y-coordinate does not add to the entropy of the key, and both parties
   * can independently compute the x-coordinate.  Consquently, this implementation
   * omits the y-coordinate for simplicity and standard compliance.
   *
   * @example
   * ```ts
   * const privateKeyA = { ... }; // A Jwk object for party A
   * const publicKeyB = { ... }; // A PublicKeyJwk object for party B
   * const sharedSecret = await Secp256k1.sharedSecret({
   *   privateKeyA,
   *   publicKeyB
   * });
   * ```
   *
   * @param params - The parameters for the shared secret computation.
   * @param params.privateKeyA - The private key in JWK format of one party.
   * @param params.publicKeyB - The public key in JWK format of the other party.
   *
   * @returns A Promise that resolves to the computed shared secret as a Uint8Array.
   */
  static sharedSecret({ privateKeyA, publicKeyB }) {
    return __awaiter12(this, void 0, void 0, function* () {
      if ("x" in privateKeyA && "x" in publicKeyB && privateKeyA.x === publicKeyB.x) {
        throw new Error(`X25519: ECDH shared secret cannot be computed from a single key pair's public and private keys.`);
      }
      const privateKeyABytes = yield _X25519.privateKeyToBytes({ privateKey: privateKeyA });
      const publicKeyBBytes = yield _X25519.publicKeyToBytes({ publicKey: publicKeyB });
      const sharedSecret = x25519.getSharedSecret(privateKeyABytes, publicKeyBBytes);
      return sharedSecret;
    });
  }
};

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/primitives/xchacha20.js
var import_dist37 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/node_modules/@web5/crypto/dist/esm/primitives/xchacha20-poly1305.js
var import_dist38 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/dist/esm/src/did-resolver.js
var import_dist56 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/node_modules/@web5/dids/dist/esm/index.js
var import_dist55 = __toESM(require_dist());

// node_modules/@tbdex/protocol/node_modules/@web5/dids/dist/esm/types/did-core.js
var import_dist40 = __toESM(require_dist(), 1);
var DidVerificationRelationship;
(function(DidVerificationRelationship3) {
  DidVerificationRelationship3["authentication"] = "authentication";
  DidVerificationRelationship3["assertionMethod"] = "assertionMethod";
  DidVerificationRelationship3["keyAgreement"] = "keyAgreement";
  DidVerificationRelationship3["capabilityDelegation"] = "capabilityDelegation";
  DidVerificationRelationship3["capabilityInvocation"] = "capabilityInvocation";
})(DidVerificationRelationship || (DidVerificationRelationship = {}));

// node_modules/@tbdex/protocol/node_modules/@web5/dids/dist/esm/types/did-resolution.js
var import_dist41 = __toESM(require_dist(), 1);
var EMPTY_DID_RESOLUTION_RESULT = {
  "@context": "https://w3id.org/did-resolution/v1",
  didResolutionMetadata: {},
  didDocument: null,
  didDocumentMetadata: {}
};

// node_modules/@tbdex/protocol/node_modules/@web5/dids/dist/esm/did.js
var import_dist42 = __toESM(require_dist(), 1);
var Did = class _Did {
  /**
   * Constructs a new `Did` instance from individual components.
   *
   * @param params - An object containing the parameters to be included in the DID URI.
   * @param params.method - The name of the DID method.
   * @param params.id - The DID method identifier.
   * @param params.path - Optional. The path component of the DID URI.
   * @param params.query - Optional. The query component of the DID URI.
   * @param params.fragment - Optional. The fragment component of the DID URI.
   * @param params.params - Optional. The query parameters in the DID URI.
   */
  constructor({ method, id, path, query, fragment, params }) {
    this.uri = `did:${method}:${id}`;
    this.method = method;
    this.id = id;
    this.path = path;
    this.query = query;
    this.fragment = fragment;
    this.params = params;
  }
  /**
   * Parses a DID URI string into its individual components.
   *
   * @example
   * ```ts
   * const did = Did.parse('did:example:123?service=agent&relativeRef=/credentials#degree');
   *
   * console.log(did.uri)      // Output: 'did:example:123'
   * console.log(did.method)   // Output: 'example'
   * console.log(did.id)       // Output: '123'
   * console.log(did.query)    // Output: 'service=agent&relativeRef=/credentials'
   * console.log(did.fragment) // Output: 'degree'
   * console.log(did.params)   // Output: { service: 'agent', relativeRef: '/credentials' }
   * ```
   *
   * @params didUri - The DID URI string to be parsed.
   * @returns A `Did` object representing the parsed DID URI, or `null` if the input string is not a valid DID URI.
   */
  static parse(didUri) {
    if (!didUri)
      return null;
    const match = _Did.DID_URI_PATTERN.exec(didUri);
    if (!match || !match.groups)
      return null;
    const { method, id, path, query, fragment } = match.groups;
    const did = {
      uri: `did:${method}:${id}`,
      method,
      id
    };
    if (path)
      did.path = path;
    if (query)
      did.query = query.slice(1);
    if (fragment)
      did.fragment = fragment.slice(1);
    if (query) {
      const parsedParams = {};
      const paramPairs = query.slice(1).split("&");
      for (const pair of paramPairs) {
        const [key, value] = pair.split("=");
        parsedParams[key] = value;
      }
      did.params = parsedParams;
    }
    return did;
  }
};
Did.METHOD_PATTERN = "([a-z0-9]+)";
Did.PCT_ENCODED_PATTERN = "(?:%[0-9a-fA-F]{2})";
Did.ID_CHAR_PATTERN = `(?:[a-zA-Z0-9._-]|${Did.PCT_ENCODED_PATTERN})`;
Did.METHOD_ID_PATTERN = `((?:${Did.ID_CHAR_PATTERN}*:)*(${Did.ID_CHAR_PATTERN}+))`;
Did.PATH_PATTERN = `(/[^#?]*)?`;
Did.QUERY_PATTERN = `([?][^#]*)?`;
Did.FRAGMENT_PATTERN = `(#.*)?`;
Did.DID_URI_PATTERN = new RegExp(`^did:(?<method>${Did.METHOD_PATTERN}):(?<id>${Did.METHOD_ID_PATTERN})(?<path>${Did.PATH_PATTERN})(?<query>${Did.QUERY_PATTERN})(?<fragment>${Did.FRAGMENT_PATTERN})$`);

// node_modules/@tbdex/protocol/node_modules/@web5/dids/dist/esm/did-error.js
var import_dist43 = __toESM(require_dist(), 1);
var DidError = class _DidError extends Error {
  /**
   * Constructs an instance of DidError, a custom error class for handling DID-related errors.
   *
   * @param code - A {@link DidErrorCode} representing the specific type of error encountered.
   * @param message - A human-readable description of the error.
   */
  constructor(code, message2) {
    super(message2);
    this.code = code;
    this.name = "DidError";
    Object.setPrototypeOf(this, new.target.prototype);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _DidError);
    }
  }
};
var DidErrorCode;
(function(DidErrorCode3) {
  DidErrorCode3["InvalidDid"] = "invalidDid";
  DidErrorCode3["MethodNotSupported"] = "methodNotSupported";
  DidErrorCode3["InternalError"] = "internalError";
  DidErrorCode3["InvalidDidDocument"] = "invalidDidDocument";
  DidErrorCode3["InvalidDidDocumentLength"] = "invalidDidDocumentLength";
  DidErrorCode3["InvalidDidUrl"] = "invalidDidUrl";
  DidErrorCode3["InvalidPublicKey"] = "invalidPublicKey";
  DidErrorCode3["InvalidPublicKeyLength"] = "invalidPublicKeyLength";
  DidErrorCode3["InvalidPublicKeyType"] = "invalidPublicKeyType";
  DidErrorCode3["InvalidSignature"] = "invalidSignature";
  DidErrorCode3["NotFound"] = "notFound";
  DidErrorCode3["RepresentationNotSupported"] = "representationNotSupported";
  DidErrorCode3["UnsupportedPublicKeyType"] = "unsupportedPublicKeyType";
})(DidErrorCode || (DidErrorCode = {}));

// node_modules/@tbdex/protocol/node_modules/@web5/dids/dist/esm/bearer-did.js
var import_dist45 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/node_modules/@web5/dids/dist/esm/utils.js
var utils_exports2 = {};
__export(utils_exports2, {
  extractDidFragment: () => extractDidFragment,
  getServices: () => getServices,
  getVerificationMethodByKey: () => getVerificationMethodByKey,
  getVerificationMethodTypes: () => getVerificationMethodTypes,
  getVerificationMethods: () => getVerificationMethods,
  getVerificationRelationshipsById: () => getVerificationRelationshipsById,
  isDidService: () => isDidService,
  isDidVerificationMethod: () => isDidVerificationMethod,
  isDwnDidService: () => isDwnDidService,
  keyBytesToMultibaseId: () => keyBytesToMultibaseId,
  multibaseIdToKeyBytes: () => multibaseIdToKeyBytes
});
var import_dist44 = __toESM(require_dist(), 1);
var __awaiter13 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function extractDidFragment(input) {
  if (typeof input !== "string")
    return void 0;
  if (input.length === 0)
    return void 0;
  return input.split("#").pop();
}
function getServices({ didDocument, id, type }) {
  var _a, _b;
  return (_b = (_a = didDocument === null || didDocument === void 0 ? void 0 : didDocument.service) === null || _a === void 0 ? void 0 : _a.filter((service) => {
    if (id && service.id !== id)
      return false;
    if (type && service.type !== type)
      return false;
    return true;
  })) !== null && _b !== void 0 ? _b : [];
}
function getVerificationMethodByKey({ didDocument, publicKeyJwk, publicKeyMultibase }) {
  return __awaiter13(this, void 0, void 0, function* () {
    const verificationMethods = getVerificationMethods({ didDocument });
    for (let method of verificationMethods) {
      if (publicKeyJwk && method.publicKeyJwk) {
        const publicKeyThumbprint = yield computeJwkThumbprint({ jwk: publicKeyJwk });
        if (publicKeyThumbprint === (yield computeJwkThumbprint({ jwk: method.publicKeyJwk }))) {
          return method;
        }
      } else if (publicKeyMultibase && method.publicKeyMultibase) {
        if (publicKeyMultibase === method.publicKeyMultibase) {
          return method;
        }
      }
    }
    return null;
  });
}
function getVerificationMethods({ didDocument }) {
  var _a, _b;
  if (!didDocument)
    throw new TypeError(`Required parameter missing: 'didDocument'`);
  const verificationMethods = [];
  verificationMethods.push(...(_b = (_a = didDocument.verificationMethod) === null || _a === void 0 ? void 0 : _a.filter(isDidVerificationMethod)) !== null && _b !== void 0 ? _b : []);
  Object.keys(DidVerificationRelationship).forEach((relationship) => {
    var _a2, _b2;
    verificationMethods.push(...(_b2 = (_a2 = didDocument[relationship]) === null || _a2 === void 0 ? void 0 : _a2.filter(isDidVerificationMethod)) !== null && _b2 !== void 0 ? _b2 : []);
  });
  return verificationMethods;
}
function getVerificationMethodTypes({ didDocument }) {
  const verificationMethods = getVerificationMethods({ didDocument });
  const types = verificationMethods.map((method) => method.type);
  return [...new Set(types)];
}
function getVerificationRelationshipsById({ didDocument, methodId }) {
  const relationships = [];
  Object.keys(DidVerificationRelationship).forEach((relationship) => {
    if (Array.isArray(didDocument[relationship])) {
      const relationshipMethods = didDocument[relationship];
      const methodIdFragment = extractDidFragment(methodId);
      const containsMethodId = relationshipMethods.some((method) => {
        const isByReferenceMatch = extractDidFragment(method) === methodIdFragment;
        const isEmbeddedMethodMatch = isDidVerificationMethod(method) && extractDidFragment(method.id) === methodIdFragment;
        return isByReferenceMatch || isEmbeddedMethodMatch;
      });
      if (containsMethodId) {
        relationships.push(relationship);
      }
    }
  });
  return relationships;
}
function isDidService(obj) {
  if (!obj || typeof obj !== "object" || obj === null)
    return false;
  return "id" in obj && "type" in obj && "serviceEndpoint" in obj;
}
function isDwnDidService(obj) {
  if (!isDidService(obj))
    return false;
  if (obj.type !== "DecentralizedWebNode")
    return false;
  if (!("enc" in obj && "sig" in obj))
    return false;
  const isStringOrStringArray = (prop) => typeof prop === "string" || Array.isArray(prop) && prop.every((item) => typeof item === "string");
  return isStringOrStringArray(obj.enc) && isStringOrStringArray(obj.sig);
}
function isDidVerificationMethod(obj) {
  if (!obj || typeof obj !== "object" || obj === null)
    return false;
  if (!("id" in obj && "type" in obj && "controller" in obj))
    return false;
  if (typeof obj.id !== "string")
    return false;
  if (typeof obj.type !== "string")
    return false;
  if (typeof obj.controller !== "string")
    return false;
  return true;
}
function keyBytesToMultibaseId({ keyBytes, multicodecCode, multicodecName }) {
  const prefixedKey = Multicodec.addPrefix({
    code: multicodecCode,
    data: keyBytes,
    name: multicodecName
  });
  const prefixedKeyB58 = Convert.uint8Array(prefixedKey).toBase58Btc();
  const multibaseKeyId = Convert.base58Btc(prefixedKeyB58).toMultibase();
  return multibaseKeyId;
}
function multibaseIdToKeyBytes({ multibaseKeyId }) {
  try {
    const prefixedKeyB58 = Convert.multibase(multibaseKeyId).toBase58Btc();
    const prefixedKey = Convert.base58Btc(prefixedKeyB58).toUint8Array();
    const { code, data, name } = Multicodec.removePrefix({ prefixedData: prefixedKey });
    return { keyBytes: data, multicodecCode: code, multicodecName: name };
  } catch (error) {
    throw new DidError(DidErrorCode.InvalidDid, `Invalid multibase identifier: ${multibaseKeyId}`);
  }
}

// node_modules/@tbdex/protocol/node_modules/@web5/dids/dist/esm/bearer-did.js
var __awaiter14 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var BearerDid = class _BearerDid {
  constructor({ uri, document, metadata, keyManager: keyManager2 }) {
    this.uri = uri;
    this.document = document;
    this.metadata = metadata;
    this.keyManager = keyManager2;
  }
  /**
   * Converts a `BearerDid` object to a portable format containing the URI and verification methods
   * associated with the DID.
   *
   * This method is useful when you need to represent the key material and metadata associated with
   * a DID in format that can be used independently of the specific DID method implementation. It
   * extracts both public and private keys from the DID's key manager and organizes them into a
   * `PortableDid` structure.
   *
   * @remarks
   * If the DID's key manager does not allow private keys to be exported, the `PortableDid` returned
   * will not contain a `privateKeys` property. This enables the importing and exporting DIDs that
   * use the same underlying KMS even if the KMS does not support exporting private keys. Examples
   * include hardware security modules (HSMs) and cloud-based KMS services like AWS KMS.
   *
   * If the DID's key manager does support exporting private keys, the resulting `PortableDid` will
   * include a `privateKeys` property which contains the same number of entries as there are
   * verification methods as the DID document, each with its associated private key and the
   * purpose(s) for which the key can be used (e.g., `authentication`, `assertionMethod`, etc.).
   *
   * @example
   * ```ts
   * // Assuming `did` is an instance of BearerDid
   * const portableDid = await did.export();
   * // portableDid now contains the DID URI, document, metadata, and optionally, private keys.
   * ```
   *
   * @returns A `PortableDid` containing the URI, DID document, metadata, and optionally private
   *          keys associated with the `BearerDid`.
   * @throws An error if the DID document does not contain any verification methods or the keys for
   *         any verification method are missing in the key manager.
   */
  export() {
    return __awaiter14(this, void 0, void 0, function* () {
      if (!(Array.isArray(this.document.verificationMethod) && this.document.verificationMethod.length > 0)) {
        throw new Error(`DID document for '${this.uri}' is missing verification methods`);
      }
      let portableDid = {
        uri: this.uri,
        document: this.document,
        metadata: this.metadata
      };
      if ("exportKey" in this.keyManager && typeof this.keyManager.exportKey === "function") {
        const privateKeys = [];
        for (let vm of this.document.verificationMethod) {
          if (!vm.publicKeyJwk) {
            throw new Error(`Verification method '${vm.id}' does not contain a public key in JWK format`);
          }
          const keyUri = yield this.keyManager.getKeyUri({ key: vm.publicKeyJwk });
          const privateKey = yield this.keyManager.exportKey({ keyUri });
          privateKeys.push(Object.assign({}, privateKey));
        }
        portableDid.privateKeys = privateKeys;
      }
      return portableDid;
    });
  }
  /**
   * Return a {@link Signer} that can be used to sign messages, credentials, or arbitrary data.
   *
   * If given, the `methodId` parameter is used to select a key from the verification methods
   * present in the DID Document.
   *
   * If `methodID` is not given, the first verification method intended for signing claims is used.
   *
   * @param params - The parameters for the `getSigner` operation.
   * @param params.methodId - ID of the verification method key that will be used for sign and
   *                          verify operations. Optional.
   * @returns An instantiated {@link Signer} that can be used to sign and verify data.
   */
  getSigner(params) {
    var _a;
    return __awaiter14(this, void 0, void 0, function* () {
      const verificationMethod = (_a = this.document.verificationMethod) === null || _a === void 0 ? void 0 : _a.find((vm) => {
        var _a2, _b;
        return extractDidFragment(vm.id) === ((_a2 = extractDidFragment(params === null || params === void 0 ? void 0 : params.methodId)) !== null && _a2 !== void 0 ? _a2 : extractDidFragment((_b = this.document.assertionMethod) === null || _b === void 0 ? void 0 : _b[0]));
      });
      if (!(verificationMethod && verificationMethod.publicKeyJwk)) {
        throw new DidError(DidErrorCode.InternalError, "A verification method intended for signing could not be determined from the DID Document");
      }
      const keyUri = yield this.keyManager.getKeyUri({ key: verificationMethod.publicKeyJwk });
      const publicKey = yield this.keyManager.getPublicKey({ keyUri });
      const keyManager2 = this.keyManager;
      const algorithm = utils_exports.getJoseSignatureAlgorithmFromPublicKey(publicKey);
      return {
        algorithm,
        keyId: verificationMethod.id,
        sign({ data }) {
          return __awaiter14(this, void 0, void 0, function* () {
            const signature = yield keyManager2.sign({ data, keyUri });
            return signature;
          });
        },
        verify({ data, signature }) {
          return __awaiter14(this, void 0, void 0, function* () {
            const isValid3 = yield keyManager2.verify({ data, key: publicKey, signature });
            return isValid3;
          });
        }
      };
    });
  }
  /**
   * Instantiates a {@link BearerDid} object from a given {@link PortableDid}.
   *
   * This method allows for the creation of a `BearerDid` object using a previously created DID's
   * key material, DID document, and metadata.
   *
   * @example
   * ```ts
   * // Export an existing BearerDid to PortableDid format.
   * const portableDid = await did.export();
   * // Reconstruct a BearerDid object from the PortableDid.
   * const did = await BearerDid.import({ portableDid });
   * ```
   *
   * @param params - The parameters for the import operation.
   * @param params.portableDid - The PortableDid object to import.
   * @param params.keyManager - Optionally specify an external Key Management System (KMS) used to
   *                            generate keys and sign data. If not given, a new
   *                            {@link LocalKeyManager} instance will be created and
   *                            used.
   * @returns A Promise resolving to a `BearerDid` object representing the DID formed from the
   *          provided PortableDid.
   * @throws An error if the PortableDid document does not contain any verification methods or the
   *         keys for any verification method are missing in the key manager.
   */
  static import({ portableDid, keyManager: keyManager2 = new LocalKeyManager() }) {
    var _a;
    return __awaiter14(this, void 0, void 0, function* () {
      const verificationMethods = getVerificationMethods({ didDocument: portableDid.document });
      if (verificationMethods.length === 0) {
        throw new DidError(DidErrorCode.InvalidDidDocument, `At least one verification method is required but 0 were given`);
      }
      for (let key of (_a = portableDid.privateKeys) !== null && _a !== void 0 ? _a : []) {
        yield keyManager2.importKey({ key });
      }
      for (let vm of verificationMethods) {
        if (!vm.publicKeyJwk) {
          throw new Error(`Verification method '${vm.id}' does not contain a public key in JWK format`);
        }
        const keyUri = yield keyManager2.getKeyUri({ key: vm.publicKeyJwk });
        yield keyManager2.getPublicKey({ keyUri });
      }
      const did = new _BearerDid({
        uri: portableDid.uri,
        document: portableDid.document,
        metadata: portableDid.metadata,
        keyManager: keyManager2
      });
      return did;
    });
  }
};

// node_modules/@tbdex/protocol/node_modules/@web5/dids/dist/esm/methods/did-dht.js
var import_dist47 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/node_modules/@web5/dids/dist/esm/methods/did-method.js
var import_dist46 = __toESM(require_dist(), 1);
var __awaiter15 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DidMethod = class {
  /**
   * MUST be implemented by all DID method implementations that extend {@link DidMethod}.
   *
   * Given the W3C DID Document of a DID, return the verification method that will be used for
   * signing messages and credentials. If given, the `methodId` parameter is used to select the
   * verification method. If not given, each DID method implementation will select a default
   * verification method from the DID Document.
   *
   * @param _params - The parameters for the `getSigningMethod` operation.
   * @param _params.didDocument - DID Document to get the verification method from.
   * @param _params.methodId - ID of the verification method to use for signing.
   * @returns Verification method to use for signing.
   */
  static getSigningMethod(_params) {
    return __awaiter15(this, void 0, void 0, function* () {
      throw new Error(`Not implemented: Classes extending DidMethod must implement getSigningMethod()`);
    });
  }
  /**
   * MUST be implemented by all DID method implementations that extend {@link DidMethod}.
   *
   * Resolves a DID URI to a DID Document.
   *
   * @param _didUri - The DID to be resolved.
   * @param _options - Optional parameters for resolving the DID.
   * @returns A Promise resolving to a {@link DidResolutionResult} object representing the result of the resolution.
   */
  static resolve(_didUri, _options) {
    return __awaiter15(this, void 0, void 0, function* () {
      throw new Error(`Not implemented: Classes extending DidMethod must implement resolve()`);
    });
  }
};

// node_modules/@tbdex/protocol/node_modules/@web5/dids/dist/esm/methods/did-dht.js
var __awaiter16 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest5 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var DEFAULT_GATEWAY_URI = "https://diddht.tbddev.org";
var DID_DHT_SPECIFICATION_VERSION = 0;
var DNS_RECORD_TTL = 7200;
var PROPERTY_SEPARATOR = ";";
var VALUE_SEPARATOR = ",";
var DidDhtRegisteredDidType;
(function(DidDhtRegisteredDidType3) {
  DidDhtRegisteredDidType3[DidDhtRegisteredDidType3["Discoverable"] = 0] = "Discoverable";
  DidDhtRegisteredDidType3[DidDhtRegisteredDidType3["Organization"] = 1] = "Organization";
  DidDhtRegisteredDidType3[DidDhtRegisteredDidType3["Government"] = 2] = "Government";
  DidDhtRegisteredDidType3[DidDhtRegisteredDidType3["Corporation"] = 3] = "Corporation";
  DidDhtRegisteredDidType3[DidDhtRegisteredDidType3["LocalBusiness"] = 4] = "LocalBusiness";
  DidDhtRegisteredDidType3[DidDhtRegisteredDidType3["SoftwarePackage"] = 5] = "SoftwarePackage";
  DidDhtRegisteredDidType3[DidDhtRegisteredDidType3["WebApp"] = 6] = "WebApp";
  DidDhtRegisteredDidType3[DidDhtRegisteredDidType3["FinancialInstitution"] = 7] = "FinancialInstitution";
})(DidDhtRegisteredDidType || (DidDhtRegisteredDidType = {}));
var DidDhtRegisteredKeyType;
(function(DidDhtRegisteredKeyType3) {
  DidDhtRegisteredKeyType3[DidDhtRegisteredKeyType3["Ed25519"] = 0] = "Ed25519";
  DidDhtRegisteredKeyType3[DidDhtRegisteredKeyType3["secp256k1"] = 1] = "secp256k1";
  DidDhtRegisteredKeyType3[DidDhtRegisteredKeyType3["secp256r1"] = 2] = "secp256r1";
})(DidDhtRegisteredKeyType || (DidDhtRegisteredKeyType = {}));
var DidDhtVerificationRelationship;
(function(DidDhtVerificationRelationship3) {
  DidDhtVerificationRelationship3["authentication"] = "auth";
  DidDhtVerificationRelationship3["assertionMethod"] = "asm";
  DidDhtVerificationRelationship3["capabilityDelegation"] = "del";
  DidDhtVerificationRelationship3["capabilityInvocation"] = "inv";
  DidDhtVerificationRelationship3["keyAgreement"] = "agm";
})(DidDhtVerificationRelationship || (DidDhtVerificationRelationship = {}));
var AlgorithmToKeyTypeMap = {
  Ed25519: DidDhtRegisteredKeyType.Ed25519,
  ES256K: DidDhtRegisteredKeyType.secp256k1,
  ES256: DidDhtRegisteredKeyType.secp256r1,
  "P-256": DidDhtRegisteredKeyType.secp256r1,
  secp256k1: DidDhtRegisteredKeyType.secp256k1,
  secp256r1: DidDhtRegisteredKeyType.secp256r1
};
var DidDht = class _DidDht extends DidMethod {
  /**
   * Creates a new DID using the `did:dht` method formed from a newly generated key.
   *
   * @remarks
   * The DID URI is formed by z-base-32 encoding the Identity Key public key and prefixing with
   * `did:dht:`.
   *
   * Notes:
   * - If no `options` are given, by default a new Ed25519 key will be generated which serves as the
   *   Identity Key.
   *
   * @example
   * ```ts
   * // DID Creation
   * const did = await DidDht.create();
   *
   * // DID Creation with a KMS
   * const keyManager = new LocalKeyManager();
   * const did = await DidDht.create({ keyManager });
   * ```
   *
   * @param params - The parameters for the create operation.
   * @param params.keyManager - Optionally specify a Key Management System (KMS) used to generate
   *                            keys and sign data.
   * @param params.options - Optional parameters that can be specified when creating a new DID.
   * @returns A Promise resolving to a {@link BearerDid} object representing the new DID.
   */
  static create({ keyManager: keyManager2 = new LocalKeyManager(), options = {} } = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    return __awaiter16(this, void 0, void 0, function* () {
      if ((_a = options.verificationMethods) === null || _a === void 0 ? void 0 : _a.some((vm) => !(vm.algorithm in AlgorithmToKeyTypeMap))) {
        throw new Error("One or more verification method algorithms are not supported");
      }
      const methodIds = (_b = options.verificationMethods) === null || _b === void 0 ? void 0 : _b.filter((vm) => "id" in vm).map((vm) => vm.id);
      if (methodIds && methodIds.length !== new Set(methodIds).size) {
        throw new Error("One or more verification method IDs are not unique");
      }
      if ((_c = options.services) === null || _c === void 0 ? void 0 : _c.some((s) => !s.id || !s.type || !s.serviceEndpoint)) {
        throw new Error("One or more services are missing required properties");
      }
      const identityKeyUri = yield keyManager2.generateKey({ algorithm: "Ed25519" });
      const identityKey = yield keyManager2.getPublicKey({ keyUri: identityKeyUri });
      const didUri = yield DidDhtUtils.identityKeyToIdentifier({ identityKey });
      const document = Object.assign(Object.assign({ id: didUri }, options.alsoKnownAs && { alsoKnownAs: options.alsoKnownAs }), options.controllers && { controller: options.controllers });
      const verificationMethodsToAdd = [...(_d = options.verificationMethods) !== null && _d !== void 0 ? _d : []];
      if (!(verificationMethodsToAdd === null || verificationMethodsToAdd === void 0 ? void 0 : verificationMethodsToAdd.some((vm) => {
        var _a2;
        return ((_a2 = vm.id) === null || _a2 === void 0 ? void 0 : _a2.split("#").pop()) === "0";
      }))) {
        verificationMethodsToAdd.unshift({
          algorithm: "Ed25519",
          id: "0",
          purposes: ["authentication", "assertionMethod", "capabilityDelegation", "capabilityInvocation"]
        });
      }
      for (const vm of verificationMethodsToAdd) {
        const keyUri = vm.id && vm.id.split("#").pop() === "0" ? identityKeyUri : yield keyManager2.generateKey({ algorithm: vm.algorithm });
        const publicKey = yield keyManager2.getPublicKey({ keyUri });
        let methodId = (_f = (_e = vm.id) !== null && _e !== void 0 ? _e : publicKey.kid) !== null && _f !== void 0 ? _f : yield computeJwkThumbprint({ jwk: publicKey });
        methodId = `${didUri}#${extractDidFragment(methodId)}`;
        (_g = document.verificationMethod) !== null && _g !== void 0 ? _g : document.verificationMethod = [];
        document.verificationMethod.push({
          id: methodId,
          type: "JsonWebKey",
          controller: (_h = vm.controller) !== null && _h !== void 0 ? _h : didUri,
          publicKeyJwk: publicKey
        });
        for (const purpose of (_j = vm.purposes) !== null && _j !== void 0 ? _j : []) {
          if (!document[purpose])
            document[purpose] = [];
          document[purpose].push(methodId);
        }
      }
      (_k = options.services) === null || _k === void 0 ? void 0 : _k.forEach((service) => {
        var _a2;
        (_a2 = document.service) !== null && _a2 !== void 0 ? _a2 : document.service = [];
        service.id = `${didUri}#${service.id.split("#").pop()}`;
        document.service.push(service);
      });
      const did = new BearerDid({
        uri: didUri,
        document,
        metadata: Object.assign({ published: false }, options.types && { types: options.types }),
        keyManager: keyManager2
      });
      if ((_l = options.publish) !== null && _l !== void 0 ? _l : true) {
        const registrationResult = yield _DidDht.publish({ did, gatewayUri: options.gatewayUri });
        did.metadata = registrationResult.didDocumentMetadata;
      }
      return did;
    });
  }
  /**
   * Instantiates a {@link BearerDid} object for the DID DHT method from a given {@link PortableDid}.
   *
   * This method allows for the creation of a `BearerDid` object using a previously created DID's
   * key material, DID document, and metadata.
   *
   * @example
   * ```ts
   * // Export an existing BearerDid to PortableDid format.
   * const portableDid = await did.export();
   * // Reconstruct a BearerDid object from the PortableDid.
   * const did = await DidDht.import({ portableDid });
   * ```
   *
   * @param params - The parameters for the import operation.
   * @param params.portableDid - The PortableDid object to import.
   * @param params.keyManager - Optionally specify an external Key Management System (KMS) used to
   *                            generate keys and sign data. If not given, a new
   *                            {@link LocalKeyManager} instance will be created and
   *                            used.
   * @returns A Promise resolving to a `BearerDid` object representing the DID formed from the
   *          provided PortableDid.
   * @throws An error if the PortableDid document does not contain any verification methods, lacks
   *         an Identity Key, or the keys for any verification method are missing in the key
   *         manager.
   */
  static import({ portableDid, keyManager: keyManager2 = new LocalKeyManager() }) {
    var _a;
    return __awaiter16(this, void 0, void 0, function* () {
      const parsedDid = Did.parse(portableDid.uri);
      if ((parsedDid === null || parsedDid === void 0 ? void 0 : parsedDid.method) !== _DidDht.methodName) {
        throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported`);
      }
      const did = yield BearerDid.import({ portableDid, keyManager: keyManager2 });
      if (!((_a = did.document.verificationMethod) === null || _a === void 0 ? void 0 : _a.some((vm) => {
        var _a2;
        return ((_a2 = vm.id) === null || _a2 === void 0 ? void 0 : _a2.split("#").pop()) === "0";
      }))) {
        throw new DidError(DidErrorCode.InvalidDidDocument, `DID document must contain an Identity Key`);
      }
      return did;
    });
  }
  /**
   * Given the W3C DID Document of a `did:dht` DID, return the verification method that will be used
   * for signing messages and credentials. If given, the `methodId` parameter is used to select the
   * verification method. If not given, the Identity Key's verification method with an ID fragment
   * of '#0' is used.
   *
   * @param params - The parameters for the `getSigningMethod` operation.
   * @param params.didDocument - DID Document to get the verification method from.
   * @param params.methodId - ID of the verification method to use for signing.
   * @returns Verification method to use for signing.
   */
  static getSigningMethod({ didDocument, methodId = "#0" }) {
    var _a;
    return __awaiter16(this, void 0, void 0, function* () {
      const parsedDid = Did.parse(didDocument.id);
      if (parsedDid && parsedDid.method !== this.methodName) {
        throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported: ${parsedDid.method}`);
      }
      const verificationMethod = (_a = didDocument.verificationMethod) === null || _a === void 0 ? void 0 : _a.find((vm) => {
        var _a2, _b;
        return extractDidFragment(vm.id) === ((_a2 = extractDidFragment(methodId)) !== null && _a2 !== void 0 ? _a2 : extractDidFragment((_b = didDocument.assertionMethod) === null || _b === void 0 ? void 0 : _b[0]));
      });
      if (!(verificationMethod && verificationMethod.publicKeyJwk)) {
        throw new DidError(DidErrorCode.InternalError, "A verification method intended for signing could not be determined from the DID Document");
      }
      return verificationMethod;
    });
  }
  /**
   * Publishes a DID to the DHT, making it publicly discoverable and resolvable.
   *
   * This method handles the publication of a DID Document associated with a `did:dht` DID to the
   * Mainline DHT network. The publication process involves storing the DID Document in Mainline DHT
   * via a Pkarr relay server.
   *
   * @remarks
   * - This method is typically invoked automatically during the creation of a new DID unless the
   *   `publish` option is set to `false`.
   * - For existing, unpublished DIDs, it can be used to publish the DID Document to Mainline DHT.
   * - The method relies on the specified Pkarr relay server to interface with the DHT network.
   *
   * @example
   * ```ts
   * // Generate a new DID and keys but explicitly disable publishing.
   * const did = await DidDht.create({ options: { publish: false } });
   * // Publish the DID to the DHT.
   * const registrationResult = await DidDht.publish({ did });
   * // `registrationResult.didDocumentMetadata.published` is true if the DID was successfully published.
   * ```
   *
   * @param params - The parameters for the `publish` operation.
   * @param params.did - The `BearerDid` object representing the DID to be published.
   * @param params.gatewayUri - Optional. The URI of a server involved in executing DID method
   *                            operations. In the context of publishing, the endpoint is expected
   *                            to be a DID DHT Gateway or Pkarr Relay. If not specified, a default
   *                            gateway node is used.
   * @returns A promise that resolves to a {@link DidRegistrationResult} object that contains
   *          the result of registering the DID with a DID DHT Gateway or Pkarr relay.
   */
  static publish({ did, gatewayUri = DEFAULT_GATEWAY_URI }) {
    return __awaiter16(this, void 0, void 0, function* () {
      const registrationResult = yield DidDhtDocument.put({ did, gatewayUri });
      return registrationResult;
    });
  }
  /**
   * Resolves a `did:dht` identifier to its corresponding DID document.
   *
   * This method performs the resolution of a `did:dht` DID, retrieving its DID Document from the
   * Mainline DHT network. The process involves querying the DHT network via a Pkarr relay server to
   * retrieve the DID Document that corresponds to the given DID identifier.
   *
   * @remarks
   * - If a `gatewayUri` option is not specified, a default Pkarr relay is used to access the DHT
   *   network.
   * - It decodes the DID identifier and retrieves the associated DID Document and metadata.
   * - In case of resolution failure, appropriate error information is returned.
   *
   * @example
   * ```ts
   * const resolutionResult = await DidDht.resolve('did:dht:example');
   * ```
   *
   * @param didUri - The DID to be resolved.
   * @param options - Optional parameters for resolving the DID. Unused by this DID method.
   * @returns A Promise resolving to a {@link DidResolutionResult} object representing the result of
   *          the resolution.
   */
  static resolve(didUri, options = {}) {
    var _a;
    return __awaiter16(this, void 0, void 0, function* () {
      const gatewayUri = (_a = options === null || options === void 0 ? void 0 : options.gatewayUri) !== null && _a !== void 0 ? _a : DEFAULT_GATEWAY_URI;
      try {
        yield DidDhtUtils.identifierToIdentityKey({ didUri });
        const { didDocument, didDocumentMetadata } = yield DidDhtDocument.get({ didUri, gatewayUri });
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), {
          didDocument,
          didDocumentMetadata
        });
      } catch (error) {
        if (!(error instanceof DidError))
          throw new Error(error);
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didResolutionMetadata: Object.assign({ error: error.code }, error.message && { errorMessage: error.message }) });
      }
    });
  }
};
DidDht.methodName = "dht";
var DidDhtDocument = class _DidDhtDocument {
  /**
   * Retrieves a DID document and its metadata from the DHT network.
   *
   * @param params - The parameters for the get operation.
   * @param params.didUri - The DID URI containing the Identity Key.
   * @param params.gatewayUri - The DID DHT Gateway or Pkarr Relay URI.
   * @returns A Promise resolving to a {@link DidResolutionResult} object containing the DID
   *          document and its metadata.
   */
  static get({ didUri, gatewayUri }) {
    return __awaiter16(this, void 0, void 0, function* () {
      const publicKeyBytes = DidDhtUtils.identifierToIdentityKeyBytes({ didUri });
      const bep44Message = yield _DidDhtDocument.pkarrGet({ gatewayUri, publicKeyBytes });
      const dnsPacket = yield DidDhtUtils.parseBep44GetMessage({ bep44Message });
      const resolutionResult = yield _DidDhtDocument.fromDnsPacket({ didUri, dnsPacket });
      resolutionResult.didDocumentMetadata.versionId = bep44Message.seq.toString();
      return resolutionResult;
    });
  }
  /**
   * Publishes a DID document to the DHT network.
   *
   * @param params - The parameters to use when publishing the DID document to the DHT network.
   * @param params.did - The DID object whose DID document will be published.
   * @param params.gatewayUri - The DID DHT Gateway or Pkarr Relay URI.
   * @returns A promise that resolves to a {@link DidRegistrationResult} object that contains
   *          the result of registering the DID with a DID DHT Gateway or Pkarr relay.
   */
  static put({ did, gatewayUri }) {
    return __awaiter16(this, void 0, void 0, function* () {
      const dnsPacket = yield _DidDhtDocument.toDnsPacket({
        didDocument: did.document,
        didMetadata: did.metadata
      });
      const bep44Message = yield DidDhtUtils.createBep44PutMessage({
        dnsPacket,
        publicKeyBytes: DidDhtUtils.identifierToIdentityKeyBytes({ didUri: did.uri }),
        signer: yield did.getSigner({ methodId: "0" })
      });
      const putResult = yield _DidDhtDocument.pkarrPut({ gatewayUri, bep44Message });
      return {
        didDocument: did.document,
        didDocumentMetadata: Object.assign(Object.assign({}, did.metadata), { published: putResult, versionId: bep44Message.seq.toString() }),
        didRegistrationMetadata: {}
      };
    });
  }
  /**
   * Retrieves a signed BEP44 message from a DID DHT Gateway or Pkarr Relay server.
   *
   * @see {@link https://github.com/Nuhvi/pkarr/blob/main/design/relays.md | Pkarr Relay design}
   *
   * @param params
   * @param params.gatewayUri - The DID DHT Gateway or Pkarr Relay URI.
   * @param params.publicKeyBytes - The public key bytes of the Identity Key, z-base-32 encoded.
   * @returns A promise resolving to a BEP44 message containing the signed DNS packet.
  */
  static pkarrGet({ gatewayUri, publicKeyBytes }) {
    return __awaiter16(this, void 0, void 0, function* () {
      const identifier = Convert.uint8Array(publicKeyBytes).toBase32Z();
      const url = new URL(identifier, gatewayUri).href;
      let response;
      try {
        response = yield fetch(url, { method: "GET" });
        if (!response.ok) {
          throw new DidError(DidErrorCode.NotFound, `Pkarr record not found for: ${identifier}`);
        }
      } catch (error) {
        if (error instanceof DidError)
          throw error;
        throw new DidError(DidErrorCode.InternalError, `Failed to fetch Pkarr record: ${error.message}`);
      }
      const messageBytes = yield response.arrayBuffer();
      if (!messageBytes) {
        throw new DidError(DidErrorCode.NotFound, `Pkarr record not found for: ${identifier}`);
      }
      if (messageBytes.byteLength < 72) {
        throw new DidError(DidErrorCode.InvalidDidDocumentLength, `Pkarr response must be at least 72 bytes but got: ${messageBytes.byteLength}`);
      }
      if (messageBytes.byteLength > 1072) {
        throw new DidError(DidErrorCode.InvalidDidDocumentLength, `Pkarr response exceeds 1000 byte limit: ${messageBytes.byteLength}`);
      }
      const bep44Message = {
        k: publicKeyBytes,
        seq: Number(new DataView(messageBytes).getBigUint64(64)),
        sig: new Uint8Array(messageBytes, 0, 64),
        v: new Uint8Array(messageBytes, 72)
      };
      return bep44Message;
    });
  }
  /**
   * Publishes a signed BEP44 message to a DID DHT Gateway or Pkarr Relay server.
   *
   * @see {@link https://github.com/Nuhvi/pkarr/blob/main/design/relays.md | Pkarr Relay design}
   *
   * @param params - The parameters to use when publishing a signed BEP44 message to a Pkarr relay server.
   * @param params.gatewayUri - The DID DHT Gateway or Pkarr Relay URI.
   * @param params.bep44Message - The BEP44 message to be published, containing the signed DNS packet.
   * @returns A promise resolving to `true` if the message was successfully published, otherwise `false`.
   */
  static pkarrPut({ gatewayUri, bep44Message }) {
    return __awaiter16(this, void 0, void 0, function* () {
      const identifier = Convert.uint8Array(bep44Message.k).toBase32Z();
      const url = new URL(identifier, gatewayUri).href;
      const body = new Uint8Array(bep44Message.v.length + 72);
      body.set(bep44Message.sig, 0);
      new DataView(body.buffer).setBigUint64(bep44Message.sig.length, BigInt(bep44Message.seq));
      body.set(bep44Message.v, bep44Message.sig.length + 8);
      let response;
      try {
        response = yield fetch(url, {
          method: "PUT",
          headers: { "Content-Type": "application/octet-stream" },
          body
        });
      } catch (error) {
        throw new DidError(DidErrorCode.InternalError, `Failed to put Pkarr record: ${error.message}`);
      }
      return response.ok;
    });
  }
  /**
   * Converts a DNS packet to a DID document according to the DID DHT specification.
   *
   * @see {@link https://did-dht.com/#dids-as-dns-records | DID DHT Specification, § DIDs as DNS Records}
   *
   * @param params - The parameters to use when converting a DNS packet to a DID document.
   * @param params.didUri - The DID URI of the DID document.
   * @param params.dnsPacket - The DNS packet to convert to a DID document.
   * @returns A Promise resolving to a {@link DidResolutionResult} object containing the DID
   *          document and its metadata.
   */
  static fromDnsPacket({ didUri, dnsPacket }) {
    var _a, _b, _c;
    return __awaiter16(this, void 0, void 0, function* () {
      const didDocument = { id: didUri };
      const didDocumentMetadata = {
        published: true
      };
      const idLookup = /* @__PURE__ */ new Map();
      for (const answer of (_a = dnsPacket === null || dnsPacket === void 0 ? void 0 : dnsPacket.answers) !== null && _a !== void 0 ? _a : []) {
        if (answer.type !== "TXT")
          continue;
        const dnsRecordId = answer.name.split(".")[0].substring(1);
        switch (true) {
          case dnsRecordId.startsWith("aka"): {
            const data = DidDhtUtils.parseTxtDataToString(answer.data);
            didDocument.alsoKnownAs = data.split(VALUE_SEPARATOR);
            break;
          }
          case dnsRecordId.startsWith("cnt"): {
            const data = DidDhtUtils.parseTxtDataToString(answer.data);
            didDocument.controller = data.includes(VALUE_SEPARATOR) ? data.split(VALUE_SEPARATOR) : data;
            break;
          }
          case dnsRecordId.startsWith("k"): {
            const { id, t, k, c } = DidDhtUtils.parseTxtDataToObject(answer.data);
            const publicKeyBytes = Convert.base64Url(k).toUint8Array();
            const namedCurve = DidDhtRegisteredKeyType[Number(t)];
            let publicKey = yield DidDhtUtils.keyConverter(namedCurve).bytesToPublicKey({ publicKeyBytes });
            (_b = didDocument.verificationMethod) !== null && _b !== void 0 ? _b : didDocument.verificationMethod = [];
            const methodId = `${didUri}#${id}`;
            didDocument.verificationMethod.push({
              id: methodId,
              type: "JsonWebKey",
              controller: c !== null && c !== void 0 ? c : didUri,
              publicKeyJwk: publicKey
            });
            idLookup.set(dnsRecordId, methodId);
            break;
          }
          case dnsRecordId.startsWith("s"): {
            const _d = DidDhtUtils.parseTxtDataToObject(answer.data), { id, t, se } = _d, customProperties = __rest5(_d, ["id", "t", "se"]);
            const serviceEndpoint = se.includes(VALUE_SEPARATOR) ? se.split(VALUE_SEPARATOR) : se;
            const serviceProperties = Object.fromEntries(Object.entries(customProperties).map(([k, v]) => [k, v.includes(VALUE_SEPARATOR) ? v.split(VALUE_SEPARATOR) : v]));
            (_c = didDocument.service) !== null && _c !== void 0 ? _c : didDocument.service = [];
            didDocument.service.push(Object.assign(Object.assign({}, serviceProperties), { id: `${didUri}#${id}`, type: t, serviceEndpoint }));
            break;
          }
          case dnsRecordId.startsWith("typ"): {
            const { id: types } = DidDhtUtils.parseTxtDataToObject(answer.data);
            didDocumentMetadata.types = types.split(VALUE_SEPARATOR).map((typeInteger) => Number(typeInteger));
            break;
          }
          case dnsRecordId.startsWith("did"): {
            const recordIdsToMethodIds = (data) => data.split(VALUE_SEPARATOR).map((dnsRecordId2) => idLookup.get(dnsRecordId2)).filter((id) => typeof id === "string");
            const { auth, asm, del, inv, agm } = DidDhtUtils.parseTxtDataToObject(answer.data);
            if (auth)
              didDocument.authentication = recordIdsToMethodIds(auth);
            if (asm)
              didDocument.assertionMethod = recordIdsToMethodIds(asm);
            if (del)
              didDocument.capabilityDelegation = recordIdsToMethodIds(del);
            if (inv)
              didDocument.capabilityInvocation = recordIdsToMethodIds(inv);
            if (agm)
              didDocument.keyAgreement = recordIdsToMethodIds(agm);
            break;
          }
        }
      }
      return { didDocument, didDocumentMetadata, didResolutionMetadata: {} };
    });
  }
  /**
   * Converts a DID document to a DNS packet according to the DID DHT specification.
   *
   * @see {@link https://did-dht.com/#dids-as-dns-records | DID DHT Specification, § DIDs as DNS Records}
   *
   * @param params - The parameters to use when converting a DID document to a DNS packet.
   * @param params.didDocument - The DID document to convert to a DNS packet.
   * @param params.didMetadata - The DID metadata to include in the DNS packet.
   * @returns A promise that resolves to a DNS packet.
   */
  static toDnsPacket({ didDocument, didMetadata }) {
    var _a, _b, _c, _d, _e;
    return __awaiter16(this, void 0, void 0, function* () {
      const dnsAnswerRecords = [];
      const idLookup = /* @__PURE__ */ new Map();
      const serviceIds = [];
      const verificationMethodIds = [];
      if (didDocument.alsoKnownAs) {
        dnsAnswerRecords.push({
          type: "TXT",
          name: "_aka.did.",
          ttl: DNS_RECORD_TTL,
          data: didDocument.alsoKnownAs.join(VALUE_SEPARATOR)
        });
      }
      if (didDocument.controller) {
        const controller = Array.isArray(didDocument.controller) ? didDocument.controller.join(VALUE_SEPARATOR) : didDocument.controller;
        dnsAnswerRecords.push({
          type: "TXT",
          name: "_cnt.did.",
          ttl: DNS_RECORD_TTL,
          data: controller
        });
      }
      for (const [index, vm] of (_b = (_a = didDocument.verificationMethod) === null || _a === void 0 ? void 0 : _a.entries()) !== null && _b !== void 0 ? _b : []) {
        const dnsRecordId = `k${index}`;
        verificationMethodIds.push(dnsRecordId);
        let methodId = vm.id.split("#").pop();
        idLookup.set(methodId, dnsRecordId);
        const publicKey = vm.publicKeyJwk;
        if (!((publicKey === null || publicKey === void 0 ? void 0 : publicKey.crv) && publicKey.crv in AlgorithmToKeyTypeMap)) {
          throw new DidError(DidErrorCode.InvalidPublicKeyType, `Verification method '${vm.id}' contains an unsupported key type: ${(_c = publicKey === null || publicKey === void 0 ? void 0 : publicKey.crv) !== null && _c !== void 0 ? _c : "undefined"}`);
        }
        const keyType = DidDhtRegisteredKeyType[publicKey.crv];
        const publicKeyBytes = yield DidDhtUtils.keyConverter(publicKey.crv).publicKeyToBytes({ publicKey });
        const publicKeyBase64Url = Convert.uint8Array(publicKeyBytes).toBase64Url();
        const txtData = [`id=${methodId}`, `t=${keyType}`, `k=${publicKeyBase64Url}`];
        if (vm.controller !== didDocument.id)
          txtData.push(`c=${vm.controller}`);
        dnsAnswerRecords.push({
          type: "TXT",
          name: `_${dnsRecordId}._did.`,
          ttl: DNS_RECORD_TTL,
          data: txtData.join(PROPERTY_SEPARATOR)
        });
      }
      (_d = didDocument.service) === null || _d === void 0 ? void 0 : _d.forEach((service, index) => {
        const dnsRecordId = `s${index}`;
        serviceIds.push(dnsRecordId);
        let { id, type: t, serviceEndpoint: se } = service, customProperties = __rest5(service, ["id", "type", "serviceEndpoint"]);
        id = extractDidFragment(id);
        se = Array.isArray(se) ? se.join(",") : se;
        const txtData = Object.entries(Object.assign({ id, t, se }, customProperties)).map(([key, value]) => `${key}=${value}`);
        dnsAnswerRecords.push({
          type: "TXT",
          name: `_${dnsRecordId}._did.`,
          ttl: DNS_RECORD_TTL,
          data: txtData.join(PROPERTY_SEPARATOR)
        });
      });
      const rootRecord = [`v=${DID_DHT_SPECIFICATION_VERSION}`];
      if (verificationMethodIds.length) {
        rootRecord.push(`vm=${verificationMethodIds.join(VALUE_SEPARATOR)}`);
      }
      Object.keys(DidVerificationRelationship).forEach((relationship) => {
        var _a2;
        const dnsRecordIds = (_a2 = didDocument[relationship]) === null || _a2 === void 0 ? void 0 : _a2.map((id) => idLookup.get(id.split("#").pop()));
        if (dnsRecordIds) {
          const recordName = DidDhtVerificationRelationship[relationship];
          rootRecord.push(`${recordName}=${dnsRecordIds.join(VALUE_SEPARATOR)}`);
        }
      });
      if (serviceIds.length) {
        rootRecord.push(`svc=${serviceIds.join(VALUE_SEPARATOR)}`);
      }
      if ((_e = didMetadata.types) === null || _e === void 0 ? void 0 : _e.length) {
        const types = didMetadata.types;
        const typeIntegers = types.map((type) => typeof type === "string" ? DidDhtRegisteredDidType[type] : type);
        dnsAnswerRecords.push({
          type: "TXT",
          name: "_typ._did.",
          ttl: DNS_RECORD_TTL,
          data: `id=${typeIntegers.join(VALUE_SEPARATOR)}`
        });
      }
      dnsAnswerRecords.push({
        type: "TXT",
        name: "_did.",
        ttl: DNS_RECORD_TTL,
        data: rootRecord.join(PROPERTY_SEPARATOR)
      });
      const [, , identifier] = didDocument.id.split(":");
      dnsAnswerRecords.forEach((record) => record.name += identifier);
      const dnsPacket = {
        id: 0,
        type: "response",
        flags: AUTHORITATIVE_ANSWER,
        answers: dnsAnswerRecords
      };
      return dnsPacket;
    });
  }
};
var DidDhtUtils = class _DidDhtUtils {
  /**
   * Creates a BEP44 put message, which is used to publish a DID document to the DHT network.
   *
   * @param params - The parameters to use when creating the BEP44 put message
   * @param params.dnsPacket - The DNS packet to encode in the BEP44 message.
   * @param params.publicKeyBytes - The public key bytes of the Identity Key.
   * @param params.signer - Signer that can sign and verify data using the Identity Key.
   * @returns A promise that resolves to a BEP44 put message.
   */
  static createBep44PutMessage({ dnsPacket, publicKeyBytes, signer }) {
    return __awaiter16(this, void 0, void 0, function* () {
      const sequenceNumber = Math.ceil(Date.now() / 1e3);
      const encodedDnsPacket = encode(dnsPacket);
      const bencodedData = bencode_default.encode({ seq: sequenceNumber, v: encodedDnsPacket }).subarray(1, -1);
      if (bencodedData.length > 1e3) {
        throw new DidError(DidErrorCode.InvalidDidDocumentLength, `DNS packet exceeds the 1000 byte maximum size: ${bencodedData.length} bytes`);
      }
      const signature = yield signer.sign({ data: bencodedData });
      return { k: publicKeyBytes, seq: sequenceNumber, sig: signature, v: encodedDnsPacket };
    });
  }
  /**
   * Converts a DID URI to a JSON Web Key (JWK) representing the Identity Key.
   *
   * @param params - The parameters to use for the conversion.
   * @param params.didUri - The DID URI containing the Identity Key.
   * @returns A promise that resolves to a JWK representing the Identity Key.
   */
  static identifierToIdentityKey({ didUri }) {
    return __awaiter16(this, void 0, void 0, function* () {
      let identityKeyBytes = _DidDhtUtils.identifierToIdentityKeyBytes({ didUri });
      const identityKey = yield Ed25519.bytesToPublicKey({ publicKeyBytes: identityKeyBytes });
      return identityKey;
    });
  }
  /**
   * Converts a DID URI to the byte array representation of the Identity Key.
   *
   * @param params - The parameters to use for the conversion.
   * @param params.didUri - The DID URI containing the Identity Key.
   * @returns A byte array representation of the Identity Key.
   */
  static identifierToIdentityKeyBytes({ didUri }) {
    const parsedDid = Did.parse(didUri);
    if (!parsedDid) {
      throw new DidError(DidErrorCode.InvalidDid, `Invalid DID URI: ${didUri}`);
    }
    if (parsedDid.method !== DidDht.methodName) {
      throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported: ${parsedDid.method}`);
    }
    let identityKeyBytes;
    try {
      identityKeyBytes = Convert.base32Z(parsedDid.id).toUint8Array();
    } catch (_a) {
      throw new DidError(DidErrorCode.InvalidPublicKey, `Failed to decode method-specific identifier`);
    }
    if (identityKeyBytes.length !== 32) {
      throw new DidError(DidErrorCode.InvalidPublicKeyLength, `Invalid public key length: ${identityKeyBytes.length}`);
    }
    return identityKeyBytes;
  }
  /**
   * Encodes a DID DHT Identity Key into a DID identifier.
   *
   * This method first z-base-32 encodes the Identity Key. The resulting string is prefixed with
   * `did:dht:` to form the DID identifier.
   *
   * @param params - The parameters to use for the conversion.
   * @param params.identityKey The Identity Key from which the DID identifier is computed.
   * @returns A promise that resolves to a string containing the DID identifier.
   */
  static identityKeyToIdentifier({ identityKey }) {
    return __awaiter16(this, void 0, void 0, function* () {
      const publicKeyBytes = yield Ed25519.publicKeyToBytes({ publicKey: identityKey });
      const identifier = Convert.uint8Array(publicKeyBytes).toBase32Z();
      return `did:${DidDht.methodName}:${identifier}`;
    });
  }
  /**
   * Returns the appropriate key converter for the specified cryptographic curve.
   *
   * @param curve - The cryptographic curve to use for the key conversion.
   * @returns An `AsymmetricKeyConverter` for the specified curve.
   */
  static keyConverter(curve) {
    const converters = {
      "Ed25519": Ed25519,
      "P-256": Secp256r1,
      "secp256k1": Secp256k1
    };
    const converter = converters[curve];
    if (!converter)
      throw new DidError(DidErrorCode.InvalidPublicKeyType, `Unsupported curve: ${curve}`);
    return converter;
  }
  /**
   * Parses and verifies a BEP44 Get message, converting it to a DNS packet.
   *
   * @param params - The parameters to use when verifying and parsing the BEP44 Get response message.
   * @param params.bep44Message - The BEP44 message to verify and parse.
   * @returns A promise that resolves to a DNS packet.
   */
  static parseBep44GetMessage({ bep44Message }) {
    return __awaiter16(this, void 0, void 0, function* () {
      const publicKey = yield Ed25519.bytesToPublicKey({ publicKeyBytes: bep44Message.k });
      const bencodedData = bencode_default.encode({ seq: bep44Message.seq, v: bep44Message.v }).subarray(1, -1);
      const isValid3 = yield Ed25519.verify({
        key: publicKey,
        signature: bep44Message.sig,
        data: bencodedData
      });
      if (!isValid3) {
        throw new DidError(DidErrorCode.InvalidSignature, `Invalid signature for DHT BEP44 message`);
      }
      return decode(bep44Message.v);
    });
  }
  /**
   * Decodes and parses the data value of a DNS TXT record into a key-value object.
   *
   * @param txtData - The data value of a DNS TXT record.
   * @returns An object containing the key/value pairs of the TXT record data.
   */
  static parseTxtDataToObject(txtData) {
    return this.parseTxtDataToString(txtData).split(PROPERTY_SEPARATOR).reduce((acc, pair) => {
      const [key, value] = pair.split("=");
      acc[key] = value;
      return acc;
    }, {});
  }
  /**
   * Decodes and parses the data value of a DNS TXT record into a string.
   *
   * @param txtData - The data value of a DNS TXT record.
   * @returns A string representation of the TXT record data.
   */
  static parseTxtDataToString(txtData) {
    if (typeof txtData === "string") {
      return txtData;
    } else if (txtData instanceof Uint8Array) {
      return Convert.uint8Array(txtData).toString();
    } else if (Array.isArray(txtData)) {
      return txtData.map((item) => this.parseTxtDataToString(item)).join("");
    } else {
      throw new DidError(DidErrorCode.InternalError, "Pkarr returned DNS TXT record with invalid data type");
    }
  }
};

// node_modules/@tbdex/protocol/node_modules/@web5/dids/dist/esm/methods/did-ion.js
var import_dist48 = __toESM(require_dist(), 1);
var __awaiter17 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DidIonRegisteredKeyType;
(function(DidIonRegisteredKeyType3) {
  DidIonRegisteredKeyType3["Ed25519"] = "Ed25519";
  DidIonRegisteredKeyType3["secp256k1"] = "secp256k1";
  DidIonRegisteredKeyType3["secp256r1"] = "secp256r1";
  DidIonRegisteredKeyType3["X25519"] = "X25519";
})(DidIonRegisteredKeyType || (DidIonRegisteredKeyType = {}));
var AlgorithmToKeyTypeMap2 = {
  Ed25519: DidIonRegisteredKeyType.Ed25519,
  ES256K: DidIonRegisteredKeyType.secp256k1,
  ES256: DidIonRegisteredKeyType.secp256r1,
  "P-256": DidIonRegisteredKeyType.secp256r1,
  secp256k1: DidIonRegisteredKeyType.secp256k1,
  secp256r1: DidIonRegisteredKeyType.secp256r1
};
var DEFAULT_GATEWAY_URI2 = "https://ion.tbd.engineering";
var DidIon = class _DidIon extends DidMethod {
  /**
   * Creates a new DID using the `did:ion` method formed from a newly generated key.
   *
   * Notes:
   * - If no `options` are given, by default a new Ed25519 key will be generated.
   *
   * @example
   * ```ts
   * // DID Creation
   * const did = await DidIon.create();
   *
   * // DID Creation with a KMS
   * const keyManager = new LocalKeyManager();
   * const did = await DidIon.create({ keyManager });
   * ```
   *
   * @param params - The parameters for the create operation.
   * @param params.keyManager - Optionally specify a Key Management System (KMS) used to generate
   *                            keys and sign data.
   * @param params.options - Optional parameters that can be specified when creating a new DID.
   * @returns A Promise resolving to a {@link BearerDid} object representing the new DID.
   */
  static create({ keyManager: keyManager2 = new LocalKeyManager(), options = {} } = {}) {
    var _a, _b, _c, _d, _e, _f, _g;
    return __awaiter17(this, void 0, void 0, function* () {
      if ((_a = options.verificationMethods) === null || _a === void 0 ? void 0 : _a.some((vm) => !(vm.algorithm in AlgorithmToKeyTypeMap2))) {
        throw new Error("One or more verification method algorithms are not supported");
      }
      const methodIds = (_b = options.verificationMethods) === null || _b === void 0 ? void 0 : _b.filter((vm) => "id" in vm).map((vm) => vm.id);
      if (methodIds && methodIds.length !== new Set(methodIds).size) {
        throw new Error("One or more verification method IDs are not unique");
      }
      if ((_c = options.services) === null || _c === void 0 ? void 0 : _c.some((s) => !s.id || !s.type || !s.serviceEndpoint)) {
        throw new Error("One or more services are missing required properties");
      }
      const defaultVerificationMethod = {
        algorithm: "Ed25519",
        purposes: ["authentication", "assertionMethod", "capabilityDelegation", "capabilityInvocation"]
      };
      const verificationMethodsToAdd = [];
      for (const vm of (_d = options.verificationMethods) !== null && _d !== void 0 ? _d : [defaultVerificationMethod]) {
        const keyUri = yield keyManager2.generateKey({ algorithm: vm.algorithm });
        const publicKey = yield keyManager2.getPublicKey({ keyUri });
        verificationMethodsToAdd.push({
          id: vm.id,
          publicKeyJwk: publicKey,
          purposes: (_e = vm.purposes) !== null && _e !== void 0 ? _e : ["authentication", "assertionMethod", "capabilityDelegation", "capabilityInvocation"]
        });
      }
      const recoveryKeyUri = yield keyManager2.generateKey({ algorithm: DidIonRegisteredKeyType.secp256k1 });
      const recoveryKey = yield keyManager2.getPublicKey({ keyUri: recoveryKeyUri });
      const updateKeyUri = yield keyManager2.generateKey({ algorithm: DidIonRegisteredKeyType.secp256k1 });
      const updateKey = yield keyManager2.getPublicKey({ keyUri: updateKeyUri });
      const longFormDidUri = yield DidIonUtils.computeLongFormDidUri({
        recoveryKey,
        updateKey,
        services: (_f = options.services) !== null && _f !== void 0 ? _f : [],
        verificationMethods: verificationMethodsToAdd
      });
      const { didDocument, didResolutionMetadata } = yield _DidIon.resolve(longFormDidUri, { gatewayUri: options.gatewayUri });
      if (didDocument === null) {
        throw new Error(`Unable to resolve DID during creation: ${didResolutionMetadata === null || didResolutionMetadata === void 0 ? void 0 : didResolutionMetadata.error}`);
      }
      const did = new BearerDid({
        uri: longFormDidUri,
        document: didDocument,
        metadata: {
          published: false,
          canonicalId: longFormDidUri.split(":", 3).join(":"),
          recoveryKey,
          updateKey
        },
        keyManager: keyManager2
      });
      if ((_g = options.publish) !== null && _g !== void 0 ? _g : true) {
        const registrationResult = yield _DidIon.publish({ did, gatewayUri: options.gatewayUri });
        did.metadata = registrationResult.didDocumentMetadata;
      }
      return did;
    });
  }
  /**
   * Given the W3C DID Document of a `did:ion` DID, return the verification method that will be used
   * for signing messages and credentials. If given, the `methodId` parameter is used to select the
   * verification method. If not given, the first verification method in the authentication property
   * in the DID Document is used.
   *
   * @param params - The parameters for the `getSigningMethod` operation.
   * @param params.didDocument - DID Document to get the verification method from.
   * @param params.methodId - ID of the verification method to use for signing.
   * @returns Verification method to use for signing.
   */
  static getSigningMethod({ didDocument, methodId }) {
    var _a;
    return __awaiter17(this, void 0, void 0, function* () {
      const parsedDid = Did.parse(didDocument.id);
      if (parsedDid && parsedDid.method !== this.methodName) {
        throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported: ${parsedDid.method}`);
      }
      const verificationMethod = (_a = didDocument.verificationMethod) === null || _a === void 0 ? void 0 : _a.find((vm) => {
        var _a2;
        return vm.id === (methodId !== null && methodId !== void 0 ? methodId : (_a2 = didDocument.assertionMethod) === null || _a2 === void 0 ? void 0 : _a2[0]);
      });
      if (!(verificationMethod && verificationMethod.publicKeyJwk)) {
        throw new DidError(DidErrorCode.InternalError, "A verification method intended for signing could not be determined from the DID Document");
      }
      return verificationMethod;
    });
  }
  /**
   * Instantiates a {@link BearerDid} object for the DID ION method from a given {@link PortableDid}.
   *
   * This method allows for the creation of a `BearerDid` object using a previously created DID's
   * key material, DID document, and metadata.
   *
   * @example
   * ```ts
   * // Export an existing BearerDid to PortableDid format.
   * const portableDid = await did.export();
   * // Reconstruct a BearerDid object from the PortableDid.
   * const did = await DidIon.import({ portableDid });
   * ```
   *
   * @param params - The parameters for the import operation.
   * @param params.portableDid - The PortableDid object to import.
   * @param params.keyManager - Optionally specify an external Key Management System (KMS) used to
   *                            generate keys and sign data. If not given, a new
   *                            {@link LocalKeyManager} instance will be created and
   *                            used.
   * @returns A Promise resolving to a `BearerDid` object representing the DID formed from the
   *          provided PortableDid.
   * @throws An error if the DID document does not contain any verification methods or the keys for
   *         any verification method are missing in the key manager.
   */
  static import({ portableDid, keyManager: keyManager2 = new LocalKeyManager() }) {
    return __awaiter17(this, void 0, void 0, function* () {
      const parsedDid = Did.parse(portableDid.uri);
      if ((parsedDid === null || parsedDid === void 0 ? void 0 : parsedDid.method) !== _DidIon.methodName) {
        throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported`);
      }
      const did = yield BearerDid.import({ portableDid, keyManager: keyManager2 });
      return did;
    });
  }
  /**
   * Publishes a DID to a Sidetree node, making it publicly discoverable and resolvable.
   *
   * This method handles the publication of a DID Document associated with a `did:ion` DID to a
   * Sidetree node.
   *
   * @remarks
   * - This method is typically invoked automatically during the creation of a new DID unless the
   *   `publish` option is set to `false`.
   * - For existing, unpublished DIDs, it can be used to publish the DID Document to a Sidetree node.
   * - The method relies on the specified Sidetree node to interface with the network.
   *
   * @param params - The parameters for the `publish` operation.
   * @param params.did - The `BearerDid` object representing the DID to be published.
   * @param params.gatewayUri - Optional. The URI of a server involved in executing DID
   *                                    method operations. In the context of publishing, the
   *                                    endpoint is expected to be a Sidetree node. If not
   *                                    specified, a default node is used.
   * @returns A Promise resolving to a boolean indicating whether the publication was successful.
   *
   * @example
   * ```ts
   * // Generate a new DID and keys but explicitly disable publishing.
   * const did = await DidIon.create({ options: { publish: false } });
   * // Publish the DID to the Sidetree network.
   * const isPublished = await DidIon.publish({ did });
   * // `isPublished` is true if the DID was successfully published.
   * ```
   */
  static publish({ did, gatewayUri = DEFAULT_GATEWAY_URI2 }) {
    var _a, _b, _c;
    return __awaiter17(this, void 0, void 0, function* () {
      const verificationMethods = (_b = (_a = did.document.verificationMethod) === null || _a === void 0 ? void 0 : _a.map((vm) => ({
        id: vm.id,
        publicKeyJwk: vm.publicKeyJwk,
        purposes: getVerificationRelationshipsById({ didDocument: did.document, methodId: vm.id })
      }))) !== null && _b !== void 0 ? _b : [];
      const ionDocument = yield DidIonUtils.createIonDocument({
        services: (_c = did.document.service) !== null && _c !== void 0 ? _c : [],
        verificationMethods
      });
      const createOperation = yield DidIonUtils.constructCreateRequest({
        ionDocument,
        recoveryKey: did.metadata.recoveryKey,
        updateKey: did.metadata.updateKey
      });
      try {
        const operationsUrl = DidIonUtils.appendPathToUrl({
          baseUrl: gatewayUri,
          path: `/operations`
        });
        const response = yield fetch(operationsUrl, {
          method: "POST",
          mode: "cors",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(createOperation)
        });
        return {
          didDocument: did.document,
          didDocumentMetadata: Object.assign(Object.assign({}, did.metadata), { published: response.ok }),
          didRegistrationMetadata: {}
        };
      } catch (error) {
        return {
          didDocument: null,
          didDocumentMetadata: {
            published: false
          },
          didRegistrationMetadata: {
            error: DidErrorCode.InternalError,
            errorMessage: `Failed to publish DID document for: ${did.uri}`
          }
        };
      }
    });
  }
  /**
   * Resolves a `did:ion` identifier to its corresponding DID document.
   *
   * This method performs the resolution of a `did:ion` DID, retrieving its DID Document from the
   * Sidetree-based DID overlay network. The process involves querying a Sidetree node to retrieve
   * the DID Document that corresponds to the given DID identifier.
   *
   * @remarks
   * - If a `gatewayUri` option is not specified, a default node is used to access the Sidetree
   *   network.
   * - It decodes the DID identifier and retrieves the associated DID Document and metadata.
   * - In case of resolution failure, appropriate error information is returned.
   *
   * @example
   * ```ts
   * const resolutionResult = await DidIon.resolve('did:ion:example');
   * ```
   *
   * @param didUri - The DID to be resolved.
   * @param options - Optional parameters for resolving the DID. Unused by this DID method.
   * @returns A Promise resolving to a {@link DidResolutionResult} object representing the result of the resolution.
   */
  static resolve(didUri, options = {}) {
    var _a, _b;
    return __awaiter17(this, void 0, void 0, function* () {
      const parsedDid = Did.parse(didUri);
      if (!parsedDid) {
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didResolutionMetadata: { error: "invalidDid" } });
      }
      if (parsedDid.method !== _DidIon.methodName) {
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didResolutionMetadata: { error: "methodNotSupported" } });
      }
      const gatewayUri = (_a = options === null || options === void 0 ? void 0 : options.gatewayUri) !== null && _a !== void 0 ? _a : DEFAULT_GATEWAY_URI2;
      try {
        const resolutionUrl = DidIonUtils.appendPathToUrl({
          baseUrl: gatewayUri,
          path: `/identifiers/${didUri}`
        });
        const response = yield fetch(resolutionUrl);
        if (!response.ok) {
          throw new DidError(DidErrorCode.NotFound, `Unable to find DID document for: ${didUri}`);
        }
        const { didDocument, didDocumentMetadata } = yield response.json();
        return Object.assign(Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), didDocument && { didDocument }), { didDocumentMetadata: Object.assign({ published: (_b = didDocumentMetadata === null || didDocumentMetadata === void 0 ? void 0 : didDocumentMetadata.method) === null || _b === void 0 ? void 0 : _b.published }, didDocumentMetadata) });
      } catch (error) {
        if (!(error instanceof DidError))
          throw new Error(error);
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didResolutionMetadata: Object.assign({ error: error.code }, error.message && { errorMessage: error.message }) });
      }
    });
  }
};
DidIon.methodName = "ion";
var DidIonUtils = class _DidIonUtils {
  /**
   * Appends a specified path to a base URL, ensuring proper formatting of the resulting URL.
   *
   * This method is useful for constructing URLs for accessing various endpoints, such as Sidetree
   * nodes in the ION network. It handles the nuances of URL path concatenation, including the
   * addition or removal of leading/trailing slashes, to create a well-formed URL.
   *
   * @param params - The parameters for URL construction.
   * @param params.baseUrl - The base URL to which the path will be appended.
   * @param params.path - The path to append to the base URL.
   * @returns The fully constructed URL string with the path appended to the base URL.
   */
  static appendPathToUrl({ baseUrl, path }) {
    const url = new URL(baseUrl);
    url.pathname = url.pathname.endsWith("/") ? url.pathname : url.pathname + "/";
    url.pathname += path.startsWith("/") ? path.substring(1) : path;
    return url.toString();
  }
  /**
   * Computes the Long Form DID URI given an ION DID's recovery key, update key, services, and
   * verification methods.
   *
   * @param params - The parameters for computing the Long Form DID URI.
   * @param params.recoveryKey - The ION Recovery Key.
   * @param params.updateKey - The ION Update Key.
   * @param params.services - An array of services associated with the DID.
   * @param params.verificationMethods - An array of verification methods associated with the DID.
   * @returns A Promise resolving to the Long Form DID URI.
   */
  static computeLongFormDidUri({ recoveryKey, updateKey, services, verificationMethods }) {
    return __awaiter17(this, void 0, void 0, function* () {
      const ionDocument = yield _DidIonUtils.createIonDocument({ services, verificationMethods });
      const normalizedRecoveryKey = _DidIonUtils.normalizeJwk(recoveryKey);
      const normalizedUpdateKey = _DidIonUtils.normalizeJwk(updateKey);
      const longFormDidUri = yield IonDid.createLongFormDid({
        document: ionDocument,
        recoveryKey: normalizedRecoveryKey,
        updateKey: normalizedUpdateKey
      });
      return longFormDidUri;
    });
  }
  /**
   * Constructs a Sidetree Create Operation request for a DID document within the ION network.
   *
   * This method prepares the necessary payload for submitting a Create Operation to a Sidetree
   * node, encapsulating the details of the DID document, recovery key, and update key.
   *
   * @param params - Parameters required to construct the Create Operation request.
   * @param params.ionDocument - The DID document model containing public keys and service endpoints.
   * @param params.recoveryKey - The recovery public key in JWK format.
   * @param params.updateKey - The update public key in JWK format.
   * @returns A promise resolving to the ION Create Operation request model, ready for submission to a Sidetree node.
   */
  static constructCreateRequest({ ionDocument, recoveryKey, updateKey }) {
    return __awaiter17(this, void 0, void 0, function* () {
      const createRequest = yield IonRequest.createCreateRequest({
        document: ionDocument,
        recoveryKey: _DidIonUtils.normalizeJwk(recoveryKey),
        updateKey: _DidIonUtils.normalizeJwk(updateKey)
      });
      return createRequest;
    });
  }
  /**
   * Assembles an ION document model from provided services and verification methods
   *
   * This model serves as the foundation for a DID document in the ION network, facilitating the
   * creation and management of decentralized identities. It translates service endpoints and
   * public keys into a format compatible with the Sidetree protocol, ensuring the resulting DID
   * document adheres to the required specifications for ION DIDs. This method is essential for
   * constructing the payload needed to register or update DIDs within the ION network.
   *
   * @param params - The parameters containing the services and verification methods to include in the ION document.
   * @param params.services - A list of service endpoints to be included in the DID document, specifying ways to interact with the DID subject.
   * @param params.verificationMethods - A list of verification methods to be included, detailing the cryptographic keys and their intended uses within the DID document.
   * @returns A Promise resolving to an `IonDocumentModel`, ready for use in Sidetree operations like DID creation and updates.
   */
  static createIonDocument({ services, verificationMethods }) {
    var _a, _b;
    return __awaiter17(this, void 0, void 0, function* () {
      const ionPublicKeys = [];
      for (const vm of verificationMethods) {
        let methodId = (_b = (_a = vm.id) !== null && _a !== void 0 ? _a : vm.publicKeyJwk.kid) !== null && _b !== void 0 ? _b : yield computeJwkThumbprint({ jwk: vm.publicKeyJwk });
        methodId = `${methodId.split("#").pop()}`;
        const publicKey = {
          id: methodId,
          publicKeyJwk: _DidIonUtils.normalizeJwk(vm.publicKeyJwk),
          purposes: vm.purposes,
          type: "JsonWebKey2020"
        };
        ionPublicKeys.push(publicKey);
      }
      const ionServices = services.map((service) => Object.assign(Object.assign({}, service), {
        id: `${service.id.split("#").pop()}`
        // Remove fragment prefix, if any.
      }));
      const ionDocumentModel = {
        publicKeys: ionPublicKeys,
        services: ionServices
      };
      return ionDocumentModel;
    });
  }
  /**
   * Normalize the given JWK to include only specific members and in lexicographic order.
   *
   * @param jwk - The JWK to normalize.
   * @returns The normalized JWK.
   */
  static normalizeJwk(jwk) {
    const keyType = jwk.kty;
    let normalizedJwk;
    if (keyType === "EC") {
      normalizedJwk = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };
    } else if (keyType === "oct") {
      normalizedJwk = { k: jwk.k, kty: jwk.kty };
    } else if (keyType === "OKP") {
      normalizedJwk = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };
    } else if (keyType === "RSA") {
      normalizedJwk = { e: jwk.e, kty: jwk.kty, n: jwk.n };
    } else {
      throw new Error(`Unsupported key type: ${keyType}`);
    }
    return normalizedJwk;
  }
};

// node_modules/@tbdex/protocol/node_modules/@web5/dids/dist/esm/methods/did-jwk.js
var import_dist49 = __toESM(require_dist(), 1);
var __awaiter18 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DidJwk = class _DidJwk extends DidMethod {
  /**
   * Creates a new DID using the `did:jwk` method formed from a newly generated key.
   *
   * @remarks
   * The DID URI is formed by Base64URL-encoding the JWK and prefixing with `did:jwk:`.
   *
   * Notes:
   * - If no `options` are given, by default a new Ed25519 key will be generated.
   * - The `algorithm` and `verificationMethods` options are mutually exclusive. If both are given,
   *   an error will be thrown.
   *
   * @example
   * ```ts
   * // DID Creation
   * const did = await DidJwk.create();
   *
   * // DID Creation with a KMS
   * const keyManager = new LocalKeyManager();
   * const did = await DidJwk.create({ keyManager });
   * ```
   *
   * @param params - The parameters for the create operation.
   * @param params.keyManager - Optionally specify a Key Management System (KMS) used to generate
   *                            keys and sign data.
   * @param params.options - Optional parameters that can be specified when creating a new DID.
   * @returns A Promise resolving to a {@link BearerDid} object representing the new DID.
   */
  static create({ keyManager: keyManager2 = new LocalKeyManager(), options = {} } = {}) {
    var _a, _b, _c, _d;
    return __awaiter18(this, void 0, void 0, function* () {
      if (options.algorithm && options.verificationMethods) {
        throw new Error(`The 'algorithm' and 'verificationMethods' options are mutually exclusive`);
      }
      if (options.verificationMethods && options.verificationMethods.length !== 1) {
        throw new Error(`The 'verificationMethods' option must contain exactly one entry`);
      }
      const algorithm = (_d = (_a = options.algorithm) !== null && _a !== void 0 ? _a : (_c = (_b = options.verificationMethods) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.algorithm) !== null && _d !== void 0 ? _d : "Ed25519";
      const keyUri = yield keyManager2.generateKey({ algorithm });
      const publicKey = yield keyManager2.getPublicKey({ keyUri });
      const identifier = Convert.object(publicKey).toBase64Url();
      const didUri = `did:${_DidJwk.methodName}:${identifier}`;
      const didResolutionResult = yield _DidJwk.resolve(didUri);
      const document = didResolutionResult.didDocument;
      const did = new BearerDid({
        uri: didUri,
        document,
        metadata: {},
        keyManager: keyManager2
      });
      return did;
    });
  }
  /**
   * Given the W3C DID Document of a `did:jwk` DID, return the verification method that will be used
   * for signing messages and credentials. If given, the `methodId` parameter is used to select the
   * verification method. If not given, the first verification method in the DID Document is used.
   *
   * Note that for DID JWK, only one verification method can exist so specifying `methodId` could be
   * considered redundant or unnecessary. The option is provided for consistency with other DID
   * method implementations.
   *
   * @param params - The parameters for the `getSigningMethod` operation.
   * @param params.didDocument - DID Document to get the verification method from.
   * @param params.methodId - ID of the verification method to use for signing.
   * @returns Verification method to use for signing.
   */
  static getSigningMethod({ didDocument }) {
    var _a;
    return __awaiter18(this, void 0, void 0, function* () {
      const parsedDid = Did.parse(didDocument.id);
      if (parsedDid && parsedDid.method !== this.methodName) {
        throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported: ${parsedDid.method}`);
      }
      const [verificationMethod] = (_a = didDocument.verificationMethod) !== null && _a !== void 0 ? _a : [];
      if (!(verificationMethod && verificationMethod.publicKeyJwk)) {
        throw new DidError(DidErrorCode.InternalError, "A verification method intended for signing could not be determined from the DID Document");
      }
      return verificationMethod;
    });
  }
  /**
   * Instantiates a {@link BearerDid} object for the DID JWK method from a given {@link PortableDid}.
   *
   * This method allows for the creation of a `BearerDid` object using a previously created DID's
   * key material, DID document, and metadata.
   *
   * @remarks
   * The `verificationMethod` array of the DID document must contain exactly one key since the
   * `did:jwk` method only supports a single verification method.
   *
   * @example
   * ```ts
   * // Export an existing BearerDid to PortableDid format.
   * const portableDid = await did.export();
   * // Reconstruct a BearerDid object from the PortableDid.
   * const did = await DidJwk.import({ portableDid });
   * ```
   *
   * @param params - The parameters for the import operation.
   * @param params.portableDid - The PortableDid object to import.
   * @param params.keyManager - Optionally specify an external Key Management System (KMS) used to
   *                            generate keys and sign data. If not given, a new
   *                            {@link LocalKeyManager} instance will be created and
   *                            used.
   * @returns A Promise resolving to a `BearerDid` object representing the DID formed from the provided keys.
   * @throws An error if the DID document does not contain exactly one verification method.
   */
  static import({ portableDid, keyManager: keyManager2 = new LocalKeyManager() }) {
    return __awaiter18(this, void 0, void 0, function* () {
      const parsedDid = Did.parse(portableDid.uri);
      if ((parsedDid === null || parsedDid === void 0 ? void 0 : parsedDid.method) !== _DidJwk.methodName) {
        throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported`);
      }
      const did = yield BearerDid.import({ portableDid, keyManager: keyManager2 });
      if (did.document.verificationMethod.length !== 1) {
        throw new DidError(DidErrorCode.InvalidDidDocument, `DID document must contain exactly one verification method`);
      }
      return did;
    });
  }
  /**
   * Resolves a `did:jwk` identifier to a DID Document.
   *
   * @param didUri - The DID to be resolved.
   * @param _options - Optional parameters for resolving the DID. Unused by this DID method.
   * @returns A Promise resolving to a {@link DidResolutionResult} object representing the result of the resolution.
   */
  static resolve(didUri, _options) {
    return __awaiter18(this, void 0, void 0, function* () {
      const parsedDid = Did.parse(didUri);
      let publicKey;
      try {
        publicKey = Convert.base64Url(parsedDid.id).toObject();
      } catch (_a) {
      }
      if (!parsedDid || !publicKey) {
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didResolutionMetadata: { error: "invalidDid" } });
      }
      if (parsedDid.method !== _DidJwk.methodName) {
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didResolutionMetadata: { error: "methodNotSupported" } });
      }
      const didDocument = {
        "@context": [
          "https://www.w3.org/ns/did/v1"
        ],
        id: parsedDid.uri
      };
      const keyUri = `${didDocument.id}#0`;
      didDocument.verificationMethod = [{
        id: keyUri,
        type: "JsonWebKey",
        controller: didDocument.id,
        publicKeyJwk: publicKey
      }];
      didDocument.authentication = [keyUri];
      didDocument.assertionMethod = [keyUri];
      didDocument.capabilityInvocation = [keyUri];
      didDocument.capabilityDelegation = [keyUri];
      didDocument.keyAgreement = [keyUri];
      switch (publicKey.use) {
        case "sig": {
          delete didDocument.keyAgreement;
          break;
        }
        case "enc": {
          delete didDocument.authentication;
          delete didDocument.assertionMethod;
          delete didDocument.capabilityInvocation;
          delete didDocument.capabilityDelegation;
          break;
        }
      }
      return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didDocument });
    });
  }
};
DidJwk.methodName = "jwk";

// node_modules/@tbdex/protocol/node_modules/@web5/dids/dist/esm/methods/did-key.js
var import_dist50 = __toESM(require_dist(), 1);
var __awaiter19 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DidKeyRegisteredKeyType;
(function(DidKeyRegisteredKeyType3) {
  DidKeyRegisteredKeyType3["Ed25519"] = "Ed25519";
  DidKeyRegisteredKeyType3["secp256k1"] = "secp256k1";
  DidKeyRegisteredKeyType3["secp256r1"] = "secp256r1";
  DidKeyRegisteredKeyType3["X25519"] = "X25519";
})(DidKeyRegisteredKeyType || (DidKeyRegisteredKeyType = {}));
var DidKeyVerificationMethodType = {
  /** Represents an Ed25519 public key used for digital signatures. */
  Ed25519VerificationKey2020: "https://w3id.org/security/suites/ed25519-2020/v1",
  /** Represents a JSON Web Key (JWK) used for digital signatures and key agreement protocols. */
  JsonWebKey2020: "https://w3id.org/security/suites/jws-2020/v1",
  /** Represents an X25519 public key used for key agreement protocols. */
  X25519KeyAgreementKey2020: "https://w3id.org/security/suites/x25519-2020/v1"
};
var AlgorithmToKeyTypeMap3 = {
  Ed25519: DidKeyRegisteredKeyType.Ed25519,
  ES256K: DidKeyRegisteredKeyType.secp256k1,
  ES256: DidKeyRegisteredKeyType.secp256r1,
  "P-256": DidKeyRegisteredKeyType.secp256r1,
  secp256k1: DidKeyRegisteredKeyType.secp256k1,
  secp256r1: DidKeyRegisteredKeyType.secp256r1,
  X25519: DidKeyRegisteredKeyType.X25519
};
var DidKey = class _DidKey extends DidMethod {
  /**
   * Creates a new DID using the `did:key` method formed from a newly generated key.
   *
   * @remarks
   * The DID URI is formed by
   * {@link https://datatracker.ietf.org/doc/html/draft-multiformats-multibase#name-base-58-bitcoin-encoding | Multibase base58-btc}
   * encoding the
   * {@link https://github.com/multiformats/multicodec/blob/master/README.md | Multicodec}-encoded
   * public key and prefixing with `did:key:`.
   *
   * This method can optionally derive an encryption key from the public key used to create the DID
   * if and only if the public key algorithm is `Ed25519`. This feature enables the same DID to be
   * used for encrypted communication, in addition to signature verification. To enable this
   * feature, specify an `algorithm` of `Ed25519` as either a top-level option or in a
   * `verificationMethod` and set the `enableEncryptionKeyDerivation` option to `true`.
   *
   * Notes:
   * - If no `options` are given, by default a new Ed25519 key will be generated.
   * - The `algorithm` and `verificationMethods` options are mutually exclusive. If both are given,
   *   an error will be thrown.
   *
   * @example
   * ```ts
   * // DID Creation
   * const did = await DidKey.create();
   *
   * // DID Creation with a KMS
   * const keyManager = new LocalKeyManager();
   * const did = await DidKey.create({ keyManager });
   * ```
   *
   * @param params - The parameters for the create operation.
   * @param params.keyManager - Key Management System (KMS) used to generate keys and sign data.
   * @param params.options - Optional parameters that can be specified when creating a new DID.
   * @returns A Promise resolving to a {@link BearerDid} object representing the new DID.
   */
  static create({ keyManager: keyManager2 = new LocalKeyManager(), options = {} } = {}) {
    var _a, _b, _c, _d;
    return __awaiter19(this, void 0, void 0, function* () {
      if (options.algorithm && options.verificationMethods) {
        throw new Error(`The 'algorithm' and 'verificationMethods' options are mutually exclusive`);
      }
      if (options.verificationMethods && options.verificationMethods.length !== 1) {
        throw new Error(`The 'verificationMethods' option must contain exactly one entry`);
      }
      const algorithm = (_d = (_a = options.algorithm) !== null && _a !== void 0 ? _a : (_c = (_b = options.verificationMethods) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.algorithm) !== null && _d !== void 0 ? _d : "Ed25519";
      const keyUri = yield keyManager2.generateKey({ algorithm });
      const publicKey = yield keyManager2.getPublicKey({ keyUri });
      const identifier = yield DidKeyUtils.publicKeyToMultibaseId({ publicKey });
      const didUri = `did:${_DidKey.methodName}:${identifier}`;
      const didResolutionResult = yield _DidKey.resolve(didUri, options);
      const document = didResolutionResult.didDocument;
      const did = new BearerDid({
        uri: didUri,
        document,
        metadata: {},
        keyManager: keyManager2
      });
      return did;
    });
  }
  /**
   * Given the W3C DID Document of a `did:key` DID, return the verification method that will be used
   * for signing messages and credentials. With DID Key, the first verification method in the
   * authentication property in the DID Document is used.
   *
   * Note that for DID Key, only one verification method intended for signing can exist so
   * specifying `methodId` could be considered redundant or unnecessary. The option is provided for
   * consistency with other DID method implementations.
   *
   * @param params - The parameters for the `getSigningMethod` operation.
   * @param params.didDocument - DID Document to get the verification method from.
   * @param params.methodId - ID of the verification method to use for signing.
   * @returns Verification method to use for signing.
   */
  static getSigningMethod({ didDocument }) {
    var _a;
    return __awaiter19(this, void 0, void 0, function* () {
      const parsedDid = Did.parse(didDocument.id);
      if (parsedDid && parsedDid.method !== this.methodName) {
        throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported: ${parsedDid.method}`);
      }
      const [methodId] = didDocument.assertionMethod || [];
      const verificationMethod = (_a = didDocument.verificationMethod) === null || _a === void 0 ? void 0 : _a.find((vm) => vm.id === methodId);
      if (!(verificationMethod && verificationMethod.publicKeyJwk)) {
        throw new DidError(DidErrorCode.InternalError, "A verification method intended for signing could not be determined from the DID Document");
      }
      return verificationMethod;
    });
  }
  /**
   * Instantiates a {@link BearerDid} object for the DID Key method from a given {@link PortableDid}.
   *
   * This method allows for the creation of a `BearerDid` object using a previously created DID's
   * key material, DID document, and metadata.
   *
   * @remarks
   * The `verificationMethod` array of the DID document must contain exactly one key since the
   * `did:key` method only supports a single verification method.
   *
   * @example
   * ```ts
   * // Export an existing BearerDid to PortableDid format.
   * const portableDid = await did.export();
   * // Reconstruct a BearerDid object from the PortableDid.
   * const did = await DidKey.import({ portableDid });
   * ```
   *
   * @param params - The parameters for the import operation.
   * @param params.portableDid - The PortableDid object to import.
   * @param params.keyManager - Optionally specify an external Key Management System (KMS) used to
   *                            generate keys and sign data. If not given, a new
   *                            {@link LocalKeyManager} instance will be created and
   *                            used.
   * @returns A Promise resolving to a `BearerDid` object representing the DID formed from the provided keys.
   * @throws An error if the DID document does not contain exactly one verification method.
   */
  static import({ portableDid, keyManager: keyManager2 = new LocalKeyManager() }) {
    return __awaiter19(this, void 0, void 0, function* () {
      const parsedDid = Did.parse(portableDid.uri);
      if ((parsedDid === null || parsedDid === void 0 ? void 0 : parsedDid.method) !== _DidKey.methodName) {
        throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported`);
      }
      const did = yield BearerDid.import({ portableDid, keyManager: keyManager2 });
      if (did.document.verificationMethod.length !== 1) {
        throw new DidError(DidErrorCode.InvalidDidDocument, `DID document must contain exactly one verification method`);
      }
      return did;
    });
  }
  /**
   * Resolves a `did:key` identifier to a DID Document.
   *
   * @param didUri - The DID to be resolved.
   * @param options - Optional parameters for resolving the DID.
   * @returns A Promise resolving to a {@link DidResolutionResult} object representing the result of the resolution.
   */
  static resolve(didUri, options) {
    return __awaiter19(this, void 0, void 0, function* () {
      try {
        const didDocument = yield _DidKey.createDocument({ didUri, options });
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didDocument });
      } catch (error) {
        if (!(error instanceof DidError))
          throw new Error(error);
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didResolutionMetadata: Object.assign({ error: error.code }, error.message && { errorMessage: error.message }) });
      }
    });
  }
  /**
   * Expands a did:key identifier to a DID Document.
   *
   * Reference: https://w3c-ccg.github.io/did-method-key/#document-creation-algorithm
   *
   * @param options
   * @returns - A DID dodcument.
   */
  static createDocument({ didUri, options = {} }) {
    return __awaiter19(this, void 0, void 0, function* () {
      const { defaultContext = "https://www.w3.org/ns/did/v1", enableEncryptionKeyDerivation = false, enableExperimentalPublicKeyTypes = false, publicKeyFormat = "JsonWebKey2020" } = options;
      const didDocument = { id: "" };
      const parsedDid = Did.parse(didUri);
      if (!parsedDid) {
        throw new DidError(DidErrorCode.InvalidDid, `Invalid DID URI: ${didUri}`);
      }
      const multibaseValue = parsedDid.id;
      if (parsedDid.method !== _DidKey.methodName) {
        throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported: ${parsedDid.method}`);
      }
      if (!_DidKey.validateIdentifier(parsedDid)) {
        throw new DidError(DidErrorCode.InvalidDid, `Invalid DID URI: ${didUri}`);
      }
      const signatureVerificationMethod = yield _DidKey.createSignatureMethod({
        didUri,
        multibaseValue,
        options: { enableExperimentalPublicKeyTypes, publicKeyFormat }
      });
      didDocument.id = parsedDid.uri;
      didDocument.verificationMethod = [signatureVerificationMethod];
      didDocument.authentication = [signatureVerificationMethod.id];
      didDocument.assertionMethod = [signatureVerificationMethod.id];
      didDocument.capabilityInvocation = [signatureVerificationMethod.id];
      didDocument.capabilityDelegation = [signatureVerificationMethod.id];
      if (enableEncryptionKeyDerivation === true) {
        const encryptionPublicKeyFormat = publicKeyFormat === "Ed25519VerificationKey2020" ? "X25519KeyAgreementKey2020" : "JsonWebKey2020";
        const encryptionVerificationMethod = yield this.createEncryptionMethod({
          didUri,
          multibaseValue,
          options: { enableExperimentalPublicKeyTypes, publicKeyFormat: encryptionPublicKeyFormat }
        });
        didDocument.verificationMethod.push(encryptionVerificationMethod);
        didDocument.keyAgreement = [encryptionVerificationMethod.id];
      }
      const contextArray = [defaultContext];
      const verificationMethodTypes = getVerificationMethodTypes({ didDocument });
      verificationMethodTypes.forEach((typeName) => {
        const typeUrl = DidKeyVerificationMethodType[typeName];
        contextArray.push(typeUrl);
      });
      didDocument["@context"] = contextArray;
      return didDocument;
    });
  }
  /**
   * Decoding a multibase-encoded multicodec value into a verification method
   * that is suitable for verifying that encrypted information will be
   * received by the intended recipient.
   */
  static createEncryptionMethod({ didUri, multibaseValue, options }) {
    return __awaiter19(this, void 0, void 0, function* () {
      const { enableExperimentalPublicKeyTypes, publicKeyFormat } = options;
      const verificationMethod = { id: "", type: "", controller: "" };
      const { keyBytes: publicKeyBytes, multicodecCode: multicodecValue } = yield _DidKey.deriveEncryptionKey({ multibaseValue });
      const actualLength = publicKeyBytes.byteLength;
      const expectedLength = DidKeyUtils.MULTICODEC_PUBLIC_KEY_LENGTH[multicodecValue];
      if (actualLength !== expectedLength) {
        throw new DidError(DidErrorCode.InvalidPublicKeyLength, `Expected ${actualLength} bytes. Actual: ${expectedLength}`);
      }
      const kemMultibaseValue = keyBytesToMultibaseId({
        keyBytes: publicKeyBytes,
        multicodecCode: multicodecValue
      });
      verificationMethod.id = `${didUri}#${kemMultibaseValue}`;
      try {
        new URL(verificationMethod.id);
      } catch (error) {
        throw new DidError(DidErrorCode.InvalidDidUrl, "Verification Method ID is not a valid DID URL.");
      }
      if (!(publicKeyFormat in DidKeyVerificationMethodType)) {
        throw new DidError(DidErrorCode.UnsupportedPublicKeyType, `Unsupported format: ${publicKeyFormat}`);
      }
      const StandardPublicKeyTypes = ["Multikey", "JsonWebKey2020", "X25519KeyAgreementKey2020"];
      if (enableExperimentalPublicKeyTypes === false && !StandardPublicKeyTypes.includes(publicKeyFormat)) {
        throw new DidError(DidErrorCode.InvalidPublicKeyType, `Specified '${publicKeyFormat}' without setting enableExperimentalPublicKeyTypes to true.`);
      }
      verificationMethod.type = publicKeyFormat;
      verificationMethod.controller = didUri;
      if (publicKeyFormat === "X25519KeyAgreementKey2020") {
        verificationMethod.publicKeyMultibase = kemMultibaseValue;
      }
      if (publicKeyFormat === "JsonWebKey2020") {
        const { crv } = yield DidKeyUtils.multicodecToJwk({ code: multicodecValue });
        verificationMethod.publicKeyJwk = yield DidKeyUtils.keyConverter(crv).bytesToPublicKey({ publicKeyBytes });
      }
      return verificationMethod;
    });
  }
  /**
   * Decodes a multibase-encoded multicodec value into a verification method
   * that is suitable for verifying digital signatures.
   * @param options - Signature method creation algorithm inputs.
   * @returns - A verification method.
   */
  static createSignatureMethod({ didUri, multibaseValue, options }) {
    return __awaiter19(this, void 0, void 0, function* () {
      const { enableExperimentalPublicKeyTypes, publicKeyFormat } = options;
      const verificationMethod = { id: "", type: "", controller: "" };
      const { keyBytes: publicKeyBytes, multicodecCode: multicodecValue, multicodecName } = multibaseIdToKeyBytes({ multibaseKeyId: multibaseValue });
      const actualLength = publicKeyBytes.byteLength;
      const expectedLength = DidKeyUtils.MULTICODEC_PUBLIC_KEY_LENGTH[multicodecValue];
      if (actualLength !== expectedLength) {
        throw new DidError(DidErrorCode.InvalidPublicKeyLength, `Expected ${actualLength} bytes. Actual: ${expectedLength}`);
      }
      let isValid3 = false;
      switch (multicodecName) {
        case "secp256k1-pub":
          isValid3 = yield Secp256k1.validatePublicKey({ publicKeyBytes });
          break;
        case "ed25519-pub":
          isValid3 = yield Ed25519.validatePublicKey({ publicKeyBytes });
          break;
        case "x25519-pub":
          isValid3 = true;
          break;
      }
      if (!isValid3) {
        throw new DidError(DidErrorCode.InvalidPublicKey, "Invalid public key detected.");
      }
      verificationMethod.id = `${didUri}#${multibaseValue}`;
      try {
        new URL(verificationMethod.id);
      } catch (error) {
        throw new DidError(DidErrorCode.InvalidDidUrl, "Verification Method ID is not a valid DID URL.");
      }
      if (!(publicKeyFormat in DidKeyVerificationMethodType)) {
        throw new DidError(DidErrorCode.UnsupportedPublicKeyType, `Unsupported format: ${publicKeyFormat}`);
      }
      const StandardPublicKeyTypes = ["Multikey", "JsonWebKey2020", "Ed25519VerificationKey2020"];
      if (enableExperimentalPublicKeyTypes === false && !StandardPublicKeyTypes.includes(publicKeyFormat)) {
        throw new DidError(DidErrorCode.InvalidPublicKeyType, `Specified '${publicKeyFormat}' without setting enableExperimentalPublicKeyTypes to true.`);
      }
      verificationMethod.type = publicKeyFormat;
      verificationMethod.controller = didUri;
      if (publicKeyFormat === "Ed25519VerificationKey2020") {
        verificationMethod.publicKeyMultibase = multibaseValue;
      }
      if (publicKeyFormat === "JsonWebKey2020") {
        const { crv } = yield DidKeyUtils.multicodecToJwk({ code: multicodecValue });
        verificationMethod.publicKeyJwk = yield DidKeyUtils.keyConverter(crv).bytesToPublicKey({ publicKeyBytes });
      }
      return verificationMethod;
    });
  }
  /**
   * Transform a multibase-encoded multicodec value to public encryption key
   * components that are suitable for encrypting messages to a receiver. A
   * mathematical proof elaborating on the safety of performing this operation
   * is available in:
   * {@link https://eprint.iacr.org/2021/509.pdf | On using the same key pair for Ed25519 and an X25519 based KEM}
   */
  static deriveEncryptionKey({ multibaseValue }) {
    return __awaiter19(this, void 0, void 0, function* () {
      let publicEncryptionKey = {
        keyBytes: new Uint8Array(),
        multicodecCode: 0
      };
      const { keyBytes: publicKeyBytes, multicodecCode: multicodecValue } = multibaseIdToKeyBytes({ multibaseKeyId: multibaseValue });
      if (multicodecValue === 237) {
        const ed25519PublicKey = yield DidKeyUtils.keyConverter("Ed25519").bytesToPublicKey({
          publicKeyBytes
        });
        const generatedPublicEncryptionKey = yield Ed25519.convertPublicKeyToX25519({
          publicKey: ed25519PublicKey
        });
        const generatedPublicEncryptionKeyBytes = yield DidKeyUtils.keyConverter("Ed25519").publicKeyToBytes({
          publicKey: generatedPublicEncryptionKey
        });
        publicEncryptionKey = {
          keyBytes: generatedPublicEncryptionKeyBytes,
          multicodecCode: 236
        };
      }
      return publicEncryptionKey;
    });
  }
  /**
   * Validates the structure and components of a DID URI against the `did:key` method specification.
   *
   * @param parsedDid - An object representing the parsed components of a DID URI, including the
   *                    scheme, method, and method-specific identifier.
   * @returns `true` if the DID URI meets the `did:key` method's structural requirements, `false` otherwise.
   *
   */
  static validateIdentifier(parsedDid) {
    const { method, id: multibaseValue } = parsedDid;
    const [scheme] = parsedDid.uri.split(":", 1);
    const version = "1";
    return scheme === "did" && method === "key" && Number(version) > 0 && universalTypeOf(multibaseValue) === "String" && multibaseValue.startsWith("z");
  }
};
DidKey.methodName = "key";
var DidKeyUtils = class _DidKeyUtils {
  /**
   * Converts a JWK (JSON Web Key) to a Multicodec code and name.
   *
   * @example
   * ```ts
   * const jwk: Jwk = { crv: 'Ed25519', kty: 'OKP', x: '...' };
   * const { code, name } = await DidKeyUtils.jwkToMulticodec({ jwk });
   * ```
   *
   * @param params - The parameters for the conversion.
   * @param params.jwk - The JSON Web Key to be converted.
   * @returns A promise that resolves to a Multicodec definition.
   */
  static jwkToMulticodec({ jwk }) {
    return __awaiter19(this, void 0, void 0, function* () {
      const params = [];
      if (jwk.crv) {
        params.push(jwk.crv);
        if (jwk.d) {
          params.push("private");
        } else {
          params.push("public");
        }
      }
      const lookupKey = params.join(":");
      const name = _DidKeyUtils.JWK_TO_MULTICODEC[lookupKey];
      if (name === void 0) {
        throw new Error(`Unsupported JWK to Multicodec conversion: '${lookupKey}'`);
      }
      const code = Multicodec.getCodeFromName({ name });
      return { code, name };
    });
  }
  /**
   * Returns the appropriate public key compressor for the specified cryptographic curve.
   *
   * @param curve - The cryptographic curve to use for the key conversion.
   * @returns A public key compressor for the specified curve.
   */
  static keyCompressor(curve) {
    const compressors = {
      "P-256": Secp256r1.compressPublicKey,
      "secp256k1": Secp256k1.compressPublicKey
    };
    const compressor = compressors[curve];
    if (!compressor)
      throw new DidError(DidErrorCode.InvalidPublicKeyType, `Unsupported curve: ${curve}`);
    return compressor;
  }
  /**
   * Returns the appropriate key converter for the specified cryptographic curve.
   *
   * @param curve - The cryptographic curve to use for the key conversion.
   * @returns An `AsymmetricKeyConverter` for the specified curve.
   */
  static keyConverter(curve) {
    const converters = {
      "Ed25519": Ed25519,
      "P-256": Secp256r1,
      "secp256k1": Secp256k1,
      "X25519": X25519
    };
    const converter = converters[curve];
    if (!converter)
      throw new DidError(DidErrorCode.InvalidPublicKeyType, `Unsupported curve: ${curve}`);
    return converter;
  }
  /**
   * Converts a Multicodec code or name to parial JWK (JSON Web Key).
   *
   * @example
   * ```ts
   * const partialJwk = await DidKeyUtils.multicodecToJwk({ name: 'ed25519-pub' });
   * ```
   *
   * @param params - The parameters for the conversion.
   * @param params.code - Optional Multicodec code to convert.
   * @param params.name - Optional Multicodec name to convert.
   * @returns A promise that resolves to a JOSE format key.
   */
  static multicodecToJwk({ code, name }) {
    return __awaiter19(this, void 0, void 0, function* () {
      if (!(name ? !code : code)) {
        throw new Error(`Either 'name' or 'code' must be defined, but not both.`);
      }
      name = name === void 0 ? Multicodec.getNameFromCode({ code }) : name;
      const lookupKey = name;
      const jose = _DidKeyUtils.MULTICODEC_TO_JWK[lookupKey];
      if (jose === void 0) {
        throw new Error(`Unsupported Multicodec to JWK conversion`);
      }
      return Object.assign({}, jose);
    });
  }
  /**
   * Converts a public key in JWK (JSON Web Key) format to a multibase identifier.
   *
   * @remarks
   * Note: All secp public keys are converted to compressed point encoding
   *       before the multibase identifier is computed.
   *
   * Per {@link https://github.com/multiformats/multicodec/blob/master/table.csv | Multicodec table}:
   *    Public keys for Elliptic Curve cryptography algorithms (e.g., secp256k1,
   *    secp256k1r1, secp384r1, etc.) are always represented with compressed point
   *    encoding (e.g., secp256k1-pub, p256-pub, p384-pub, etc.).
   *
   * Per {@link https://datatracker.ietf.org/doc/html/rfc8812#name-jose-and-cose-secp256k1-cur | RFC 8812}:
   *    "As a compressed point encoding representation is not defined for JWK
   *    elliptic curve points, the uncompressed point encoding defined there
   *    MUST be used. The x and y values represented MUST both be exactly
   *    256 bits, with any leading zeros preserved."
   *
   * @example
   * ```ts
   * const publicKey = { crv: 'Ed25519', kty: 'OKP', x: '...' };
   * const multibaseId = await DidKeyUtils.publicKeyToMultibaseId({ publicKey });
   * ```
   *
   * @param params - The parameters for the conversion.
   * @param params.publicKey - The public key in JWK format.
   * @returns A promise that resolves to the multibase identifier.
   */
  static publicKeyToMultibaseId({ publicKey }) {
    var _a;
    return __awaiter19(this, void 0, void 0, function* () {
      if (!((publicKey === null || publicKey === void 0 ? void 0 : publicKey.crv) && publicKey.crv in AlgorithmToKeyTypeMap3)) {
        throw new DidError(DidErrorCode.InvalidPublicKeyType, `Public key contains an unsupported key type: ${(_a = publicKey === null || publicKey === void 0 ? void 0 : publicKey.crv) !== null && _a !== void 0 ? _a : "undefined"}`);
      }
      let publicKeyBytes = yield _DidKeyUtils.keyConverter(publicKey.crv).publicKeyToBytes({ publicKey });
      if (/^(secp256k1|P-256|P-384|P-521)$/.test(publicKey.crv)) {
        publicKeyBytes = yield _DidKeyUtils.keyCompressor(publicKey.crv)({ publicKeyBytes });
      }
      const { name: multicodecName } = yield _DidKeyUtils.jwkToMulticodec({ jwk: publicKey });
      const multibaseId = keyBytesToMultibaseId({
        keyBytes: publicKeyBytes,
        multicodecName
      });
      return multibaseId;
    });
  }
};
DidKeyUtils.JWK_TO_MULTICODEC = {
  "Ed25519:public": "ed25519-pub",
  "Ed25519:private": "ed25519-priv",
  "secp256k1:public": "secp256k1-pub",
  "secp256k1:private": "secp256k1-priv",
  "X25519:public": "x25519-pub",
  "X25519:private": "x25519-priv"
};
DidKeyUtils.MULTICODEC_PUBLIC_KEY_LENGTH = {
  // secp256k1-pub - Secp256k1 public key (compressed) - 33 bytes
  231: 33,
  // x25519-pub - Curve25519 public key - 32 bytes
  236: 32,
  // ed25519-pub - Ed25519 public key - 32 bytes
  237: 32
};
DidKeyUtils.MULTICODEC_TO_JWK = {
  "ed25519-pub": { crv: "Ed25519", kty: "OKP", x: "" },
  "ed25519-priv": { crv: "Ed25519", kty: "OKP", x: "", d: "" },
  "secp256k1-pub": { crv: "secp256k1", kty: "EC", x: "", y: "" },
  "secp256k1-priv": { crv: "secp256k1", kty: "EC", x: "", y: "", d: "" },
  "x25519-pub": { crv: "X25519", kty: "OKP", x: "" },
  "x25519-priv": { crv: "X25519", kty: "OKP", x: "", d: "" }
};

// node_modules/@tbdex/protocol/node_modules/@web5/dids/dist/esm/methods/did-web.js
var import_dist51 = __toESM(require_dist(), 1);
var __awaiter20 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DidWeb = class _DidWeb extends DidMethod {
  /**
   * Resolves a `did:web` identifier to a DID Document.
   *
   * @param didUri - The DID to be resolved.
   * @param _options - Optional parameters for resolving the DID. Unused by this DID method.
   * @returns A Promise resolving to a {@link DidResolutionResult} object representing the result of the resolution.
   */
  static resolve(didUri, _options) {
    return __awaiter20(this, void 0, void 0, function* () {
      const parsedDid = Did.parse(didUri);
      if (!parsedDid) {
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didResolutionMetadata: { error: "invalidDid" } });
      }
      if (parsedDid.method !== _DidWeb.methodName) {
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didResolutionMetadata: { error: "methodNotSupported" } });
      }
      let baseUrl = `https://${parsedDid.id.replace(/:/g, "/")}`;
      baseUrl = decodeURIComponent(baseUrl);
      const didDocumentUrl = parsedDid.id.includes(":") ? `${baseUrl}/did.json` : `${baseUrl}/.well-known/did.json`;
      try {
        const response = yield fetch(didDocumentUrl);
        if (!response.ok)
          throw new Error("HTTP error status code returned");
        const didDocument = yield response.json();
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didDocument });
      } catch (error) {
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didResolutionMetadata: { error: "notFound" } });
      }
    });
  }
};
DidWeb.methodName = "web";

// node_modules/@tbdex/protocol/node_modules/@web5/dids/dist/esm/resolver/resolver-cache-level.js
var import_dist52 = __toESM(require_dist(), 1);
var import_ms = __toESM(require_ms(), 1);
var import_level2 = __toESM(require_browser2(), 1);

// node_modules/@tbdex/protocol/node_modules/@web5/dids/dist/esm/resolver/resolver-cache-noop.js
var import_dist53 = __toESM(require_dist(), 1);
var DidResolverCacheNoop = {
  get: function(_key) {
    return null;
  },
  set: function(_key, _value) {
    return null;
  },
  delete: function(_key) {
    return null;
  },
  clear: function() {
    return null;
  },
  close: function() {
    return null;
  }
};

// node_modules/@tbdex/protocol/node_modules/@web5/dids/dist/esm/resolver/universal-resolver.js
var import_dist54 = __toESM(require_dist(), 1);
var __awaiter21 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var UniversalResolver = class {
  /**
   * Constructs a new `DidResolver`.
   *
   * @param params - The parameters for constructing the `DidResolver`.
   */
  constructor({ cache, didResolvers }) {
    this.didResolvers = /* @__PURE__ */ new Map();
    this.cache = cache || DidResolverCacheNoop;
    for (const resolver of didResolvers) {
      this.didResolvers.set(resolver.methodName, resolver);
    }
  }
  /**
   * Resolves a DID to a DID Resolution Result.
   *
   * If the DID Resolution Result is present in the cache, it returns the cached result. Otherwise,
   * it uses the appropriate method resolver to resolve the DID, stores the resolution result in the
   * cache, and returns the resolultion result.
   *
   * @param didUri - The DID or DID URL to resolve.
   * @returns A promise that resolves to the DID Resolution Result.
   */
  resolve(didUri, options) {
    return __awaiter21(this, void 0, void 0, function* () {
      const parsedDid = Did.parse(didUri);
      if (!parsedDid) {
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didResolutionMetadata: {
          error: DidErrorCode.InvalidDid,
          errorMessage: `Invalid DID URI: ${didUri}`
        } });
      }
      const resolver = this.didResolvers.get(parsedDid.method);
      if (!resolver) {
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didResolutionMetadata: {
          error: DidErrorCode.MethodNotSupported,
          errorMessage: `Method not supported: ${parsedDid.method}`
        } });
      }
      const cachedResolutionResult = yield this.cache.get(parsedDid.uri);
      if (cachedResolutionResult) {
        return cachedResolutionResult;
      } else {
        const resolutionResult = yield resolver.resolve(parsedDid.uri, options);
        yield this.cache.set(parsedDid.uri, resolutionResult);
        return resolutionResult;
      }
    });
  }
  /**
   * Dereferences a DID (Decentralized Identifier) URL to a corresponding DID resource.
   *
   * This method interprets the DID URL's components, which include the DID method, method-specific
   * identifier, path, query, and fragment, and retrieves the related resource as per the DID Core
   * specifications.
   *
   * The dereferencing process involves resolving the DID contained in the DID URL to a DID document,
   * and then extracting the specific part of the document identified by the fragment in the DID URL.
   * If no fragment is specified, the entire DID document is returned.
   *
   * This method supports resolution of different components within a DID document such as service
   * endpoints and verification methods, based on their IDs. It accommodates both full and
   * DID URLs as specified in the DID Core specification.
   *
   * More information on DID URL dereferencing can be found in the
   * {@link https://www.w3.org/TR/did-core/#did-url-dereferencing | DID Core specification}.
   *
   * TODO: This is a partial implementation and does not fully implement DID URL dereferencing. (https://github.com/TBD54566975/web5-js/issues/387)
   *
   * @param didUrl - The DID URL string to dereference.
   * @param [_options] - Input options to the dereference function. Optional.
   * @returns a {@link DidDereferencingResult}
   */
  dereference(didUrl, _options) {
    return __awaiter21(this, void 0, void 0, function* () {
      const parsedDidUrl = Did.parse(didUrl);
      if (!parsedDidUrl) {
        return {
          dereferencingMetadata: { error: DidErrorCode.InvalidDidUrl },
          contentStream: null,
          contentMetadata: {}
        };
      }
      const { didDocument, didResolutionMetadata, didDocumentMetadata } = yield this.resolve(parsedDidUrl.uri);
      if (!didDocument) {
        return {
          dereferencingMetadata: { error: didResolutionMetadata.error },
          contentStream: null,
          contentMetadata: {}
        };
      }
      if (!parsedDidUrl.fragment || parsedDidUrl.query) {
        return {
          dereferencingMetadata: { contentType: "application/did+json" },
          contentStream: didDocument,
          contentMetadata: didDocumentMetadata
        };
      }
      const { service = [], verificationMethod = [] } = didDocument;
      const idSet = /* @__PURE__ */ new Set([didUrl, parsedDidUrl.fragment, `#${parsedDidUrl.fragment}`]);
      let didResource;
      for (let vm of verificationMethod) {
        if (idSet.has(vm.id)) {
          didResource = vm;
          break;
        }
      }
      for (let svc of service) {
        if (idSet.has(svc.id)) {
          didResource = svc;
          break;
        }
      }
      if (didResource) {
        return {
          dereferencingMetadata: { contentType: "application/did+json" },
          contentStream: didResource,
          contentMetadata: didResolutionMetadata
        };
      } else {
        return {
          dereferencingMetadata: { error: DidErrorCode.NotFound },
          contentStream: null,
          contentMetadata: {}
        };
      }
    });
  }
};

// node_modules/@tbdex/protocol/dist/esm/src/did-resolver.js
var DidResolver = new UniversalResolver({
  didResolvers: [DidDht, DidJwk, DidWeb]
});
async function resolveDid(did) {
  const { didResolutionMetadata, didDocument } = await DidResolver.resolve(did);
  if (didResolutionMetadata.error) {
    throw new Error(`Failed to resolve DID: ${did}. Error: ${didResolutionMetadata.error}`);
  }
  return didDocument;
}
function isVerificationMethod(didResource) {
  return !!didResource && "id" in didResource && "type" in didResource && "controller" in didResource;
}

// node_modules/@tbdex/protocol/dist/esm/src/crypto.js
var import_canonicalize = __toESM(require_canonicalize(), 1);
var keyManager = new LocalKeyManager();
var Crypto = class {
  /**
   * Computes a digest of the payload by:
   * * JSON serializing the payload as per [RFC-8785: JSON Canonicalization Scheme](https://www.rfc-editor.org/rfc/rfc8785)
   * * sha256 hashing the serialized payload
   *
   * @returns The SHA-256 hash of the canonicalized payload, represented as a byte array.
   */
  static digest(payload) {
    const canonicalized = (0, import_canonicalize.default)(payload);
    const canonicalizedBytes = Convert.string(canonicalized).toUint8Array();
    return sha256(canonicalizedBytes);
  }
  /**
   * Signs the provided payload and produces a compact JSON Web Signature (JWS).
   *
   * @param opts - The options required for signing.
   * @returns A promise that resolves to the generated compact JWS.
   * @throws Will throw an error if the specified algorithm is not supported.
   */
  static async sign(opts) {
    const { did, payload, detached } = opts;
    const signer = await did.getSigner();
    let verificationMethodId = signer.keyId;
    if (verificationMethodId.startsWith("#")) {
      verificationMethodId = `${did.uri}${verificationMethodId}`;
    }
    const jwsHeader = { alg: signer.algorithm, kid: verificationMethodId };
    const base64UrlEncodedJwsHeader = Convert.object(jwsHeader).toBase64Url();
    const base64urlEncodedJwsPayload = Convert.uint8Array(payload).toBase64Url();
    const toSign = `${base64UrlEncodedJwsHeader}.${base64urlEncodedJwsPayload}`;
    const toSignBytes = Convert.string(toSign).toUint8Array();
    const signatureBytes = await signer.sign({ data: toSignBytes });
    const base64UrlEncodedSignature = Convert.uint8Array(signatureBytes).toBase64Url();
    if (detached) {
      return `${base64UrlEncodedJwsHeader}..${base64UrlEncodedSignature}`;
    } else {
      return `${base64UrlEncodedJwsHeader}.${base64urlEncodedJwsPayload}.${base64UrlEncodedSignature}`;
    }
  }
  /**
   * Verifies the integrity of a message or resource's signature.
   *
   * @param opts - The options required for verification.
   * @returns A promise that resolves to the DID of the signer if verification is successful.
   * @throws Various errors related to invalid input or failed verification.
   */
  static async verify(opts) {
    const { signature, detachedPayload } = opts;
    if (!signature) {
      throw new Error("Signature verification failed: Expected signature property to exist");
    }
    const splitJws = signature.split(".");
    if (splitJws.length !== 3) {
      throw new Error("Signature verification failed: Expected valid JWS with detached content");
    }
    let [base64UrlEncodedJwsHeader, base64urlEncodedJwsPayload, base64UrlEncodedSignature] = splitJws;
    if (detachedPayload) {
      if (base64urlEncodedJwsPayload.length !== 0) {
        throw new Error("Signature verification failed: Expected valid JWS with detached content");
      }
      base64urlEncodedJwsPayload = Convert.uint8Array(detachedPayload).toBase64Url();
    }
    const jwsHeader = Convert.base64Url(base64UrlEncodedJwsHeader).toObject();
    if (!jwsHeader.alg || !jwsHeader.kid) {
      throw new Error("Signature verification failed: Expected JWS header to contain alg and kid");
    }
    const dereferenceResult = await DidResolver.dereference(jwsHeader.kid);
    const verificationMethod = dereferenceResult.contentStream;
    if (!isVerificationMethod(verificationMethod)) {
      throw new Error("Signature verification failed: Expected kid in JWS header to dereference to a DID Document Verification Method");
    }
    const publicKeyJwk = verificationMethod.publicKeyJwk;
    if (!publicKeyJwk) {
      throw new Error("Signature verification failed: Expected kid in JWS header to dereference to a DID Document Verification Method with publicKeyJwk");
    }
    const signedData = `${base64UrlEncodedJwsHeader}.${base64urlEncodedJwsPayload}`;
    const signedDataBytes = Convert.string(signedData).toUint8Array();
    const signatureBytes = Convert.base64Url(base64UrlEncodedSignature).toUint8Array();
    const isLegit = await keyManager.verify({ key: publicKeyJwk, data: signedDataBytes, signature: signatureBytes });
    if (!isLegit) {
      throw new Error("Signature verification failed: Integrity mismatch");
    }
    const [did] = jwsHeader.kid.split("#");
    return did;
  }
};

// node_modules/@tbdex/protocol/dist/esm/src/validator.js
var import_dist59 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/dist/esm/generated/compiled-validators.js
var compiled_validators_exports = {};
__export(compiled_validators_exports, {
  balance: () => balance,
  close: () => close,
  definitions: () => definitions,
  message: () => message,
  offering: () => offering,
  order: () => order,
  orderstatus: () => orderstatus,
  quote: () => quote,
  resource: () => resource,
  rfq: () => rfq,
  rfqPrivate: () => rfqPrivate
});
var import_dist58 = __toESM(require_dist(), 1);
var import_equal = __toESM(require_equal(), 1);
var close = validate10;
function validate10(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      const _errs1 = errors;
      for (const key0 in data) {
        if (!(key0 === "reason" || key0 === "success")) {
          validate10.errors = [{ instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" }];
          return false;
          break;
        }
      }
      if (_errs1 === errors) {
        if (data.reason !== void 0) {
          const _errs2 = errors;
          if (typeof data.reason !== "string") {
            validate10.errors = [{ instancePath: instancePath + "/reason", schemaPath: "#/properties/reason/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
            return false;
          }
          var valid0 = _errs2 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.success !== void 0) {
            const _errs4 = errors;
            if (typeof data.success !== "boolean") {
              validate10.errors = [{ instancePath: instancePath + "/success", schemaPath: "#/properties/success/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
              return false;
            }
            var valid0 = _errs4 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate10.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate10.errors = vErrors;
  return errors === 0;
}
var definitions = validate11;
function validate11(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  if (!(data && typeof data == "object" && !Array.isArray(data))) {
    validate11.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
    return false;
  }
  validate11.errors = vErrors;
  return errors === 0;
}
var offering = validate12;
var schema13 = { "$schema": "http://json-schema.org/draft-07/schema#", "$id": "https://tbdex.dev/offering.schema.json", "type": "object", "properties": { "additionalProperties": false, "description": { "type": "string", "description": "Brief description of what is being offered." }, "payin": { "type": "object", "additionalProperties": false, "properties": { "currencyCode": { "type": "string", "description": "ISO 3166 currency code string" }, "min": { "$ref": "definitions.json#/definitions/decimalString", "description": "Minimum amount of currency that can be requested" }, "max": { "$ref": "definitions.json#/definitions/decimalString", "description": "Maximum amount of currency that can be requested" }, "methods": { "type": "array", "items": { "type": "object", "additionalProperties": false, "properties": { "kind": { "type": "string", "description": "The type of payment method. e.g. BITCOIN_ADDRESS, DEBIT_CARD, etc." }, "name": { "type": "string", "description": "Payment Method name. Expected to be rendered on screen." }, "description": { "type": "string", "description": 'Blurb containing helpful information about the payment method. Expected to be rendered on screen. e.g. "segwit addresses only"' }, "group": { "type": "string", "description": "Value that can be used to group specific payment methods together (e.g. Mobile Money vs. Direct Bank Deposit)." }, "requiredPaymentDetails": { "$ref": "http://json-schema.org/draft-07/schema", "description": "A JSON Schema containing the fields that need to be collected in order to use this payment method" }, "min": { "$ref": "definitions.json#/definitions/decimalString", "description": "Minimum amount required to use this payment method." }, "max": { "$ref": "definitions.json#/definitions/decimalString", "description": "Maximum amount allowed when using this payment method." }, "fee": { "$ref": "definitions.json#/definitions/decimalString", "description": "Fee charged to use this payment method. Absence of this field implies that there is no _additional_ fee associated to the respective payment method." } }, "required": ["kind"] } } }, "required": ["currencyCode", "methods"] }, "payout": { "type": "object", "additionalProperties": false, "properties": { "currencyCode": { "type": "string", "description": "ISO 3166 currency code string" }, "min": { "$ref": "definitions.json#/definitions/decimalString", "description": "Minimum amount of currency that can be requested" }, "max": { "$ref": "definitions.json#/definitions/decimalString", "description": "Maximum amount of currency that can be requested" }, "methods": { "type": "array", "items": { "type": "object", "additionalProperties": false, "properties": { "kind": { "type": "string", "description": "The type of payment method. e.g. BITCOIN_ADDRESS, DEBIT_CARD, etc." }, "name": { "type": "string", "description": "Payment Method name. Expected to be rendered on screen." }, "description": { "type": "string", "description": 'Blurb containing helpful information about the payment method. Expected to be rendered on screen. e.g. "segwit addresses only"' }, "group": { "type": "string", "description": "Value that can be used to group specific payment methods together (e.g. Mobile Money vs. Direct Bank Deposit)." }, "requiredPaymentDetails": { "$ref": "http://json-schema.org/draft-07/schema", "description": "A JSON Schema containing the fields that need to be collected in order to use this payment method" }, "min": { "$ref": "definitions.json#/definitions/decimalString", "description": "Minimum amount required to use this payment method." }, "max": { "$ref": "definitions.json#/definitions/decimalString", "description": "Maximum amount allowed when using this payment method." }, "fee": { "$ref": "definitions.json#/definitions/decimalString", "description": "Fee charged to use this payment method. absence of this field implies that there is no _additional_ fee associated to the respective payment method" }, "estimatedSettlementTime": { "type": "number", "description": "Estimated time in seconds for the payout to be settled. e.g. 3600 for 1 hour. 0 for instant settlement.", "minimum": 0 } }, "required": ["kind", "estimatedSettlementTime"] } } }, "required": ["currencyCode", "methods"] }, "payoutUnitsPerPayinUnit": { "type": "string", "description": "Number of payout currency units for one payin currency unit (i.e 290000 USD for 1 BTC)" }, "requiredClaims": { "type": "object", "description": "PresentationDefinition that describes the credential(s) the PFI requires in order to provide a quote." } }, "required": ["description", "payin", "payout", "payoutUnitsPerPayinUnit"] };
var pattern0 = new RegExp("^([0-9]+(?:[.][0-9]+)?)$", "u");
var schema0 = { "$schema": "http://json-schema.org/draft-07/schema#", "$id": "http://json-schema.org/draft-07/schema#", "title": "Core schema meta-schema", "definitions": { "schemaArray": { "type": "array", "minItems": 1, "items": { "$ref": "#" } }, "nonNegativeInteger": { "type": "integer", "minimum": 0 }, "nonNegativeIntegerDefault0": { "allOf": [{ "$ref": "#/definitions/nonNegativeInteger" }, { "default": 0 }] }, "simpleTypes": { "enum": ["array", "boolean", "integer", "null", "number", "object", "string"] }, "stringArray": { "type": "array", "items": { "type": "string" }, "uniqueItems": true, "default": [] } }, "type": ["object", "boolean"], "properties": { "$id": { "type": "string", "format": "uri-reference" }, "$schema": { "type": "string", "format": "uri" }, "$ref": { "type": "string", "format": "uri-reference" }, "$comment": { "type": "string" }, "title": { "type": "string" }, "description": { "type": "string" }, "default": true, "readOnly": { "type": "boolean", "default": false }, "examples": { "type": "array", "items": true }, "multipleOf": { "type": "number", "exclusiveMinimum": 0 }, "maximum": { "type": "number" }, "exclusiveMaximum": { "type": "number" }, "minimum": { "type": "number" }, "exclusiveMinimum": { "type": "number" }, "maxLength": { "$ref": "#/definitions/nonNegativeInteger" }, "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "pattern": { "type": "string", "format": "regex" }, "additionalItems": { "$ref": "#" }, "items": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/schemaArray" }], "default": true }, "maxItems": { "$ref": "#/definitions/nonNegativeInteger" }, "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "uniqueItems": { "type": "boolean", "default": false }, "contains": { "$ref": "#" }, "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" }, "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "required": { "$ref": "#/definitions/stringArray" }, "additionalProperties": { "$ref": "#" }, "definitions": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "properties": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "patternProperties": { "type": "object", "additionalProperties": { "$ref": "#" }, "propertyNames": { "format": "regex" }, "default": {} }, "dependencies": { "type": "object", "additionalProperties": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/stringArray" }] } }, "propertyNames": { "$ref": "#" }, "const": true, "enum": { "type": "array", "items": true, "minItems": 1, "uniqueItems": true }, "type": { "anyOf": [{ "$ref": "#/definitions/simpleTypes" }, { "type": "array", "items": { "$ref": "#/definitions/simpleTypes" }, "minItems": 1, "uniqueItems": true }] }, "format": { "type": "string" }, "contentMediaType": { "type": "string" }, "contentEncoding": { "type": "string" }, "if": { "$ref": "#" }, "then": { "$ref": "#" }, "else": { "$ref": "#" }, "allOf": { "$ref": "#/definitions/schemaArray" }, "anyOf": { "$ref": "#/definitions/schemaArray" }, "oneOf": { "$ref": "#/definitions/schemaArray" }, "not": { "$ref": "#" } }, "default": true };
var schema9 = { "enum": ["array", "boolean", "integer", "null", "number", "object", "string"] };
function validate1(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  let vErrors = null;
  let errors = 0;
  const _errs1 = errors;
  if (!(typeof data == "number" && (!(data % 1) && !isNaN(data)) && isFinite(data))) {
    validate1.errors = [{ instancePath, schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
    return false;
  }
  if (errors === _errs1) {
    if (typeof data == "number" && isFinite(data)) {
      if (data < 0 || isNaN(data)) {
        validate1.errors = [{ instancePath, schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
        return false;
      }
    }
  }
  validate1.errors = vErrors;
  return errors === 0;
}
var root0 = { validate: validate0 };
function validate3(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (Array.isArray(data)) {
      if (data.length < 1) {
        validate3.errors = [{ instancePath, schemaPath: "#/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }];
        return false;
      } else {
        var valid0 = true;
        const len0 = data.length;
        for (let i0 = 0; i0 < len0; i0++) {
          const _errs1 = errors;
          if (!root0.validate(data[i0], { instancePath: instancePath + "/" + i0, parentData: data, parentDataProperty: i0, rootData })) {
            vErrors = vErrors === null ? root0.validate.errors : vErrors.concat(root0.validate.errors);
            errors = vErrors.length;
          }
          var valid0 = _errs1 === errors;
          if (!valid0) {
            break;
          }
        }
      }
    } else {
      validate3.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
      return false;
    }
  }
  validate3.errors = vErrors;
  return errors === 0;
}
function validate0(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  if (!(data && typeof data == "object" && !Array.isArray(data)) && typeof data !== "boolean") {
    validate0.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: schema0.type }, message: "must be object,boolean" }];
    return false;
  }
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      if (data.$id !== void 0) {
        const _errs1 = errors;
        if (errors === _errs1) {
          if (errors === _errs1) {
            if (!(typeof data.$id === "string")) {
              validate0.errors = [{ instancePath: instancePath + "/$id", schemaPath: "#/properties/%24id/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
              return false;
            }
          }
        }
        var valid0 = _errs1 === errors;
      } else {
        var valid0 = true;
      }
      if (valid0) {
        if (data.$schema !== void 0) {
          const _errs3 = errors;
          if (errors === _errs3) {
            if (errors === _errs3) {
              if (!(typeof data.$schema === "string")) {
                validate0.errors = [{ instancePath: instancePath + "/$schema", schemaPath: "#/properties/%24schema/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                return false;
              }
            }
          }
          var valid0 = _errs3 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.$ref !== void 0) {
            const _errs5 = errors;
            if (errors === _errs5) {
              if (errors === _errs5) {
                if (!(typeof data.$ref === "string")) {
                  validate0.errors = [{ instancePath: instancePath + "/$ref", schemaPath: "#/properties/%24ref/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                  return false;
                }
              }
            }
            var valid0 = _errs5 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.$comment !== void 0) {
              const _errs7 = errors;
              if (typeof data.$comment !== "string") {
                validate0.errors = [{ instancePath: instancePath + "/$comment", schemaPath: "#/properties/%24comment/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                return false;
              }
              var valid0 = _errs7 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.title !== void 0) {
                const _errs9 = errors;
                if (typeof data.title !== "string") {
                  validate0.errors = [{ instancePath: instancePath + "/title", schemaPath: "#/properties/title/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                  return false;
                }
                var valid0 = _errs9 === errors;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data.description !== void 0) {
                  const _errs11 = errors;
                  if (typeof data.description !== "string") {
                    validate0.errors = [{ instancePath: instancePath + "/description", schemaPath: "#/properties/description/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                    return false;
                  }
                  var valid0 = _errs11 === errors;
                } else {
                  var valid0 = true;
                }
                if (valid0) {
                  if (data.readOnly !== void 0) {
                    const _errs13 = errors;
                    if (typeof data.readOnly !== "boolean") {
                      validate0.errors = [{ instancePath: instancePath + "/readOnly", schemaPath: "#/properties/readOnly/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                      return false;
                    }
                    var valid0 = _errs13 === errors;
                  } else {
                    var valid0 = true;
                  }
                  if (valid0) {
                    if (data.examples !== void 0) {
                      const _errs15 = errors;
                      if (errors === _errs15) {
                        if (!Array.isArray(data.examples)) {
                          validate0.errors = [{ instancePath: instancePath + "/examples", schemaPath: "#/properties/examples/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                          return false;
                        }
                      }
                      var valid0 = _errs15 === errors;
                    } else {
                      var valid0 = true;
                    }
                    if (valid0) {
                      if (data.multipleOf !== void 0) {
                        let data8 = data.multipleOf;
                        const _errs17 = errors;
                        if (errors === _errs17) {
                          if (typeof data8 == "number" && isFinite(data8)) {
                            if (data8 <= 0 || isNaN(data8)) {
                              validate0.errors = [{ instancePath: instancePath + "/multipleOf", schemaPath: "#/properties/multipleOf/exclusiveMinimum", keyword: "exclusiveMinimum", params: { comparison: ">", limit: 0 }, message: "must be > 0" }];
                              return false;
                            }
                          } else {
                            validate0.errors = [{ instancePath: instancePath + "/multipleOf", schemaPath: "#/properties/multipleOf/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                            return false;
                          }
                        }
                        var valid0 = _errs17 === errors;
                      } else {
                        var valid0 = true;
                      }
                      if (valid0) {
                        if (data.maximum !== void 0) {
                          let data9 = data.maximum;
                          const _errs19 = errors;
                          if (!(typeof data9 == "number" && isFinite(data9))) {
                            validate0.errors = [{ instancePath: instancePath + "/maximum", schemaPath: "#/properties/maximum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                            return false;
                          }
                          var valid0 = _errs19 === errors;
                        } else {
                          var valid0 = true;
                        }
                        if (valid0) {
                          if (data.exclusiveMaximum !== void 0) {
                            let data10 = data.exclusiveMaximum;
                            const _errs21 = errors;
                            if (!(typeof data10 == "number" && isFinite(data10))) {
                              validate0.errors = [{ instancePath: instancePath + "/exclusiveMaximum", schemaPath: "#/properties/exclusiveMaximum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                              return false;
                            }
                            var valid0 = _errs21 === errors;
                          } else {
                            var valid0 = true;
                          }
                          if (valid0) {
                            if (data.minimum !== void 0) {
                              let data11 = data.minimum;
                              const _errs23 = errors;
                              if (!(typeof data11 == "number" && isFinite(data11))) {
                                validate0.errors = [{ instancePath: instancePath + "/minimum", schemaPath: "#/properties/minimum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                return false;
                              }
                              var valid0 = _errs23 === errors;
                            } else {
                              var valid0 = true;
                            }
                            if (valid0) {
                              if (data.exclusiveMinimum !== void 0) {
                                let data12 = data.exclusiveMinimum;
                                const _errs25 = errors;
                                if (!(typeof data12 == "number" && isFinite(data12))) {
                                  validate0.errors = [{ instancePath: instancePath + "/exclusiveMinimum", schemaPath: "#/properties/exclusiveMinimum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                  return false;
                                }
                                var valid0 = _errs25 === errors;
                              } else {
                                var valid0 = true;
                              }
                              if (valid0) {
                                if (data.maxLength !== void 0) {
                                  let data13 = data.maxLength;
                                  const _errs27 = errors;
                                  const _errs28 = errors;
                                  if (!(typeof data13 == "number" && (!(data13 % 1) && !isNaN(data13)) && isFinite(data13))) {
                                    validate0.errors = [{ instancePath: instancePath + "/maxLength", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                    return false;
                                  }
                                  if (errors === _errs28) {
                                    if (typeof data13 == "number" && isFinite(data13)) {
                                      if (data13 < 0 || isNaN(data13)) {
                                        validate0.errors = [{ instancePath: instancePath + "/maxLength", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
                                        return false;
                                      }
                                    }
                                  }
                                  var valid0 = _errs27 === errors;
                                } else {
                                  var valid0 = true;
                                }
                                if (valid0) {
                                  if (data.minLength !== void 0) {
                                    const _errs30 = errors;
                                    if (!validate1(data.minLength, { instancePath: instancePath + "/minLength", parentData: data, parentDataProperty: "minLength", rootData })) {
                                      vErrors = vErrors === null ? validate1.errors : vErrors.concat(validate1.errors);
                                      errors = vErrors.length;
                                    }
                                    var valid0 = _errs30 === errors;
                                  } else {
                                    var valid0 = true;
                                  }
                                  if (valid0) {
                                    if (data.pattern !== void 0) {
                                      const _errs31 = errors;
                                      if (errors === _errs31) {
                                        if (errors === _errs31) {
                                          if (!(typeof data.pattern === "string")) {
                                            validate0.errors = [{ instancePath: instancePath + "/pattern", schemaPath: "#/properties/pattern/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                            return false;
                                          }
                                        }
                                      }
                                      var valid0 = _errs31 === errors;
                                    } else {
                                      var valid0 = true;
                                    }
                                    if (valid0) {
                                      if (data.additionalItems !== void 0) {
                                        const _errs33 = errors;
                                        if (!validate0(data.additionalItems, { instancePath: instancePath + "/additionalItems", parentData: data, parentDataProperty: "additionalItems", rootData })) {
                                          vErrors = vErrors === null ? validate0.errors : vErrors.concat(validate0.errors);
                                          errors = vErrors.length;
                                        }
                                        var valid0 = _errs33 === errors;
                                      } else {
                                        var valid0 = true;
                                      }
                                      if (valid0) {
                                        if (data.items !== void 0) {
                                          let data17 = data.items;
                                          const _errs34 = errors;
                                          const _errs35 = errors;
                                          let valid2 = false;
                                          const _errs36 = errors;
                                          if (!validate0(data17, { instancePath: instancePath + "/items", parentData: data, parentDataProperty: "items", rootData })) {
                                            vErrors = vErrors === null ? validate0.errors : vErrors.concat(validate0.errors);
                                            errors = vErrors.length;
                                          }
                                          var _valid0 = _errs36 === errors;
                                          valid2 = valid2 || _valid0;
                                          if (!valid2) {
                                            const _errs37 = errors;
                                            if (!validate3(data17, { instancePath: instancePath + "/items", parentData: data, parentDataProperty: "items", rootData })) {
                                              vErrors = vErrors === null ? validate3.errors : vErrors.concat(validate3.errors);
                                              errors = vErrors.length;
                                            }
                                            var _valid0 = _errs37 === errors;
                                            valid2 = valid2 || _valid0;
                                          }
                                          if (!valid2) {
                                            const err0 = { instancePath: instancePath + "/items", schemaPath: "#/properties/items/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                            if (vErrors === null) {
                                              vErrors = [err0];
                                            } else {
                                              vErrors.push(err0);
                                            }
                                            errors++;
                                            validate0.errors = vErrors;
                                            return false;
                                          } else {
                                            errors = _errs35;
                                            if (vErrors !== null) {
                                              if (_errs35) {
                                                vErrors.length = _errs35;
                                              } else {
                                                vErrors = null;
                                              }
                                            }
                                          }
                                          var valid0 = _errs34 === errors;
                                        } else {
                                          var valid0 = true;
                                        }
                                        if (valid0) {
                                          if (data.maxItems !== void 0) {
                                            let data18 = data.maxItems;
                                            const _errs38 = errors;
                                            const _errs39 = errors;
                                            if (!(typeof data18 == "number" && (!(data18 % 1) && !isNaN(data18)) && isFinite(data18))) {
                                              validate0.errors = [{ instancePath: instancePath + "/maxItems", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                              return false;
                                            }
                                            if (errors === _errs39) {
                                              if (typeof data18 == "number" && isFinite(data18)) {
                                                if (data18 < 0 || isNaN(data18)) {
                                                  validate0.errors = [{ instancePath: instancePath + "/maxItems", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
                                                  return false;
                                                }
                                              }
                                            }
                                            var valid0 = _errs38 === errors;
                                          } else {
                                            var valid0 = true;
                                          }
                                          if (valid0) {
                                            if (data.minItems !== void 0) {
                                              const _errs41 = errors;
                                              if (!validate1(data.minItems, { instancePath: instancePath + "/minItems", parentData: data, parentDataProperty: "minItems", rootData })) {
                                                vErrors = vErrors === null ? validate1.errors : vErrors.concat(validate1.errors);
                                                errors = vErrors.length;
                                              }
                                              var valid0 = _errs41 === errors;
                                            } else {
                                              var valid0 = true;
                                            }
                                            if (valid0) {
                                              if (data.uniqueItems !== void 0) {
                                                const _errs42 = errors;
                                                if (typeof data.uniqueItems !== "boolean") {
                                                  validate0.errors = [{ instancePath: instancePath + "/uniqueItems", schemaPath: "#/properties/uniqueItems/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                  return false;
                                                }
                                                var valid0 = _errs42 === errors;
                                              } else {
                                                var valid0 = true;
                                              }
                                              if (valid0) {
                                                if (data.contains !== void 0) {
                                                  const _errs44 = errors;
                                                  if (!validate0(data.contains, { instancePath: instancePath + "/contains", parentData: data, parentDataProperty: "contains", rootData })) {
                                                    vErrors = vErrors === null ? validate0.errors : vErrors.concat(validate0.errors);
                                                    errors = vErrors.length;
                                                  }
                                                  var valid0 = _errs44 === errors;
                                                } else {
                                                  var valid0 = true;
                                                }
                                                if (valid0) {
                                                  if (data.maxProperties !== void 0) {
                                                    let data22 = data.maxProperties;
                                                    const _errs45 = errors;
                                                    const _errs46 = errors;
                                                    if (!(typeof data22 == "number" && (!(data22 % 1) && !isNaN(data22)) && isFinite(data22))) {
                                                      validate0.errors = [{ instancePath: instancePath + "/maxProperties", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                      return false;
                                                    }
                                                    if (errors === _errs46) {
                                                      if (typeof data22 == "number" && isFinite(data22)) {
                                                        if (data22 < 0 || isNaN(data22)) {
                                                          validate0.errors = [{ instancePath: instancePath + "/maxProperties", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
                                                          return false;
                                                        }
                                                      }
                                                    }
                                                    var valid0 = _errs45 === errors;
                                                  } else {
                                                    var valid0 = true;
                                                  }
                                                  if (valid0) {
                                                    if (data.minProperties !== void 0) {
                                                      const _errs48 = errors;
                                                      if (!validate1(data.minProperties, { instancePath: instancePath + "/minProperties", parentData: data, parentDataProperty: "minProperties", rootData })) {
                                                        vErrors = vErrors === null ? validate1.errors : vErrors.concat(validate1.errors);
                                                        errors = vErrors.length;
                                                      }
                                                      var valid0 = _errs48 === errors;
                                                    } else {
                                                      var valid0 = true;
                                                    }
                                                    if (valid0) {
                                                      if (data.required !== void 0) {
                                                        let data24 = data.required;
                                                        const _errs49 = errors;
                                                        const _errs50 = errors;
                                                        if (errors === _errs50) {
                                                          if (Array.isArray(data24)) {
                                                            var valid6 = true;
                                                            const len0 = data24.length;
                                                            for (let i0 = 0; i0 < len0; i0++) {
                                                              const _errs52 = errors;
                                                              if (typeof data24[i0] !== "string") {
                                                                validate0.errors = [{ instancePath: instancePath + "/required/" + i0, schemaPath: "#/definitions/stringArray/items/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                return false;
                                                              }
                                                              var valid6 = _errs52 === errors;
                                                              if (!valid6) {
                                                                break;
                                                              }
                                                            }
                                                            if (valid6) {
                                                              let i1 = data24.length;
                                                              let j0;
                                                              if (i1 > 1) {
                                                                const indices0 = {};
                                                                for (; i1--; ) {
                                                                  let item0 = data24[i1];
                                                                  if (typeof item0 !== "string") {
                                                                    continue;
                                                                  }
                                                                  if (typeof indices0[item0] == "number") {
                                                                    j0 = indices0[item0];
                                                                    validate0.errors = [{ instancePath: instancePath + "/required", schemaPath: "#/definitions/stringArray/uniqueItems", keyword: "uniqueItems", params: { i: i1, j: j0 }, message: "must NOT have duplicate items (items ## " + j0 + " and " + i1 + " are identical)" }];
                                                                    return false;
                                                                    break;
                                                                  }
                                                                  indices0[item0] = i1;
                                                                }
                                                              }
                                                            }
                                                          } else {
                                                            validate0.errors = [{ instancePath: instancePath + "/required", schemaPath: "#/definitions/stringArray/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                                                            return false;
                                                          }
                                                        }
                                                        var valid0 = _errs49 === errors;
                                                      } else {
                                                        var valid0 = true;
                                                      }
                                                      if (valid0) {
                                                        if (data.additionalProperties !== void 0) {
                                                          const _errs54 = errors;
                                                          if (!validate0(data.additionalProperties, { instancePath: instancePath + "/additionalProperties", parentData: data, parentDataProperty: "additionalProperties", rootData })) {
                                                            vErrors = vErrors === null ? validate0.errors : vErrors.concat(validate0.errors);
                                                            errors = vErrors.length;
                                                          }
                                                          var valid0 = _errs54 === errors;
                                                        } else {
                                                          var valid0 = true;
                                                        }
                                                        if (valid0) {
                                                          if (data.definitions !== void 0) {
                                                            let data27 = data.definitions;
                                                            const _errs55 = errors;
                                                            if (errors === _errs55) {
                                                              if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                                                                for (const key0 in data27) {
                                                                  const _errs58 = errors;
                                                                  if (!validate0(data27[key0], { instancePath: instancePath + "/definitions/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data27, parentDataProperty: key0, rootData })) {
                                                                    vErrors = vErrors === null ? validate0.errors : vErrors.concat(validate0.errors);
                                                                    errors = vErrors.length;
                                                                  }
                                                                  var valid8 = _errs58 === errors;
                                                                  if (!valid8) {
                                                                    break;
                                                                  }
                                                                }
                                                              } else {
                                                                validate0.errors = [{ instancePath: instancePath + "/definitions", schemaPath: "#/properties/definitions/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                return false;
                                                              }
                                                            }
                                                            var valid0 = _errs55 === errors;
                                                          } else {
                                                            var valid0 = true;
                                                          }
                                                          if (valid0) {
                                                            if (data.properties !== void 0) {
                                                              let data29 = data.properties;
                                                              const _errs59 = errors;
                                                              if (errors === _errs59) {
                                                                if (data29 && typeof data29 == "object" && !Array.isArray(data29)) {
                                                                  for (const key1 in data29) {
                                                                    const _errs62 = errors;
                                                                    if (!validate0(data29[key1], { instancePath: instancePath + "/properties/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data29, parentDataProperty: key1, rootData })) {
                                                                      vErrors = vErrors === null ? validate0.errors : vErrors.concat(validate0.errors);
                                                                      errors = vErrors.length;
                                                                    }
                                                                    var valid9 = _errs62 === errors;
                                                                    if (!valid9) {
                                                                      break;
                                                                    }
                                                                  }
                                                                } else {
                                                                  validate0.errors = [{ instancePath: instancePath + "/properties", schemaPath: "#/properties/properties/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                  return false;
                                                                }
                                                              }
                                                              var valid0 = _errs59 === errors;
                                                            } else {
                                                              var valid0 = true;
                                                            }
                                                            if (valid0) {
                                                              if (data.patternProperties !== void 0) {
                                                                let data31 = data.patternProperties;
                                                                const _errs63 = errors;
                                                                if (errors === _errs63) {
                                                                  if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                                                                    for (const key2 in data31) {
                                                                      const _errs65 = errors;
                                                                      var valid10 = _errs65 === errors;
                                                                      if (!valid10) {
                                                                        const err1 = { instancePath: instancePath + "/patternProperties", schemaPath: "#/properties/patternProperties/propertyNames", keyword: "propertyNames", params: { propertyName: key2 }, message: "property name must be valid" };
                                                                        if (vErrors === null) {
                                                                          vErrors = [err1];
                                                                        } else {
                                                                          vErrors.push(err1);
                                                                        }
                                                                        errors++;
                                                                        validate0.errors = vErrors;
                                                                        return false;
                                                                        break;
                                                                      }
                                                                    }
                                                                    if (valid10) {
                                                                      for (const key3 in data31) {
                                                                        const _errs67 = errors;
                                                                        if (!validate0(data31[key3], { instancePath: instancePath + "/patternProperties/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data31, parentDataProperty: key3, rootData })) {
                                                                          vErrors = vErrors === null ? validate0.errors : vErrors.concat(validate0.errors);
                                                                          errors = vErrors.length;
                                                                        }
                                                                        var valid11 = _errs67 === errors;
                                                                        if (!valid11) {
                                                                          break;
                                                                        }
                                                                      }
                                                                    }
                                                                  } else {
                                                                    validate0.errors = [{ instancePath: instancePath + "/patternProperties", schemaPath: "#/properties/patternProperties/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                    return false;
                                                                  }
                                                                }
                                                                var valid0 = _errs63 === errors;
                                                              } else {
                                                                var valid0 = true;
                                                              }
                                                              if (valid0) {
                                                                if (data.dependencies !== void 0) {
                                                                  let data33 = data.dependencies;
                                                                  const _errs68 = errors;
                                                                  if (errors === _errs68) {
                                                                    if (data33 && typeof data33 == "object" && !Array.isArray(data33)) {
                                                                      for (const key4 in data33) {
                                                                        let data34 = data33[key4];
                                                                        const _errs71 = errors;
                                                                        const _errs72 = errors;
                                                                        let valid13 = false;
                                                                        const _errs73 = errors;
                                                                        if (!validate0(data34, { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data33, parentDataProperty: key4, rootData })) {
                                                                          vErrors = vErrors === null ? validate0.errors : vErrors.concat(validate0.errors);
                                                                          errors = vErrors.length;
                                                                        }
                                                                        var _valid1 = _errs73 === errors;
                                                                        valid13 = valid13 || _valid1;
                                                                        if (!valid13) {
                                                                          const _errs74 = errors;
                                                                          const _errs75 = errors;
                                                                          if (errors === _errs75) {
                                                                            if (Array.isArray(data34)) {
                                                                              var valid15 = true;
                                                                              const len1 = data34.length;
                                                                              for (let i2 = 0; i2 < len1; i2++) {
                                                                                const _errs77 = errors;
                                                                                if (typeof data34[i2] !== "string") {
                                                                                  const err2 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1") + "/" + i2, schemaPath: "#/definitions/stringArray/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                                                  if (vErrors === null) {
                                                                                    vErrors = [err2];
                                                                                  } else {
                                                                                    vErrors.push(err2);
                                                                                  }
                                                                                  errors++;
                                                                                }
                                                                                var valid15 = _errs77 === errors;
                                                                                if (!valid15) {
                                                                                  break;
                                                                                }
                                                                              }
                                                                              if (valid15) {
                                                                                let i3 = data34.length;
                                                                                let j1;
                                                                                if (i3 > 1) {
                                                                                  const indices1 = {};
                                                                                  for (; i3--; ) {
                                                                                    let item1 = data34[i3];
                                                                                    if (typeof item1 !== "string") {
                                                                                      continue;
                                                                                    }
                                                                                    if (typeof indices1[item1] == "number") {
                                                                                      j1 = indices1[item1];
                                                                                      const err3 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/stringArray/uniqueItems", keyword: "uniqueItems", params: { i: i3, j: j1 }, message: "must NOT have duplicate items (items ## " + j1 + " and " + i3 + " are identical)" };
                                                                                      if (vErrors === null) {
                                                                                        vErrors = [err3];
                                                                                      } else {
                                                                                        vErrors.push(err3);
                                                                                      }
                                                                                      errors++;
                                                                                      break;
                                                                                    }
                                                                                    indices1[item1] = i3;
                                                                                  }
                                                                                }
                                                                              }
                                                                            } else {
                                                                              const err4 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/stringArray/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                                              if (vErrors === null) {
                                                                                vErrors = [err4];
                                                                              } else {
                                                                                vErrors.push(err4);
                                                                              }
                                                                              errors++;
                                                                            }
                                                                          }
                                                                          var _valid1 = _errs74 === errors;
                                                                          valid13 = valid13 || _valid1;
                                                                        }
                                                                        if (!valid13) {
                                                                          const err5 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/dependencies/additionalProperties/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                          if (vErrors === null) {
                                                                            vErrors = [err5];
                                                                          } else {
                                                                            vErrors.push(err5);
                                                                          }
                                                                          errors++;
                                                                          validate0.errors = vErrors;
                                                                          return false;
                                                                        } else {
                                                                          errors = _errs72;
                                                                          if (vErrors !== null) {
                                                                            if (_errs72) {
                                                                              vErrors.length = _errs72;
                                                                            } else {
                                                                              vErrors = null;
                                                                            }
                                                                          }
                                                                        }
                                                                        var valid12 = _errs71 === errors;
                                                                        if (!valid12) {
                                                                          break;
                                                                        }
                                                                      }
                                                                    } else {
                                                                      validate0.errors = [{ instancePath: instancePath + "/dependencies", schemaPath: "#/properties/dependencies/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                      return false;
                                                                    }
                                                                  }
                                                                  var valid0 = _errs68 === errors;
                                                                } else {
                                                                  var valid0 = true;
                                                                }
                                                                if (valid0) {
                                                                  if (data.propertyNames !== void 0) {
                                                                    const _errs79 = errors;
                                                                    if (!validate0(data.propertyNames, { instancePath: instancePath + "/propertyNames", parentData: data, parentDataProperty: "propertyNames", rootData })) {
                                                                      vErrors = vErrors === null ? validate0.errors : vErrors.concat(validate0.errors);
                                                                      errors = vErrors.length;
                                                                    }
                                                                    var valid0 = _errs79 === errors;
                                                                  } else {
                                                                    var valid0 = true;
                                                                  }
                                                                  if (valid0) {
                                                                    if (data.enum !== void 0) {
                                                                      let data37 = data.enum;
                                                                      const _errs80 = errors;
                                                                      if (errors === _errs80) {
                                                                        if (Array.isArray(data37)) {
                                                                          if (data37.length < 1) {
                                                                            validate0.errors = [{ instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }];
                                                                            return false;
                                                                          } else {
                                                                            let i4 = data37.length;
                                                                            let j2;
                                                                            if (i4 > 1) {
                                                                              outer0:
                                                                                for (; i4--; ) {
                                                                                  for (j2 = i4; j2--; ) {
                                                                                    if ((0, import_equal.default)(data37[i4], data37[j2])) {
                                                                                      validate0.errors = [{ instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/uniqueItems", keyword: "uniqueItems", params: { i: i4, j: j2 }, message: "must NOT have duplicate items (items ## " + j2 + " and " + i4 + " are identical)" }];
                                                                                      return false;
                                                                                      break outer0;
                                                                                    }
                                                                                  }
                                                                                }
                                                                            }
                                                                          }
                                                                        } else {
                                                                          validate0.errors = [{ instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                                                                          return false;
                                                                        }
                                                                      }
                                                                      var valid0 = _errs80 === errors;
                                                                    } else {
                                                                      var valid0 = true;
                                                                    }
                                                                    if (valid0) {
                                                                      if (data.type !== void 0) {
                                                                        let data38 = data.type;
                                                                        const _errs82 = errors;
                                                                        const _errs83 = errors;
                                                                        let valid18 = false;
                                                                        const _errs84 = errors;
                                                                        if (!(data38 === "array" || data38 === "boolean" || data38 === "integer" || data38 === "null" || data38 === "number" || data38 === "object" || data38 === "string")) {
                                                                          const err6 = { instancePath: instancePath + "/type", schemaPath: "#/definitions/simpleTypes/enum", keyword: "enum", params: { allowedValues: schema9.enum }, message: "must be equal to one of the allowed values" };
                                                                          if (vErrors === null) {
                                                                            vErrors = [err6];
                                                                          } else {
                                                                            vErrors.push(err6);
                                                                          }
                                                                          errors++;
                                                                        }
                                                                        var _valid2 = _errs84 === errors;
                                                                        valid18 = valid18 || _valid2;
                                                                        if (!valid18) {
                                                                          const _errs86 = errors;
                                                                          if (errors === _errs86) {
                                                                            if (Array.isArray(data38)) {
                                                                              if (data38.length < 1) {
                                                                                const err7 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf/1/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
                                                                                if (vErrors === null) {
                                                                                  vErrors = [err7];
                                                                                } else {
                                                                                  vErrors.push(err7);
                                                                                }
                                                                                errors++;
                                                                              } else {
                                                                                var valid20 = true;
                                                                                const len2 = data38.length;
                                                                                for (let i5 = 0; i5 < len2; i5++) {
                                                                                  let data39 = data38[i5];
                                                                                  const _errs88 = errors;
                                                                                  if (!(data39 === "array" || data39 === "boolean" || data39 === "integer" || data39 === "null" || data39 === "number" || data39 === "object" || data39 === "string")) {
                                                                                    const err8 = { instancePath: instancePath + "/type/" + i5, schemaPath: "#/definitions/simpleTypes/enum", keyword: "enum", params: { allowedValues: schema9.enum }, message: "must be equal to one of the allowed values" };
                                                                                    if (vErrors === null) {
                                                                                      vErrors = [err8];
                                                                                    } else {
                                                                                      vErrors.push(err8);
                                                                                    }
                                                                                    errors++;
                                                                                  }
                                                                                  var valid20 = _errs88 === errors;
                                                                                  if (!valid20) {
                                                                                    break;
                                                                                  }
                                                                                }
                                                                                if (valid20) {
                                                                                  let i6 = data38.length;
                                                                                  let j3;
                                                                                  if (i6 > 1) {
                                                                                    outer1:
                                                                                      for (; i6--; ) {
                                                                                        for (j3 = i6; j3--; ) {
                                                                                          if ((0, import_equal.default)(data38[i6], data38[j3])) {
                                                                                            const err9 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf/1/uniqueItems", keyword: "uniqueItems", params: { i: i6, j: j3 }, message: "must NOT have duplicate items (items ## " + j3 + " and " + i6 + " are identical)" };
                                                                                            if (vErrors === null) {
                                                                                              vErrors = [err9];
                                                                                            } else {
                                                                                              vErrors.push(err9);
                                                                                            }
                                                                                            errors++;
                                                                                            break outer1;
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                  }
                                                                                }
                                                                              }
                                                                            } else {
                                                                              const err10 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf/1/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                                              if (vErrors === null) {
                                                                                vErrors = [err10];
                                                                              } else {
                                                                                vErrors.push(err10);
                                                                              }
                                                                              errors++;
                                                                            }
                                                                          }
                                                                          var _valid2 = _errs86 === errors;
                                                                          valid18 = valid18 || _valid2;
                                                                        }
                                                                        if (!valid18) {
                                                                          const err11 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                          if (vErrors === null) {
                                                                            vErrors = [err11];
                                                                          } else {
                                                                            vErrors.push(err11);
                                                                          }
                                                                          errors++;
                                                                          validate0.errors = vErrors;
                                                                          return false;
                                                                        } else {
                                                                          errors = _errs83;
                                                                          if (vErrors !== null) {
                                                                            if (_errs83) {
                                                                              vErrors.length = _errs83;
                                                                            } else {
                                                                              vErrors = null;
                                                                            }
                                                                          }
                                                                        }
                                                                        var valid0 = _errs82 === errors;
                                                                      } else {
                                                                        var valid0 = true;
                                                                      }
                                                                      if (valid0) {
                                                                        if (data.format !== void 0) {
                                                                          const _errs90 = errors;
                                                                          if (typeof data.format !== "string") {
                                                                            validate0.errors = [{ instancePath: instancePath + "/format", schemaPath: "#/properties/format/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                            return false;
                                                                          }
                                                                          var valid0 = _errs90 === errors;
                                                                        } else {
                                                                          var valid0 = true;
                                                                        }
                                                                        if (valid0) {
                                                                          if (data.contentMediaType !== void 0) {
                                                                            const _errs92 = errors;
                                                                            if (typeof data.contentMediaType !== "string") {
                                                                              validate0.errors = [{ instancePath: instancePath + "/contentMediaType", schemaPath: "#/properties/contentMediaType/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                              return false;
                                                                            }
                                                                            var valid0 = _errs92 === errors;
                                                                          } else {
                                                                            var valid0 = true;
                                                                          }
                                                                          if (valid0) {
                                                                            if (data.contentEncoding !== void 0) {
                                                                              const _errs94 = errors;
                                                                              if (typeof data.contentEncoding !== "string") {
                                                                                validate0.errors = [{ instancePath: instancePath + "/contentEncoding", schemaPath: "#/properties/contentEncoding/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                                return false;
                                                                              }
                                                                              var valid0 = _errs94 === errors;
                                                                            } else {
                                                                              var valid0 = true;
                                                                            }
                                                                            if (valid0) {
                                                                              if (data.if !== void 0) {
                                                                                const _errs96 = errors;
                                                                                if (!validate0(data.if, { instancePath: instancePath + "/if", parentData: data, parentDataProperty: "if", rootData })) {
                                                                                  vErrors = vErrors === null ? validate0.errors : vErrors.concat(validate0.errors);
                                                                                  errors = vErrors.length;
                                                                                }
                                                                                var valid0 = _errs96 === errors;
                                                                              } else {
                                                                                var valid0 = true;
                                                                              }
                                                                              if (valid0) {
                                                                                if (data.then !== void 0) {
                                                                                  const _errs97 = errors;
                                                                                  if (!validate0(data.then, { instancePath: instancePath + "/then", parentData: data, parentDataProperty: "then", rootData })) {
                                                                                    vErrors = vErrors === null ? validate0.errors : vErrors.concat(validate0.errors);
                                                                                    errors = vErrors.length;
                                                                                  }
                                                                                  var valid0 = _errs97 === errors;
                                                                                } else {
                                                                                  var valid0 = true;
                                                                                }
                                                                                if (valid0) {
                                                                                  if (data.else !== void 0) {
                                                                                    const _errs98 = errors;
                                                                                    if (!validate0(data.else, { instancePath: instancePath + "/else", parentData: data, parentDataProperty: "else", rootData })) {
                                                                                      vErrors = vErrors === null ? validate0.errors : vErrors.concat(validate0.errors);
                                                                                      errors = vErrors.length;
                                                                                    }
                                                                                    var valid0 = _errs98 === errors;
                                                                                  } else {
                                                                                    var valid0 = true;
                                                                                  }
                                                                                  if (valid0) {
                                                                                    if (data.allOf !== void 0) {
                                                                                      const _errs99 = errors;
                                                                                      if (!validate3(data.allOf, { instancePath: instancePath + "/allOf", parentData: data, parentDataProperty: "allOf", rootData })) {
                                                                                        vErrors = vErrors === null ? validate3.errors : vErrors.concat(validate3.errors);
                                                                                        errors = vErrors.length;
                                                                                      }
                                                                                      var valid0 = _errs99 === errors;
                                                                                    } else {
                                                                                      var valid0 = true;
                                                                                    }
                                                                                    if (valid0) {
                                                                                      if (data.anyOf !== void 0) {
                                                                                        const _errs100 = errors;
                                                                                        if (!validate3(data.anyOf, { instancePath: instancePath + "/anyOf", parentData: data, parentDataProperty: "anyOf", rootData })) {
                                                                                          vErrors = vErrors === null ? validate3.errors : vErrors.concat(validate3.errors);
                                                                                          errors = vErrors.length;
                                                                                        }
                                                                                        var valid0 = _errs100 === errors;
                                                                                      } else {
                                                                                        var valid0 = true;
                                                                                      }
                                                                                      if (valid0) {
                                                                                        if (data.oneOf !== void 0) {
                                                                                          const _errs101 = errors;
                                                                                          if (!validate3(data.oneOf, { instancePath: instancePath + "/oneOf", parentData: data, parentDataProperty: "oneOf", rootData })) {
                                                                                            vErrors = vErrors === null ? validate3.errors : vErrors.concat(validate3.errors);
                                                                                            errors = vErrors.length;
                                                                                          }
                                                                                          var valid0 = _errs101 === errors;
                                                                                        } else {
                                                                                          var valid0 = true;
                                                                                        }
                                                                                        if (valid0) {
                                                                                          if (data.not !== void 0) {
                                                                                            const _errs102 = errors;
                                                                                            if (!validate0(data.not, { instancePath: instancePath + "/not", parentData: data, parentDataProperty: "not", rootData })) {
                                                                                              vErrors = vErrors === null ? validate0.errors : vErrors.concat(validate0.errors);
                                                                                              errors = vErrors.length;
                                                                                            }
                                                                                            var valid0 = _errs102 === errors;
                                                                                          } else {
                                                                                            var valid0 = true;
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  validate0.errors = vErrors;
  return errors === 0;
}
var func2 = Object.prototype.hasOwnProperty;
function validate12(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.description === void 0 && (missing0 = "description") || data.payin === void 0 && (missing0 = "payin") || data.payout === void 0 && (missing0 = "payout") || data.payoutUnitsPerPayinUnit === void 0 && (missing0 = "payoutUnitsPerPayinUnit")) {
        validate12.errors = [{ instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" }];
        return false;
      } else {
        if (data.additionalProperties !== void 0) {
          var valid0 = false;
          validate12.errors = [{ instancePath: instancePath + "/additionalProperties", schemaPath: "#/properties/additionalProperties/false schema", keyword: "false schema", params: {}, message: "boolean schema is false" }];
          return false;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.description !== void 0) {
            const _errs1 = errors;
            if (typeof data.description !== "string") {
              validate12.errors = [{ instancePath: instancePath + "/description", schemaPath: "#/properties/description/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
              return false;
            }
            var valid0 = _errs1 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.payin !== void 0) {
              let data2 = data.payin;
              const _errs3 = errors;
              if (errors === _errs3) {
                if (data2 && typeof data2 == "object" && !Array.isArray(data2)) {
                  let missing1;
                  if (data2.currencyCode === void 0 && (missing1 = "currencyCode") || data2.methods === void 0 && (missing1 = "methods")) {
                    validate12.errors = [{ instancePath: instancePath + "/payin", schemaPath: "#/properties/payin/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" }];
                    return false;
                  } else {
                    const _errs5 = errors;
                    for (const key0 in data2) {
                      if (!(key0 === "currencyCode" || key0 === "min" || key0 === "max" || key0 === "methods")) {
                        validate12.errors = [{ instancePath: instancePath + "/payin", schemaPath: "#/properties/payin/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" }];
                        return false;
                        break;
                      }
                    }
                    if (_errs5 === errors) {
                      if (data2.currencyCode !== void 0) {
                        const _errs6 = errors;
                        if (typeof data2.currencyCode !== "string") {
                          validate12.errors = [{ instancePath: instancePath + "/payin/currencyCode", schemaPath: "#/properties/payin/properties/currencyCode/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                          return false;
                        }
                        var valid1 = _errs6 === errors;
                      } else {
                        var valid1 = true;
                      }
                      if (valid1) {
                        if (data2.min !== void 0) {
                          let data4 = data2.min;
                          const _errs8 = errors;
                          const _errs9 = errors;
                          if (errors === _errs9) {
                            if (typeof data4 === "string") {
                              if (!pattern0.test(data4)) {
                                validate12.errors = [{ instancePath: instancePath + "/payin/min", schemaPath: "definitions.json#/definitions/decimalString/pattern", keyword: "pattern", params: { pattern: "^([0-9]+(?:[.][0-9]+)?)$" }, message: 'must match pattern "^([0-9]+(?:[.][0-9]+)?)$"' }];
                                return false;
                              }
                            } else {
                              validate12.errors = [{ instancePath: instancePath + "/payin/min", schemaPath: "definitions.json#/definitions/decimalString/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                              return false;
                            }
                          }
                          var valid1 = _errs8 === errors;
                        } else {
                          var valid1 = true;
                        }
                        if (valid1) {
                          if (data2.max !== void 0) {
                            let data5 = data2.max;
                            const _errs11 = errors;
                            const _errs12 = errors;
                            if (errors === _errs12) {
                              if (typeof data5 === "string") {
                                if (!pattern0.test(data5)) {
                                  validate12.errors = [{ instancePath: instancePath + "/payin/max", schemaPath: "definitions.json#/definitions/decimalString/pattern", keyword: "pattern", params: { pattern: "^([0-9]+(?:[.][0-9]+)?)$" }, message: 'must match pattern "^([0-9]+(?:[.][0-9]+)?)$"' }];
                                  return false;
                                }
                              } else {
                                validate12.errors = [{ instancePath: instancePath + "/payin/max", schemaPath: "definitions.json#/definitions/decimalString/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                return false;
                              }
                            }
                            var valid1 = _errs11 === errors;
                          } else {
                            var valid1 = true;
                          }
                          if (valid1) {
                            if (data2.methods !== void 0) {
                              let data6 = data2.methods;
                              const _errs14 = errors;
                              if (errors === _errs14) {
                                if (Array.isArray(data6)) {
                                  var valid4 = true;
                                  const len0 = data6.length;
                                  for (let i0 = 0; i0 < len0; i0++) {
                                    let data7 = data6[i0];
                                    const _errs16 = errors;
                                    if (errors === _errs16) {
                                      if (data7 && typeof data7 == "object" && !Array.isArray(data7)) {
                                        let missing2;
                                        if (data7.kind === void 0 && (missing2 = "kind")) {
                                          validate12.errors = [{ instancePath: instancePath + "/payin/methods/" + i0, schemaPath: "#/properties/payin/properties/methods/items/required", keyword: "required", params: { missingProperty: missing2 }, message: "must have required property '" + missing2 + "'" }];
                                          return false;
                                        } else {
                                          const _errs18 = errors;
                                          for (const key1 in data7) {
                                            if (!(key1 === "kind" || key1 === "name" || key1 === "description" || key1 === "group" || key1 === "requiredPaymentDetails" || key1 === "min" || key1 === "max" || key1 === "fee")) {
                                              validate12.errors = [{ instancePath: instancePath + "/payin/methods/" + i0, schemaPath: "#/properties/payin/properties/methods/items/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key1 }, message: "must NOT have additional properties" }];
                                              return false;
                                              break;
                                            }
                                          }
                                          if (_errs18 === errors) {
                                            if (data7.kind !== void 0) {
                                              const _errs19 = errors;
                                              if (typeof data7.kind !== "string") {
                                                validate12.errors = [{ instancePath: instancePath + "/payin/methods/" + i0 + "/kind", schemaPath: "#/properties/payin/properties/methods/items/properties/kind/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                return false;
                                              }
                                              var valid5 = _errs19 === errors;
                                            } else {
                                              var valid5 = true;
                                            }
                                            if (valid5) {
                                              if (data7.name !== void 0) {
                                                const _errs21 = errors;
                                                if (typeof data7.name !== "string") {
                                                  validate12.errors = [{ instancePath: instancePath + "/payin/methods/" + i0 + "/name", schemaPath: "#/properties/payin/properties/methods/items/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                  return false;
                                                }
                                                var valid5 = _errs21 === errors;
                                              } else {
                                                var valid5 = true;
                                              }
                                              if (valid5) {
                                                if (data7.description !== void 0) {
                                                  const _errs23 = errors;
                                                  if (typeof data7.description !== "string") {
                                                    validate12.errors = [{ instancePath: instancePath + "/payin/methods/" + i0 + "/description", schemaPath: "#/properties/payin/properties/methods/items/properties/description/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                    return false;
                                                  }
                                                  var valid5 = _errs23 === errors;
                                                } else {
                                                  var valid5 = true;
                                                }
                                                if (valid5) {
                                                  if (data7.group !== void 0) {
                                                    const _errs25 = errors;
                                                    if (typeof data7.group !== "string") {
                                                      validate12.errors = [{ instancePath: instancePath + "/payin/methods/" + i0 + "/group", schemaPath: "#/properties/payin/properties/methods/items/properties/group/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                      return false;
                                                    }
                                                    var valid5 = _errs25 === errors;
                                                  } else {
                                                    var valid5 = true;
                                                  }
                                                  if (valid5) {
                                                    if (data7.requiredPaymentDetails !== void 0) {
                                                      const _errs27 = errors;
                                                      if (!validate0(data7.requiredPaymentDetails, { instancePath: instancePath + "/payin/methods/" + i0 + "/requiredPaymentDetails", parentData: data7, parentDataProperty: "requiredPaymentDetails", rootData })) {
                                                        vErrors = vErrors === null ? validate0.errors : vErrors.concat(validate0.errors);
                                                        errors = vErrors.length;
                                                      }
                                                      var valid5 = _errs27 === errors;
                                                    } else {
                                                      var valid5 = true;
                                                    }
                                                    if (valid5) {
                                                      if (data7.min !== void 0) {
                                                        let data13 = data7.min;
                                                        const _errs28 = errors;
                                                        const _errs29 = errors;
                                                        if (errors === _errs29) {
                                                          if (typeof data13 === "string") {
                                                            if (!pattern0.test(data13)) {
                                                              validate12.errors = [{ instancePath: instancePath + "/payin/methods/" + i0 + "/min", schemaPath: "definitions.json#/definitions/decimalString/pattern", keyword: "pattern", params: { pattern: "^([0-9]+(?:[.][0-9]+)?)$" }, message: 'must match pattern "^([0-9]+(?:[.][0-9]+)?)$"' }];
                                                              return false;
                                                            }
                                                          } else {
                                                            validate12.errors = [{ instancePath: instancePath + "/payin/methods/" + i0 + "/min", schemaPath: "definitions.json#/definitions/decimalString/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                            return false;
                                                          }
                                                        }
                                                        var valid5 = _errs28 === errors;
                                                      } else {
                                                        var valid5 = true;
                                                      }
                                                      if (valid5) {
                                                        if (data7.max !== void 0) {
                                                          let data14 = data7.max;
                                                          const _errs31 = errors;
                                                          const _errs32 = errors;
                                                          if (errors === _errs32) {
                                                            if (typeof data14 === "string") {
                                                              if (!pattern0.test(data14)) {
                                                                validate12.errors = [{ instancePath: instancePath + "/payin/methods/" + i0 + "/max", schemaPath: "definitions.json#/definitions/decimalString/pattern", keyword: "pattern", params: { pattern: "^([0-9]+(?:[.][0-9]+)?)$" }, message: 'must match pattern "^([0-9]+(?:[.][0-9]+)?)$"' }];
                                                                return false;
                                                              }
                                                            } else {
                                                              validate12.errors = [{ instancePath: instancePath + "/payin/methods/" + i0 + "/max", schemaPath: "definitions.json#/definitions/decimalString/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                              return false;
                                                            }
                                                          }
                                                          var valid5 = _errs31 === errors;
                                                        } else {
                                                          var valid5 = true;
                                                        }
                                                        if (valid5) {
                                                          if (data7.fee !== void 0) {
                                                            let data15 = data7.fee;
                                                            const _errs34 = errors;
                                                            const _errs35 = errors;
                                                            if (errors === _errs35) {
                                                              if (typeof data15 === "string") {
                                                                if (!pattern0.test(data15)) {
                                                                  validate12.errors = [{ instancePath: instancePath + "/payin/methods/" + i0 + "/fee", schemaPath: "definitions.json#/definitions/decimalString/pattern", keyword: "pattern", params: { pattern: "^([0-9]+(?:[.][0-9]+)?)$" }, message: 'must match pattern "^([0-9]+(?:[.][0-9]+)?)$"' }];
                                                                  return false;
                                                                }
                                                              } else {
                                                                validate12.errors = [{ instancePath: instancePath + "/payin/methods/" + i0 + "/fee", schemaPath: "definitions.json#/definitions/decimalString/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                return false;
                                                              }
                                                            }
                                                            var valid5 = _errs34 === errors;
                                                          } else {
                                                            var valid5 = true;
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      } else {
                                        validate12.errors = [{ instancePath: instancePath + "/payin/methods/" + i0, schemaPath: "#/properties/payin/properties/methods/items/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                        return false;
                                      }
                                    }
                                    var valid4 = _errs16 === errors;
                                    if (!valid4) {
                                      break;
                                    }
                                  }
                                } else {
                                  validate12.errors = [{ instancePath: instancePath + "/payin/methods", schemaPath: "#/properties/payin/properties/methods/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                                  return false;
                                }
                              }
                              var valid1 = _errs14 === errors;
                            } else {
                              var valid1 = true;
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  validate12.errors = [{ instancePath: instancePath + "/payin", schemaPath: "#/properties/payin/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                  return false;
                }
              }
              var valid0 = _errs3 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.payout !== void 0) {
                let data16 = data.payout;
                const _errs37 = errors;
                if (errors === _errs37) {
                  if (data16 && typeof data16 == "object" && !Array.isArray(data16)) {
                    let missing3;
                    if (data16.currencyCode === void 0 && (missing3 = "currencyCode") || data16.methods === void 0 && (missing3 = "methods")) {
                      validate12.errors = [{ instancePath: instancePath + "/payout", schemaPath: "#/properties/payout/required", keyword: "required", params: { missingProperty: missing3 }, message: "must have required property '" + missing3 + "'" }];
                      return false;
                    } else {
                      const _errs39 = errors;
                      for (const key2 in data16) {
                        if (!(key2 === "currencyCode" || key2 === "min" || key2 === "max" || key2 === "methods")) {
                          validate12.errors = [{ instancePath: instancePath + "/payout", schemaPath: "#/properties/payout/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key2 }, message: "must NOT have additional properties" }];
                          return false;
                          break;
                        }
                      }
                      if (_errs39 === errors) {
                        if (data16.currencyCode !== void 0) {
                          const _errs40 = errors;
                          if (typeof data16.currencyCode !== "string") {
                            validate12.errors = [{ instancePath: instancePath + "/payout/currencyCode", schemaPath: "#/properties/payout/properties/currencyCode/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                            return false;
                          }
                          var valid9 = _errs40 === errors;
                        } else {
                          var valid9 = true;
                        }
                        if (valid9) {
                          if (data16.min !== void 0) {
                            let data18 = data16.min;
                            const _errs42 = errors;
                            const _errs43 = errors;
                            if (errors === _errs43) {
                              if (typeof data18 === "string") {
                                if (!pattern0.test(data18)) {
                                  validate12.errors = [{ instancePath: instancePath + "/payout/min", schemaPath: "definitions.json#/definitions/decimalString/pattern", keyword: "pattern", params: { pattern: "^([0-9]+(?:[.][0-9]+)?)$" }, message: 'must match pattern "^([0-9]+(?:[.][0-9]+)?)$"' }];
                                  return false;
                                }
                              } else {
                                validate12.errors = [{ instancePath: instancePath + "/payout/min", schemaPath: "definitions.json#/definitions/decimalString/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                return false;
                              }
                            }
                            var valid9 = _errs42 === errors;
                          } else {
                            var valid9 = true;
                          }
                          if (valid9) {
                            if (data16.max !== void 0) {
                              let data19 = data16.max;
                              const _errs45 = errors;
                              const _errs46 = errors;
                              if (errors === _errs46) {
                                if (typeof data19 === "string") {
                                  if (!pattern0.test(data19)) {
                                    validate12.errors = [{ instancePath: instancePath + "/payout/max", schemaPath: "definitions.json#/definitions/decimalString/pattern", keyword: "pattern", params: { pattern: "^([0-9]+(?:[.][0-9]+)?)$" }, message: 'must match pattern "^([0-9]+(?:[.][0-9]+)?)$"' }];
                                    return false;
                                  }
                                } else {
                                  validate12.errors = [{ instancePath: instancePath + "/payout/max", schemaPath: "definitions.json#/definitions/decimalString/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                  return false;
                                }
                              }
                              var valid9 = _errs45 === errors;
                            } else {
                              var valid9 = true;
                            }
                            if (valid9) {
                              if (data16.methods !== void 0) {
                                let data20 = data16.methods;
                                const _errs48 = errors;
                                if (errors === _errs48) {
                                  if (Array.isArray(data20)) {
                                    var valid12 = true;
                                    const len1 = data20.length;
                                    for (let i1 = 0; i1 < len1; i1++) {
                                      let data21 = data20[i1];
                                      const _errs50 = errors;
                                      if (errors === _errs50) {
                                        if (data21 && typeof data21 == "object" && !Array.isArray(data21)) {
                                          let missing4;
                                          if (data21.kind === void 0 && (missing4 = "kind") || data21.estimatedSettlementTime === void 0 && (missing4 = "estimatedSettlementTime")) {
                                            validate12.errors = [{ instancePath: instancePath + "/payout/methods/" + i1, schemaPath: "#/properties/payout/properties/methods/items/required", keyword: "required", params: { missingProperty: missing4 }, message: "must have required property '" + missing4 + "'" }];
                                            return false;
                                          } else {
                                            const _errs52 = errors;
                                            for (const key3 in data21) {
                                              if (!func2.call(schema13.properties.payout.properties.methods.items.properties, key3)) {
                                                validate12.errors = [{ instancePath: instancePath + "/payout/methods/" + i1, schemaPath: "#/properties/payout/properties/methods/items/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key3 }, message: "must NOT have additional properties" }];
                                                return false;
                                                break;
                                              }
                                            }
                                            if (_errs52 === errors) {
                                              if (data21.kind !== void 0) {
                                                const _errs53 = errors;
                                                if (typeof data21.kind !== "string") {
                                                  validate12.errors = [{ instancePath: instancePath + "/payout/methods/" + i1 + "/kind", schemaPath: "#/properties/payout/properties/methods/items/properties/kind/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                  return false;
                                                }
                                                var valid13 = _errs53 === errors;
                                              } else {
                                                var valid13 = true;
                                              }
                                              if (valid13) {
                                                if (data21.name !== void 0) {
                                                  const _errs55 = errors;
                                                  if (typeof data21.name !== "string") {
                                                    validate12.errors = [{ instancePath: instancePath + "/payout/methods/" + i1 + "/name", schemaPath: "#/properties/payout/properties/methods/items/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                    return false;
                                                  }
                                                  var valid13 = _errs55 === errors;
                                                } else {
                                                  var valid13 = true;
                                                }
                                                if (valid13) {
                                                  if (data21.description !== void 0) {
                                                    const _errs57 = errors;
                                                    if (typeof data21.description !== "string") {
                                                      validate12.errors = [{ instancePath: instancePath + "/payout/methods/" + i1 + "/description", schemaPath: "#/properties/payout/properties/methods/items/properties/description/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                      return false;
                                                    }
                                                    var valid13 = _errs57 === errors;
                                                  } else {
                                                    var valid13 = true;
                                                  }
                                                  if (valid13) {
                                                    if (data21.group !== void 0) {
                                                      const _errs59 = errors;
                                                      if (typeof data21.group !== "string") {
                                                        validate12.errors = [{ instancePath: instancePath + "/payout/methods/" + i1 + "/group", schemaPath: "#/properties/payout/properties/methods/items/properties/group/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                        return false;
                                                      }
                                                      var valid13 = _errs59 === errors;
                                                    } else {
                                                      var valid13 = true;
                                                    }
                                                    if (valid13) {
                                                      if (data21.requiredPaymentDetails !== void 0) {
                                                        const _errs61 = errors;
                                                        if (!validate0(data21.requiredPaymentDetails, { instancePath: instancePath + "/payout/methods/" + i1 + "/requiredPaymentDetails", parentData: data21, parentDataProperty: "requiredPaymentDetails", rootData })) {
                                                          vErrors = vErrors === null ? validate0.errors : vErrors.concat(validate0.errors);
                                                          errors = vErrors.length;
                                                        }
                                                        var valid13 = _errs61 === errors;
                                                      } else {
                                                        var valid13 = true;
                                                      }
                                                      if (valid13) {
                                                        if (data21.min !== void 0) {
                                                          let data27 = data21.min;
                                                          const _errs62 = errors;
                                                          const _errs63 = errors;
                                                          if (errors === _errs63) {
                                                            if (typeof data27 === "string") {
                                                              if (!pattern0.test(data27)) {
                                                                validate12.errors = [{ instancePath: instancePath + "/payout/methods/" + i1 + "/min", schemaPath: "definitions.json#/definitions/decimalString/pattern", keyword: "pattern", params: { pattern: "^([0-9]+(?:[.][0-9]+)?)$" }, message: 'must match pattern "^([0-9]+(?:[.][0-9]+)?)$"' }];
                                                                return false;
                                                              }
                                                            } else {
                                                              validate12.errors = [{ instancePath: instancePath + "/payout/methods/" + i1 + "/min", schemaPath: "definitions.json#/definitions/decimalString/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                              return false;
                                                            }
                                                          }
                                                          var valid13 = _errs62 === errors;
                                                        } else {
                                                          var valid13 = true;
                                                        }
                                                        if (valid13) {
                                                          if (data21.max !== void 0) {
                                                            let data28 = data21.max;
                                                            const _errs65 = errors;
                                                            const _errs66 = errors;
                                                            if (errors === _errs66) {
                                                              if (typeof data28 === "string") {
                                                                if (!pattern0.test(data28)) {
                                                                  validate12.errors = [{ instancePath: instancePath + "/payout/methods/" + i1 + "/max", schemaPath: "definitions.json#/definitions/decimalString/pattern", keyword: "pattern", params: { pattern: "^([0-9]+(?:[.][0-9]+)?)$" }, message: 'must match pattern "^([0-9]+(?:[.][0-9]+)?)$"' }];
                                                                  return false;
                                                                }
                                                              } else {
                                                                validate12.errors = [{ instancePath: instancePath + "/payout/methods/" + i1 + "/max", schemaPath: "definitions.json#/definitions/decimalString/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                return false;
                                                              }
                                                            }
                                                            var valid13 = _errs65 === errors;
                                                          } else {
                                                            var valid13 = true;
                                                          }
                                                          if (valid13) {
                                                            if (data21.fee !== void 0) {
                                                              let data29 = data21.fee;
                                                              const _errs68 = errors;
                                                              const _errs69 = errors;
                                                              if (errors === _errs69) {
                                                                if (typeof data29 === "string") {
                                                                  if (!pattern0.test(data29)) {
                                                                    validate12.errors = [{ instancePath: instancePath + "/payout/methods/" + i1 + "/fee", schemaPath: "definitions.json#/definitions/decimalString/pattern", keyword: "pattern", params: { pattern: "^([0-9]+(?:[.][0-9]+)?)$" }, message: 'must match pattern "^([0-9]+(?:[.][0-9]+)?)$"' }];
                                                                    return false;
                                                                  }
                                                                } else {
                                                                  validate12.errors = [{ instancePath: instancePath + "/payout/methods/" + i1 + "/fee", schemaPath: "definitions.json#/definitions/decimalString/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                  return false;
                                                                }
                                                              }
                                                              var valid13 = _errs68 === errors;
                                                            } else {
                                                              var valid13 = true;
                                                            }
                                                            if (valid13) {
                                                              if (data21.estimatedSettlementTime !== void 0) {
                                                                let data30 = data21.estimatedSettlementTime;
                                                                const _errs71 = errors;
                                                                if (errors === _errs71) {
                                                                  if (typeof data30 == "number" && isFinite(data30)) {
                                                                    if (data30 < 0 || isNaN(data30)) {
                                                                      validate12.errors = [{ instancePath: instancePath + "/payout/methods/" + i1 + "/estimatedSettlementTime", schemaPath: "#/properties/payout/properties/methods/items/properties/estimatedSettlementTime/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
                                                                      return false;
                                                                    }
                                                                  } else {
                                                                    validate12.errors = [{ instancePath: instancePath + "/payout/methods/" + i1 + "/estimatedSettlementTime", schemaPath: "#/properties/payout/properties/methods/items/properties/estimatedSettlementTime/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                                                    return false;
                                                                  }
                                                                }
                                                                var valid13 = _errs71 === errors;
                                                              } else {
                                                                var valid13 = true;
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        } else {
                                          validate12.errors = [{ instancePath: instancePath + "/payout/methods/" + i1, schemaPath: "#/properties/payout/properties/methods/items/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                          return false;
                                        }
                                      }
                                      var valid12 = _errs50 === errors;
                                      if (!valid12) {
                                        break;
                                      }
                                    }
                                  } else {
                                    validate12.errors = [{ instancePath: instancePath + "/payout/methods", schemaPath: "#/properties/payout/properties/methods/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                                    return false;
                                  }
                                }
                                var valid9 = _errs48 === errors;
                              } else {
                                var valid9 = true;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    validate12.errors = [{ instancePath: instancePath + "/payout", schemaPath: "#/properties/payout/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                    return false;
                  }
                }
                var valid0 = _errs37 === errors;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data.payoutUnitsPerPayinUnit !== void 0) {
                  const _errs73 = errors;
                  if (typeof data.payoutUnitsPerPayinUnit !== "string") {
                    validate12.errors = [{ instancePath: instancePath + "/payoutUnitsPerPayinUnit", schemaPath: "#/properties/payoutUnitsPerPayinUnit/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                    return false;
                  }
                  var valid0 = _errs73 === errors;
                } else {
                  var valid0 = true;
                }
                if (valid0) {
                  if (data.requiredClaims !== void 0) {
                    let data32 = data.requiredClaims;
                    const _errs75 = errors;
                    if (!(data32 && typeof data32 == "object" && !Array.isArray(data32))) {
                      validate12.errors = [{ instancePath: instancePath + "/requiredClaims", schemaPath: "#/properties/requiredClaims/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                      return false;
                    }
                    var valid0 = _errs75 === errors;
                  } else {
                    var valid0 = true;
                  }
                }
              }
            }
          }
        }
      }
    } else {
      validate12.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate12.errors = vErrors;
  return errors === 0;
}
var balance = validate15;
function validate15(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.currencyCode === void 0 && (missing0 = "currencyCode") || data.available === void 0 && (missing0 = "available")) {
        validate15.errors = [{ instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" }];
        return false;
      } else {
        if (data.additionalProperties !== void 0) {
          var valid0 = false;
          validate15.errors = [{ instancePath: instancePath + "/additionalProperties", schemaPath: "#/properties/additionalProperties/false schema", keyword: "false schema", params: {}, message: "boolean schema is false" }];
          return false;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.currencyCode !== void 0) {
            const _errs1 = errors;
            if (typeof data.currencyCode !== "string") {
              validate15.errors = [{ instancePath: instancePath + "/currencyCode", schemaPath: "#/properties/currencyCode/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
              return false;
            }
            var valid0 = _errs1 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.available !== void 0) {
              let data2 = data.available;
              const _errs3 = errors;
              const _errs4 = errors;
              if (errors === _errs4) {
                if (typeof data2 === "string") {
                  if (!pattern0.test(data2)) {
                    validate15.errors = [{ instancePath: instancePath + "/available", schemaPath: "definitions.json#/definitions/decimalString/pattern", keyword: "pattern", params: { pattern: "^([0-9]+(?:[.][0-9]+)?)$" }, message: 'must match pattern "^([0-9]+(?:[.][0-9]+)?)$"' }];
                    return false;
                  }
                } else {
                  validate15.errors = [{ instancePath: instancePath + "/available", schemaPath: "definitions.json#/definitions/decimalString/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                  return false;
                }
              }
              var valid0 = _errs3 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate15.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate15.errors = vErrors;
  return errors === 0;
}
var message = validate16;
var schema27 = { "type": "object", "additionalProperties": false, "properties": { "from": { "$ref": "definitions.json#/definitions/did", "description": "The sender's DID" }, "to": { "$ref": "definitions.json#/definitions/did", "description": "The recipient's DID" }, "kind": { "type": "string", "enum": ["rfq", "quote", "order", "orderstatus", "close"], "description": "The message kind (e.g. rfq, quote)" }, "id": { "type": "string", "description": "The message ID" }, "exchangeId": { "type": "string", "description": "ID for a 'thread' of messages between Alice <-> PFI. Set by the first message in a thread" }, "externalId": { "type": "string", "description": "Arbitrary ID for the caller to associate with the message." }, "createdAt": { "type": "string", "description": "ISO8601 formatted string representing the timestamp" }, "protocol": { "type": "string", "description": "Version of the protocol in use (x.x format)" } }, "required": ["from", "to", "kind", "id", "exchangeId", "createdAt", "protocol"] };
var pattern11 = new RegExp("^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$", "u");
function validate17(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.from === void 0 && (missing0 = "from") || data.to === void 0 && (missing0 = "to") || data.kind === void 0 && (missing0 = "kind") || data.id === void 0 && (missing0 = "id") || data.exchangeId === void 0 && (missing0 = "exchangeId") || data.createdAt === void 0 && (missing0 = "createdAt") || data.protocol === void 0 && (missing0 = "protocol")) {
        validate17.errors = [{ instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" }];
        return false;
      } else {
        const _errs1 = errors;
        for (const key0 in data) {
          if (!(key0 === "from" || key0 === "to" || key0 === "kind" || key0 === "id" || key0 === "exchangeId" || key0 === "externalId" || key0 === "createdAt" || key0 === "protocol")) {
            validate17.errors = [{ instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" }];
            return false;
            break;
          }
        }
        if (_errs1 === errors) {
          if (data.from !== void 0) {
            let data0 = data.from;
            const _errs2 = errors;
            const _errs3 = errors;
            if (errors === _errs3) {
              if (typeof data0 === "string") {
                if (!pattern11.test(data0)) {
                  validate17.errors = [{ instancePath: instancePath + "/from", schemaPath: "definitions.json#/definitions/did/pattern", keyword: "pattern", params: { pattern: "^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$" }, message: 'must match pattern "^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$"' }];
                  return false;
                }
              } else {
                validate17.errors = [{ instancePath: instancePath + "/from", schemaPath: "definitions.json#/definitions/did/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                return false;
              }
            }
            var valid0 = _errs2 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.to !== void 0) {
              let data1 = data.to;
              const _errs5 = errors;
              const _errs6 = errors;
              if (errors === _errs6) {
                if (typeof data1 === "string") {
                  if (!pattern11.test(data1)) {
                    validate17.errors = [{ instancePath: instancePath + "/to", schemaPath: "definitions.json#/definitions/did/pattern", keyword: "pattern", params: { pattern: "^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$" }, message: 'must match pattern "^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$"' }];
                    return false;
                  }
                } else {
                  validate17.errors = [{ instancePath: instancePath + "/to", schemaPath: "definitions.json#/definitions/did/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                  return false;
                }
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.kind !== void 0) {
                let data2 = data.kind;
                const _errs8 = errors;
                if (typeof data2 !== "string") {
                  validate17.errors = [{ instancePath: instancePath + "/kind", schemaPath: "#/properties/kind/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                  return false;
                }
                if (!(data2 === "rfq" || data2 === "quote" || data2 === "order" || data2 === "orderstatus" || data2 === "close")) {
                  validate17.errors = [{ instancePath: instancePath + "/kind", schemaPath: "#/properties/kind/enum", keyword: "enum", params: { allowedValues: schema27.properties.kind.enum }, message: "must be equal to one of the allowed values" }];
                  return false;
                }
                var valid0 = _errs8 === errors;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data.id !== void 0) {
                  const _errs10 = errors;
                  if (typeof data.id !== "string") {
                    validate17.errors = [{ instancePath: instancePath + "/id", schemaPath: "#/properties/id/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                    return false;
                  }
                  var valid0 = _errs10 === errors;
                } else {
                  var valid0 = true;
                }
                if (valid0) {
                  if (data.exchangeId !== void 0) {
                    const _errs12 = errors;
                    if (typeof data.exchangeId !== "string") {
                      validate17.errors = [{ instancePath: instancePath + "/exchangeId", schemaPath: "#/properties/exchangeId/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                      return false;
                    }
                    var valid0 = _errs12 === errors;
                  } else {
                    var valid0 = true;
                  }
                  if (valid0) {
                    if (data.externalId !== void 0) {
                      const _errs14 = errors;
                      if (typeof data.externalId !== "string") {
                        validate17.errors = [{ instancePath: instancePath + "/externalId", schemaPath: "#/properties/externalId/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                        return false;
                      }
                      var valid0 = _errs14 === errors;
                    } else {
                      var valid0 = true;
                    }
                    if (valid0) {
                      if (data.createdAt !== void 0) {
                        const _errs16 = errors;
                        if (typeof data.createdAt !== "string") {
                          validate17.errors = [{ instancePath: instancePath + "/createdAt", schemaPath: "#/properties/createdAt/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                          return false;
                        }
                        var valid0 = _errs16 === errors;
                      } else {
                        var valid0 = true;
                      }
                      if (valid0) {
                        if (data.protocol !== void 0) {
                          const _errs18 = errors;
                          if (typeof data.protocol !== "string") {
                            validate17.errors = [{ instancePath: instancePath + "/protocol", schemaPath: "#/properties/protocol/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                            return false;
                          }
                          var valid0 = _errs18 === errors;
                        } else {
                          var valid0 = true;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      validate17.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate17.errors = vErrors;
  return errors === 0;
}
function validate16(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.metadata === void 0 && (missing0 = "metadata") || data.data === void 0 && (missing0 = "data") || data.signature === void 0 && (missing0 = "signature")) {
        validate16.errors = [{ instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" }];
        return false;
      } else {
        const _errs1 = errors;
        for (const key0 in data) {
          if (!(key0 === "metadata" || key0 === "data" || key0 === "signature" || key0 === "privateData")) {
            validate16.errors = [{ instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" }];
            return false;
            break;
          }
        }
        if (_errs1 === errors) {
          if (data.metadata !== void 0) {
            const _errs2 = errors;
            if (!validate17(data.metadata, { instancePath: instancePath + "/metadata", parentData: data, parentDataProperty: "metadata", rootData })) {
              vErrors = vErrors === null ? validate17.errors : vErrors.concat(validate17.errors);
              errors = vErrors.length;
            }
            var valid0 = _errs2 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.data !== void 0) {
              let data1 = data.data;
              const _errs3 = errors;
              if (!(data1 && typeof data1 == "object" && !Array.isArray(data1))) {
                validate16.errors = [{ instancePath: instancePath + "/data", schemaPath: "#/properties/data/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                return false;
              }
              var valid0 = _errs3 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.signature !== void 0) {
                const _errs5 = errors;
                if (typeof data.signature !== "string") {
                  validate16.errors = [{ instancePath: instancePath + "/signature", schemaPath: "#/properties/signature/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                  return false;
                }
                var valid0 = _errs5 === errors;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data.privateData !== void 0) {
                  let data3 = data.privateData;
                  const _errs7 = errors;
                  if (!(data3 && typeof data3 == "object" && !Array.isArray(data3))) {
                    validate16.errors = [{ instancePath: instancePath + "/privateData", schemaPath: "#/properties/privateData/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                    return false;
                  }
                  var valid0 = _errs7 === errors;
                } else {
                  var valid0 = true;
                }
              }
            }
          }
        }
      }
    } else {
      validate16.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate16.errors = vErrors;
  return errors === 0;
}
var order = validate19;
function validate19(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      for (const key0 in data) {
        validate19.errors = [{ instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" }];
        return false;
        break;
      }
    } else {
      validate19.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate19.errors = vErrors;
  return errors === 0;
}
var orderstatus = validate20;
function validate20(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.orderStatus === void 0 && (missing0 = "orderStatus")) {
        validate20.errors = [{ instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" }];
        return false;
      } else {
        const _errs1 = errors;
        for (const key0 in data) {
          if (!(key0 === "orderStatus")) {
            validate20.errors = [{ instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" }];
            return false;
            break;
          }
        }
        if (_errs1 === errors) {
          if (data.orderStatus !== void 0) {
            if (typeof data.orderStatus !== "string") {
              validate20.errors = [{ instancePath: instancePath + "/orderStatus", schemaPath: "#/properties/orderStatus/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
              return false;
            }
          }
        }
      }
    } else {
      validate20.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate20.errors = vErrors;
  return errors === 0;
}
var quote = validate21;
function validate22(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.currencyCode === void 0 && (missing0 = "currencyCode") || data.amount === void 0 && (missing0 = "amount")) {
        validate22.errors = [{ instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" }];
        return false;
      } else {
        const _errs1 = errors;
        for (const key0 in data) {
          if (!(key0 === "currencyCode" || key0 === "amount" || key0 === "fee" || key0 === "paymentInstruction")) {
            validate22.errors = [{ instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" }];
            return false;
            break;
          }
        }
        if (_errs1 === errors) {
          if (data.currencyCode !== void 0) {
            const _errs2 = errors;
            if (typeof data.currencyCode !== "string") {
              validate22.errors = [{ instancePath: instancePath + "/currencyCode", schemaPath: "#/properties/currencyCode/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
              return false;
            }
            var valid0 = _errs2 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.amount !== void 0) {
              let data1 = data.amount;
              const _errs4 = errors;
              const _errs5 = errors;
              if (errors === _errs5) {
                if (typeof data1 === "string") {
                  if (!pattern0.test(data1)) {
                    validate22.errors = [{ instancePath: instancePath + "/amount", schemaPath: "definitions.json#/definitions/decimalString/pattern", keyword: "pattern", params: { pattern: "^([0-9]+(?:[.][0-9]+)?)$" }, message: 'must match pattern "^([0-9]+(?:[.][0-9]+)?)$"' }];
                    return false;
                  }
                } else {
                  validate22.errors = [{ instancePath: instancePath + "/amount", schemaPath: "definitions.json#/definitions/decimalString/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                  return false;
                }
              }
              var valid0 = _errs4 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.fee !== void 0) {
                let data2 = data.fee;
                const _errs7 = errors;
                const _errs8 = errors;
                if (errors === _errs8) {
                  if (typeof data2 === "string") {
                    if (!pattern0.test(data2)) {
                      validate22.errors = [{ instancePath: instancePath + "/fee", schemaPath: "definitions.json#/definitions/decimalString/pattern", keyword: "pattern", params: { pattern: "^([0-9]+(?:[.][0-9]+)?)$" }, message: 'must match pattern "^([0-9]+(?:[.][0-9]+)?)$"' }];
                      return false;
                    }
                  } else {
                    validate22.errors = [{ instancePath: instancePath + "/fee", schemaPath: "definitions.json#/definitions/decimalString/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                    return false;
                  }
                }
                var valid0 = _errs7 === errors;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data.paymentInstruction !== void 0) {
                  let data3 = data.paymentInstruction;
                  const _errs10 = errors;
                  const _errs11 = errors;
                  if (errors === _errs11) {
                    if (data3 && typeof data3 == "object" && !Array.isArray(data3)) {
                      const _errs13 = errors;
                      for (const key1 in data3) {
                        if (!(key1 === "link" || key1 === "instruction")) {
                          validate22.errors = [{ instancePath: instancePath + "/paymentInstruction", schemaPath: "#/definitions/PaymentInstruction/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key1 }, message: "must NOT have additional properties" }];
                          return false;
                          break;
                        }
                      }
                      if (_errs13 === errors) {
                        if (data3.link !== void 0) {
                          const _errs14 = errors;
                          if (typeof data3.link !== "string") {
                            validate22.errors = [{ instancePath: instancePath + "/paymentInstruction/link", schemaPath: "#/definitions/PaymentInstruction/properties/link/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                            return false;
                          }
                          var valid4 = _errs14 === errors;
                        } else {
                          var valid4 = true;
                        }
                        if (valid4) {
                          if (data3.instruction !== void 0) {
                            const _errs16 = errors;
                            if (typeof data3.instruction !== "string") {
                              validate22.errors = [{ instancePath: instancePath + "/paymentInstruction/instruction", schemaPath: "#/definitions/PaymentInstruction/properties/instruction/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                              return false;
                            }
                            var valid4 = _errs16 === errors;
                          } else {
                            var valid4 = true;
                          }
                        }
                      }
                    } else {
                      validate22.errors = [{ instancePath: instancePath + "/paymentInstruction", schemaPath: "#/definitions/PaymentInstruction/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                      return false;
                    }
                  }
                  var valid0 = _errs10 === errors;
                } else {
                  var valid0 = true;
                }
              }
            }
          }
        }
      }
    } else {
      validate22.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate22.errors = vErrors;
  return errors === 0;
}
function validate21(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.expiresAt === void 0 && (missing0 = "expiresAt") || data.payin === void 0 && (missing0 = "payin") || data.payout === void 0 && (missing0 = "payout")) {
        validate21.errors = [{ instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" }];
        return false;
      } else {
        const _errs1 = errors;
        for (const key0 in data) {
          if (!(key0 === "expiresAt" || key0 === "payin" || key0 === "payout")) {
            validate21.errors = [{ instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" }];
            return false;
            break;
          }
        }
        if (_errs1 === errors) {
          if (data.expiresAt !== void 0) {
            const _errs2 = errors;
            if (typeof data.expiresAt !== "string") {
              validate21.errors = [{ instancePath: instancePath + "/expiresAt", schemaPath: "#/properties/expiresAt/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
              return false;
            }
            var valid0 = _errs2 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.payin !== void 0) {
              const _errs4 = errors;
              if (!validate22(data.payin, { instancePath: instancePath + "/payin", parentData: data, parentDataProperty: "payin", rootData })) {
                vErrors = vErrors === null ? validate22.errors : vErrors.concat(validate22.errors);
                errors = vErrors.length;
              }
              var valid0 = _errs4 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.payout !== void 0) {
                const _errs5 = errors;
                if (!validate22(data.payout, { instancePath: instancePath + "/payout", parentData: data, parentDataProperty: "payout", rootData })) {
                  vErrors = vErrors === null ? validate22.errors : vErrors.concat(validate22.errors);
                  errors = vErrors.length;
                }
                var valid0 = _errs5 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate21.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate21.errors = vErrors;
  return errors === 0;
}
var resource = validate25;
var schema37 = { "$schema": "http://json-schema.org/draft-07/schema#", "$id": "https://tbdex.dev/resource.schema.json", "type": "object", "additionalProperties": false, "properties": { "metadata": { "type": "object", "properties": { "from": { "$ref": "definitions.json#/definitions/did", "description": "The PFI's DID" }, "kind": { "type": "string", "enum": ["offering", "balance"], "description": "The resource kind (e.g. Offering)" }, "id": { "type": "string", "description": "The resource id" }, "createdAt": { "type": "string", "description": "When the resource was created at. Expressed as ISO8601" }, "updatedAt": { "type": "string", "description": "When the resource was last updated. Expressed as ISO8601" }, "protocol": { "type": "string", "description": "Version of the protocol in use (x.x format)" } }, "required": ["from", "kind", "id", "createdAt", "protocol"], "description": "The metadata object contains fields about the resource and is present for every tbdex resources of all types." }, "data": { "description": "The actual resource content", "type": "object" }, "signature": { "type": "string", "description": "Signature that verifies that authenticity and integrity of a message" } }, "required": ["metadata", "data", "signature"], "description": "ResourceModel" };
function validate25(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.metadata === void 0 && (missing0 = "metadata") || data.data === void 0 && (missing0 = "data") || data.signature === void 0 && (missing0 = "signature")) {
        validate25.errors = [{ instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" }];
        return false;
      } else {
        const _errs1 = errors;
        for (const key0 in data) {
          if (!(key0 === "metadata" || key0 === "data" || key0 === "signature")) {
            validate25.errors = [{ instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" }];
            return false;
            break;
          }
        }
        if (_errs1 === errors) {
          if (data.metadata !== void 0) {
            let data0 = data.metadata;
            const _errs2 = errors;
            if (errors === _errs2) {
              if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
                let missing1;
                if (data0.from === void 0 && (missing1 = "from") || data0.kind === void 0 && (missing1 = "kind") || data0.id === void 0 && (missing1 = "id") || data0.createdAt === void 0 && (missing1 = "createdAt") || data0.protocol === void 0 && (missing1 = "protocol")) {
                  validate25.errors = [{ instancePath: instancePath + "/metadata", schemaPath: "#/properties/metadata/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" }];
                  return false;
                } else {
                  if (data0.from !== void 0) {
                    let data1 = data0.from;
                    const _errs4 = errors;
                    const _errs5 = errors;
                    if (errors === _errs5) {
                      if (typeof data1 === "string") {
                        if (!pattern11.test(data1)) {
                          validate25.errors = [{ instancePath: instancePath + "/metadata/from", schemaPath: "definitions.json#/definitions/did/pattern", keyword: "pattern", params: { pattern: "^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$" }, message: 'must match pattern "^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$"' }];
                          return false;
                        }
                      } else {
                        validate25.errors = [{ instancePath: instancePath + "/metadata/from", schemaPath: "definitions.json#/definitions/did/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                        return false;
                      }
                    }
                    var valid1 = _errs4 === errors;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data0.kind !== void 0) {
                      let data2 = data0.kind;
                      const _errs7 = errors;
                      if (typeof data2 !== "string") {
                        validate25.errors = [{ instancePath: instancePath + "/metadata/kind", schemaPath: "#/properties/metadata/properties/kind/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                        return false;
                      }
                      if (!(data2 === "offering" || data2 === "balance")) {
                        validate25.errors = [{ instancePath: instancePath + "/metadata/kind", schemaPath: "#/properties/metadata/properties/kind/enum", keyword: "enum", params: { allowedValues: schema37.properties.metadata.properties.kind.enum }, message: "must be equal to one of the allowed values" }];
                        return false;
                      }
                      var valid1 = _errs7 === errors;
                    } else {
                      var valid1 = true;
                    }
                    if (valid1) {
                      if (data0.id !== void 0) {
                        const _errs9 = errors;
                        if (typeof data0.id !== "string") {
                          validate25.errors = [{ instancePath: instancePath + "/metadata/id", schemaPath: "#/properties/metadata/properties/id/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                          return false;
                        }
                        var valid1 = _errs9 === errors;
                      } else {
                        var valid1 = true;
                      }
                      if (valid1) {
                        if (data0.createdAt !== void 0) {
                          const _errs11 = errors;
                          if (typeof data0.createdAt !== "string") {
                            validate25.errors = [{ instancePath: instancePath + "/metadata/createdAt", schemaPath: "#/properties/metadata/properties/createdAt/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                            return false;
                          }
                          var valid1 = _errs11 === errors;
                        } else {
                          var valid1 = true;
                        }
                        if (valid1) {
                          if (data0.updatedAt !== void 0) {
                            const _errs13 = errors;
                            if (typeof data0.updatedAt !== "string") {
                              validate25.errors = [{ instancePath: instancePath + "/metadata/updatedAt", schemaPath: "#/properties/metadata/properties/updatedAt/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                              return false;
                            }
                            var valid1 = _errs13 === errors;
                          } else {
                            var valid1 = true;
                          }
                          if (valid1) {
                            if (data0.protocol !== void 0) {
                              const _errs15 = errors;
                              if (typeof data0.protocol !== "string") {
                                validate25.errors = [{ instancePath: instancePath + "/metadata/protocol", schemaPath: "#/properties/metadata/properties/protocol/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                return false;
                              }
                              var valid1 = _errs15 === errors;
                            } else {
                              var valid1 = true;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                validate25.errors = [{ instancePath: instancePath + "/metadata", schemaPath: "#/properties/metadata/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                return false;
              }
            }
            var valid0 = _errs2 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.data !== void 0) {
              let data7 = data.data;
              const _errs17 = errors;
              if (!(data7 && typeof data7 == "object" && !Array.isArray(data7))) {
                validate25.errors = [{ instancePath: instancePath + "/data", schemaPath: "#/properties/data/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                return false;
              }
              var valid0 = _errs17 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.signature !== void 0) {
                const _errs19 = errors;
                if (typeof data.signature !== "string") {
                  validate25.errors = [{ instancePath: instancePath + "/signature", schemaPath: "#/properties/signature/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                  return false;
                }
                var valid0 = _errs19 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate25.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate25.errors = vErrors;
  return errors === 0;
}
var rfqPrivate = validate26;
function validate26(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.salt === void 0 && (missing0 = "salt")) {
        validate26.errors = [{ instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" }];
        return false;
      } else {
        if (data.additionalProperties !== void 0) {
          var valid0 = false;
          validate26.errors = [{ instancePath: instancePath + "/additionalProperties", schemaPath: "#/properties/additionalProperties/false schema", keyword: "false schema", params: {}, message: "boolean schema is false" }];
          return false;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.salt !== void 0) {
            const _errs1 = errors;
            if (typeof data.salt !== "string") {
              validate26.errors = [{ instancePath: instancePath + "/salt", schemaPath: "#/properties/salt/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
              return false;
            }
            var valid0 = _errs1 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.claims !== void 0) {
              let data2 = data.claims;
              const _errs3 = errors;
              if (errors === _errs3) {
                if (Array.isArray(data2)) {
                  var valid1 = true;
                  const len0 = data2.length;
                  for (let i0 = 0; i0 < len0; i0++) {
                    const _errs5 = errors;
                    if (typeof data2[i0] !== "string") {
                      validate26.errors = [{ instancePath: instancePath + "/claims/" + i0, schemaPath: "#/properties/claims/items/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                      return false;
                    }
                    var valid1 = _errs5 === errors;
                    if (!valid1) {
                      break;
                    }
                  }
                } else {
                  validate26.errors = [{ instancePath: instancePath + "/claims", schemaPath: "#/properties/claims/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                  return false;
                }
              }
              var valid0 = _errs3 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.payin !== void 0) {
                let data4 = data.payin;
                const _errs7 = errors;
                if (errors === _errs7) {
                  if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
                    const _errs9 = errors;
                    for (const key0 in data4) {
                      if (!(key0 === "paymentDetails")) {
                        validate26.errors = [{ instancePath: instancePath + "/payin", schemaPath: "#/properties/payin/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" }];
                        return false;
                        break;
                      }
                    }
                    if (_errs9 === errors) {
                      if (data4.paymentDetails !== void 0) {
                        let data5 = data4.paymentDetails;
                        if (!(data5 && typeof data5 == "object" && !Array.isArray(data5))) {
                          validate26.errors = [{ instancePath: instancePath + "/payin/paymentDetails", schemaPath: "#/properties/payin/properties/paymentDetails/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                          return false;
                        }
                      }
                    }
                  } else {
                    validate26.errors = [{ instancePath: instancePath + "/payin", schemaPath: "#/properties/payin/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                    return false;
                  }
                }
                var valid0 = _errs7 === errors;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data.payout !== void 0) {
                  let data6 = data.payout;
                  const _errs12 = errors;
                  if (errors === _errs12) {
                    if (data6 && typeof data6 == "object" && !Array.isArray(data6)) {
                      const _errs14 = errors;
                      for (const key1 in data6) {
                        if (!(key1 === "paymentDetails")) {
                          validate26.errors = [{ instancePath: instancePath + "/payout", schemaPath: "#/properties/payout/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key1 }, message: "must NOT have additional properties" }];
                          return false;
                          break;
                        }
                      }
                      if (_errs14 === errors) {
                        if (data6.paymentDetails !== void 0) {
                          let data7 = data6.paymentDetails;
                          if (!(data7 && typeof data7 == "object" && !Array.isArray(data7))) {
                            validate26.errors = [{ instancePath: instancePath + "/payout/paymentDetails", schemaPath: "#/properties/payout/properties/paymentDetails/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                            return false;
                          }
                        }
                      }
                    } else {
                      validate26.errors = [{ instancePath: instancePath + "/payout", schemaPath: "#/properties/payout/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                      return false;
                    }
                  }
                  var valid0 = _errs12 === errors;
                } else {
                  var valid0 = true;
                }
              }
            }
          }
        }
      }
    } else {
      validate26.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate26.errors = vErrors;
  return errors === 0;
}
var rfq = validate27;
function validate27(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.offeringId === void 0 && (missing0 = "offeringId") || data.payin === void 0 && (missing0 = "payin") || data.payout === void 0 && (missing0 = "payout")) {
        validate27.errors = [{ instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" }];
        return false;
      } else {
        if (data.additionalProperties !== void 0) {
          var valid0 = false;
          validate27.errors = [{ instancePath: instancePath + "/additionalProperties", schemaPath: "#/properties/additionalProperties/false schema", keyword: "false schema", params: {}, message: "boolean schema is false" }];
          return false;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.offeringId !== void 0) {
            const _errs1 = errors;
            if (typeof data.offeringId !== "string") {
              validate27.errors = [{ instancePath: instancePath + "/offeringId", schemaPath: "#/properties/offeringId/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
              return false;
            }
            var valid0 = _errs1 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.claimsHash !== void 0) {
              const _errs3 = errors;
              if (typeof data.claimsHash !== "string") {
                validate27.errors = [{ instancePath: instancePath + "/claimsHash", schemaPath: "#/properties/claimsHash/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                return false;
              }
              var valid0 = _errs3 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.payin !== void 0) {
                let data3 = data.payin;
                const _errs5 = errors;
                if (errors === _errs5) {
                  if (data3 && typeof data3 == "object" && !Array.isArray(data3)) {
                    let missing1;
                    if (data3.amount === void 0 && (missing1 = "amount") || data3.kind === void 0 && (missing1 = "kind")) {
                      validate27.errors = [{ instancePath: instancePath + "/payin", schemaPath: "#/properties/payin/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" }];
                      return false;
                    } else {
                      if (data3.amount !== void 0) {
                        let data4 = data3.amount;
                        const _errs7 = errors;
                        const _errs8 = errors;
                        if (errors === _errs8) {
                          if (typeof data4 === "string") {
                            if (!pattern0.test(data4)) {
                              validate27.errors = [{ instancePath: instancePath + "/payin/amount", schemaPath: "definitions.json#/definitions/decimalString/pattern", keyword: "pattern", params: { pattern: "^([0-9]+(?:[.][0-9]+)?)$" }, message: 'must match pattern "^([0-9]+(?:[.][0-9]+)?)$"' }];
                              return false;
                            }
                          } else {
                            validate27.errors = [{ instancePath: instancePath + "/payin/amount", schemaPath: "definitions.json#/definitions/decimalString/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                            return false;
                          }
                        }
                        var valid1 = _errs7 === errors;
                      } else {
                        var valid1 = true;
                      }
                      if (valid1) {
                        if (data3.kind !== void 0) {
                          const _errs10 = errors;
                          if (typeof data3.kind !== "string") {
                            validate27.errors = [{ instancePath: instancePath + "/payin/kind", schemaPath: "#/properties/payin/properties/kind/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                            return false;
                          }
                          var valid1 = _errs10 === errors;
                        } else {
                          var valid1 = true;
                        }
                        if (valid1) {
                          if (data3.paymentDetailsHash !== void 0) {
                            const _errs12 = errors;
                            if (typeof data3.paymentDetailsHash !== "string") {
                              validate27.errors = [{ instancePath: instancePath + "/payin/paymentDetailsHash", schemaPath: "#/properties/payin/properties/paymentDetailsHash/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                              return false;
                            }
                            var valid1 = _errs12 === errors;
                          } else {
                            var valid1 = true;
                          }
                        }
                      }
                    }
                  } else {
                    validate27.errors = [{ instancePath: instancePath + "/payin", schemaPath: "#/properties/payin/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                    return false;
                  }
                }
                var valid0 = _errs5 === errors;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data.payout !== void 0) {
                  let data7 = data.payout;
                  const _errs14 = errors;
                  if (errors === _errs14) {
                    if (data7 && typeof data7 == "object" && !Array.isArray(data7)) {
                      let missing2;
                      if (data7.kind === void 0 && (missing2 = "kind")) {
                        validate27.errors = [{ instancePath: instancePath + "/payout", schemaPath: "#/properties/payout/required", keyword: "required", params: { missingProperty: missing2 }, message: "must have required property '" + missing2 + "'" }];
                        return false;
                      } else {
                        if (data7.kind !== void 0) {
                          const _errs16 = errors;
                          if (typeof data7.kind !== "string") {
                            validate27.errors = [{ instancePath: instancePath + "/payout/kind", schemaPath: "#/properties/payout/properties/kind/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                            return false;
                          }
                          var valid3 = _errs16 === errors;
                        } else {
                          var valid3 = true;
                        }
                        if (valid3) {
                          if (data7.paymentDetailsHash !== void 0) {
                            const _errs18 = errors;
                            if (typeof data7.paymentDetailsHash !== "string") {
                              validate27.errors = [{ instancePath: instancePath + "/payout/paymentDetailsHash", schemaPath: "#/properties/payout/properties/paymentDetailsHash/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                              return false;
                            }
                            var valid3 = _errs18 === errors;
                          } else {
                            var valid3 = true;
                          }
                        }
                      }
                    } else {
                      validate27.errors = [{ instancePath: instancePath + "/payout", schemaPath: "#/properties/payout/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                      return false;
                    }
                  }
                  var valid0 = _errs14 === errors;
                } else {
                  var valid0 = true;
                }
              }
            }
          }
        }
      }
    } else {
      validate27.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate27.errors = vErrors;
  return errors === 0;
}

// node_modules/@tbdex/protocol/dist/esm/src/validator.js
function validate(payload, schemaName) {
  let validateFn = compiled_validators_exports[schemaName];
  if (!validateFn) {
    throw new Error(`no validator found for ${schemaName}`);
  }
  validateFn(payload);
  if (validateFn.errors) {
    handleValidationError(validateFn.errors);
  }
}
function handleValidationError(errors) {
  const [errorObj] = errors;
  let { instancePath, message: message2, params } = errorObj;
  instancePath || (instancePath = "message");
  message2 = params.allowedValues ? `${message2} - ${params.allowedValues.join(", ")}` : message2;
  throw new Error(`${instancePath}: ${message2}`);
}

// node_modules/@tbdex/protocol/dist/esm/src/resource.js
var Resource = class {
  /**
   * Constructor is primarily for intended for internal use. For a better developer experience,
   * consumers should use concrete classes to programmatically create and parse resources,
   * e.g. {@link Offering.parse} and {@link Offering.create}
   * @param metadata - {@link Resource.metadata}
   * @param data - {@link Resource.data}
   * @param signature - {@link Resource._signature}
   */
  constructor(metadata, data, signature) {
    /** Metadata such as creator, date created, date updated, and ID */
    __publicField(this, "metadata");
    /** Resource kind-specific data */
    __publicField(this, "data");
    /** signature that verifies that authenticity and integrity of a message */
    __publicField(this, "_signature");
    this.metadata = metadata;
    this.data = data;
    this._signature = signature;
  }
  /** Generates a unique id with the resource kind's prefix */
  static generateId(resourceKind) {
    return typeid(resourceKind).toString();
  }
  /**
   * Signs the resource as a jws with detached content and sets the signature property
   * @param did - the signer's DID
   * @throws If the signature could not be produced
   */
  async sign(did) {
    this._signature = await Crypto.sign({ did, payload: this.digest(), detached: true });
  }
  /**
   * Validates the resource structure and verifies the cryptographic signature
   * @throws if the resource signature is invalid
   * @throws if the signer's DID does not match Resource.metadata.from
   * @throws if the resource structure is invalid
   * @throws see {@link Crypto.verify}
   * @returns Resource signer's DID
   */
  async verify() {
    this.validate();
    const signer = this.verifySignature();
    return signer;
  }
  /**
   * Verifies the integrity of the cryptographic signature
   * @throws if the resource signature is invalid
   * @throws if the signer's DID does not match Resource.metadata.from
   * @returns Resource signer's DID
   */
  async verifySignature() {
    if (this.signature === void 0) {
      throw new Error("Could not verify message signature because no signature is missing");
    }
    const signer = await Crypto.verify({ detachedPayload: this.digest(), signature: this.signature });
    if (this.metadata.from !== signer) {
      throw new Error("Signature verification failed: Expected DID in kid of JWS header must match metadata.from");
    }
    return signer;
  }
  /**
   * Computes a digest of the payload by:
   * * JSON serializing the payload as per [RFC-8785: JSON Canonicalization Scheme](https://www.rfc-editor.org/rfc/rfc8785)
   * * sha256 hashing the serialized payload
   *
   * @returns The SHA-256 hash of the canonicalized payload, represented as a byte array.
   */
  digest() {
    return Crypto.digest({ metadata: this.metadata, data: this.data });
  }
  /**
   * Valid structure of the resource including the presence of the signature
   * using the official spec JSON Schemas
   * @throws If the resource's structure does not match the JSON schemas
   */
  validate() {
    validate(this.toJSON(), "resource");
    this.validateData();
  }
  /**
   * Validates `data` section of resource only using the official TBDex JSON Schemas.
   * This is useful for partially validating unsigned resources.
   * @throws If the structure of the Resource's data does not match the JSON schemas
   */
  validateData() {
    validate(this.data, this.kind);
  }
  /**
   * returns the resource as a json object. Automatically used by `JSON.stringify` method.
   */
  toJSON() {
    return {
      metadata: this.metadata,
      data: this.data,
      signature: this.signature
    };
  }
  /** the resource's cryptographic signature */
  get signature() {
    return this._signature;
  }
  /** the resource's id */
  get id() {
    return this.metadata.id;
  }
  /** The sender's DID */
  get from() {
    return this.metadata.from;
  }
  /** Resource creation time. Expressed as ISO8601 */
  get createdAt() {
    return this.metadata.createdAt;
  }
  /** Resource last updated time. Expressed as ISO8601 */
  get updatedAt() {
    return this.metadata.updatedAt;
  }
  /** the protocol version */
  get protocol() {
    return this.metadata.protocol;
  }
  /** offering type guard */
  isOffering() {
    return this.metadata.kind === "offering";
  }
  /** balance type guard */
  isBalance() {
    return this.metadata.kind === "balance";
  }
};

// node_modules/@tbdex/protocol/dist/esm/src/message.js
var import_dist61 = __toESM(require_dist(), 1);
var Message = class {
  /**
   * Constructor is primarily for intended for internal use. For a better developer experience,
   * consumers should use concrete classes to programmatically create and parse messages,
   * e.g. {@link Rfq.parse} and {@link Rfq.create}
   * @param metadata - {@link Message.metadata}
   * @param data - {@link Message.data}
   * @param signature - {@link Message._signature}
   */
  constructor(metadata, data, signature) {
    /** Metadata such as sender, recipient, date created, and ID */
    __publicField(this, "metadata");
    /** Message kind-specific data to facilitate the exchange of assets between Alice and the PFI */
    __publicField(this, "data");
    /** signature that verifies that authenticity and integrity of a message */
    __publicField(this, "_signature");
    this.metadata = metadata;
    this.data = data;
    this._signature = signature;
  }
  /** Generates a unique id with the message kind's prefix */
  static generateId(messageKind) {
    return typeid(messageKind).toString();
  }
  /**
   * Signs the message as a jws with detached content and sets the signature property
   * @param did - the signer's DID
   * @throws If the signature could not be produced
   */
  async sign(did) {
    this._signature = await Crypto.sign({ did, payload: this.digest(), detached: true });
  }
  /**
   * Validates the message structure and verifies the cryptographic signature
   * @throws if the message signature is invalid
   * @throws if the message structure is invalid
   * @throws see {@link Crypto.verify}
   * @returns Signer's DID
   */
  async verify() {
    this.validate();
    const signer = await this.verifySignature();
    return signer;
  }
  /**
   * Verifies the integrity of the cryptographic signature
   * @throws if the resource signature is invalid
   * @throws if the signer's DID does not match Resource.metadata.from
   * @returns Resource signer's DID
   */
  async verifySignature() {
    if (this.signature === void 0) {
      throw new Error("Could not verify message signature because no signature is missing");
    }
    const signer = await Crypto.verify({ detachedPayload: this.digest(), signature: this.signature });
    if (this.metadata.from !== signer) {
      throw new Error("Signature verification failed: Expected DID in kid of JWS header must match metadata.from");
    }
    return signer;
  }
  /**
   * Computes a digest of the payload by:
   * * JSON serializing the payload as per [RFC-8785: JSON Canonicalization Scheme](https://www.rfc-editor.org/rfc/rfc8785)
   * * sha256 hashing the serialized payload
   *
   * @returns The SHA-256 hash of the canonicalized payload, represented as a byte array.
   */
  digest() {
    return Crypto.digest({ metadata: this.metadata, data: this.data });
  }
  /**
   * Valid structure of the message including the presence of the signature
   * using the official spec JSON Schemas
   * @throws If the message's structure does not match the JSON schemas
   */
  validate() {
    validate(this.toJSON(), "message");
    this.validateData();
  }
  /**
   * Validates `data` section of message only using the official TBDex JSON Schemas.
   * This is useful for partially validating unsigned messages.
   * @throws If the structure of the messages's data does not match the JSON schemas
   */
  validateData() {
    validate(this.data, this.kind);
  }
  /** the message's cryptographic signature */
  get signature() {
    return this._signature;
  }
  /** the message id */
  get id() {
    return this.metadata.id;
  }
  /** ID for an "exchange" of messages between Alice - PFI. Uses the id of the RFQ that initiated the exchange */
  get exchangeId() {
    return this.metadata.exchangeId;
  }
  /** The sender's DID */
  get from() {
    return this.metadata.from;
  }
  /** the recipient's DID */
  get to() {
    return this.metadata.to;
  }
  /** Message creation time. Expressed as ISO8601 */
  get createdAt() {
    return this.metadata.createdAt;
  }
  /** the external ID */
  get externalId() {
    return this.metadata.externalId;
  }
  /** the protocol version */
  get protocol() {
    return this.metadata.protocol;
  }
  /** Rfq type guard */
  isRfq() {
    return this.metadata.kind === "rfq";
  }
  /** Quote type guard */
  isQuote() {
    return this.metadata.kind === "quote";
  }
  /** Order type guard */
  isOrder() {
    return this.metadata.kind === "order";
  }
  /** OrderStatus type guard */
  isOrderStatus() {
    return this.metadata.kind === "orderstatus";
  }
  /** Close type guard */
  isClose() {
    return this.metadata.kind === "close";
  }
  /**
   * returns the message as a json object. Automatically used by `JSON.stringify` method.
   */
  toJSON() {
    const message2 = {
      metadata: this.metadata,
      data: this.data,
      signature: this.signature
    };
    return message2;
  }
};

// node_modules/@tbdex/protocol/dist/esm/src/resource-kinds/index.js
var import_dist79 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/dist/esm/src/resource-kinds/offering.js
var import_dist77 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/dist/esm/src/parser.js
var import_dist76 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/dist/esm/src/message-kinds/index.js
var import_dist75 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/dist/esm/src/message-kinds/rfq.js
var import_dist70 = __toESM(require_dist(), 1);

// node_modules/bignumber.js/bignumber.mjs
var import_dist62 = __toESM(require_dist(), 1);
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i;
var mathceil = Math.ceil;
var mathfloor = Math.floor;
var bignumberError = "[BigNumber Error] ";
var tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ";
var BASE = 1e14;
var LOG_BASE = 14;
var MAX_SAFE_INTEGER = 9007199254740991;
var POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13];
var SQRT_BASE = 1e7;
var MAX = 1e9;
function clone(configObject) {
  var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: " ",
    // non-breaking space
    suffix: ""
  }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
  function BigNumber2(v, b) {
    var alphabet3, c, caseChanged, e, i, isNum, len, str, x = this;
    if (!(x instanceof BigNumber2))
      return new BigNumber2(v, b);
    if (b == null) {
      if (v && v._isBigNumber === true) {
        x.s = v.s;
        if (!v.c || v.e > MAX_EXP) {
          x.c = x.e = null;
        } else if (v.e < MIN_EXP) {
          x.c = [x.e = 0];
        } else {
          x.e = v.e;
          x.c = v.c.slice();
        }
        return;
      }
      if ((isNum = typeof v == "number") && v * 0 == 0) {
        x.s = 1 / v < 0 ? (v = -v, -1) : 1;
        if (v === ~~v) {
          for (e = 0, i = v; i >= 10; i /= 10, e++)
            ;
          if (e > MAX_EXP) {
            x.c = x.e = null;
          } else {
            x.e = e;
            x.c = [v];
          }
          return;
        }
        str = String(v);
      } else {
        if (!isNumeric.test(str = String(v)))
          return parseNumeric(x, str, isNum);
        x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }
      if ((e = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      if ((i = str.search(/e/i)) > 0) {
        if (e < 0)
          e = i;
        e += +str.slice(i + 1);
        str = str.substring(0, i);
      } else if (e < 0) {
        e = str.length;
      }
    } else {
      intCheck(b, 2, ALPHABET.length, "Base");
      if (b == 10 && alphabetHasNormalDecimalDigits) {
        x = new BigNumber2(v);
        return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
      }
      str = String(v);
      if (isNum = typeof v == "number") {
        if (v * 0 != 0)
          return parseNumeric(x, str, isNum, b);
        x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
        if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
          throw Error(tooManyDigits + v);
        }
      } else {
        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }
      alphabet3 = ALPHABET.slice(0, b);
      e = i = 0;
      for (len = str.length; i < len; i++) {
        if (alphabet3.indexOf(c = str.charAt(i)) < 0) {
          if (c == ".") {
            if (i > e) {
              e = len;
              continue;
            }
          } else if (!caseChanged) {
            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i = -1;
              e = 0;
              continue;
            }
          }
          return parseNumeric(x, String(v), isNum, b);
        }
      }
      isNum = false;
      str = convertBase(str, b, 10, x.s);
      if ((e = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      else
        e = str.length;
    }
    for (i = 0; str.charCodeAt(i) === 48; i++)
      ;
    for (len = str.length; str.charCodeAt(--len) === 48; )
      ;
    if (str = str.slice(i, ++len)) {
      len -= i;
      if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
        throw Error(tooManyDigits + x.s * v);
      }
      if ((e = e - i - 1) > MAX_EXP) {
        x.c = x.e = null;
      } else if (e < MIN_EXP) {
        x.c = [x.e = 0];
      } else {
        x.e = e;
        x.c = [];
        i = (e + 1) % LOG_BASE;
        if (e < 0)
          i += LOG_BASE;
        if (i < len) {
          if (i)
            x.c.push(+str.slice(0, i));
          for (len -= LOG_BASE; i < len; ) {
            x.c.push(+str.slice(i, i += LOG_BASE));
          }
          i = LOG_BASE - (str = str.slice(i)).length;
        } else {
          i -= len;
        }
        for (; i--; str += "0")
          ;
        x.c.push(+str);
      }
    } else {
      x.c = [x.e = 0];
    }
  }
  BigNumber2.clone = clone;
  BigNumber2.ROUND_UP = 0;
  BigNumber2.ROUND_DOWN = 1;
  BigNumber2.ROUND_CEIL = 2;
  BigNumber2.ROUND_FLOOR = 3;
  BigNumber2.ROUND_HALF_UP = 4;
  BigNumber2.ROUND_HALF_DOWN = 5;
  BigNumber2.ROUND_HALF_EVEN = 6;
  BigNumber2.ROUND_HALF_CEIL = 7;
  BigNumber2.ROUND_HALF_FLOOR = 8;
  BigNumber2.EUCLID = 9;
  BigNumber2.config = BigNumber2.set = function(obj) {
    var p, v;
    if (obj != null) {
      if (typeof obj == "object") {
        if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          DECIMAL_PLACES = v;
        }
        if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
          v = obj[p];
          intCheck(v, 0, 8, p);
          ROUNDING_MODE = v;
        }
        if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, 0, p);
            intCheck(v[1], 0, MAX, p);
            TO_EXP_NEG = v[0];
            TO_EXP_POS = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
          }
        }
        if (obj.hasOwnProperty(p = "RANGE")) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, -1, p);
            intCheck(v[1], 1, MAX, p);
            MIN_EXP = v[0];
            MAX_EXP = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            if (v) {
              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
            } else {
              throw Error(bignumberError + p + " cannot be zero: " + v);
            }
          }
        }
        if (obj.hasOwnProperty(p = "CRYPTO")) {
          v = obj[p];
          if (v === !!v) {
            if (v) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v;
              } else {
                CRYPTO = !v;
                throw Error(bignumberError + "crypto unavailable");
              }
            } else {
              CRYPTO = v;
            }
          } else {
            throw Error(bignumberError + p + " not true or false: " + v);
          }
        }
        if (obj.hasOwnProperty(p = "MODULO_MODE")) {
          v = obj[p];
          intCheck(v, 0, 9, p);
          MODULO_MODE = v;
        }
        if (obj.hasOwnProperty(p = "POW_PRECISION")) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          POW_PRECISION = v;
        }
        if (obj.hasOwnProperty(p = "FORMAT")) {
          v = obj[p];
          if (typeof v == "object")
            FORMAT = v;
          else
            throw Error(bignumberError + p + " not an object: " + v);
        }
        if (obj.hasOwnProperty(p = "ALPHABET")) {
          v = obj[p];
          if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
            alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
            ALPHABET = v;
          } else {
            throw Error(bignumberError + p + " invalid: " + v);
          }
        }
      } else {
        throw Error(bignumberError + "Object expected: " + obj);
      }
    }
    return {
      DECIMAL_PLACES,
      ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO,
      MODULO_MODE,
      POW_PRECISION,
      FORMAT,
      ALPHABET
    };
  };
  BigNumber2.isBigNumber = function(v) {
    if (!v || v._isBigNumber !== true)
      return false;
    if (!BigNumber2.DEBUG)
      return true;
    var i, n, c = v.c, e = v.e, s = v.s;
    out:
      if ({}.toString.call(c) == "[object Array]") {
        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
          if (c[0] === 0) {
            if (e === 0 && c.length === 1)
              return true;
            break out;
          }
          i = (e + 1) % LOG_BASE;
          if (i < 1)
            i += LOG_BASE;
          if (String(c[0]).length == i) {
            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n))
                break out;
            }
            if (n !== 0)
              return true;
          }
        }
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }
    throw Error(bignumberError + "Invalid BigNumber: " + v);
  };
  BigNumber2.maximum = BigNumber2.max = function() {
    return maxOrMin(arguments, -1);
  };
  BigNumber2.minimum = BigNumber2.min = function() {
    return maxOrMin(arguments, 1);
  };
  BigNumber2.random = function() {
    var pow2_53 = 9007199254740992;
    var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
      return mathfloor(Math.random() * pow2_53);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(dp) {
      var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
      if (dp == null)
        dp = DECIMAL_PLACES;
      else
        intCheck(dp, 0, MAX);
      k = mathceil(dp / LOG_BASE);
      if (CRYPTO) {
        if (crypto.getRandomValues) {
          a = crypto.getRandomValues(new Uint32Array(k *= 2));
          for (; i < k; ) {
            v = a[i] * 131072 + (a[i + 1] >>> 11);
            if (v >= 9e15) {
              b = crypto.getRandomValues(new Uint32Array(2));
              a[i] = b[0];
              a[i + 1] = b[1];
            } else {
              c.push(v % 1e14);
              i += 2;
            }
          }
          i = k / 2;
        } else if (crypto.randomBytes) {
          a = crypto.randomBytes(k *= 7);
          for (; i < k; ) {
            v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
            if (v >= 9e15) {
              crypto.randomBytes(7).copy(a, i);
            } else {
              c.push(v % 1e14);
              i += 7;
            }
          }
          i = k / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + "crypto unavailable");
        }
      }
      if (!CRYPTO) {
        for (; i < k; ) {
          v = random53bitInt();
          if (v < 9e15)
            c[i++] = v % 1e14;
        }
      }
      k = c[--i];
      dp %= LOG_BASE;
      if (k && dp) {
        v = POWS_TEN[LOG_BASE - dp];
        c[i] = mathfloor(k / v) * v;
      }
      for (; c[i] === 0; c.pop(), i--)
        ;
      if (i < 0) {
        c = [e = 0];
      } else {
        for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
          ;
        for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
          ;
        if (i < LOG_BASE)
          e -= LOG_BASE - i;
      }
      rand.e = e;
      rand.c = c;
      return rand;
    };
  }();
  BigNumber2.sum = function() {
    var i = 1, args = arguments, sum = new BigNumber2(args[0]);
    for (; i < args.length; )
      sum = sum.plus(args[i++]);
    return sum;
  };
  convertBase = function() {
    var decimal = "0123456789";
    function toBaseOut(str, baseIn, baseOut, alphabet3) {
      var j, arr = [0], arrL, i = 0, len = str.length;
      for (; i < len; ) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
          ;
        arr[0] += alphabet3.indexOf(str.charAt(i++));
        for (j = 0; j < arr.length; j++) {
          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] == null)
              arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    return function(str, baseIn, baseOut, sign, callerIsToString) {
      var alphabet3, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
      if (i >= 0) {
        k = POW_PRECISION;
        POW_PRECISION = 0;
        str = str.replace(".", "");
        y = new BigNumber2(baseIn);
        x = y.pow(str.length - i);
        POW_PRECISION = k;
        y.c = toBaseOut(
          toFixedPoint(coeffToString(x.c), x.e, "0"),
          10,
          baseOut,
          decimal
        );
        y.e = y.c.length;
      }
      xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet3 = ALPHABET, decimal) : (alphabet3 = decimal, ALPHABET));
      e = k = xc.length;
      for (; xc[--k] == 0; xc.pop())
        ;
      if (!xc[0])
        return alphabet3.charAt(0);
      if (i < 0) {
        --e;
      } else {
        x.c = xc;
        x.e = e;
        x.s = sign;
        x = div(x, y, dp, rm, baseOut);
        xc = x.c;
        r = x.r;
        e = x.e;
      }
      d = e + dp + 1;
      i = xc[d];
      k = baseOut / 2;
      r = r || d < 0 || xc[d + 1] != null;
      r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
      if (d < 1 || !xc[0]) {
        str = r ? toFixedPoint(alphabet3.charAt(1), -dp, alphabet3.charAt(0)) : alphabet3.charAt(0);
      } else {
        xc.length = d;
        if (r) {
          for (--baseOut; ++xc[--d] > baseOut; ) {
            xc[d] = 0;
            if (!d) {
              ++e;
              xc = [1].concat(xc);
            }
          }
        }
        for (k = xc.length; !xc[--k]; )
          ;
        for (i = 0, str = ""; i <= k; str += alphabet3.charAt(xc[i++]))
          ;
        str = toFixedPoint(str, e, alphabet3.charAt(0));
      }
      return str;
    };
  }();
  div = function() {
    function multiply(x, k, base) {
      var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
      for (x = x.slice(); i--; ) {
        xlo = x[i] % SQRT_BASE;
        xhi = x[i] / SQRT_BASE | 0;
        m = khi * xlo + xhi * klo;
        temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
        x[i] = temp % base;
      }
      if (carry)
        x = [carry].concat(x);
      return x;
    }
    function compare2(a, b, aL, bL) {
      var i, cmp;
      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i = cmp = 0; i < aL; i++) {
          if (a[i] != b[i]) {
            cmp = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }
      return cmp;
    }
    function subtract(a, b, aL, base) {
      var i = 0;
      for (; aL--; ) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b[aL];
      }
      for (; !a[0] && a.length > 1; a.splice(0, 1))
        ;
    }
    return function(x, y, dp, rm, base) {
      var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
      if (!xc || !xc[0] || !yc || !yc[0]) {
        return new BigNumber2(
          // Return NaN if either NaN, or both Infinity or 0.
          !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
          )
        );
      }
      q = new BigNumber2(s);
      qc = q.c = [];
      e = x.e - y.e;
      s = dp + e + 1;
      if (!base) {
        base = BASE;
        e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
        s = s / LOG_BASE | 0;
      }
      for (i = 0; yc[i] == (xc[i] || 0); i++)
        ;
      if (yc[i] > (xc[i] || 0))
        e--;
      if (s < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i = 0;
        s += 2;
        n = mathfloor(base / (yc[0] + 1));
        if (n > 1) {
          yc = multiply(yc, n, base);
          xc = multiply(xc, n, base);
          yL = yc.length;
          xL = xc.length;
        }
        xi = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; rem[remL++] = 0)
          ;
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base / 2)
          yc0++;
        do {
          n = 0;
          cmp = compare2(yc, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base + (rem[1] || 0);
            n = mathfloor(rem0 / yc0);
            if (n > 1) {
              if (n >= base)
                n = base - 1;
              prod = multiply(yc, n, base);
              prodL = prod.length;
              remL = rem.length;
              while (compare2(prod, rem, prodL, remL) == 1) {
                n--;
                subtract(prod, yL < prodL ? yz : yc, prodL, base);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              if (n == 0) {
                cmp = n = 1;
              }
              prod = yc.slice();
              prodL = prod.length;
            }
            if (prodL < remL)
              prod = [0].concat(prod);
            subtract(rem, prod, remL, base);
            remL = rem.length;
            if (cmp == -1) {
              while (compare2(yc, rem, yL, remL) < 1) {
                n++;
                subtract(rem, yL < remL ? yz : yc, remL, base);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n++;
            rem = [0];
          }
          qc[i++] = n;
          if (rem[0]) {
            rem[remL++] = xc[xi] || 0;
          } else {
            rem = [xc[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] != null) && s--);
        more = rem[0] != null;
        if (!qc[0])
          qc.splice(0, 1);
      }
      if (base == BASE) {
        for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
          ;
        round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
      } else {
        q.e = e;
        q.r = +more;
      }
      return q;
    };
  }();
  function format(n, i, rm, id) {
    var c0, e, ne, len, str;
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    if (!n.c)
      return n.toString();
    c0 = n.c[0];
    ne = n.e;
    if (i == null) {
      str = coeffToString(n.c);
      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
    } else {
      n = round(new BigNumber2(n), i, rm);
      e = n.e;
      str = coeffToString(n.c);
      len = str.length;
      if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
        for (; len < i; str += "0", len++)
          ;
        str = toExponential(str, e);
      } else {
        i -= ne;
        str = toFixedPoint(str, e, "0");
        if (e + 1 > len) {
          if (--i > 0)
            for (str += "."; i--; str += "0")
              ;
        } else {
          i += e - len;
          if (i > 0) {
            if (e + 1 == len)
              str += ".";
            for (; i--; str += "0")
              ;
          }
        }
      }
    }
    return n.s < 0 && c0 ? "-" + str : str;
  }
  function maxOrMin(args, n) {
    var k, y, i = 1, x = new BigNumber2(args[0]);
    for (; i < args.length; i++) {
      y = new BigNumber2(args[i]);
      if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
        x = y;
      }
    }
    return x;
  }
  function normalise(n, c, e) {
    var i = 1, j = c.length;
    for (; !c[--j]; c.pop())
      ;
    for (j = c[0]; j >= 10; j /= 10, i++)
      ;
    if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
      n.c = n.e = null;
    } else if (e < MIN_EXP) {
      n.c = [n.e = 0];
    } else {
      n.e = e;
      n.c = c;
    }
    return n;
  }
  parseNumeric = function() {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(x, str, isNum, b) {
      var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
      if (isInfinityOrNaN.test(s)) {
        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
      } else {
        if (!isNum) {
          s = s.replace(basePrefix, function(m, p1, p2) {
            base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
            return !b || b == base ? p1 : m;
          });
          if (b) {
            base = b;
            s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
          }
          if (str != s)
            return new BigNumber2(s, base);
        }
        if (BigNumber2.DEBUG) {
          throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
        }
        x.s = null;
      }
      x.c = x.e = null;
    };
  }();
  function round(x, sd, rm, r) {
    var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
    if (xc) {
      out: {
        for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
          ;
        i = sd - d;
        if (i < 0) {
          i += LOG_BASE;
          j = sd;
          n = xc[ni = 0];
          rd = mathfloor(n / pows10[d - j - 1] % 10);
        } else {
          ni = mathceil((i + 1) / LOG_BASE);
          if (ni >= xc.length) {
            if (r) {
              for (; xc.length <= ni; xc.push(0))
                ;
              n = rd = 0;
              d = 1;
              i %= LOG_BASE;
              j = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n = k = xc[ni];
            for (d = 1; k >= 10; k /= 10, d++)
              ;
            i %= LOG_BASE;
            j = i - LOG_BASE + d;
            rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
          }
        }
        r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
        r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
        if (sd < 1 || !xc[0]) {
          xc.length = 0;
          if (r) {
            sd -= x.e + 1;
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x.e = -sd || 0;
          } else {
            xc[0] = x.e = 0;
          }
          return x;
        }
        if (i == 0) {
          xc.length = ni;
          k = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k = pows10[LOG_BASE - i];
          xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
        }
        if (r) {
          for (; ; ) {
            if (ni == 0) {
              for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                ;
              j = xc[0] += k;
              for (k = 1; j >= 10; j /= 10, k++)
                ;
              if (i != k) {
                x.e++;
                if (xc[0] == BASE)
                  xc[0] = 1;
              }
              break;
            } else {
              xc[ni] += k;
              if (xc[ni] != BASE)
                break;
              xc[ni--] = 0;
              k = 1;
            }
          }
        }
        for (i = xc.length; xc[--i] === 0; xc.pop())
          ;
      }
      if (x.e > MAX_EXP) {
        x.c = x.e = null;
      } else if (x.e < MIN_EXP) {
        x.c = [x.e = 0];
      }
    }
    return x;
  }
  function valueOf(n) {
    var str, e = n.e;
    if (e === null)
      return n.toString();
    str = coeffToString(n.c);
    str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
    return n.s < 0 ? "-" + str : str;
  }
  P.absoluteValue = P.abs = function() {
    var x = new BigNumber2(this);
    if (x.s < 0)
      x.s = 1;
    return x;
  };
  P.comparedTo = function(y, b) {
    return compare(this, new BigNumber2(y, b));
  };
  P.decimalPlaces = P.dp = function(dp, rm) {
    var c, n, v, x = this;
    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(new BigNumber2(x), dp + x.e + 1, rm);
    }
    if (!(c = x.c))
      return null;
    n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    if (v = c[v])
      for (; v % 10 == 0; v /= 10, n--)
        ;
    if (n < 0)
      n = 0;
    return n;
  };
  P.dividedBy = P.div = function(y, b) {
    return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
  };
  P.dividedToIntegerBy = P.idiv = function(y, b) {
    return div(this, new BigNumber2(y, b), 0, 1);
  };
  P.exponentiatedBy = P.pow = function(n, m) {
    var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
    n = new BigNumber2(n);
    if (n.c && !n.isInteger()) {
      throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
    }
    if (m != null)
      m = new BigNumber2(m);
    nIsBig = n.e > 14;
    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
      y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
      return m ? y.mod(m) : y;
    }
    nIsNeg = n.s < 0;
    if (m) {
      if (m.c ? !m.c[0] : !m.s)
        return new BigNumber2(NaN);
      isModExp = !nIsNeg && x.isInteger() && m.isInteger();
      if (isModExp)
        x = x.mod(m);
    } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
      k = x.s < 0 && isOdd(n) ? -0 : 0;
      if (x.e > -1)
        k = 1 / k;
      return new BigNumber2(nIsNeg ? 1 / k : k);
    } else if (POW_PRECISION) {
      k = mathceil(POW_PRECISION / LOG_BASE + 2);
    }
    if (nIsBig) {
      half = new BigNumber2(0.5);
      if (nIsNeg)
        n.s = 1;
      nIsOdd = isOdd(n);
    } else {
      i = Math.abs(+valueOf(n));
      nIsOdd = i % 2;
    }
    y = new BigNumber2(ONE);
    for (; ; ) {
      if (nIsOdd) {
        y = y.times(x);
        if (!y.c)
          break;
        if (k) {
          if (y.c.length > k)
            y.c.length = k;
        } else if (isModExp) {
          y = y.mod(m);
        }
      }
      if (i) {
        i = mathfloor(i / 2);
        if (i === 0)
          break;
        nIsOdd = i % 2;
      } else {
        n = n.times(half);
        round(n, n.e + 1, 1);
        if (n.e > 14) {
          nIsOdd = isOdd(n);
        } else {
          i = +valueOf(n);
          if (i === 0)
            break;
          nIsOdd = i % 2;
        }
      }
      x = x.times(x);
      if (k) {
        if (x.c && x.c.length > k)
          x.c.length = k;
      } else if (isModExp) {
        x = x.mod(m);
      }
    }
    if (isModExp)
      return y;
    if (nIsNeg)
      y = ONE.div(y);
    return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
  };
  P.integerValue = function(rm) {
    var n = new BigNumber2(this);
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    return round(n, n.e + 1, rm);
  };
  P.isEqualTo = P.eq = function(y, b) {
    return compare(this, new BigNumber2(y, b)) === 0;
  };
  P.isFinite = function() {
    return !!this.c;
  };
  P.isGreaterThan = P.gt = function(y, b) {
    return compare(this, new BigNumber2(y, b)) > 0;
  };
  P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
    return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
  };
  P.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  P.isLessThan = P.lt = function(y, b) {
    return compare(this, new BigNumber2(y, b)) < 0;
  };
  P.isLessThanOrEqualTo = P.lte = function(y, b) {
    return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
  };
  P.isNaN = function() {
    return !this.s;
  };
  P.isNegative = function() {
    return this.s < 0;
  };
  P.isPositive = function() {
    return this.s > 0;
  };
  P.isZero = function() {
    return !!this.c && this.c[0] == 0;
  };
  P.minus = function(y, b) {
    var i, j, t, xLTy, x = this, a = x.s;
    y = new BigNumber2(y, b);
    b = y.s;
    if (!a || !b)
      return new BigNumber2(NaN);
    if (a != b) {
      y.s = -b;
      return x.plus(y);
    }
    var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
    if (!xe || !ye) {
      if (!xc || !yc)
        return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
      if (!xc[0] || !yc[0]) {
        return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ROUNDING_MODE == 3 ? -0 : 0
        ));
      }
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (xLTy = a < 0) {
        a = -a;
        t = xc;
      } else {
        ye = xe;
        t = yc;
      }
      t.reverse();
      for (b = a; b--; t.push(0))
        ;
      t.reverse();
    } else {
      j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
      for (a = b = 0; b < j; b++) {
        if (xc[b] != yc[b]) {
          xLTy = xc[b] < yc[b];
          break;
        }
      }
    }
    if (xLTy) {
      t = xc;
      xc = yc;
      yc = t;
      y.s = -y.s;
    }
    b = (j = yc.length) - (i = xc.length);
    if (b > 0)
      for (; b--; xc[i++] = 0)
        ;
    b = BASE - 1;
    for (; j > a; ) {
      if (xc[--j] < yc[j]) {
        for (i = j; i && !xc[--i]; xc[i] = b)
          ;
        --xc[i];
        xc[j] += BASE;
      }
      xc[j] -= yc[j];
    }
    for (; xc[0] == 0; xc.splice(0, 1), --ye)
      ;
    if (!xc[0]) {
      y.s = ROUNDING_MODE == 3 ? -1 : 1;
      y.c = [y.e = 0];
      return y;
    }
    return normalise(y, xc, ye);
  };
  P.modulo = P.mod = function(y, b) {
    var q, s, x = this;
    y = new BigNumber2(y, b);
    if (!x.c || !y.s || y.c && !y.c[0]) {
      return new BigNumber2(NaN);
    } else if (!y.c || x.c && !x.c[0]) {
      return new BigNumber2(x);
    }
    if (MODULO_MODE == 9) {
      s = y.s;
      y.s = 1;
      q = div(x, y, 0, 3);
      y.s = s;
      q.s *= s;
    } else {
      q = div(x, y, 0, MODULO_MODE);
    }
    y = x.minus(q.times(y));
    if (!y.c[0] && MODULO_MODE == 1)
      y.s = x.s;
    return y;
  };
  P.multipliedBy = P.times = function(y, b) {
    var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
    if (!xc || !yc || !xc[0] || !yc[0]) {
      if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y.c = y.e = y.s = null;
      } else {
        y.s *= x.s;
        if (!xc || !yc) {
          y.c = y.e = null;
        } else {
          y.c = [0];
          y.e = 0;
        }
      }
      return y;
    }
    e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
    y.s *= x.s;
    xcL = xc.length;
    ycL = yc.length;
    if (xcL < ycL) {
      zc = xc;
      xc = yc;
      yc = zc;
      i = xcL;
      xcL = ycL;
      ycL = i;
    }
    for (i = xcL + ycL, zc = []; i--; zc.push(0))
      ;
    base = BASE;
    sqrtBase = SQRT_BASE;
    for (i = ycL; --i >= 0; ) {
      c = 0;
      ylo = yc[i] % sqrtBase;
      yhi = yc[i] / sqrtBase | 0;
      for (k = xcL, j = i + k; j > i; ) {
        xlo = xc[--k] % sqrtBase;
        xhi = xc[k] / sqrtBase | 0;
        m = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
        c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
        zc[j--] = xlo % base;
      }
      zc[j] = c;
    }
    if (c) {
      ++e;
    } else {
      zc.splice(0, 1);
    }
    return normalise(y, zc, e);
  };
  P.negated = function() {
    var x = new BigNumber2(this);
    x.s = -x.s || null;
    return x;
  };
  P.plus = function(y, b) {
    var t, x = this, a = x.s;
    y = new BigNumber2(y, b);
    b = y.s;
    if (!a || !b)
      return new BigNumber2(NaN);
    if (a != b) {
      y.s = -b;
      return x.minus(y);
    }
    var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
    if (!xe || !ye) {
      if (!xc || !yc)
        return new BigNumber2(a / 0);
      if (!xc[0] || !yc[0])
        return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (a > 0) {
        ye = xe;
        t = yc;
      } else {
        a = -a;
        t = xc;
      }
      t.reverse();
      for (; a--; t.push(0))
        ;
      t.reverse();
    }
    a = xc.length;
    b = yc.length;
    if (a - b < 0) {
      t = yc;
      yc = xc;
      xc = t;
      b = a;
    }
    for (a = 0; b; ) {
      a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
      xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
    }
    if (a) {
      xc = [a].concat(xc);
      ++ye;
    }
    return normalise(y, xc, ye);
  };
  P.precision = P.sd = function(sd, rm) {
    var c, n, v, x = this;
    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(new BigNumber2(x), sd, rm);
    }
    if (!(c = x.c))
      return null;
    v = c.length - 1;
    n = v * LOG_BASE + 1;
    if (v = c[v]) {
      for (; v % 10 == 0; v /= 10, n--)
        ;
      for (v = c[0]; v >= 10; v /= 10, n++)
        ;
    }
    if (sd && x.e + 1 > n)
      n = x.e + 1;
    return n;
  };
  P.shiftedBy = function(k) {
    intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times("1e" + k);
  };
  P.squareRoot = P.sqrt = function() {
    var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
    if (s !== 1 || !c || !c[0]) {
      return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
    }
    s = Math.sqrt(+valueOf(x));
    if (s == 0 || s == 1 / 0) {
      n = coeffToString(c);
      if ((n.length + e) % 2 == 0)
        n += "0";
      s = Math.sqrt(+n);
      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
      if (s == 1 / 0) {
        n = "5e" + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf("e") + 1) + e;
      }
      r = new BigNumber2(n);
    } else {
      r = new BigNumber2(s + "");
    }
    if (r.c[0]) {
      e = r.e;
      s = e + dp;
      if (s < 3)
        s = 0;
      for (; ; ) {
        t = r;
        r = half.times(t.plus(div(x, t, dp, 1)));
        if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
          if (r.e < e)
            --s;
          n = n.slice(s - 3, s + 1);
          if (n == "9999" || !rep && n == "4999") {
            if (!rep) {
              round(t, t.e + DECIMAL_PLACES + 2, 0);
              if (t.times(t).eq(x)) {
                r = t;
                break;
              }
            }
            dp += 4;
            s += 4;
            rep = 1;
          } else {
            if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
              round(r, r.e + DECIMAL_PLACES + 2, 1);
              m = !r.times(r).eq(x);
            }
            break;
          }
        }
      }
    }
    return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
  };
  P.toExponential = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format(this, dp, rm, 1);
  };
  P.toFixed = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format(this, dp, rm);
  };
  P.toFormat = function(dp, rm, format2) {
    var str, x = this;
    if (format2 == null) {
      if (dp != null && rm && typeof rm == "object") {
        format2 = rm;
        rm = null;
      } else if (dp && typeof dp == "object") {
        format2 = dp;
        dp = rm = null;
      } else {
        format2 = FORMAT;
      }
    } else if (typeof format2 != "object") {
      throw Error(bignumberError + "Argument not an object: " + format2);
    }
    str = x.toFixed(dp, rm);
    if (x.c) {
      var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
      if (g2) {
        i = g1;
        g1 = g2;
        g2 = i;
        len -= i;
      }
      if (g1 > 0 && len > 0) {
        i = len % g1 || g1;
        intPart = intDigits.substr(0, i);
        for (; i < len; i += g1)
          intPart += groupSeparator + intDigits.substr(i, g1);
        if (g2 > 0)
          intPart += groupSeparator + intDigits.slice(i);
        if (isNeg)
          intPart = "-" + intPart;
      }
      str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
        new RegExp("\\d{" + g2 + "}\\B", "g"),
        "$&" + (format2.fractionGroupSeparator || "")
      ) : fractionPart) : intPart;
    }
    return (format2.prefix || "") + str + (format2.suffix || "");
  };
  P.toFraction = function(md) {
    var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
    if (md != null) {
      n = new BigNumber2(md);
      if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
        throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
      }
    }
    if (!xc)
      return new BigNumber2(x);
    d = new BigNumber2(ONE);
    n1 = d0 = new BigNumber2(ONE);
    d1 = n0 = new BigNumber2(ONE);
    s = coeffToString(xc);
    e = d.e = s.length - x.e - 1;
    d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n = new BigNumber2(s);
    n0.c[0] = 0;
    for (; ; ) {
      q = div(n, d, 0, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.comparedTo(md) == 1)
        break;
      d0 = d1;
      d1 = d2;
      n1 = n0.plus(q.times(d2 = n1));
      n0 = d2;
      d = n.minus(q.times(d2 = d));
      n = d2;
    }
    d2 = div(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d2.times(n1));
    d0 = d0.plus(d2.times(d1));
    n0.s = n1.s = x.s;
    e = e * 2;
    r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
      div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
    ) < 1 ? [n1, d1] : [n0, d0];
    MAX_EXP = exp;
    return r;
  };
  P.toNumber = function() {
    return +valueOf(this);
  };
  P.toPrecision = function(sd, rm) {
    if (sd != null)
      intCheck(sd, 1, MAX);
    return format(this, sd, rm, 2);
  };
  P.toString = function(b) {
    var str, n = this, s = n.s, e = n.e;
    if (e === null) {
      if (s) {
        str = "Infinity";
        if (s < 0)
          str = "-" + str;
      } else {
        str = "NaN";
      }
    } else {
      if (b == null) {
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
      } else if (b === 10 && alphabetHasNormalDecimalDigits) {
        n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n.c), n.e, "0");
      } else {
        intCheck(b, 2, ALPHABET.length, "Base");
        str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
      }
      if (s < 0 && n.c[0])
        str = "-" + str;
    }
    return str;
  };
  P.valueOf = P.toJSON = function() {
    return valueOf(this);
  };
  P._isBigNumber = true;
  P[Symbol.toStringTag] = "BigNumber";
  P[Symbol.for("nodejs.util.inspect.custom")] = P.valueOf;
  if (configObject != null)
    BigNumber2.set(configObject);
  return BigNumber2;
}
function bitFloor(n) {
  var i = n | 0;
  return n > 0 || n === i ? i : i - 1;
}
function coeffToString(a) {
  var s, z, i = 1, j = a.length, r = a[0] + "";
  for (; i < j; ) {
    s = a[i++] + "";
    z = LOG_BASE - s.length;
    for (; z--; s = "0" + s)
      ;
    r += s;
  }
  for (j = r.length; r.charCodeAt(--j) === 48; )
    ;
  return r.slice(0, j + 1 || 1);
}
function compare(x, y) {
  var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
  if (!i || !j)
    return null;
  a = xc && !xc[0];
  b = yc && !yc[0];
  if (a || b)
    return a ? b ? 0 : -j : i;
  if (i != j)
    return i;
  a = i < 0;
  b = k == l;
  if (!xc || !yc)
    return b ? 0 : !xc ^ a ? 1 : -1;
  if (!b)
    return k > l ^ a ? 1 : -1;
  j = (k = xc.length) < (l = yc.length) ? k : l;
  for (i = 0; i < j; i++)
    if (xc[i] != yc[i])
      return xc[i] > yc[i] ^ a ? 1 : -1;
  return k == l ? 0 : k > l ^ a ? 1 : -1;
}
function intCheck(n, min, max, name) {
  if (n < min || n > max || n !== mathfloor(n)) {
    throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
  }
}
function isOdd(n) {
  var k = n.c.length - 1;
  return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
}
function toExponential(str, e) {
  return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
}
function toFixedPoint(str, e, z) {
  var len, zs;
  if (e < 0) {
    for (zs = z + "."; ++e; zs += z)
      ;
    str = zs + str;
  } else {
    len = str.length;
    if (++e > len) {
      for (zs = z, e -= len; --e; zs += z)
        ;
      str += zs;
    } else if (e < len) {
      str = str.slice(0, e) + "." + str.slice(e);
    }
  }
  return str;
}
var BigNumber = clone();

// node_modules/@tbdex/protocol/node_modules/@web5/credentials/dist/esm/index.js
var import_dist69 = __toESM(require_dist());

// node_modules/@tbdex/protocol/node_modules/@web5/credentials/dist/esm/jwt.js
var import_dist63 = __toESM(require_dist(), 1);
var __awaiter22 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var crypto3 = new LocalKeyManager();
var Jwt = class _Jwt {
  /**
   * Creates a signed JWT.
   *
   * @example
   * ```ts
   * const jwt = await Jwt.sign({ signerDid: myDid, payload: myPayload });
   * ```
   *
   * @param options - Parameters for JWT creation including signer DID and payload.
   * @returns The compact JWT as a string.
   */
  static sign(options) {
    return __awaiter22(this, void 0, void 0, function* () {
      const { signerDid, payload } = options;
      const signer = yield signerDid.getSigner();
      let vmId = signer.keyId;
      if (vmId.charAt(0) === "#") {
        vmId = `${signerDid.uri}${vmId}`;
      }
      const header = {
        typ: "JWT",
        alg: signer.algorithm,
        kid: vmId
      };
      const base64UrlEncodedHeader = Convert.object(header).toBase64Url();
      const base64UrlEncodedPayload = Convert.object(payload).toBase64Url();
      const toSign = `${base64UrlEncodedHeader}.${base64UrlEncodedPayload}`;
      const toSignBytes = Convert.string(toSign).toUint8Array();
      const signatureBytes = yield signer.sign({ data: toSignBytes });
      const base64UrlEncodedSignature = Convert.uint8Array(signatureBytes).toBase64Url();
      return `${toSign}.${base64UrlEncodedSignature}`;
    });
  }
  /**
   * Verifies a JWT.
   *
   * @example
   * ```ts
   * const verifiedJwt = await Jwt.verify({ jwt: myJwt });
   * ```
   *
   * @param options - Parameters for JWT verification
   * @returns Verified JWT information including signer DID, header, and payload.
   */
  static verify(options) {
    return __awaiter22(this, void 0, void 0, function* () {
      const { decoded: decodedJwt, encoded: encodedJwt } = _Jwt.parse({ jwt: options.jwt });
      if (decodedJwt.payload.exp && Math.floor(Date.now() / 1e3) > decodedJwt.payload.exp) {
        throw new Error(`Verification failed: JWT is expired`);
      }
      const dereferenceResult = yield _Jwt.didResolver.dereference(decodedJwt.header.kid);
      if (dereferenceResult.dereferencingMetadata.error) {
        throw new Error(`Failed to resolve ${decodedJwt.header.kid}`);
      }
      const verificationMethod = dereferenceResult.contentStream;
      if (!verificationMethod || !utils_exports2.isDidVerificationMethod(verificationMethod)) {
        throw new Error("Verification failed: Expected kid in JWT header to dereference a DID Document Verification Method");
      }
      const publicKeyJwk = verificationMethod.publicKeyJwk;
      if (!publicKeyJwk) {
        throw new Error("Verification failed: Expected kid in JWT header to dereference to a DID Document Verification Method with publicKeyJwk");
      }
      if (publicKeyJwk.alg && publicKeyJwk.alg !== decodedJwt.header.alg) {
        throw new Error("Verification failed: Expected alg in JWT header to match DID Document Verification Method alg");
      }
      const signedData = `${encodedJwt.header}.${encodedJwt.payload}`;
      const signedDataBytes = Convert.string(signedData).toUint8Array();
      const signatureBytes = Convert.base64Url(encodedJwt.signature).toUint8Array();
      const isSignatureValid = yield crypto3.verify({
        key: publicKeyJwk,
        signature: signatureBytes,
        data: signedDataBytes
      });
      if (!isSignatureValid) {
        throw new Error("Signature verification failed: Integrity mismatch");
      }
      return decodedJwt;
    });
  }
  /**
   * Parses a JWT without verifying its signature.
   *
   * @example
   * ```ts
   * const { encoded: encodedJwt, decoded: decodedJwt } = Jwt.parse({ jwt: myJwt });
   * ```
   *
   * @param options - Parameters for JWT decoding, including the JWT string.
   * @returns both encoded and decoded JWT parts
   */
  static parse(options) {
    const splitJwt = options.jwt.split(".");
    if (splitJwt.length !== 3) {
      throw new Error(`Verification failed: Malformed JWT. expected 3 parts. got ${splitJwt.length}`);
    }
    const [base64urlEncodedJwtHeader, base64urlEncodedJwtPayload, base64urlEncodedSignature] = splitJwt;
    let jwtHeader;
    let jwtPayload;
    try {
      jwtHeader = Convert.base64Url(base64urlEncodedJwtHeader).toObject();
    } catch (e) {
      throw new Error("Verification failed: Malformed JWT. Invalid base64url encoding for JWT header");
    }
    if (!jwtHeader.typ || jwtHeader.typ !== "JWT") {
      throw new Error("Verification failed: Expected JWT header to contain typ property set to JWT");
    }
    if (!jwtHeader.alg || !jwtHeader.kid) {
      throw new Error("Verification failed: Expected JWT header to contain alg and kid");
    }
    try {
      jwtPayload = Convert.base64Url(base64urlEncodedJwtPayload).toObject();
    } catch (e) {
      throw new Error("Verification failed: Malformed JWT. Invalid base64url encoding for JWT payload");
    }
    return {
      decoded: {
        header: jwtHeader,
        payload: jwtPayload
      },
      encoded: {
        header: base64urlEncodedJwtHeader,
        payload: base64urlEncodedJwtPayload,
        signature: base64urlEncodedSignature
      }
    };
  }
};
Jwt.didResolver = new UniversalResolver({ didResolvers: [DidDht, DidIon, DidKey, DidJwk, DidWeb] });

// node_modules/@tbdex/protocol/node_modules/@web5/credentials/dist/esm/presentation-exchange.js
var import_dist64 = __toESM(require_dist(), 1);
var PresentationExchange = class {
  /**
   * Selects credentials that satisfy a given presentation definition.
   *
   * @param params - The parameters for the credential selection.
   * @param params.vcJwts  The list of Verifiable Credentials to select from.
   * @param params.presentationDefinition The Presentation Definition to match against.
   * @returns {string[]} selectedVcJwts A list of Verifiable Credentials that satisfy the Presentation Definition.
   */
  static selectCredentials({ vcJwts, presentationDefinition }) {
    var _a, _b;
    this.resetPex();
    const selectResults = this.pex.selectFrom(presentationDefinition, vcJwts);
    if (((_a = selectResults.errors) === null || _a === void 0 ? void 0 : _a.length) !== 0) {
      return [];
    }
    return Array.from(new Set((_b = selectResults.verifiableCredential) !== null && _b !== void 0 ? _b : []));
  }
  /**
   * Validates if a list of VC JWTs satisfies the given presentation definition.
   *
   * @param params - The parameters for the satisfaction check.
   * @param params.vcJwts - An array of VC JWTs as strings.
   * @param params.presentationDefinition - The criteria to validate against.
   * @throws Error if the evaluation results in warnings or errors.
   */
  static satisfiesPresentationDefinition({ vcJwts, presentationDefinition }) {
    var _a, _b, _c;
    this.resetPex();
    const evaluationResults = this.pex.evaluateCredentials(presentationDefinition, vcJwts);
    if ((_a = evaluationResults.warnings) === null || _a === void 0 ? void 0 : _a.length) {
      console.warn("Warnings were generated during the evaluation process: " + JSON.stringify(evaluationResults.warnings));
    }
    if (evaluationResults.areRequiredCredentialsPresent.toString() !== "info" || ((_b = evaluationResults.errors) === null || _b === void 0 ? void 0 : _b.length)) {
      let errorMessage = "Failed to create Verifiable Presentation JWT due to: ";
      if (evaluationResults.areRequiredCredentialsPresent) {
        errorMessage += "Required Credentials Not Present: " + JSON.stringify(evaluationResults.areRequiredCredentialsPresent);
      }
      if ((_c = evaluationResults.errors) === null || _c === void 0 ? void 0 : _c.length) {
        errorMessage += "Errors: " + JSON.stringify(evaluationResults.errors);
      }
      throw new Error(errorMessage);
    }
  }
  /**
   * Creates a presentation from a list of Verifiable Credentials that satisfy a given presentation definition.
   * This function initializes the Presentation Exchange (PEX) process, validates the presentation definition,
   * evaluates the credentials against the definition, and finally constructs the presentation result if the
   * evaluation is successful.
   *
   * @param params - The parameters for the presentation creation.
   * @param params.vcJwts The list of Verifiable Credentials (VCs) in JWT format to be evaluated.
   * @param params.presentationDefinition The Presentation Definition V2 to match the VCs against.
   * @returns {PresentationResult} The result of the presentation creation process, containing a presentation submission
   *                               that satisfies the presentation definition criteria.
   * @throws {Error} If the evaluation results in warnings or errors, or if the required credentials are not present,
   *                 an error is thrown with a descriptive message.
   */
  static createPresentationFromCredentials({ vcJwts, presentationDefinition }) {
    var _a, _b, _c;
    this.resetPex();
    const pdValidated = PEX.validateDefinition(presentationDefinition);
    isValid(pdValidated);
    const evaluationResults = this.pex.evaluateCredentials(presentationDefinition, vcJwts);
    if ((_a = evaluationResults.warnings) === null || _a === void 0 ? void 0 : _a.length) {
      console.warn("Warnings were generated during the evaluation process: " + JSON.stringify(evaluationResults.warnings));
    }
    if (evaluationResults.areRequiredCredentialsPresent.toString() !== "info" || ((_b = evaluationResults.errors) === null || _b === void 0 ? void 0 : _b.length)) {
      let errorMessage = "Failed to create Verifiable Presentation JWT due to: ";
      if (evaluationResults.areRequiredCredentialsPresent) {
        errorMessage += "Required Credentials Not Present: " + JSON.stringify(evaluationResults.areRequiredCredentialsPresent);
      }
      if ((_c = evaluationResults.errors) === null || _c === void 0 ? void 0 : _c.length) {
        errorMessage += "Errors: " + JSON.stringify(evaluationResults.errors);
      }
      throw new Error(errorMessage);
    }
    const presentationResult = this.pex.presentationFrom(presentationDefinition, vcJwts);
    const submissionValidated = PEX.validateSubmission(presentationResult.presentationSubmission);
    isValid(submissionValidated);
    return presentationResult;
  }
  /**
   * This method validates whether an object is usable as a presentation definition or not.
   *
   * @param {PresentationDefinitionV2} presentationDefinition: presentationDefinition to be validated.
   * @returns {Validated} the validation results to reveal what is acceptable/unacceptable about the passed object to be considered a valid presentation definition
   */
  static validateDefinition({ presentationDefinition }) {
    return PEX.validateDefinition(presentationDefinition);
  }
  /**
   * This method validates whether an object is usable as a presentation submission or not.
   *
   * @param {PresentationSubmission} presentationSubmission the object to be validated.
   * @returns {Validated} the validation results to reveal what is acceptable/unacceptable about the passed object to be considered a valid presentation submission
   */
  static validateSubmission({ presentationSubmission }) {
    return PEX.validateSubmission(presentationSubmission);
  }
  /**
   * Evaluates a presentation against a presentation definition.
   *
   * @returns {EvaluationResults} The result of the evaluation process.
   */
  static evaluatePresentation({ presentationDefinition, presentation }) {
    this.resetPex();
    return this.pex.evaluatePresentation(presentationDefinition, presentation);
  }
  /** Resets the PEX instance. */
  static resetPex() {
    this.pex = new PEX();
  }
};
PresentationExchange.pex = new PEX();
function isValid(validated) {
  let errorMessage = "Failed to pass validation check due to: ";
  if (Array.isArray(validated)) {
    if (!validated.every((item) => item.status === "info")) {
      errorMessage += "Validation Errors: " + JSON.stringify(validated);
      throw new Error(errorMessage);
    }
  } else {
    if (validated.status !== "info") {
      errorMessage += "Validation Errors: " + JSON.stringify(validated);
      throw new Error(errorMessage);
    }
  }
}

// node_modules/@tbdex/protocol/node_modules/@web5/credentials/dist/esm/verifiable-credential.js
var import_dist68 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/node_modules/@web5/credentials/dist/esm/validators.js
var import_dist67 = __toESM(require_dist(), 1);

// node_modules/@tbdex/protocol/node_modules/@web5/credentials/dist/esm/utils.js
var utils_exports3 = {};
__export(utils_exports3, {
  getCurrentXmlSchema112Timestamp: () => getCurrentXmlSchema112Timestamp,
  getFutureXmlSchema112Timestamp: () => getFutureXmlSchema112Timestamp,
  getXmlSchema112Timestamp: () => getXmlSchema112Timestamp,
  isValidRFC3339Timestamp: () => isValidRFC3339Timestamp,
  isValidXmlSchema112Timestamp: () => isValidXmlSchema112Timestamp
});
var import_dist65 = __toESM(require_dist(), 1);
function getCurrentXmlSchema112Timestamp() {
  return (/* @__PURE__ */ new Date()).toISOString().replace(/\.\d+Z$/, "Z");
}
function getXmlSchema112Timestamp(timestampInSeconds) {
  const date = new Date(timestampInSeconds * 1e3);
  return date.toISOString().replace(/\.\d{3}/, "");
}
function getFutureXmlSchema112Timestamp(secondsInFuture) {
  const futureDate = new Date(Date.now() + secondsInFuture * 1e3);
  return futureDate.toISOString().replace(/\.\d+Z$/, "Z");
}
function isValidXmlSchema112Timestamp(timestamp) {
  const regex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z$/;
  if (!regex.test(timestamp)) {
    return false;
  }
  const date = new Date(timestamp);
  return !isNaN(date.getTime());
}
function isValidRFC3339Timestamp(timestamp) {
  const regex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[+-]\d{2}:\d{2})$/;
  if (!regex.test(timestamp)) {
    return false;
  }
  const date = new Date(timestamp);
  return !isNaN(date.getTime());
}

// node_modules/@tbdex/protocol/node_modules/@web5/credentials/dist/esm/verifiable-presentation.js
var import_dist66 = __toESM(require_dist(), 1);
var DEFAULT_VP_TYPE = "VerifiablePresentation";

// node_modules/@tbdex/protocol/node_modules/@web5/credentials/dist/esm/validators.js
var SsiValidator = class {
  static validateCredentialPayload(vc) {
    this.validateContext(vc.vcDataModel["@context"]);
    this.validateVcType(vc.type);
    this.validateCredentialSubject(vc.vcDataModel.credentialSubject);
    if (vc.vcDataModel.issuanceDate)
      this.validateTimestamp(vc.vcDataModel.issuanceDate);
    if (vc.vcDataModel.expirationDate)
      this.validateTimestamp(vc.vcDataModel.expirationDate);
  }
  static validateContext(value) {
    const input = this.asArray(value);
    if (input.length < 1 || input.indexOf(DEFAULT_VC_CONTEXT) === -1) {
      throw new Error(`@context is missing default context "${DEFAULT_VC_CONTEXT}"`);
    }
  }
  static validateVcType(value) {
    const input = this.asArray(value);
    if (input.length < 1 || input.indexOf(DEFAULT_VC_TYPE) === -1) {
      throw new Error(`type is missing default "${DEFAULT_VC_TYPE}"`);
    }
  }
  static validateVpType(value) {
    const input = this.asArray(value);
    if (input.length < 1 || input.indexOf(DEFAULT_VP_TYPE) === -1) {
      throw new Error(`type is missing default "${DEFAULT_VP_TYPE}"`);
    }
  }
  static validateCredentialSubject(value) {
    if (Object.keys(value).length === 0) {
      throw new Error(`credentialSubject must not be empty`);
    }
  }
  static validateTimestamp(timestamp) {
    if (!isValidXmlSchema112Timestamp(timestamp) && !isValidRFC3339Timestamp(timestamp)) {
      throw new Error(`timestamp is not valid xml schema 112 timestamp`);
    }
  }
  static asArray(arg) {
    return Array.isArray(arg) ? arg : [arg];
  }
};

// node_modules/@tbdex/protocol/node_modules/@web5/credentials/dist/esm/verifiable-credential.js
var __awaiter23 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DEFAULT_VC_CONTEXT = "https://www.w3.org/2018/credentials/v1";
var DEFAULT_VC_TYPE = "VerifiableCredential";
var VerifiableCredential = class _VerifiableCredential {
  constructor(vcDataModel) {
    this.vcDataModel = vcDataModel;
  }
  /** The type of the credential. */
  get type() {
    return this.vcDataModel.type[this.vcDataModel.type.length - 1];
  }
  /** The issuer of the credential. */
  get issuer() {
    return this.vcDataModel.issuer.toString();
  }
  /** The subject of the credential. */
  get subject() {
    if (Array.isArray(this.vcDataModel.credentialSubject)) {
      return this.vcDataModel.credentialSubject[0].id;
    } else {
      return this.vcDataModel.credentialSubject.id;
    }
  }
  /**
   * Signs the verifiable credential and returns it as a signed JWT.
   *
   * @example
   * ```ts
   * const vcJwt = verifiableCredential.sign({ did: myDid });
   * ```
   *
   * @param options - The sign options used to sign the credential.
   * @returns The JWT representing the signed verifiable credential.
   */
  sign(options) {
    return __awaiter23(this, void 0, void 0, function* () {
      const vcJwt = yield Jwt.sign({
        signerDid: options.did,
        payload: Object.assign({ vc: this.vcDataModel, nbf: Math.floor(new Date(this.vcDataModel.issuanceDate).getTime() / 1e3), jti: this.vcDataModel.id, iss: options.did.uri, sub: this.subject, iat: Math.floor(Date.now() / 1e3) }, this.vcDataModel.expirationDate && {
          exp: Math.floor(new Date(this.vcDataModel.expirationDate).getTime() / 1e3)
        })
      });
      return vcJwt;
    });
  }
  /**
   * Converts the current object to its JSON representation.
   *
   * @returns The JSON representation of the object.
   */
  toString() {
    return JSON.stringify(this.vcDataModel);
  }
  /**
   * Create a [VerifiableCredential] based on the provided parameters.
   *
   * @example
   * ```ts
   * const vc = await VerifiableCredential.create({
   *     type: 'StreetCredibility',
   *     issuer: 'did:ex:issuer',
   *     subject: 'did:ex:subject',
   *     data: { 'arbitrary': 'data' }
   *   })
   * ```
   *
   * @param options - The options to use when creating the Verifiable Credential.
   * @returns A [VerifiableCredential] instance.
   */
  static create(options) {
    return __awaiter23(this, void 0, void 0, function* () {
      const { type, issuer, subject, data, issuanceDate, expirationDate, evidence } = options;
      const jsonData = JSON.parse(JSON.stringify(data));
      if (typeof jsonData !== "object") {
        throw new Error("Expected data to be parseable into a JSON object");
      }
      if (!issuer || !subject) {
        throw new Error("Issuer and subject must be defined");
      }
      if (typeof issuer !== "string" || typeof subject !== "string") {
        throw new Error("Issuer and subject must be of type string");
      }
      const credentialSubject = Object.assign({ id: subject }, jsonData);
      const vcDataModel = Object.assign(Object.assign({ "@context": [DEFAULT_VC_CONTEXT], type: Array.isArray(type) ? [DEFAULT_VC_TYPE, ...type] : type ? [DEFAULT_VC_TYPE, type] : [DEFAULT_VC_TYPE], id: `urn:uuid:${utils_exports.randomUuid()}`, issuer, issuanceDate: issuanceDate || getCurrentXmlSchema112Timestamp(), credentialSubject }, expirationDate && { expirationDate }), evidence && { evidence });
      validatePayload(vcDataModel);
      return new _VerifiableCredential(vcDataModel);
    });
  }
  /**
   * Verifies the integrity and authenticity of a Verifiable Credential (VC) encoded as a JSON Web Token (JWT).
   *
   * This function performs several crucial validation steps to ensure the trustworthiness of the provided VC:
   * - Parses and validates the structure of the JWT.
   * - Ensures the presence of critical header elements `alg` and `kid` in the JWT header.
   * - Resolves the Decentralized Identifier (DID) and retrieves the associated DID Document.
   * - Validates the DID and establishes a set of valid verification method IDs.
   * - Identifies the correct Verification Method from the DID Document based on the `kid` parameter.
   * - Verifies the JWT's signature using the public key associated with the Verification Method.
   *
   * If any of these steps fail, the function will throw a [Error] with a message indicating the nature of the failure:
   * - exp MUST represent the expirationDate property, encoded as a UNIX timestamp (NumericDate).
   * - iss MUST represent the issuer property of a verifiable credential or the holder property of a verifiable presentation.
   * - nbf MUST represent issuanceDate, encoded as a UNIX timestamp (NumericDate).
   * - jti MUST represent the id property of the verifiable credential or verifiable presentation.
   * - sub MUST represent the id property contained in the credentialSubject.
   *
   * Once the verifications are successful, when recreating the VC data model object, this function will:
   * - If exp is present, the UNIX timestamp MUST be converted to an [XMLSCHEMA11-2] date-time, and MUST be used to set the value of the expirationDate property of credentialSubject of the new JSON object.
   * - If iss is present, the value MUST be used to set the issuer property of the new credential JSON object or the holder property of the new presentation JSON object.
   * - If nbf is present, the UNIX timestamp MUST be converted to an [XMLSCHEMA11-2] date-time, and MUST be used to set the value of the issuanceDate property of the new JSON object.
   * - If sub is present, the value MUST be used to set the value of the id property of credentialSubject of the new credential JSON object.
   * - If jti is present, the value MUST be used to set the value of the id property of the new JSON object.
   *
   * @example
   * ```ts
   * try {
   *     VerifiableCredential.verify({ vcJwt: signedVcJwt })
   *     console.log("VC Verification successful!")
   * } catch (e: Error) {
   *     console.log("VC Verification failed: ${e.message}")
   * }
   * ```
   * @param param - The parameters for the verification process.
   * @param param.vcJwt The Verifiable Credential in JWT format as a [string].
   * @throws Error if the verification fails at any step, providing a message with failure details.
   * @throws Error if critical JWT header elements are absent.
   */
  static verify({ vcJwt }) {
    return __awaiter23(this, void 0, void 0, function* () {
      const { payload } = yield Jwt.verify({ jwt: vcJwt });
      const { exp, iss, nbf, jti, sub, vc } = payload;
      if (!vc) {
        throw new Error("vc property missing.");
      }
      const vcTyped = payload["vc"];
      if (exp && vcTyped.expirationDate && exp !== Math.floor(new Date(vcTyped.expirationDate).getTime() / 1e3)) {
        throw new Error("Verification failed: exp claim does not match expirationDate");
      }
      if (exp) {
        vcTyped.expirationDate = getXmlSchema112Timestamp(exp);
      }
      if (!iss)
        throw new Error("Verification failed: iss claim is required");
      if (iss !== vcTyped.issuer) {
        throw new Error("Verification failed: iss claim does not match expected issuer");
      }
      if (nbf && nbf > Math.floor(Date.now() / 1e3)) {
        throw new Error("Verification failed: nbf claim is in the future");
      }
      if (nbf && vcTyped.issuanceDate && nbf !== Math.floor(new Date(vcTyped.issuanceDate).getTime() / 1e3)) {
        throw new Error("Verification failed: nbf claim does not match issuanceDate");
      }
      if (nbf) {
        vcTyped.issuanceDate = getXmlSchema112Timestamp(nbf);
      }
      if (sub && !Array.isArray(vcTyped.credentialSubject) && sub !== vcTyped.credentialSubject.id) {
        throw new Error("Verification failed: sub claim does not match credentialSubject.id");
      }
      if (sub && !Array.isArray(vcTyped.credentialSubject)) {
        vcTyped.credentialSubject.id = sub;
      }
      if (jti && jti !== vcTyped.id) {
        throw new Error("Verification failed: jti claim does not match id");
      }
      if (jti) {
        vcTyped.id = jti;
      }
      validatePayload(vcTyped);
      return {
        /** The issuer of the VC. */
        issuer: payload.iss,
        /** The subject of the VC. */
        subject: payload.sub,
        /** The VC data model object. */
        vc: vcTyped
      };
    });
  }
  /**
   * Parses a JWT into a [VerifiableCredential] instance.
   *
   * @example
   * ```ts
   * const vc = VerifiableCredential.parseJwt({ vcJwt: signedVcJwt })
   * ```
   *
   * @param vcJwt The verifiable credential JWT as a [String].
   * @returns A [VerifiableCredential] instance derived from the JWT.
   */
  static parseJwt({ vcJwt }) {
    const parsedJwt = Jwt.parse({ jwt: vcJwt });
    const vcDataModel = parsedJwt.decoded.payload["vc"];
    if (!vcDataModel) {
      throw Error("Jwt payload missing vc property");
    }
    validatePayload(vcDataModel);
    return new _VerifiableCredential(vcDataModel);
  }
};
function validatePayload(vc) {
  SsiValidator.validateContext(vc["@context"]);
  SsiValidator.validateVcType(vc.type);
  SsiValidator.validateCredentialSubject(vc.credentialSubject);
  if (vc.issuanceDate)
    SsiValidator.validateTimestamp(vc.issuanceDate);
  if (vc.expirationDate)
    SsiValidator.validateTimestamp(vc.expirationDate);
}

// node_modules/@tbdex/protocol/dist/esm/src/message-kinds/rfq.js
var import_ajv = __toESM(require_ajv(), 1);
var Rfq = class _Rfq extends Message {
  constructor(metadata, data, signature, privateData) {
    super(metadata, data, signature);
    /** a set of valid Message kinds that can come after an rfq */
    __publicField(this, "validNext", /* @__PURE__ */ new Set(["quote", "close"]));
    /** The message kind (rfq) */
    __publicField(this, "kind", "rfq");
    /** Metadata such as sender, recipient, date created, and ID */
    __publicField(this, "metadata");
    /** Rfq's data containing information to initiate an exchange between Alice and a PFI */
    __publicField(this, "data");
    /** Rfq's unhashed private information to initiate an exchange between Alice and a PFI */
    __publicField(this, "privateData");
    this.metadata = metadata;
    this.data = data;
    this.privateData = privateData;
  }
  /**
   * Parses a json message into an Rfq
   * @param rawMessage - the rfq to parse
   * @throws if the rfq could not be parsed or is not a valid Rfq
   * @returns The parsed Rfq
   */
  static async parse(rawMessage, opts) {
    const jsonMessage = Parser.rawToMessageModel(rawMessage);
    const rfq2 = new _Rfq(jsonMessage.metadata, jsonMessage.data, jsonMessage.signature, jsonMessage.privateData);
    await rfq2.verify();
    if (opts == null ? void 0 : opts.requireAllPrivateData) {
      rfq2.verifyAllPrivateData();
    } else {
      rfq2.verifyPresentPrivateData();
    }
    return rfq2;
  }
  /**
   * Valid structure of the message including the presence of the signature
   * using the official spec JSON Schemas
   * @override
   * @throws If the message's structure does not match the JSON schemas
   */
  validate() {
    super.validate();
    if (this.privateData !== void 0) {
      validate(this.privateData, "rfqPrivate");
    }
  }
  /**
   * Creates an rfq with the given options
   * @param opts - options to create an rfq
   * @returns {@link Rfq}
   */
  static create(opts) {
    const id = Message.generateId("rfq");
    const metadata = {
      ...opts.metadata,
      kind: "rfq",
      id,
      exchangeId: id,
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      protocol: opts.metadata.protocol ?? "1.0"
    };
    const { data, privateData } = _Rfq.hashPrivateData(opts.data);
    const rfq2 = new _Rfq(metadata, data, void 0, privateData);
    rfq2.validateData();
    return rfq2;
  }
  /**
   * Hash private RFQ data and set private fields in an RfqPrivateData object
   * @param - unhashedRfqData
   * @returns An object with fields data and privateData.
   * @returns {@link RfqData} The value of data field.
   * @returns {@link RfqPrivateData} The value of privateData field.
   */
  static hashPrivateData(unhashedRfqData) {
    const salt = Convert.uint8Array(randomBytes2(16)).toBase64Url();
    const { claims, payin, payout, ...remainingRfqData } = unhashedRfqData;
    const { paymentDetails: payinDetails, ...remainingPayin } = payin;
    const { paymentDetails: payoutDetails, ...remainingPayout } = payout;
    const data = {
      ...remainingRfqData,
      payin: remainingPayin,
      payout: remainingPayout
    };
    if (payinDetails !== void 0) {
      data.payin.paymentDetailsHash = _Rfq.digestPrivateData(salt, payinDetails);
    }
    if (payoutDetails !== void 0) {
      data.payout.paymentDetailsHash = _Rfq.digestPrivateData(salt, payoutDetails);
    }
    if (claims !== void 0 && (claims == null ? void 0 : claims.length) > 0) {
      data.claimsHash = _Rfq.digestPrivateData(salt, claims);
    }
    const privateData = {
      salt,
      payin: {
        paymentDetails: payinDetails
      },
      payout: {
        paymentDetails: payoutDetails
      },
      claims
    };
    return {
      data,
      privateData
    };
  }
  /**
   * Verify the presence and integrity of all possible properties in {@link Rfq.privateData}.
   * @throws if there are properties missing in {@link Rfq.privateData} or which do not match the corresponding
   *         hashed property in {@link Rfq.data}
   */
  verifyAllPrivateData() {
    if (this.privateData === void 0) {
      throw new Error("Could not verify all privateData because privateData property is missing");
    }
    if (this.data.payin.paymentDetailsHash !== void 0) {
      this.verifyPayinDetailsHash();
    }
    if (this.data.payout.paymentDetailsHash !== void 0) {
      this.verifyPayoutDetailsHash();
    }
    if (this.data.claimsHash !== void 0) {
      this.verifyClaimsHash();
    }
  }
  /**
   * Verify the integrity properties that are present in {@link Rfq.privateData}.
   * @throws if there are properties present in {@link Rfq.privateData} which do not match the corresponding
   *         hashed property in {@link Rfq.data}
   */
  verifyPresentPrivateData() {
    var _a, _b, _c, _d, _e;
    if (this.data.payin.paymentDetailsHash !== void 0 && ((_b = (_a = this.privateData) == null ? void 0 : _a.payin) == null ? void 0 : _b.paymentDetails) !== void 0) {
      this.verifyPayinDetailsHash();
    }
    if (this.data.payout.paymentDetailsHash !== void 0 && ((_d = (_c = this.privateData) == null ? void 0 : _c.payout) == null ? void 0 : _d.paymentDetails) !== void 0) {
      this.verifyPayoutDetailsHash();
    }
    if (this.data.claimsHash !== void 0 && ((_e = this.privateData) == null ? void 0 : _e.claims) !== void 0) {
      this.verifyClaimsHash();
    }
  }
  verifyPayinDetailsHash() {
    var _a, _b;
    const digest = _Rfq.digestPrivateData(this.privateData.salt, (_b = (_a = this.privateData) == null ? void 0 : _a.payin) == null ? void 0 : _b.paymentDetails);
    if (digest !== this.data.payin.paymentDetailsHash) {
      throw new Error("Private data integrity check failed: data.payin.paymentDetailsHash does not match digest of privateData.payin.paymentDetails");
    }
  }
  verifyPayoutDetailsHash() {
    var _a, _b;
    const digest = _Rfq.digestPrivateData(this.privateData.salt, (_b = (_a = this.privateData) == null ? void 0 : _a.payout) == null ? void 0 : _b.paymentDetails);
    if (digest !== this.data.payout.paymentDetailsHash) {
      throw new Error("Private data integrity check failed: data.payout.paymentDetailsHash does not match digest of privateData.payout.paymentDetails");
    }
  }
  verifyClaimsHash() {
    var _a;
    const claimsHash = this.data.claimsHash;
    const claims = (_a = this.privateData) == null ? void 0 : _a.claims;
    const digest = _Rfq.digestPrivateData(this.privateData.salt, claims);
    if (digest !== claimsHash) {
      throw new Error(`Private data integrity check failed: data.claimsHash does not match digest of privateData.claims`);
    }
  }
  /**
   * Given a salt and a value, compute a deterministic digest used in hashed fields in RfqData
   * @param - salt
   * @param - value
   * @returns salted hash of the private data value
   */
  static digestPrivateData(salt, value) {
    const digestible = [salt, value];
    const byteArray = Crypto.digest(digestible);
    return Convert.uint8Array(byteArray).toBase64Url();
  }
  /**
   * evaluates this rfq against the provided offering
   * @param offering - the offering to evaluate this rfq against
   * @throws if Rfq.data.offeringId doesn't match the provided offering's id
   * @see RfqData#offeringId
   * @throws if payinAmount in {@link Rfq.data} exceeds the provided offering's max units allowed or is below the offering's min units allowed
   * @throws if payinMethod in {@link Rfq.data} property `kind` cannot be validated against the provided offering's payinMethod kinds
   * @throws if payinMethod in {@link Rfq.data} property `paymentDetails` cannot be validated against the provided offering's payinMethod requiredPaymentDetails
   * @throws if payoutMethod in {@link Rfq.data} property `kind` cannot be validated against the provided offering's payoutMethod kinds
   * @throws if payoutMethod in {@link Rfq.data} property `paymentDetails` cannot be validated against the provided offering's payoutMethod requiredPaymentDetails
   */
  async verifyOfferingRequirements(offering2) {
    var _a, _b, _c, _d;
    if (offering2.metadata.protocol !== this.metadata.protocol) {
      throw new Error(`protocol version mismatch. (rfq) ${this.metadata.protocol} !== ${offering2.metadata.protocol} (offering)`);
    }
    if (offering2.metadata.id !== this.data.offeringId) {
      throw new Error(`offering id mismatch. (rfq) ${this.data.offeringId} !== ${offering2.metadata.id} (offering)`);
    }
    let payinAmount;
    if (offering2.data.payin.max) {
      payinAmount = BigNumber(this.data.payin.amount);
      const maxAmount = BigNumber(offering2.data.payin.max);
      if (payinAmount.isGreaterThan(maxAmount)) {
        throw new Error(`rfq payinAmount exceeds offering's maxAmount. (rfq) ${this.data.payin.amount} > ${offering2.data.payin.max} (offering)`);
      }
    }
    if (offering2.data.payin.min) {
      payinAmount ?? (payinAmount = BigNumber(this.data.payin.amount));
      const minAmount = BigNumber(offering2.data.payin.min);
      if (payinAmount.isLessThan(minAmount)) {
        throw new Error(`rfq payinAmount is below offering's minAmount. (rfq) ${this.data.payin.amount} > ${offering2.data.payin.min} (offering)`);
      }
    }
    this.verifyPaymentMethod(this.data.payin.kind, this.data.payin.paymentDetailsHash, (_b = (_a = this.privateData) == null ? void 0 : _a.payin) == null ? void 0 : _b.paymentDetails, offering2.data.payin.methods, "payin");
    this.verifyPaymentMethod(this.data.payout.kind, this.data.payout.paymentDetailsHash, (_d = (_c = this.privateData) == null ? void 0 : _c.payout) == null ? void 0 : _d.paymentDetails, offering2.data.payout.methods, "payout");
    await this.verifyClaims(offering2);
  }
  /**
   * Validate the Rfq's payin/payout method against an Offering's allow payin/payout methods
   *
   * @param rfqPaymentMethod - The Rfq's selected payin/payout method being validated
   * @param allowedPaymentMethods - The Offering's allowed payin/payout methods
   * @param payDirection - Either 'payin' or 'payout', used to provide more detailed error messages.
   *
   * @throws if rfqPaymentMethod property `kind` cannot be validated against the provided offering's paymentMethod's kinds
   * @throws if {@link Rfq.privateData} property `paymentDetails` is missing but is necessary to validate against the provided offering's paymentMethod's kinds
   * @throws if rfqPaymentMethod property `paymentDetails` cannot be validated against the provided offering's paymentMethod's requiredPaymentDetails
   */
  verifyPaymentMethod(selectedPaymentKind, selectedPaymentDetailsHash, selectedPaymentDetails, allowedPaymentMethods, payDirection) {
    const paymentMethodMatches = allowedPaymentMethods.filter((paymentMethod) => paymentMethod.kind === selectedPaymentKind);
    if (!paymentMethodMatches.length) {
      const paymentMethodKinds = allowedPaymentMethods.map((paymentMethod) => paymentMethod.kind).join(", ");
      throw new Error(`offering does not support rfq's ${payDirection}Method kind. (rfq) ${selectedPaymentKind} was not found in: [${paymentMethodKinds}] (offering)`);
    }
    const ajv = new import_ajv.default.default();
    const invalidPaymentDetailsErrors = /* @__PURE__ */ new Set();
    for (const paymentMethodMatch of paymentMethodMatches) {
      if (!paymentMethodMatch.requiredPaymentDetails) {
        if (selectedPaymentDetailsHash === void 0) {
          return;
        }
        invalidPaymentDetailsErrors.add(new Error("paymentDetails must be omitted when requiredPaymentDetails is omitted"));
      } else {
        const validate2 = ajv.compile(paymentMethodMatch.requiredPaymentDetails);
        const isValid3 = validate2(selectedPaymentDetails);
        if (isValid3) {
          return;
        }
        invalidPaymentDetailsErrors.add(validate2.errors);
      }
    }
    throw new Error(`rfq ${payDirection}Method paymentDetails could not be validated against offering requiredPaymentDetails. Schema validation errors: ${Array.from(invalidPaymentDetailsErrors).join()}`);
  }
  /**
   * checks the claims provided in this rfq against an offering's requirements
   * @param offering - the offering to check against
   * @throws if rfq's claims do not fulfill the offering's requirements
   */
  async verifyClaims(offering2) {
    var _a;
    if (!offering2.data.requiredClaims) {
      return;
    }
    const credentials = PresentationExchange.selectCredentials({ vcJwts: ((_a = this.privateData) == null ? void 0 : _a.claims) ?? [], presentationDefinition: offering2.data.requiredClaims });
    if (credentials.length === 0) {
      throw new Error("claims do not fulfill the offering's requirements");
    }
    for (let credential of credentials) {
      await VerifiableCredential.verify({ vcJwt: credential });
    }
  }
  /**
   * Converts this rfq message to a json object
   */
  toJSON() {
    const jsonMessage = super.toJSON();
    if (this.privateData !== void 0) {
      jsonMessage.privateData = this.privateData;
    }
    return jsonMessage;
  }
};

// node_modules/@tbdex/protocol/dist/esm/src/message-kinds/quote.js
var import_dist71 = __toESM(require_dist(), 1);
var Quote = class _Quote extends Message {
  constructor(metadata, data, signature) {
    super(metadata, data, signature);
    /** a set of valid Message kinds that can come after a quote */
    __publicField(this, "validNext", /* @__PURE__ */ new Set(["order", "close"]));
    /** The message kind (quote) */
    __publicField(this, "kind", "quote");
    /** Metadata such as sender, recipient, date created, and ID */
    __publicField(this, "metadata");
    /**
     * Quote's data containing locked-in price and payment methods that the PFI is willing to honor
     * until the quote expires
     */
    __publicField(this, "data");
    this.metadata = metadata;
    this.data = data;
  }
  /**
   * Parses a json message into a Quote
   * @param rawMessage - the quote to parse
   * @throws if the quote could not be parsed or is not a valid Quote
   * @returns The parsed Quote
   */
  static async parse(rawMessage) {
    const jsonMessage = Parser.rawToMessageModel(rawMessage);
    const quote2 = new _Quote(jsonMessage.metadata, jsonMessage.data, jsonMessage.signature);
    await quote2.verify();
    return quote2;
  }
  /**
   * Creates a quote message with the given options
   * @param opts - options to create a quote
   */
  static create(opts) {
    const metadata = {
      ...opts.metadata,
      kind: "quote",
      id: Message.generateId("quote"),
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      protocol: opts.metadata.protocol ?? "1.0"
    };
    const quote2 = new _Quote(metadata, opts.data);
    quote2.validateData();
    return quote2;
  }
};

// node_modules/@tbdex/protocol/dist/esm/src/message-kinds/order.js
var import_dist72 = __toESM(require_dist(), 1);
var Order = class _Order extends Message {
  constructor(metadata, data, signature) {
    super(metadata, data, signature);
    /** a set of valid Message kinds that can come after an order */
    __publicField(this, "validNext", /* @__PURE__ */ new Set(["orderstatus"]));
    /** The message kind (order) */
    __publicField(this, "kind", "order");
    /** Metadata such as sender, recipient, date created, and ID */
    __publicField(this, "metadata");
    /** Order's data */
    __publicField(this, "data");
    this.metadata = metadata;
    this.data = data;
  }
  /**
   * Parses a json message into an Order
   * @param rawMessage - the order to parse
   * @throws if the order could not be parsed or is not a valid Order
   * @returns The parsed Order
   */
  static async parse(rawMessage) {
    const jsonMessage = Parser.rawToMessageModel(rawMessage);
    const order2 = new _Order(jsonMessage.metadata, jsonMessage.data, jsonMessage.signature);
    await order2.verify();
    return order2;
  }
  /**
   * Creates an order with the given options
   * @param opts - options to create an order
   */
  static create(opts) {
    const metadata = {
      ...opts.metadata,
      kind: "order",
      id: Message.generateId("order"),
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      protocol: opts.metadata.protocol ?? "1.0"
    };
    const order2 = new _Order(metadata, {});
    order2.validateData();
    return order2;
  }
};

// node_modules/@tbdex/protocol/dist/esm/src/message-kinds/order-status.js
var import_dist73 = __toESM(require_dist(), 1);
var OrderStatus = class _OrderStatus extends Message {
  constructor(metadata, data, signature) {
    super(metadata, data, signature);
    /** a set of valid Message kinds that can come after an order status */
    __publicField(this, "validNext", /* @__PURE__ */ new Set(["orderstatus", "close"]));
    /** The message kind (orderstatus) */
    __publicField(this, "kind", "orderstatus");
    /** Metadata such as sender, recipient, date created, and ID */
    __publicField(this, "metadata");
    /** OrderStatus's data containing a description of the status */
    __publicField(this, "data");
    this.metadata = metadata;
    this.data = data;
  }
  /**
   * Parses a json message into an OrderStatus
   * @param rawMessage - the orderstatus to parse
   * @throws if the orderstatus could not be parsed or is not a valid OrderStatus
   * @returns The parsed OrderStatus
   */
  static async parse(rawMessage) {
    const jsonMessage = Parser.rawToMessageModel(rawMessage);
    const orderStatus = new _OrderStatus(jsonMessage.metadata, jsonMessage.data, jsonMessage.signature);
    await orderStatus.verify();
    return orderStatus;
  }
  /**
   * Creates an order status with the given options
   * @param opts - options to create an order status
   */
  static create(opts) {
    const metadata = {
      ...opts.metadata,
      kind: "orderstatus",
      id: Message.generateId("orderstatus"),
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      protocol: opts.metadata.protocol ?? "1.0"
    };
    const orderStatus = new _OrderStatus(metadata, opts.data);
    orderStatus.validateData();
    return orderStatus;
  }
  /** Current status of Order that's being executed (e.g. PROCESSING, COMPLETED, FAILED etc.) */
  get orderStatus() {
    return this.data.orderStatus;
  }
};

// node_modules/@tbdex/protocol/dist/esm/src/message-kinds/close.js
var import_dist74 = __toESM(require_dist(), 1);
var Close = class _Close extends Message {
  constructor(metadata, data, signature) {
    super(metadata, data, signature);
    /** A set of valid Message kinds that can come after a close */
    __publicField(this, "validNext", /* @__PURE__ */ new Set([]));
    /** The message kind (close) */
    __publicField(this, "kind", "close");
    /** Metadata such as sender, recipient, date created, and ID */
    __publicField(this, "metadata");
    /** Close's data containing a reason why the exchange was closed */
    __publicField(this, "data");
    this.metadata = metadata;
    this.data = data;
  }
  /**
   * Parses a json message into an Close
   * @param rawMessage - the close to parse
   * @throws if the close could not be parsed or is not a valid Close
   * @returns The parsed Close
   */
  static async parse(rawMessage) {
    const jsonMessage = Parser.rawToMessageModel(rawMessage);
    const close2 = new _Close(jsonMessage.metadata, jsonMessage.data, jsonMessage.signature);
    await close2.verify();
    return close2;
  }
  /**
   * Creates a close message with the given options
   * @param opts - options to create a close message
   */
  static create(opts) {
    const metadata = {
      ...opts.metadata,
      kind: "close",
      id: Message.generateId("close"),
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      protocol: opts.metadata.protocol ?? "1.0"
    };
    const close2 = new _Close(metadata, opts.data);
    close2.validateData();
    return close2;
  }
  /** an explanation of why the exchange is being closed */
  get reason() {
    return this.data.reason;
  }
};

// node_modules/@tbdex/protocol/dist/esm/src/parser.js
var Parser = class _Parser {
  constructor() {
  }
  /**
   * @beta
   *
   * Parses the json message into a message instance.
   * Performs format validation and an integrity check on the signature
   * @param message - the message to parse. can either be an object or a string
   * @returns {@link Message}
   */
  static async parseMessage(rawMessage) {
    const jsonMessage = _Parser.rawToMessageModel(rawMessage);
    let message2;
    switch (jsonMessage.metadata.kind) {
      case "rfq":
        message2 = new Rfq(jsonMessage.metadata, jsonMessage.data, jsonMessage.signature, jsonMessage.privateData);
        break;
      case "quote":
        message2 = new Quote(jsonMessage.metadata, jsonMessage.data, jsonMessage.signature);
        break;
      case "order":
        message2 = new Order(jsonMessage.metadata, jsonMessage.data, jsonMessage.signature);
        break;
      case "orderstatus":
        message2 = new OrderStatus(jsonMessage.metadata, jsonMessage.data, jsonMessage.signature);
        break;
      case "close":
        message2 = new Close(jsonMessage.metadata, jsonMessage.data, jsonMessage.signature);
        break;
      default:
        throw new Error(`Unrecognized message kind (${jsonMessage.metadata.kind})`);
    }
    await message2.verify();
    return message2;
  }
  /**
   * @beta
   *
   * Parses a json message into an instance of message kind's class.
   * Performs format validation and an integrity check of the signature
   * @param jsonResource - the resource to parse
   * @returns {@link Resource}
   */
  static async parseResource(rawResource) {
    const jsonResource = _Parser.rawToResourceModel(rawResource);
    let resource2;
    switch (jsonResource.metadata.kind) {
      case "offering":
        resource2 = new Offering(jsonResource.metadata, jsonResource.data, jsonResource.signature);
        break;
      case "balance":
        resource2 = new Balance(jsonResource.metadata, jsonResource.data, jsonResource.signature);
        break;
      default:
        throw new Error(`Unrecognized resource kind (${jsonResource.metadata.kind})`);
    }
    await resource2.verify();
    return resource2;
  }
  /**
   * Util for JSON.parse-ing a stringified Tbdex Message
   * @param rawMessage - Either a stringified Tbdex Message or an object Tbdex Message
   * @returns A Tbdex Message as an object
   * @throws If the stringified message could not be JSON.parse'd
   */
  static rawToMessageModel(rawMessage) {
    try {
      return typeof rawMessage === "string" ? JSON.parse(rawMessage) : rawMessage;
    } catch (e) {
      const errorMessage = e instanceof Error ? e.message : e;
      throw new Error(`parse: Failed to parse message. Error: ${errorMessage}`);
    }
  }
  /**
   * Util for JSON.parse-ing a stringified Tbdex resource
   * @param rawResource - Either a stringified Tbdex resource or an object Tbdex resource
   * @returns A Tbdex message as an object
   * @throws If the stringified resource could not be JSON.parse'd
   */
  static rawToResourceModel(rawResource) {
    try {
      return typeof rawResource === "string" ? JSON.parse(rawResource) : rawResource;
    } catch (e) {
      const errorMessage = e instanceof Error ? e.message : e;
      throw new Error(`parse: Failed to parse resource. Error: ${errorMessage}`);
    }
  }
};

// node_modules/@tbdex/protocol/dist/esm/src/resource-kinds/offering.js
var Offering = class _Offering extends Resource {
  constructor(metadata, data, signature) {
    super(metadata, data, signature);
    /** The resource kind (offering) */
    __publicField(this, "kind", "offering");
    /** Metadata such as sender, date created, date updated, and ID */
    __publicField(this, "metadata");
    /** Offering's data such as payment methods, required claims, and currencies */
    __publicField(this, "data");
    this.metadata = metadata;
    this.data = data;
  }
  /**
   * Parses a json resource into an Offering
   * @param rawMessage - the Offering to parse
   * @throws if the offering could not be parsed or is not a valid Offering
   * @returns The parsed Offering
   */
  static async parse(rawMessage) {
    const jsonMessage = Parser.rawToResourceModel(rawMessage);
    const offering2 = new _Offering(jsonMessage.metadata, jsonMessage.data, jsonMessage.signature);
    await offering2.verify();
    return offering2;
  }
  /**
   * Creates an Offering with the given options
   * @param opts - options to create an offering
   */
  static create(opts) {
    const metadata = {
      ...opts.metadata,
      kind: "offering",
      id: Resource.generateId("offering"),
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      protocol: opts.metadata.protocol ?? "1.0"
    };
    const offering2 = new _Offering(metadata, opts.data);
    offering2.validateData();
    return offering2;
  }
};

// node_modules/@tbdex/protocol/dist/esm/src/resource-kinds/balance.js
var import_dist78 = __toESM(require_dist(), 1);
var Balance = class _Balance extends Resource {
  constructor(metadata, data, signature) {
    super(metadata, data, signature);
    /** The resource kind (balance) */
    __publicField(this, "kind", "balance");
    /** Metadata such as sender, date created, date updated, and ID */
    __publicField(this, "metadata");
    /** Balance's data such as currencies and available amounts */
    __publicField(this, "data");
    this.metadata = metadata;
    this.data = data;
  }
  /**
   * Parses a json resource into an Balance
   * @param rawMessage - the Balance to parse
   * @throws if the balance could not be parsed or is not a valid Balance
   * @returns The parsed Balance
   */
  static async parse(rawMessage) {
    const jsonMessage = Parser.rawToResourceModel(rawMessage);
    const balance2 = new _Balance(jsonMessage.metadata, jsonMessage.data, jsonMessage.signature);
    await balance2.verify();
    return balance2;
  }
  /**
   * Creates an Balance with the given options
   * @param opts - options to create an balance
   */
  static create(opts) {
    const metadata = {
      ...opts.metadata,
      kind: "balance",
      id: Resource.generateId("balance"),
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      protocol: opts.metadata.protocol ?? "1.0"
    };
    const balance2 = new _Balance(metadata, opts.data);
    balance2.validateData();
    return balance2;
  }
};

// node_modules/@tbdex/protocol/dist/esm/src/exchange.js
var import_dist80 = __toESM(require_dist(), 1);
var Exchange = class {
  constructor() {
    /** Message sent by Alice to PFI to request a quote */
    __publicField(this, "rfq");
    /** Message sent by the PFI in response to an RFQ */
    __publicField(this, "quote");
    /** Message sent by Alice to the PFI to accept a quote*/
    __publicField(this, "order");
    /** Message sent by the PFI to Alice to convet the current status of the order */
    __publicField(this, "orderstatus");
    /** Message sent by either the PFI or Alice to terminate an exchange */
    __publicField(this, "close");
    this.orderstatus = [];
  }
  /**
   * Add a list of unsorted messages to an exchange.
   * @param messages - An unsorted array of Tbdex messages in a given exchange
   */
  addMessages(messages) {
    const sortedMessages = messages.sort((m1, m2) => {
      const time1 = new Date(m1.metadata.createdAt).getTime();
      const time2 = new Date(m2.metadata.createdAt).getTime();
      return time1 - time2;
    });
    for (const message2 of sortedMessages) {
      this.addNextMessage(message2);
    }
  }
  /**
   * Add the next message in the exchange
   * @param message - The next allowed message in the exchange
   * @throws if message's protocol version does not match protocol version of other messages in the exchange
   * @throws if message is not a valid next message. See {@link Exchange.isValidNext}
   * @throws if message's exchangeId does not match id of the exchange
   */
  addNextMessage(message2) {
    if (this.protocol !== void 0 && message2.metadata.protocol !== this.protocol) {
      throw new Error(`Could not add message (${message2.metadata.id}) with protocol version ${message2.metadata.protocol} to exchange because it does not have matching protocol version ${this.protocol} as other messages in the exchange`);
    }
    if (!this.isValidNext(message2.metadata.kind)) {
      throw new Error(`Could not add message (${message2.metadata.id}) to exchange because ${message2.metadata.kind} is not a valid next message`);
    }
    if (this.exchangeId !== void 0 && message2.metadata.exchangeId !== this.exchangeId) {
      throw new Error(`Could not add message (${message2.metadata.id}) with exchange id ${message2.metadata.exchangeId} to exchange because it does not have matching exchange id ${this.exchangeId} as the exchange`);
    }
    if (message2.isRfq()) {
      this.rfq = message2;
    } else if (message2.isQuote()) {
      this.quote = message2;
    } else if (message2.isClose()) {
      this.close = message2;
    } else if (message2.isOrder()) {
      this.order = message2;
    } else if (message2.isOrderStatus()) {
      this.orderstatus.push(message2);
    } else {
      throw new Error("Unrecognized message kind");
    }
  }
  /**
   * Determines if the message kind is a valid next message in the current exchange
   * @param messageKind - the kind of TBDex message
   * @returns true if the next message in the exchange may have kind messageKind, false otherwise
   */
  isValidNext(messageKind) {
    var _a;
    const validNext = ((_a = this.latestMessage) == null ? void 0 : _a.validNext) ?? /* @__PURE__ */ new Set(["rfq"]);
    return validNext.has(messageKind);
  }
  /**
   * Latest message in an exchange if there are any messages currently
   */
  get latestMessage() {
    return this.close ?? this.orderstatus[this.orderstatus.length - 1] ?? this.order ?? this.quote ?? this.rfq;
  }
  /**
   * The exchangeId of all messages in the Exchange
   */
  get exchangeId() {
    var _a, _b;
    return (_b = (_a = this.rfq) == null ? void 0 : _a.metadata) == null ? void 0 : _b.exchangeId;
  }
  /**
   * The protocol version of all messages in the Exchange
   */
  get protocol() {
    var _a, _b;
    return (_b = (_a = this.rfq) == null ? void 0 : _a.metadata) == null ? void 0 : _b.protocol;
  }
  /**
   * A sorted list of messages currently in the exchange.
   */
  get messages() {
    const allPossibleMessages = [
      this.rfq,
      this.quote,
      this.order,
      ...this.orderstatus,
      this.close
    ];
    return allPossibleMessages.filter((message2) => message2 !== void 0);
  }
};

// node_modules/@tbdex/protocol/dist/esm/src/dev-tools.js
var import_dist81 = __toESM(require_dist(), 1);
var DevTools = class _DevTools {
  /**
   * creates and returns an example offering. Useful for testing purposes
   */
  static createOffering(opts) {
    return Offering.create({
      metadata: { from: (opts == null ? void 0 : opts.from) ?? "did:ex:pfi" },
      data: (opts == null ? void 0 : opts.offeringData) ?? _DevTools.createOfferingData()
    });
  }
  /**
   * creates an example OfferingData. Useful for testing purposes
   */
  static createOfferingData() {
    return {
      description: "Selling BTC for USD",
      payin: {
        currencyCode: "USD",
        min: "0.0",
        max: "999999.99",
        methods: [{
          kind: "DEBIT_CARD",
          requiredPaymentDetails: {
            $schema: "http://json-schema.org/draft-07/schema",
            type: "object",
            properties: {
              cardNumber: {
                type: "string",
                description: "The 16-digit debit card number",
                minLength: 16,
                maxLength: 16
              },
              expiryDate: {
                type: "string",
                description: "The expiry date of the card in MM/YY format",
                pattern: "^(0[1-9]|1[0-2])\\/([0-9]{2})$"
              },
              cardHolderName: {
                type: "string",
                description: "Name of the cardholder as it appears on the card"
              },
              cvv: {
                type: "string",
                description: "The 3-digit CVV code",
                minLength: 3,
                maxLength: 3
              }
            },
            required: ["cardNumber", "expiryDate", "cardHolderName", "cvv"],
            additionalProperties: false
          }
        }]
      },
      payout: {
        currencyCode: "BTC",
        max: "999526.11",
        methods: [{
          kind: "BTC_ADDRESS",
          requiredPaymentDetails: {
            $schema: "http://json-schema.org/draft-07/schema",
            type: "object",
            properties: {
              btcAddress: {
                type: "string",
                description: "your Bitcoin wallet address"
              }
            },
            required: ["btcAddress"],
            additionalProperties: false
          },
          estimatedSettlementTime: 10
          // seconds
        }]
      },
      payoutUnitsPerPayinUnit: "0.00003826",
      requiredClaims: {
        id: "7ce4004c-3c38-4853-968b-e411bafcd945",
        input_descriptors: [{
          id: "bbdb9b7c-5754-4f46-b63b-590bada959e0",
          constraints: {
            fields: [
              {
                path: ["$.type[*]"],
                filter: {
                  type: "string",
                  pattern: "^YoloCredential$"
                }
              }
            ]
          }
        }]
      }
    };
  }
  /**
   * creates and returns an example balance. Useful for testing purposes
   */
  static createBalance(opts) {
    return Balance.create({
      metadata: { from: (opts == null ? void 0 : opts.from) ?? "did:ex:pfi" },
      data: (opts == null ? void 0 : opts.balanceData) ?? _DevTools.createBalanceData()
    });
  }
  /**
   * creates an example BalanceData. Useful for testing purposes
   */
  static createBalanceData() {
    return {
      currencyCode: "USD",
      available: "400.00"
    };
  }
  /**
   * creates an example QuoteData. Useful for testing purposes
   */
  static createQuoteData() {
    return {
      expiresAt: (/* @__PURE__ */ new Date()).toISOString(),
      payin: {
        currencyCode: "BTC",
        amount: "0.01",
        fee: "0.0001",
        paymentInstruction: {
          link: "tbdex.io/example",
          instruction: "Fake instruction"
        }
      },
      payout: {
        currencyCode: "USD",
        amount: "1000.00",
        paymentInstruction: {
          link: "tbdex.io/example",
          instruction: "Fake instruction"
        }
      }
    };
  }
  /**
   *
   * creates and returns an example rfq for the offering returned by {@link DevTools.createOffering}.
   * Useful for testing purposes.
   *
   * **NOTE**: generates a random credential that fulfills the offering's required claims
   */
  static async createRfq(opts) {
    const { sender, receiver } = opts;
    const rfqData = await _DevTools.createRfqData(opts);
    return Rfq.create({
      metadata: { from: sender.uri, to: (receiver == null ? void 0 : receiver.uri) ?? "did:ex:pfi" },
      data: rfqData
    });
  }
  /**
   * creates an example RfqData. Useful for testing purposes
   */
  static async createRfqData(opts) {
    let vcJwt = "";
    if (opts == null ? void 0 : opts.sender) {
      const vc = await VerifiableCredential.create({
        type: "YoloCredential",
        issuer: opts.sender.uri,
        subject: opts.sender.uri,
        data: {
          "beep": "boop"
        }
      });
      vcJwt = await vc.sign({ did: opts.sender });
    }
    return {
      offeringId: Resource.generateId("offering"),
      payin: {
        kind: "DEBIT_CARD",
        amount: "200.00",
        paymentDetails: {
          "cardNumber": "1234567890123456",
          "expiryDate": "12/22",
          "cardHolderName": "Ephraim Bartholomew Winthrop",
          "cvv": "123"
        }
      },
      payout: {
        kind: "BTC_ADDRESS",
        paymentDetails: {
          btcAddress: "1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa"
        }
      },
      claims: [vcJwt]
    };
  }
};

// node_modules/@tbdex/protocol/dist/esm/src/types.js
var import_dist82 = __toESM(require_dist(), 1);

// node_modules/@tbdex/http-client/dist/esm/src/client.js
var import_dist156 = __toESM(require_dist(), 1);

// node_modules/@tbdex/http-client/dist/esm/src/errors/index.js
var import_dist88 = __toESM(require_dist(), 1);

// node_modules/@tbdex/http-client/dist/esm/src/errors/request-error.js
var import_dist84 = __toESM(require_dist(), 1);
var RequestError = class extends Error {
  constructor(params) {
    super(params.message, { cause: params.cause });
    /** string DID of the recipient */
    __publicField(this, "recipientDid");
    /** URL of the request */
    __publicField(this, "url");
    this.name = this.constructor.name;
    this.recipientDid = params.recipientDid;
    this.url = params.url;
  }
};

// node_modules/@tbdex/http-client/dist/esm/src/errors/response-error.js
var import_dist85 = __toESM(require_dist(), 1);
var ResponseError = class extends Error {
  constructor(params) {
    super();
    /** HTTP status code of the error */
    __publicField(this, "statusCode");
    /** Array of ErrorDetails */
    __publicField(this, "details");
    /** String DID of the recipient of the error */
    __publicField(this, "recipientDid");
    /** URL where the error was thrown */
    __publicField(this, "url");
    this.name = this.constructor.name;
    this.statusCode = params.statusCode;
    this.details = params.details;
    this.recipientDid = params.recipientDid;
    this.url = params.url;
  }
};

// node_modules/@tbdex/http-client/dist/esm/src/errors/validation-error.js
var import_dist86 = __toESM(require_dist(), 1);
var ValidationError = class extends Error {
  constructor(message2) {
    super(message2);
    this.name = this.constructor.name;
  }
};
var InvalidDidError = class extends ValidationError {
};
var MissingServiceEndpointError = class extends ValidationError {
};

// node_modules/@tbdex/http-client/dist/esm/src/errors/request-token-error.js
var import_dist87 = __toESM(require_dist(), 1);
var RequestTokenError = class extends Error {
  constructor(params) {
    super(params.message, { cause: params.cause });
    this.name = this.constructor.name;
  }
};
var RequestTokenSigningError = class extends RequestTokenError {
};
var RequestTokenVerificationError = class extends RequestTokenError {
};
var RequestTokenMissingClaimsError = class extends RequestTokenError {
};
var RequestTokenAudienceMismatchError = class extends RequestTokenError {
};
var RequestTokenIssuerSignerMismatchError = class extends RequestTokenError {
};

// node_modules/@tbdex/http-client/node_modules/@web5/dids/dist/esm/index.js
var import_dist138 = __toESM(require_dist());

// node_modules/@tbdex/http-client/node_modules/@web5/dids/dist/esm/types/did-core.js
var import_dist89 = __toESM(require_dist(), 1);
var DidVerificationRelationship2;
(function(DidVerificationRelationship3) {
  DidVerificationRelationship3["authentication"] = "authentication";
  DidVerificationRelationship3["assertionMethod"] = "assertionMethod";
  DidVerificationRelationship3["keyAgreement"] = "keyAgreement";
  DidVerificationRelationship3["capabilityDelegation"] = "capabilityDelegation";
  DidVerificationRelationship3["capabilityInvocation"] = "capabilityInvocation";
})(DidVerificationRelationship2 || (DidVerificationRelationship2 = {}));

// node_modules/@tbdex/http-client/node_modules/@web5/dids/dist/esm/types/did-resolution.js
var import_dist90 = __toESM(require_dist(), 1);
var EMPTY_DID_RESOLUTION_RESULT2 = {
  "@context": "https://w3id.org/did-resolution/v1",
  didResolutionMetadata: {},
  didDocument: null,
  didDocumentMetadata: {}
};

// node_modules/@tbdex/http-client/node_modules/@web5/dids/dist/esm/did.js
var import_dist91 = __toESM(require_dist(), 1);
var Did2 = class _Did {
  /**
   * Constructs a new `Did` instance from individual components.
   *
   * @param params - An object containing the parameters to be included in the DID URI.
   * @param params.method - The name of the DID method.
   * @param params.id - The DID method identifier.
   * @param params.path - Optional. The path component of the DID URI.
   * @param params.query - Optional. The query component of the DID URI.
   * @param params.fragment - Optional. The fragment component of the DID URI.
   * @param params.params - Optional. The query parameters in the DID URI.
   */
  constructor({ method, id, path, query, fragment, params }) {
    this.uri = `did:${method}:${id}`;
    this.method = method;
    this.id = id;
    this.path = path;
    this.query = query;
    this.fragment = fragment;
    this.params = params;
  }
  /**
   * Parses a DID URI string into its individual components.
   *
   * @example
   * ```ts
   * const did = Did.parse('did:example:123?service=agent&relativeRef=/credentials#degree');
   *
   * console.log(did.uri)      // Output: 'did:example:123'
   * console.log(did.method)   // Output: 'example'
   * console.log(did.id)       // Output: '123'
   * console.log(did.query)    // Output: 'service=agent&relativeRef=/credentials'
   * console.log(did.fragment) // Output: 'degree'
   * console.log(did.params)   // Output: { service: 'agent', relativeRef: '/credentials' }
   * ```
   *
   * @params didUri - The DID URI string to be parsed.
   * @returns A `Did` object representing the parsed DID URI, or `null` if the input string is not a valid DID URI.
   */
  static parse(didUri) {
    if (!didUri)
      return null;
    const match = _Did.DID_URI_PATTERN.exec(didUri);
    if (!match || !match.groups)
      return null;
    const { method, id, path, query, fragment } = match.groups;
    const did = {
      uri: `did:${method}:${id}`,
      method,
      id
    };
    if (path)
      did.path = path;
    if (query)
      did.query = query.slice(1);
    if (fragment)
      did.fragment = fragment.slice(1);
    if (query) {
      const parsedParams = {};
      const paramPairs = query.slice(1).split("&");
      for (const pair of paramPairs) {
        const [key, value] = pair.split("=");
        parsedParams[key] = value;
      }
      did.params = parsedParams;
    }
    return did;
  }
};
Did2.METHOD_PATTERN = "([a-z0-9]+)";
Did2.PCT_ENCODED_PATTERN = "(?:%[0-9a-fA-F]{2})";
Did2.ID_CHAR_PATTERN = `(?:[a-zA-Z0-9._-]|${Did2.PCT_ENCODED_PATTERN})`;
Did2.METHOD_ID_PATTERN = `((?:${Did2.ID_CHAR_PATTERN}*:)*(${Did2.ID_CHAR_PATTERN}+))`;
Did2.PATH_PATTERN = `(/[^#?]*)?`;
Did2.QUERY_PATTERN = `([?][^#]*)?`;
Did2.FRAGMENT_PATTERN = `(#.*)?`;
Did2.DID_URI_PATTERN = new RegExp(`^did:(?<method>${Did2.METHOD_PATTERN}):(?<id>${Did2.METHOD_ID_PATTERN})(?<path>${Did2.PATH_PATTERN})(?<query>${Did2.QUERY_PATTERN})(?<fragment>${Did2.FRAGMENT_PATTERN})$`);

// node_modules/@tbdex/http-client/node_modules/@web5/dids/dist/esm/did-error.js
var import_dist92 = __toESM(require_dist(), 1);
var DidError2 = class _DidError extends Error {
  /**
   * Constructs an instance of DidError, a custom error class for handling DID-related errors.
   *
   * @param code - A {@link DidErrorCode} representing the specific type of error encountered.
   * @param message - A human-readable description of the error.
   */
  constructor(code, message2) {
    super(message2);
    this.code = code;
    this.name = "DidError";
    Object.setPrototypeOf(this, new.target.prototype);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _DidError);
    }
  }
};
var DidErrorCode2;
(function(DidErrorCode3) {
  DidErrorCode3["InvalidDid"] = "invalidDid";
  DidErrorCode3["MethodNotSupported"] = "methodNotSupported";
  DidErrorCode3["InternalError"] = "internalError";
  DidErrorCode3["InvalidDidDocument"] = "invalidDidDocument";
  DidErrorCode3["InvalidDidDocumentLength"] = "invalidDidDocumentLength";
  DidErrorCode3["InvalidDidUrl"] = "invalidDidUrl";
  DidErrorCode3["InvalidPublicKey"] = "invalidPublicKey";
  DidErrorCode3["InvalidPublicKeyLength"] = "invalidPublicKeyLength";
  DidErrorCode3["InvalidPublicKeyType"] = "invalidPublicKeyType";
  DidErrorCode3["InvalidSignature"] = "invalidSignature";
  DidErrorCode3["NotFound"] = "notFound";
  DidErrorCode3["RepresentationNotSupported"] = "representationNotSupported";
  DidErrorCode3["UnsupportedPublicKeyType"] = "unsupportedPublicKeyType";
})(DidErrorCode2 || (DidErrorCode2 = {}));

// node_modules/@tbdex/http-client/node_modules/@web5/dids/dist/esm/bearer-did.js
var import_dist128 = __toESM(require_dist(), 1);

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/index.js
var import_dist126 = __toESM(require_dist());

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/local-key-manager.js
var import_dist112 = __toESM(require_dist(), 1);

// node_modules/@tbdex/http-client/node_modules/@web5/common/dist/esm/index.js
var import_dist101 = __toESM(require_dist());

// node_modules/@tbdex/http-client/node_modules/@web5/common/dist/esm/cache.js
var import_dist93 = __toESM(require_dist(), 1);
var import_ttlcache2 = __toESM(require_ttlcache(), 1);

// node_modules/@tbdex/http-client/node_modules/@web5/common/dist/esm/convert.js
var import_dist95 = __toESM(require_dist(), 1);

// node_modules/@tbdex/http-client/node_modules/@web5/common/dist/esm/type-utils.js
var import_dist94 = __toESM(require_dist(), 1);
function isArrayBufferSlice2(arrayBufferView) {
  return arrayBufferView.byteOffset !== 0 || arrayBufferView.byteLength !== arrayBufferView.buffer.byteLength;
}
function isAsyncIterable2(obj) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  return typeof obj[Symbol.asyncIterator] === "function";
}
function universalTypeOf2(value) {
  const typeString = Object.prototype.toString.call(value);
  const match = typeString.match(/\s([a-zA-Z0-9]+)/);
  const [_, type] = match;
  return type;
}

// node_modules/@tbdex/http-client/node_modules/@web5/common/dist/esm/convert.js
var __awaiter24 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __asyncValues2 = function(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
};
var textEncoder2 = new TextEncoder();
var textDecoder2 = new TextDecoder();
var Convert2 = class _Convert {
  constructor(data, format) {
    this.data = data;
    this.format = format;
  }
  static arrayBuffer(data) {
    return new _Convert(data, "ArrayBuffer");
  }
  static asyncIterable(data) {
    if (!isAsyncIterable2(data)) {
      throw new TypeError("Input must be of type AsyncIterable.");
    }
    return new _Convert(data, "AsyncIterable");
  }
  static base32Z(data) {
    return new _Convert(data, "Base32Z");
  }
  static base58Btc(data) {
    return new _Convert(data, "Base58Btc");
  }
  static base64Url(data) {
    return new _Convert(data, "Base64Url");
  }
  /**
   * Reference:
   * The BufferSource type is a TypeScript type that represents an ArrayBuffer
   * or one of the ArrayBufferView types, such a TypedArray (e.g., Uint8Array)
   * or a DataView.
   */
  static bufferSource(data) {
    return new _Convert(data, "BufferSource");
  }
  static hex(data) {
    if (typeof data !== "string") {
      throw new TypeError("Hex input must be a string.");
    }
    if (data.length % 2 !== 0) {
      throw new TypeError("Hex input must have an even number of characters.");
    }
    return new _Convert(data, "Hex");
  }
  static multibase(data) {
    return new _Convert(data, "Multibase");
  }
  static object(data) {
    return new _Convert(data, "Object");
  }
  static string(data) {
    return new _Convert(data, "String");
  }
  static uint8Array(data) {
    return new _Convert(data, "Uint8Array");
  }
  toArrayBuffer() {
    switch (this.format) {
      case "Base58Btc": {
        return base58btc.baseDecode(this.data).buffer;
      }
      case "Base64Url": {
        return base64url.baseDecode(this.data).buffer;
      }
      case "BufferSource": {
        const dataType = universalTypeOf2(this.data);
        if (dataType === "ArrayBuffer") {
          return this.data;
        } else if (ArrayBuffer.isView(this.data)) {
          if (isArrayBufferSlice2(this.data)) {
            return this.data.buffer.slice(this.data.byteOffset, this.data.byteOffset + this.data.byteLength);
          } else {
            return this.data.buffer;
          }
        } else {
          throw new TypeError(`${this.format} value is not of type: ArrayBuffer, DataView, or TypedArray.`);
        }
      }
      case "Hex": {
        return this.toUint8Array().buffer;
      }
      case "String": {
        return this.toUint8Array().buffer;
      }
      case "Uint8Array": {
        return this.data.buffer;
      }
      default:
        throw new TypeError(`Conversion from ${this.format} to ArrayBuffer is not supported.`);
    }
  }
  toArrayBufferAsync() {
    return __awaiter24(this, void 0, void 0, function* () {
      switch (this.format) {
        case "AsyncIterable": {
          const blob = yield this.toBlobAsync();
          return yield blob.arrayBuffer();
        }
        default:
          throw new TypeError(`Asynchronous conversion from ${this.format} to ArrayBuffer is not supported.`);
      }
    });
  }
  toBase32Z() {
    switch (this.format) {
      case "Uint8Array": {
        return base32z.baseEncode(this.data);
      }
      default:
        throw new TypeError(`Conversion from ${this.format} to Base64Z is not supported.`);
    }
  }
  toBase58Btc() {
    switch (this.format) {
      case "ArrayBuffer": {
        const u8a = new Uint8Array(this.data);
        return base58btc.baseEncode(u8a);
      }
      case "Multibase": {
        return this.data.substring(1);
      }
      case "Uint8Array": {
        return base58btc.baseEncode(this.data);
      }
      default:
        throw new TypeError(`Conversion from ${this.format} to Base58Btc is not supported.`);
    }
  }
  toBase64Url() {
    switch (this.format) {
      case "ArrayBuffer": {
        const u8a = new Uint8Array(this.data);
        return base64url.baseEncode(u8a);
      }
      case "BufferSource": {
        const u8a = this.toUint8Array();
        return base64url.baseEncode(u8a);
      }
      case "Object": {
        const string = JSON.stringify(this.data);
        const u8a = textEncoder2.encode(string);
        return base64url.baseEncode(u8a);
      }
      case "String": {
        const u8a = textEncoder2.encode(this.data);
        return base64url.baseEncode(u8a);
      }
      case "Uint8Array": {
        return base64url.baseEncode(this.data);
      }
      default:
        throw new TypeError(`Conversion from ${this.format} to Base64Url is not supported.`);
    }
  }
  toBlobAsync() {
    var _a, e_1, _b, _c;
    return __awaiter24(this, void 0, void 0, function* () {
      switch (this.format) {
        case "AsyncIterable": {
          const chunks = [];
          try {
            for (var _d = true, _e = __asyncValues2(this.data), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
              _c = _f.value;
              _d = false;
              const chunk = _c;
              chunks.push(chunk);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (!_d && !_a && (_b = _e.return))
                yield _b.call(_e);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          const blob = new Blob(chunks);
          return blob;
        }
        default:
          throw new TypeError(`Asynchronous conversion from ${this.format} to Blob is not supported.`);
      }
    });
  }
  toHex() {
    const hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
    switch (this.format) {
      case "ArrayBuffer": {
        const u8a = this.toUint8Array();
        return _Convert.uint8Array(u8a).toHex();
      }
      case "Base64Url": {
        const u8a = this.toUint8Array();
        return _Convert.uint8Array(u8a).toHex();
      }
      case "Uint8Array": {
        let hex = "";
        for (let i = 0; i < this.data.length; i++) {
          hex += hexes[this.data[i]];
        }
        return hex;
      }
      default:
        throw new TypeError(`Conversion from ${this.format} to Hex is not supported.`);
    }
  }
  toMultibase() {
    switch (this.format) {
      case "Base58Btc": {
        return `z${this.data}`;
      }
      default:
        throw new TypeError(`Conversion from ${this.format} to Multibase is not supported.`);
    }
  }
  toObject() {
    switch (this.format) {
      case "Base64Url": {
        const u8a = base64url.baseDecode(this.data);
        const text = textDecoder2.decode(u8a);
        return JSON.parse(text);
      }
      case "String": {
        return JSON.parse(this.data);
      }
      case "Uint8Array": {
        const text = textDecoder2.decode(this.data);
        return JSON.parse(text);
      }
      default:
        throw new TypeError(`Conversion from ${this.format} to Object is not supported.`);
    }
  }
  toObjectAsync() {
    return __awaiter24(this, void 0, void 0, function* () {
      switch (this.format) {
        case "AsyncIterable": {
          const text = yield this.toStringAsync();
          const json = JSON.parse(text);
          return json;
        }
        default:
          throw new TypeError(`Asynchronous conversion from ${this.format} to Object is not supported.`);
      }
    });
  }
  toString() {
    switch (this.format) {
      case "ArrayBuffer": {
        return textDecoder2.decode(this.data);
      }
      case "Base64Url": {
        const u8a = base64url.baseDecode(this.data);
        return textDecoder2.decode(u8a);
      }
      case "Object": {
        return JSON.stringify(this.data);
      }
      case "Uint8Array": {
        return textDecoder2.decode(this.data);
      }
      default:
        throw new TypeError(`Conversion from ${this.format} to String is not supported.`);
    }
  }
  toStringAsync() {
    var _a, e_2, _b, _c;
    return __awaiter24(this, void 0, void 0, function* () {
      switch (this.format) {
        case "AsyncIterable": {
          let str = "";
          try {
            for (var _d = true, _e = __asyncValues2(this.data), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
              _c = _f.value;
              _d = false;
              const chunk = _c;
              if (typeof chunk === "string")
                str += chunk;
              else
                str += textDecoder2.decode(chunk, { stream: true });
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (!_d && !_a && (_b = _e.return))
                yield _b.call(_e);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
          str += textDecoder2.decode(void 0, { stream: false });
          return str;
        }
        default:
          throw new TypeError(`Asynchronous conversion from ${this.format} to String is not supported.`);
      }
    });
  }
  toUint8Array() {
    switch (this.format) {
      case "ArrayBuffer": {
        return new Uint8Array(this.data);
      }
      case "Base32Z": {
        return base32z.baseDecode(this.data);
      }
      case "Base58Btc": {
        return base58btc.baseDecode(this.data);
      }
      case "Base64Url": {
        return base64url.baseDecode(this.data);
      }
      case "BufferSource": {
        const dataType = universalTypeOf2(this.data);
        if (dataType === "Uint8Array") {
          return this.data;
        } else if (dataType === "ArrayBuffer") {
          return new Uint8Array(this.data);
        } else if (ArrayBuffer.isView(this.data)) {
          return new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);
        } else {
          throw new TypeError(`${this.format} value is not of type: ArrayBuffer, DataView, or TypedArray.`);
        }
      }
      case "Hex": {
        const u8a = new Uint8Array(this.data.length / 2);
        for (let i = 0; i < this.data.length; i += 2) {
          const byteValue = parseInt(this.data.substring(i, i + 2), 16);
          if (isNaN(byteValue)) {
            throw new TypeError("Input is not a valid hexadecimal string.");
          }
          u8a[i / 2] = byteValue;
        }
        return u8a;
      }
      case "Object": {
        const string = JSON.stringify(this.data);
        return textEncoder2.encode(string);
      }
      case "String": {
        return textEncoder2.encode(this.data);
      }
      default:
        throw new TypeError(`Conversion from ${this.format} to Uint8Array is not supported.`);
    }
  }
  toUint8ArrayAsync() {
    return __awaiter24(this, void 0, void 0, function* () {
      switch (this.format) {
        case "AsyncIterable": {
          const arrayBuffer = yield this.toArrayBufferAsync();
          return new Uint8Array(arrayBuffer);
        }
        default:
          throw new TypeError(`Asynchronous conversion from ${this.format} to Uint8Array is not supported.`);
      }
    });
  }
};

// node_modules/@tbdex/http-client/node_modules/@web5/common/dist/esm/multicodec.js
var import_dist96 = __toESM(require_dist(), 1);
var Multicodec2 = class _Multicodec {
  /**
   * Adds a multicodec prefix to input data.
   *
   * @param options - The options for adding a prefix.
   * @param options.code - The codec code. Either the code or name must be provided.
   * @param options.name - The codec name. Either the code or name must be provided.
   * @param options.data - The data to be prefixed.
   * @returns The data with the added prefix as a Uint8Array.
   */
  static addPrefix(options) {
    var _a;
    let { code, data, name } = options;
    if (!(name ? !code : code)) {
      throw new Error(`Either 'name' or 'code' must be defined, but not both.`);
    }
    code = _Multicodec.codeToName.has(code) ? code : _Multicodec.nameToCode.get(name);
    if (code === void 0) {
      throw new Error(`Unsupported multicodec: ${(_a = options.name) !== null && _a !== void 0 ? _a : options.code}`);
    }
    const prefixLength = varint_exports.encodingLength(code);
    const dataWithPrefix = new Uint8Array(prefixLength + data.byteLength);
    dataWithPrefix.set(data, prefixLength);
    varint_exports.encodeTo(code, dataWithPrefix);
    return dataWithPrefix;
  }
  /**
   * Get the Multicodec code from given prefixed data.
   *
   * @param options - The options for getting the codec code.
   * @param options.prefixedData - The data to extract the codec code from.
   * @returns - The Multicodec code as a number.
   */
  static getCodeFromData(options) {
    const { prefixedData } = options;
    const [code, _] = varint_exports.decode(prefixedData);
    return code;
  }
  /**
   * Get the Multicodec code from given Multicodec name.
   *
   * @param options - The options for getting the codec code.
   * @param options.name - The name to lookup.
   * @returns - The Multicodec code as a number.
   */
  static getCodeFromName(options) {
    const { name } = options;
    const code = _Multicodec.nameToCode.get(name);
    if (code === void 0) {
      throw new Error(`Unsupported multicodec: ${name}`);
    }
    return code;
  }
  /**
   * Get the Multicodec name from given Multicodec code.
   *
   * @param options - The options for getting the codec name.
   * @param options.name - The code to lookup.
   * @returns - The Multicodec name as a string.
   */
  static getNameFromCode(options) {
    const { code } = options;
    const name = _Multicodec.codeToName.get(code);
    if (name === void 0) {
      throw new Error(`Unsupported multicodec: ${code}`);
    }
    return name;
  }
  /**
   * Registers a new codec in the Multicodec class.
   *
   * @param codec - The codec to be registered.
   */
  static registerCodec(codec) {
    _Multicodec.codeToName.set(codec.code, codec.name);
    _Multicodec.nameToCode.set(codec.name, codec.code);
  }
  /**
   * Returns the data with the Multicodec prefix removed.
   *
   * @param refixedData - The data to extract the codec code from.
   * @returns {Uint8Array}
   */
  static removePrefix(options) {
    const { prefixedData } = options;
    const [code, codeByteLength] = varint_exports.decode(prefixedData);
    const name = _Multicodec.codeToName.get(code);
    if (name === void 0) {
      throw new Error(`Unsupported multicodec: ${code}`);
    }
    return { code, data: prefixedData.slice(codeByteLength), name };
  }
};
Multicodec2.codeToName = /* @__PURE__ */ new Map();
Multicodec2.nameToCode = /* @__PURE__ */ new Map();
Multicodec2.registerCodec({ code: 237, name: "ed25519-pub" });
Multicodec2.registerCodec({ code: 4864, name: "ed25519-priv" });
Multicodec2.registerCodec({ code: 236, name: "x25519-pub" });
Multicodec2.registerCodec({ code: 4866, name: "x25519-priv" });
Multicodec2.registerCodec({ code: 231, name: "secp256k1-pub" });
Multicodec2.registerCodec({ code: 4865, name: "secp256k1-priv" });

// node_modules/@tbdex/http-client/node_modules/@web5/common/dist/esm/object.js
var import_dist97 = __toESM(require_dist(), 1);
function removeUndefinedProperties2(obj) {
  Object.keys(obj).forEach((key) => {
    if (obj[key] === void 0) {
      delete obj[key];
    } else if (typeof obj[key] === "object") {
      removeUndefinedProperties2(obj[key]);
    }
  });
}

// node_modules/@tbdex/http-client/node_modules/@web5/common/dist/esm/stores.js
var import_dist98 = __toESM(require_dist(), 1);
var import_level3 = __toESM(require_browser2(), 1);
var __awaiter25 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MemoryStore2 = class {
  constructor() {
    this.store = /* @__PURE__ */ new Map();
  }
  /**
   * Clears all entries in the key-value store.
   *
   * @returns A Promise that resolves when the operation is complete.
   */
  clear() {
    return __awaiter25(this, void 0, void 0, function* () {
      this.store.clear();
    });
  }
  /**
   * This operation is no-op for `MemoryStore`
   * and will log a warning if called.
   */
  close() {
    return __awaiter25(this, void 0, void 0, function* () {
    });
  }
  /**
   * Deletes an entry from the key-value store by its key.
   *
   * @param id - The key of the entry to delete.
   * @returns A Promise that resolves to a boolean indicating whether the entry was successfully deleted.
   */
  delete(id) {
    return __awaiter25(this, void 0, void 0, function* () {
      return this.store.delete(id);
    });
  }
  /**
   * Retrieves the value of an entry by its key.
   *
   * @param id - The key of the entry to retrieve.
   * @returns A Promise that resolves to the value of the entry, or `undefined` if the entry does not exist.
   */
  get(id) {
    return __awaiter25(this, void 0, void 0, function* () {
      return this.store.get(id);
    });
  }
  /**
   * Checks for the presence of an entry by key.
   *
   * @param id - The key to check for the existence of.
   * @returns A Promise that resolves to a boolean indicating whether an element with the specified key exists or not.
   */
  has(id) {
    return __awaiter25(this, void 0, void 0, function* () {
      return this.store.has(id);
    });
  }
  /**
   * Retrieves all values in the key-value store.
   *
   * @returns A Promise that resolves to an array of all values in the store.
   */
  list() {
    return __awaiter25(this, void 0, void 0, function* () {
      return Array.from(this.store.values());
    });
  }
  /**
   * Sets the value of an entry in the key-value store.
   *
   * @param id - The key of the entry to set.
   * @param key - The new value for the entry.
   * @returns A Promise that resolves when the operation is complete.
   */
  set(id, key) {
    return __awaiter25(this, void 0, void 0, function* () {
      this.store.set(id, key);
    });
  }
};

// node_modules/@tbdex/http-client/node_modules/@web5/common/dist/esm/stream.js
var import_dist99 = __toESM(require_dist(), 1);

// node_modules/@tbdex/http-client/node_modules/@web5/common/dist/esm/stream-node.js
var import_dist100 = __toESM(require_dist(), 1);
var import_readable_stream3 = __toESM(require_browser5(), 1);
var import_readable_stream4 = __toESM(require_browser5(), 1);

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/algorithms/sha-2.js
var import_dist104 = __toESM(require_dist(), 1);

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/primitives/sha256.js
var import_dist102 = __toESM(require_dist(), 1);
var __awaiter26 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Sha2562 = class {
  /**
   * Generates a SHA-256 hash digest for the given data.
   *
   * @remarks
   * This method produces a hash digest using the SHA-256 algorithm. The resultant digest
   * is deterministic, meaning the same data will always produce the same hash, but
   * is computationally infeasible to regenerate the original data from the hash.
   *
   * @example
   * ```ts
   * const data = new Uint8Array([...]);
   * const hash = await Sha256.digest({ data });
   * ```
   *
   * @param params - The parameters for the hashing operation.
   * @param params.data - The data to hash, represented as a Uint8Array.
   *
   * @returns A Promise that resolves to the SHA-256 hash digest of the provided data as a Uint8Array.
   */
  static digest({ data }) {
    return __awaiter26(this, void 0, void 0, function* () {
      const hash = sha256(data);
      return hash;
    });
  }
};

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/algorithms/crypto-algorithm.js
var import_dist103 = __toESM(require_dist(), 1);
var CryptoAlgorithm2 = class {
};

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/algorithms/sha-2.js
var __awaiter27 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Sha2Algorithm2 = class extends CryptoAlgorithm2 {
  /**
   * Generates a hash digest of the provided data.
   *
   * @remarks
   * A digest is the output of the hash function. It's a fixed-size string of bytes
   * that uniquely represents the data input into the hash function. The digest is often used for
   * data integrity checks, as any alteration in the input data results in a significantly
   * different digest.
   *
   * It takes the algorithm identifier of the hash function and data to digest as input and returns
   * the digest of the data.
   *
   * @example
   * ```ts
   * const sha2 = new Sha2Algorithm();
   * const data = new TextEncoder().encode('Messsage');
   * const digest = await sha2.digest({ data });
   * ```
   *
   * @param params - The parameters for the digest operation.
   * @param params.algorithm - The name of hash function to use.
   * @param params.data - The data to digest.
   *
   * @returns A Promise which will be fulfilled with the hash digest.
   */
  digest({ algorithm, data }) {
    return __awaiter27(this, void 0, void 0, function* () {
      switch (algorithm) {
        case "SHA-256": {
          const hash = yield Sha2562.digest({ data });
          return hash;
        }
      }
    });
  }
};

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/algorithms/ecdsa.js
var import_dist109 = __toESM(require_dist(), 1);

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/primitives/secp256k1.js
var import_dist107 = __toESM(require_dist(), 1);

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/jose/jwk.js
var import_dist106 = __toESM(require_dist(), 1);

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/jose/utils.js
var import_dist105 = __toESM(require_dist(), 1);
function canonicalize3(obj) {
  const sortObjKeys = (obj2) => {
    if (obj2 !== null && typeof obj2 === "object" && !Array.isArray(obj2)) {
      const sortedKeys = Object.keys(obj2).sort();
      const sortedObj2 = {};
      for (const key of sortedKeys) {
        sortedObj2[key] = sortObjKeys(obj2[key]);
      }
      return sortedObj2;
    }
    return obj2;
  };
  const sortedObj = sortObjKeys(obj);
  return JSON.stringify(sortedObj);
}

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/jose/jwk.js
var __awaiter28 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var KEY_URI_PREFIX_JWK2 = "urn:jwk:";
function computeJwkThumbprint2({ jwk }) {
  return __awaiter28(this, void 0, void 0, function* () {
    const keyType = jwk.kty;
    let normalizedJwk;
    if (keyType === "EC") {
      normalizedJwk = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };
    } else if (keyType === "oct") {
      normalizedJwk = { k: jwk.k, kty: jwk.kty };
    } else if (keyType === "OKP") {
      normalizedJwk = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };
    } else if (keyType === "RSA") {
      normalizedJwk = { e: jwk.e, kty: jwk.kty, n: jwk.n };
    } else {
      throw new Error(`Unsupported key type: ${keyType}`);
    }
    removeUndefinedProperties2(normalizedJwk);
    const serializedJwk = canonicalize3(normalizedJwk);
    const utf8Bytes = Convert2.string(serializedJwk).toUint8Array();
    const digest = yield Sha2562.digest({ data: utf8Bytes });
    const thumbprint = Convert2.uint8Array(digest).toBase64Url();
    return thumbprint;
  });
}
function isEcPrivateJwk2(obj) {
  if (!obj || typeof obj !== "object")
    return false;
  if (!("kty" in obj && "crv" in obj && "x" in obj && "d" in obj))
    return false;
  if (obj.kty !== "EC")
    return false;
  if (typeof obj.d !== "string")
    return false;
  if (typeof obj.x !== "string")
    return false;
  return true;
}
function isEcPublicJwk2(obj) {
  if (!obj || typeof obj !== "object")
    return false;
  if (!("kty" in obj && "crv" in obj && "x" in obj))
    return false;
  if ("d" in obj)
    return false;
  if (obj.kty !== "EC")
    return false;
  if (typeof obj.x !== "string")
    return false;
  return true;
}
function isOkpPrivateJwk2(obj) {
  if (!obj || typeof obj !== "object")
    return false;
  if (!("kty" in obj && "crv" in obj && "x" in obj && "d" in obj))
    return false;
  if (obj.kty !== "OKP")
    return false;
  if (typeof obj.d !== "string")
    return false;
  if (typeof obj.x !== "string")
    return false;
  return true;
}
function isOkpPublicJwk2(obj) {
  if (!obj || typeof obj !== "object")
    return false;
  if ("d" in obj)
    return false;
  if (!("kty" in obj && "crv" in obj && "x" in obj))
    return false;
  if (obj.kty !== "OKP")
    return false;
  if (typeof obj.x !== "string")
    return false;
  return true;
}
function isPrivateJwk2(obj) {
  if (!obj || typeof obj !== "object")
    return false;
  const kty = obj.kty;
  switch (kty) {
    case "EC":
    case "OKP":
    case "RSA":
      return "d" in obj;
    case "oct":
      return "k" in obj;
    default:
      return false;
  }
}

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/primitives/secp256k1.js
var __awaiter29 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest6 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Secp256k12 = class _Secp256k1 {
  /**
   * Adjusts an ECDSA signature to a normalized, low-S form.
   *
   * @remarks
   * All ECDSA signatures, regardless of the curve, consist of two components, `r` and `s`, both of
   * which are integers. The curve's order (the total number of points on the curve) is denoted by
   * `n`. In a valid ECDSA signature, both `r` and `s` must be in the range [1, n-1]. However, due
   * to the mathematical properties of ECDSA, if `(r, s)` is a valid signature, then `(r, n - s)` is
   * also a valid signature for the same message and public key. In other words, for every
   * signature, there's a "mirror" signature that's equally valid. For these elliptic curves:
   *
   * - Low S Signature: A signature where the `s` component is in the lower half of the range,
   *                    specifically less than or equal to `n/2`.
   *
   * - High S Signature: This is where the `s` component is in the upper half of the range, greater
   *                     than `n/2`.
   *
   * The practical implication is that a third-party can forge a second valid signature for the same
   * message by negating the `s` component of the original signature, without any knowledge of the
   * private key. This is known as a "signature malleability" attack.
   *
   * This type of forgery is not a problem in all systems, but it can be an issue in systems that
   * rely on digital signature uniqueness to ensure transaction integrity. For example, in Bitcoin,
   * transaction malleability is an issue because it allows for the modification of transaction
   * identifiers (and potentially, transactions themselves) after they're signed but before they're
   * confirmed in a block. By enforcing low `s` values, the Bitcoin network reduces the likelihood of
   * this occurring, making the system more secure and predictable.
   *
   * For this reason, it's common practice to normalize ECDSA signatures to a low-S form. This
   * form is considered standard and preferable in some systems and is known as the "normalized"
   * form of the signature.
   *
   * This method takes a signature, and if it's high-S, returns the normalized low-S form. If the
   * signature is already low-S, it's returned unmodified. It's important to note that this
   * method does not change the validity of the signature but makes it compliant with systems that
   * enforce low-S signatures.
   *
   * @example
   * ```ts
   * const signature = new Uint8Array([...]); // Your ECDSA signature
   * const adjustedSignature = await Secp256k1.adjustSignatureToLowS({ signature });
   * // Now 'adjustedSignature' is in the low-S form.
   * ```
   *
   * @param params - The parameters for the signature adjustment.
   * @param params.signature - The ECDSA signature as a `Uint8Array`.
   *
   * @returns A Promise that resolves to the adjusted signature in low-S form as a `Uint8Array`.
   */
  static adjustSignatureToLowS({ signature }) {
    return __awaiter29(this, void 0, void 0, function* () {
      const signatureObject = secp256k1.Signature.fromCompact(signature);
      if (signatureObject.hasHighS()) {
        const adjustedSignatureObject = signatureObject.normalizeS();
        const adjustedSignature = adjustedSignatureObject.toCompactRawBytes();
        return adjustedSignature;
      } else {
        return signature;
      }
    });
  }
  /**
   * Converts a raw private key in bytes to its corresponding JSON Web Key (JWK) format.
   *
   * @remarks
   * This method takes a private key represented as a byte array (Uint8Array) and
   * converts it into a JWK object. The conversion involves extracting the
   * elliptic curve point (x and y coordinates) from the private key and encoding
   * them into base64url format, alongside other JWK parameters.
   *
   * The resulting JWK object includes the following properties:
   * - `kty`: Key Type, set to 'EC' for Elliptic Curve.
   * - `crv`: Curve Name, set to 'secp256k1'.
   * - `d`: The private key component, base64url-encoded.
   * - `x`: The x-coordinate of the public key point, base64url-encoded.
   * - `y`: The y-coordinate of the public key point, base64url-encoded.
   *
   * This method is useful for converting raw public keys into a standardized
   * JSON format, facilitating their use in cryptographic operations and making
   * them easy to share and store.
   *
   * @example
   * ```ts
   * const privateKeyBytes = new Uint8Array([...]); // Replace with actual private key bytes
   * const privateKey = await Secp256k1.bytesToPrivateKey({ privateKeyBytes });
   * ```
   *
   * @param params - The parameters for the private key conversion.
   * @param params.privateKeyBytes - The raw private key as a Uint8Array.
   *
   * @returns A Promise that resolves to the private key in JWK format.
   */
  static bytesToPrivateKey({ privateKeyBytes }) {
    return __awaiter29(this, void 0, void 0, function* () {
      const point = yield _Secp256k1.getCurvePoint({ keyBytes: privateKeyBytes });
      const privateKey = {
        kty: "EC",
        crv: "secp256k1",
        d: Convert2.uint8Array(privateKeyBytes).toBase64Url(),
        x: Convert2.uint8Array(point.x).toBase64Url(),
        y: Convert2.uint8Array(point.y).toBase64Url()
      };
      privateKey.kid = yield computeJwkThumbprint2({ jwk: privateKey });
      return privateKey;
    });
  }
  /**
   * Converts a raw public key in bytes to its corresponding JSON Web Key (JWK) format.
   *
   * @remarks
   * This method accepts a public key in a byte array (Uint8Array) format and
   * transforms it to a JWK object. It involves decoding the elliptic curve point
   * (x and y coordinates) from the raw public key bytes and encoding them into
   * base64url format, along with setting appropriate JWK parameters.
   *
   * The resulting JWK object includes the following properties:
   * - `kty`: Key Type, set to 'EC' for Elliptic Curve.
   * - `crv`: Curve Name, set to 'secp256k1'.
   * - `x`: The x-coordinate of the public key point, base64url-encoded.
   * - `y`: The y-coordinate of the public key point, base64url-encoded.
   *
   * This method is useful for converting raw public keys into a standardized
   * JSON format, facilitating their use in cryptographic operations and making
   * them easy to share and store.
   *
   * @example
   * ```ts
   * const publicKeyBytes = new Uint8Array([...]); // Replace with actual public key bytes
   * const publicKey = await Secp256k1.bytesToPublicKey({ publicKeyBytes });
   * ```
   *
   * @param params - The parameters for the public key conversion.
   * @param params.publicKeyBytes - The raw public key as a Uint8Array.
   *
   * @returns A Promise that resolves to the public key in JWK format.
   */
  static bytesToPublicKey({ publicKeyBytes }) {
    return __awaiter29(this, void 0, void 0, function* () {
      const point = yield _Secp256k1.getCurvePoint({ keyBytes: publicKeyBytes });
      const publicKey = {
        kty: "EC",
        crv: "secp256k1",
        x: Convert2.uint8Array(point.x).toBase64Url(),
        y: Convert2.uint8Array(point.y).toBase64Url()
      };
      publicKey.kid = yield computeJwkThumbprint2({ jwk: publicKey });
      return publicKey;
    });
  }
  /**
   * Converts a public key to its compressed form.
   *
   * @remarks
   * This method takes a public key represented as a byte array and compresses it. Public key
   * compression is a process that reduces the size of the public key by removing the y-coordinate,
   * making it more efficient for storage and transmission. The compressed key retains the same
   * level of security as the uncompressed key.
   *
   * @example
   * ```ts
   * const uncompressedPublicKeyBytes = new Uint8Array([...]); // Replace with actual uncompressed public key bytes
   * const compressedPublicKey = await Secp256k1.compressPublicKey({
   *   publicKeyBytes: uncompressedPublicKeyBytes
   * });
   * ```
   *
   * @param params - The parameters for the public key compression.
   * @param params.publicKeyBytes - The public key as a Uint8Array.
   *
   * @returns A Promise that resolves to the compressed public key as a Uint8Array.
   */
  static compressPublicKey({ publicKeyBytes }) {
    return __awaiter29(this, void 0, void 0, function* () {
      const point = secp256k1.ProjectivePoint.fromHex(publicKeyBytes);
      return point.toRawBytes(true);
    });
  }
  /**
   * Derives the public key in JWK format from a given private key.
   *
   * @remarks
   * This method takes a private key in JWK format and derives its corresponding public key,
   * also in JWK format. The derivation process involves converting the private key to a raw
   * byte array, then computing the elliptic curve point (x and y coordinates) from this private
   * key. These coordinates are then encoded into base64url format to construct the public key in
   * JWK format.
   *
   * The process ensures that the derived public key correctly corresponds to the given private key,
   * adhering to the secp256k1 elliptic curve standards. This method is useful in cryptographic
   * operations where a public key is needed for operations like signature verification, but only
   * the private key is available.
   *
   * @example
   * ```ts
   * const privateKey = { ... }; // A Jwk object representing a secp256k1 private key
   * const publicKey = await Secp256k1.computePublicKey({ key: privateKey });
   * ```
   *
   * @param params - The parameters for the public key derivation.
   * @param params.key - The private key in JWK format from which to derive the public key.
   *
   * @returns A Promise that resolves to the derived public key in JWK format.
   */
  static computePublicKey({ key }) {
    return __awaiter29(this, void 0, void 0, function* () {
      const privateKeyBytes = yield _Secp256k1.privateKeyToBytes({ privateKey: key });
      const point = yield _Secp256k1.getCurvePoint({ keyBytes: privateKeyBytes });
      const publicKey = {
        kty: "EC",
        crv: "secp256k1",
        x: Convert2.uint8Array(point.x).toBase64Url(),
        y: Convert2.uint8Array(point.y).toBase64Url()
      };
      publicKey.kid = yield computeJwkThumbprint2({ jwk: publicKey });
      return publicKey;
    });
  }
  /**
   * Converts an ASN.1 DER encoded ECDSA signature to a compact R+S format.
   *
   * @remarks
   * This method is used for converting an ECDSA signature from the ASN.1 DER encoding to the more
   * compact R+S format. This conversion is often required when dealing with ECDSA signatures in
   * certain cryptographic standards such as JWS (JSON Web Signature).
   *
   * The method decodes the DER-encoded signature, extracts the R and S values, and concatenates
   * them into a single byte array. This process involves handling the ASN.1 structure to correctly
   * parse the R and S values, considering padding and integer encoding specifics of DER.
   *
   * @example
   * ```ts
   * const derSignature = new Uint8Array([...]); // Replace with your DER-encoded signature
   * const signature = await Secp256k1.convertDerToCompactSignature({ derSignature });
   * ```
   *
   * @param params - The parameters for the signature conversion.
   * @param params.derSignature - The signature in ASN.1 DER format as a `Uint8Array`.
   *
   * @returns A Promise that resolves to the signature in compact R+S format as a `Uint8Array`.
   */
  static convertDerToCompactSignature({ derSignature }) {
    return __awaiter29(this, void 0, void 0, function* () {
      const signatureObject = secp256k1.Signature.fromDER(derSignature);
      const compactSignature = signatureObject.toCompactRawBytes();
      return compactSignature;
    });
  }
  /**
   * Converts a public key to its uncompressed form.
   *
   * @remarks
   * This method takes a compressed public key represented as a byte array and decompresses it.
   * Public key decompression involves reconstructing the y-coordinate from the x-coordinate,
   * resulting in the full public key. This method is used when the uncompressed key format is
   * required for certain cryptographic operations or interoperability.
   *
   * @example
   * ```ts
   * const compressedPublicKeyBytes = new Uint8Array([...]); // Replace with actual compressed public key bytes
   * const decompressedPublicKey = await Secp256k1.decompressPublicKey({
   *   publicKeyBytes: compressedPublicKeyBytes
   * });
   * ```
   *
   * @param params - The parameters for the public key decompression.
   * @param params.publicKeyBytes - The public key as a Uint8Array.
   *
   * @returns A Promise that resolves to the uncompressed public key as a Uint8Array.
   */
  static decompressPublicKey({ publicKeyBytes }) {
    return __awaiter29(this, void 0, void 0, function* () {
      const point = secp256k1.ProjectivePoint.fromHex(publicKeyBytes);
      return point.toRawBytes(false);
    });
  }
  /**
   * Generates a secp256k1 private key in JSON Web Key (JWK) format.
   *
   * @remarks
   * This method creates a new private key suitable for use with the secp256k1
   * elliptic curve. The key is generated using cryptographically secure random
   * number generation to ensure its uniqueness and security. The resulting
   * private key adheres to the JWK format, specifically tailored for secp256k1,
   * making it compatible with common cryptographic standards and easy to use in
   * various cryptographic processes.
   *
   * The private key generated by this method includes the following components:
   * - `kty`: Key Type, set to 'EC' for Elliptic Curve.
   * - `crv`: Curve Name, set to 'secp256k1'.
   * - `d`: The private key component, base64url-encoded.
   * - `x`: The x-coordinate of the public key point, derived from the private key, base64url-encoded.
   * - `y`: The y-coordinate of the public key point, derived from the private key, base64url-encoded.
   *
   * The key is returned in a format suitable for direct use in signin and key agreement operations.
   *
   * @example
   * ```ts
   * const privateKey = await Secp256k1.generateKey();
   * ```
   *
   * @returns A Promise that resolves to the generated private key in JWK format.
   */
  static generateKey() {
    return __awaiter29(this, void 0, void 0, function* () {
      const privateKeyBytes = secp256k1.utils.randomPrivateKey();
      const privateKey = yield _Secp256k1.bytesToPrivateKey({ privateKeyBytes });
      privateKey.kid = yield computeJwkThumbprint2({ jwk: privateKey });
      return privateKey;
    });
  }
  /**
   * Retrieves the public key properties from a given private key in JWK format.
   *
   * @remarks
   * This method extracts the public key portion from a secp256k1 private key in JWK format. It does
   * so by removing the private key property 'd' and making a shallow copy, effectively yielding the
   * public key. The method sets the 'kid' (key ID) property using the JWK thumbprint if it is not
   * already defined. This approach is used under the assumption that a private key in JWK format
   * always contains the corresponding public key properties.
   *
   * Note: This method offers a significant performance advantage, being about 200 times faster
   * than `computePublicKey()`. However, it does not mathematically validate the private key, nor
   * does it derive the public key from the private key. It simply extracts existing public key
   * properties from the private key object. This makes it suitable for scenarios where speed is
   * critical and the private key's integrity is already assured.
   *
   * @example
   * ```ts
   * const privateKey = { ... }; // A Jwk object representing a secp256k1 private key
   * const publicKey = await Secp256k1.getPublicKey({ key: privateKey });
   * ```
   *
   * @param params - The parameters for retrieving the public key properties.
   * @param params.key - The private key in JWK format.
   *
   * @returns A Promise that resolves to the public key in JWK format.
   */
  static getPublicKey({ key }) {
    var _a;
    return __awaiter29(this, void 0, void 0, function* () {
      if (!(isEcPrivateJwk2(key) && key.crv === "secp256k1")) {
        throw new Error(`Secp256k1: The provided key is not a secp256k1 private JWK.`);
      }
      let { d } = key, publicKey = __rest6(key, ["d"]);
      (_a = publicKey.kid) !== null && _a !== void 0 ? _a : publicKey.kid = yield computeJwkThumbprint2({ jwk: publicKey });
      return publicKey;
    });
  }
  /**
   * Converts a private key from JSON Web Key (JWK) format to a raw byte array (Uint8Array).
   *
   * @remarks
   * This method takes a private key in JWK format and extracts its raw byte representation.
   * It specifically focuses on the 'd' parameter of the JWK, which represents the private
   * key component in base64url encoding. The method decodes this value into a byte array.
   *
   * This conversion is essential for operations that require the private key in its raw
   * binary form, such as certain low-level cryptographic operations or when interfacing
   * with systems and libraries that expect keys in a byte array format.
   *
   * @example
   * ```ts
   * const privateKey = { ... }; // An X25519 private key in JWK format
   * const privateKeyBytes = await Secp256k1.privateKeyToBytes({ privateKey });
   * ```
   *
   * @param params - The parameters for the private key conversion.
   * @param params.privateKey - The private key in JWK format.
   *
   * @returns A Promise that resolves to the private key as a Uint8Array.
   */
  static privateKeyToBytes({ privateKey }) {
    return __awaiter29(this, void 0, void 0, function* () {
      if (!isEcPrivateJwk2(privateKey)) {
        throw new Error(`Secp256k1: The provided key is not a valid EC private key.`);
      }
      const privateKeyBytes = Convert2.base64Url(privateKey.d).toUint8Array();
      return privateKeyBytes;
    });
  }
  /**
   * Converts a public key from JSON Web Key (JWK) format to a raw byte array (Uint8Array).
   *
   * @remarks
   * This method accepts a public key in JWK format and converts it into its raw binary
   * form. The conversion process involves decoding the 'x' and 'y' parameters of the JWK
   * (which represent the x and y coordinates of the elliptic curve point, respectively)
   * from base64url format into a byte array. The method then concatenates these values,
   * along with a prefix indicating the key format, to form the full public key.
   *
   * This function is particularly useful for use cases where the public key is needed
   * in its raw byte format, such as for certain cryptographic operations or when
   * interfacing with systems that require raw key formats.
   *
   * @example
   * ```ts
   * const publicKey = { ... }; // A Jwk public key object
   * const publicKeyBytes = await Secp256k1.publicKeyToBytes({ publicKey });
   * ```
   *
   * @param params - The parameters for the public key conversion.
   * @param params.publicKey - The public key in JWK format.
   *
   * @returns A Promise that resolves to the public key as a Uint8Array.
   */
  static publicKeyToBytes({ publicKey }) {
    return __awaiter29(this, void 0, void 0, function* () {
      if (!(isEcPublicJwk2(publicKey) && publicKey.y)) {
        throw new Error(`Secp256k1: The provided key is not a valid EC public key.`);
      }
      const prefix = new Uint8Array([4]);
      const x = Convert2.base64Url(publicKey.x).toUint8Array();
      const y = Convert2.base64Url(publicKey.y).toUint8Array();
      const publicKeyBytes = new Uint8Array([...prefix, ...x, ...y]);
      return publicKeyBytes;
    });
  }
  /**
   * Computes an RFC6090-compliant Elliptic Curve Diffie-Hellman (ECDH) shared secret
   * using secp256k1 private and public keys in JSON Web Key (JWK) format.
   *
   * @remarks
   * This method facilitates the ECDH key agreement protocol, which is a method of securely
   * deriving a shared secret between two parties based on their private and public keys.
   * It takes the private key of one party (privateKeyA) and the public key of another
   * party (publicKeyB) to compute a shared secret. The shared secret is derived from the
   * x-coordinate of the elliptic curve point resulting from the multiplication of the
   * public key with the private key.
   *
   * Note: When performing Elliptic Curve Diffie-Hellman (ECDH) key agreement,
   * the resulting shared secret is a point on the elliptic curve, which
   * consists of an x-coordinate and a y-coordinate. With a 256-bit curve like
   * secp256k1, each of these coordinates is 32 bytes (256 bits) long. However,
   * in the ECDH process, it's standard practice to use only the x-coordinate
   * of the shared secret point as the resulting shared key. This is because
   * the y-coordinate does not add to the entropy of the key, and both parties
   * can independently compute the x-coordinate.  Consquently, this implementation
   * omits the y-coordinate for simplicity and standard compliance.
   *
   * @example
   * ```ts
   * const privateKeyA = { ... }; // A Jwk private key object for party A
   * const publicKeyB = { ... }; // A Jwk public key object for party B
   * const sharedSecret = await Secp256k1.sharedSecret({
   *   privateKeyA,
   *   publicKeyB
   * });
   * ```
   *
   * @param params - The parameters for the shared secret computation.
   * @param params.privateKeyA - The private key in JWK format of one party.
   * @param params.publicKeyB - The public key in JWK format of the other party.
   *
   * @returns A Promise that resolves to the computed shared secret as a Uint8Array.
   */
  static sharedSecret({ privateKeyA, publicKeyB }) {
    return __awaiter29(this, void 0, void 0, function* () {
      if ("x" in privateKeyA && "x" in publicKeyB && privateKeyA.x === publicKeyB.x) {
        throw new Error(`Secp256k1: ECDH shared secret cannot be computed from a single key pair's public and private keys.`);
      }
      const privateKeyABytes = yield _Secp256k1.privateKeyToBytes({ privateKey: privateKeyA });
      const publicKeyBBytes = yield _Secp256k1.publicKeyToBytes({ publicKey: publicKeyB });
      const sharedSecret = secp256k1.getSharedSecret(privateKeyABytes, publicKeyBBytes, true);
      return sharedSecret.slice(1);
    });
  }
  /**
   * Generates an RFC6979-compliant ECDSA signature of given data using a secp256k1 private key.
   *
   * @remarks
   * This method signs the provided data with a specified private key using the ECDSA
   * (Elliptic Curve Digital Signature Algorithm) signature algorithm, as defined in RFC6979.
   * The data to be signed is first hashed using the SHA-256 algorithm, and this hash is then
   * signed using the private key. The output is a digital signature in the form of a
   * Uint8Array, which uniquely corresponds to both the data and the private key used for signing.
   *
   * This method is commonly used in cryptographic applications to ensure data integrity and
   * authenticity. The signature can later be verified by parties with access to the corresponding
   * public key, ensuring that the data has not been tampered with and was indeed signed by the
   * holder of the private key.
   *
   * @example
   * ```ts
   * const data = new TextEncoder().encode('Messsage'); // Data to be signed
   * const privateKey = { ... }; // A Jwk object representing a secp256k1 private key
   * const signature = await Secp256k1.sign({
   *   key: privateKey,
   *   data
   * });
   * ```
   *
   * @param params - The parameters for the signing operation.
   * @param params.key - The private key to use for signing, represented in JWK format.
   * @param params.data - The data to sign, represented as a Uint8Array.
   *
   * @returns A Promise that resolves to the signature as a Uint8Array.
   */
  static sign({ data, key }) {
    return __awaiter29(this, void 0, void 0, function* () {
      const privateKeyBytes = yield _Secp256k1.privateKeyToBytes({ privateKey: key });
      const digest = sha256(data);
      const signatureObject = secp256k1.sign(digest, privateKeyBytes);
      const signature = signatureObject.toCompactRawBytes();
      return signature;
    });
  }
  /**
   * Validates a given private key to ensure its compliance with the secp256k1 curve standards.
   *
   * @remarks
   * This method checks whether a provided private key is a valid 32-byte number and falls within
   * the range defined by the secp256k1 curve's order. It is essential for ensuring the private
   * key's mathematical correctness in the context of secp256k1-based cryptographic operations.
   *
   * Note that this validation strictly pertains to the key's format and numerical validity; it does
   * not assess whether the key corresponds to a known entity or its security status (e.g., whether
   * it has been compromised).
   *
   * @example
   * ```ts
   * const privateKeyBytes = new Uint8Array([...]); // A 32-byte private key
   * const isValid = await Secp256k1.validatePrivateKey({ privateKeyBytes });
   * console.log(isValid); // true or false based on the key's validity
   * ```
   *
   * @param params - The parameters for the key validation.
   * @param params.privateKeyBytes - The private key to validate, represented as a Uint8Array.
   *
   * @returns A Promise that resolves to a boolean indicating whether the private key is valid.
   */
  static validatePrivateKey({ privateKeyBytes }) {
    return __awaiter29(this, void 0, void 0, function* () {
      return secp256k1.utils.isValidPrivateKey(privateKeyBytes);
    });
  }
  /**
   * Validates a given public key to confirm its mathematical correctness on the secp256k1 curve.
   *
   * @remarks
   * This method checks if the provided public key represents a valid point on the secp256k1 curve.
   * It decodes the key's Weierstrass points (x and y coordinates) and verifies their validity
   * against the curve's parameters. A valid point must lie on the curve and meet specific
   * mathematical criteria defined by the curve's equation.
   *
   * It's important to note that this method does not verify the key's ownership or whether it has
   * been compromised; it solely focuses on the key's adherence to the curve's mathematical
   * principles.
   *
   * @example
   * ```ts
   * const publicKeyBytes = new Uint8Array([...]); // A public key in byte format
   * const isValid = await Secp256k1.validatePublicKey({ publicKeyBytes });
   * console.log(isValid); // true if the key is valid on the secp256k1 curve, false otherwise
   * ```
   *
   * @param params - The parameters for the key validation.
   * @param params.publicKeyBytes - The public key to validate, represented as a Uint8Array.
   *
   * @returns A Promise that resolves to a boolean indicating the public key's validity on
   *          the secp256k1 curve.
   */
  static validatePublicKey({ publicKeyBytes }) {
    return __awaiter29(this, void 0, void 0, function* () {
      try {
        const point = secp256k1.ProjectivePoint.fromHex(publicKeyBytes);
        point.assertValidity();
      } catch (error) {
        return false;
      }
      return true;
    });
  }
  /**
   * Verifies an RFC6979-compliant ECDSA signature against given data and a secp256k1 public key.
   *
   * @remarks
   * This method validates a digital signature to ensure that it was generated by the holder of the
   * corresponding private key and that the signed data has not been altered. The signature
   * verification is performed using the ECDSA (Elliptic Curve Digital Signature Algorithm) as
   * specified in RFC6979. The data to be verified is first hashed using the SHA-256 algorithm, and
   * this hash is then used along with the public key to verify the signature.
   *
   * The method returns a boolean value indicating whether the signature is valid. A valid signature
   * proves that the signed data was indeed signed by the owner of the private key corresponding to
   * the provided public key and that the data has not been tampered with since it was signed.
   *
   * Note: The verification process does not consider the malleability of low-s signatures, which
   * may be relevant in certain contexts, such as Bitcoin transactions.
   *
   * @example
   * ```ts
   * const data = new TextEncoder().encode('Messsage'); // Data that was signed
   * const publicKey = { ... }; // Public key in JWK format corresponding to the private key that signed the data
   * const signature = new Uint8Array([...]); // Signature to verify
   * const isSignatureValid = await Secp256k1.verify({
   *   key: publicKey,
   *   signature,
   *   data
   * });
   * console.log(isSignatureValid); // true if the signature is valid, false otherwise
   * ```
   *
   * @param params - The parameters for the signature verification.
   * @param params.key - The public key used for verification, represented in JWK format.
   * @param params.signature - The signature to verify, represented as a Uint8Array.
   * @param params.data - The data that was signed, represented as a Uint8Array.
   *
   * @returns A Promise that resolves to a boolean indicating whether the signature is valid.
   */
  static verify({ key, signature, data }) {
    return __awaiter29(this, void 0, void 0, function* () {
      const publicKeyBytes = yield _Secp256k1.publicKeyToBytes({ publicKey: key });
      const digest = sha256(data);
      const isValid3 = secp256k1.verify(signature, digest, publicKeyBytes, { lowS: false });
      return isValid3;
    });
  }
  /**
   * Returns the elliptic curve point (x and y coordinates) for a given secp256k1 key.
   *
   * @remarks
   * This method extracts the elliptic curve point from a given secp256k1 key, whether
   * it's a private or a public key. For a private key, the method first computes the
   * corresponding public key and then extracts the x and y coordinates. For a public key,
   * it directly returns these coordinates. The coordinates are represented as Uint8Array.
   *
   * The x and y coordinates represent the key's position on the elliptic curve and can be
   * used in various cryptographic operations, such as digital signatures or key agreement
   * protocols.
   *
   * @example
   * ```ts
   * // For a private key
   * const privateKey = new Uint8Array([...]); // A 32-byte private key
   * const { x: xFromPrivateKey, y: yFromPrivateKey } = await Secp256k1.getCurvePoint({ keyBytes: privateKey });
   *
   * // For a public key
   * const publicKey = new Uint8Array([...]); // A 33-byte or 65-byte public key
   * const { x: xFromPublicKey, y: yFromPublicKey } = await Secp256k1.getCurvePoint({ keyBytes: publicKey });
   * ```
   *
   * @param params - The parameters for the curve point decoding operation.
   * @param params.keyBytes - The key for which to get the elliptic curve point.
   *                          Can be either a private key or a public key.
   *                          The key should be passed as a `Uint8Array`.
   *
   * @returns A Promise that resolves to an object with properties 'x' and 'y',
   *          each being a Uint8Array representing the x and y coordinates of the key point on the
   *          elliptic curve.
   */
  static getCurvePoint({ keyBytes }) {
    return __awaiter29(this, void 0, void 0, function* () {
      if (keyBytes.byteLength === 32) {
        keyBytes = secp256k1.getPublicKey(keyBytes);
      }
      const point = secp256k1.ProjectivePoint.fromHex(keyBytes);
      const x = numberToBytesBE(point.x, 32);
      const y = numberToBytesBE(point.y, 32);
      return { x, y };
    });
  }
};

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/primitives/secp256r1.js
var import_dist108 = __toESM(require_dist(), 1);
var __awaiter30 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest7 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Secp256r12 = class _Secp256r1 {
  /**
     * Adjusts an ECDSA signature to a normalized, low-S form.
     *
     * @remarks
     * All ECDSA signatures, regardless of the curve, consist of two components, `r` and `s`, both of
     * which are integers. The curve's order (the total number of points on the curve) is denoted by
     * `n`. In a valid ECDSA signature, both `r` and `s` must be in the range [1, n-1]. However, due
     * to the mathematical properties of ECDSA, if `(r, s)` is a valid signature, then `(r, n - s)` is
     * also a valid signature for the same message and public key. In other words, for every
     * signature, there's a "mirror" signature that's equally valid. For these elliptic curves:
     *
     * - Low S Signature: A signature where the `s` component is in the lower half of the range,
     *                    specifically less than or equal to `n/2`.
     *
     * - High S Signature: This is where the `s` component is in the upper half of the range, greater
     *                     than `n/2`.
     *
     * The practical implication is that a third-party can forge a second valid signature for the same
     * message by negating the `s` component of the original signature, without any knowledge of the
     * private key. This is known as a "signature malleability" attack.
     *
     * This type of forgery is not a problem in all systems, but it can be an issue in systems that
     * rely on digital signature uniqueness to ensure transaction integrity. For example, in Bitcoin,
     * transaction malleability is an issue because it allows for the modification of transaction
     * identifiers (and potentially, transactions themselves) after they're signed but before they're
     * confirmed in a block. By enforcing low `s` values, the Bitcoin network reduces the likelihood of
     * this occurring, making the system more secure and predictable.
     *
     * For this reason, it's common practice to normalize ECDSA signatures to a low-S form. This
     * form is considered standard and preferable in some systems and is known as the "normalized"
     * form of the signature.
     *
     * This method takes a signature, and if it's high-S, returns the normalized low-S form. If the
     * signature is already low-S, it's returned unmodified. It's important to note that this
     * method does not change the validity of the signature but makes it compliant with systems that
     * enforce low-S signatures.
     *
     * @example
     * ```ts
     * const signature = new Uint8Array([...]); // Your ECDSA signature
     * const adjustedSignature = await Secp256r1.adjustSignatureToLowS({ signature });
     * // Now 'adjustedSignature' is in the low-S form.
     * ```
     *
     * @param params - The parameters for the signature adjustment.
     * @param params.signature - The ECDSA signature as a `Uint8Array`.
     *
     * @returns A Promise that resolves to the adjusted signature in low-S form as a `Uint8Array`.
     */
  static adjustSignatureToLowS({ signature }) {
    return __awaiter30(this, void 0, void 0, function* () {
      const signatureObject = secp256r1.Signature.fromCompact(signature);
      if (signatureObject.hasHighS()) {
        const adjustedSignatureObject = signatureObject.normalizeS();
        const adjustedSignature = adjustedSignatureObject.toCompactRawBytes();
        return adjustedSignature;
      } else {
        return signature;
      }
    });
  }
  /**
   * Converts a raw private key in bytes to its corresponding JSON Web Key (JWK) format.
   *
   * @remarks
   * This method takes a private key represented as a byte array (Uint8Array) and
   * converts it into a JWK object. The conversion involves extracting the
   * elliptic curve point (x and y coordinates) from the private key and encoding
   * them into base64url format, alongside other JWK parameters.
   *
   * The resulting JWK object includes the following properties:
   * - `kty`: Key Type, set to 'EC' for Elliptic Curve.
   * - `crv`: Curve Name, set to 'P-256'.
   * - `d`: The private key component, base64url-encoded.
   * - `x`: The x-coordinate of the public key point, base64url-encoded.
   * - `y`: The y-coordinate of the public key point, base64url-encoded.
   *
   * This method is useful for converting raw public keys into a standardized
   * JSON format, facilitating their use in cryptographic operations and making
   * them easy to share and store.
   *
   * @example
   * ```ts
   * const privateKeyBytes = new Uint8Array([...]); // Replace with actual private key bytes
   * const privateKey = await Secp256r1.bytesToPrivateKey({ privateKeyBytes });
   * ```
   *
   * @param params - The parameters for the private key conversion.
   * @param params.privateKeyBytes - The raw private key as a Uint8Array.
   *
   * @returns A Promise that resolves to the private key in JWK format.
   */
  static bytesToPrivateKey({ privateKeyBytes }) {
    return __awaiter30(this, void 0, void 0, function* () {
      const point = yield _Secp256r1.getCurvePoint({ keyBytes: privateKeyBytes });
      const privateKey = {
        kty: "EC",
        crv: "P-256",
        d: Convert2.uint8Array(privateKeyBytes).toBase64Url(),
        x: Convert2.uint8Array(point.x).toBase64Url(),
        y: Convert2.uint8Array(point.y).toBase64Url()
      };
      privateKey.kid = yield computeJwkThumbprint2({ jwk: privateKey });
      return privateKey;
    });
  }
  /**
   * Converts a raw public key in bytes to its corresponding JSON Web Key (JWK) format.
   *
   * @remarks
   * This method accepts a public key in a byte array (Uint8Array) format and
   * transforms it to a JWK object. It involves decoding the elliptic curve point
   * (x and y coordinates) from the raw public key bytes and encoding them into
   * base64url format, along with setting appropriate JWK parameters.
   *
   * The resulting JWK object includes the following properties:
   * - `kty`: Key Type, set to 'EC' for Elliptic Curve.
   * - `crv`: Curve Name, set to 'P-256'.
   * - `x`: The x-coordinate of the public key point, base64url-encoded.
   * - `y`: The y-coordinate of the public key point, base64url-encoded.
   *
   * This method is useful for converting raw public keys into a standardized
   * JSON format, facilitating their use in cryptographic operations and making
   * them easy to share and store.
   *
   * @example
   * ```ts
   * const publicKeyBytes = new Uint8Array([...]); // Replace with actual public key bytes
   * const publicKey = await Secp256r1.bytesToPublicKey({ publicKeyBytes });
   * ```
   *
   * @param params - The parameters for the public key conversion.
   * @param params.publicKeyBytes - The raw public key as a Uint8Array.
   *
   * @returns A Promise that resolves to the public key in JWK format.
   */
  static bytesToPublicKey({ publicKeyBytes }) {
    return __awaiter30(this, void 0, void 0, function* () {
      const point = yield _Secp256r1.getCurvePoint({ keyBytes: publicKeyBytes });
      const publicKey = {
        kty: "EC",
        crv: "P-256",
        x: Convert2.uint8Array(point.x).toBase64Url(),
        y: Convert2.uint8Array(point.y).toBase64Url()
      };
      publicKey.kid = yield computeJwkThumbprint2({ jwk: publicKey });
      return publicKey;
    });
  }
  /**
   * Converts a public key to its compressed form.
   *
   * @remarks
   * This method takes a public key represented as a byte array and compresses it. Public key
   * compression is a process that reduces the size of the public key by removing the y-coordinate,
   * making it more efficient for storage and transmission. The compressed key retains the same
   * level of security as the uncompressed key.
   *
   * @example
   * ```ts
   * const uncompressedPublicKeyBytes = new Uint8Array([...]); // Replace with actual uncompressed public key bytes
   * const compressedPublicKey = await Secp256r1.compressPublicKey({
   *   publicKeyBytes: uncompressedPublicKeyBytes
   * });
   * ```
   *
   * @param params - The parameters for the public key compression.
   * @param params.publicKeyBytes - The public key as a Uint8Array.
   *
   * @returns A Promise that resolves to the compressed public key as a Uint8Array.
   */
  static compressPublicKey({ publicKeyBytes }) {
    return __awaiter30(this, void 0, void 0, function* () {
      const point = secp256r1.ProjectivePoint.fromHex(publicKeyBytes);
      return point.toRawBytes(true);
    });
  }
  /**
   * Derives the public key in JWK format from a given private key.
   *
   * @remarks
   * This method takes a private key in JWK format and derives its corresponding public key,
   * also in JWK format. The derivation process involves converting the private key to a raw
   * byte array, then computing the elliptic curve point (x and y coordinates) from this private
   * key. These coordinates are then encoded into base64url format to construct the public key in
   * JWK format.
   *
   * The process ensures that the derived public key correctly corresponds to the given private key,
   * adhering to the secp256r1 elliptic curve standards. This method is useful in cryptographic
   * operations where a public key is needed for operations like signature verification, but only
   * the private key is available.
   *
   * @example
   * ```ts
   * const privateKey = { ... }; // A Jwk object representing a secp256r1 private key
   * const publicKey = await Secp256r1.computePublicKey({ key: privateKey });
   * ```
   *
   * @param params - The parameters for the public key derivation.
   * @param params.key - The private key in JWK format from which to derive the public key.
   *
   * @returns A Promise that resolves to the derived public key in JWK format.
   */
  static computePublicKey({ key }) {
    return __awaiter30(this, void 0, void 0, function* () {
      const privateKeyBytes = yield _Secp256r1.privateKeyToBytes({ privateKey: key });
      const point = yield _Secp256r1.getCurvePoint({ keyBytes: privateKeyBytes });
      const publicKey = {
        kty: "EC",
        crv: "P-256",
        x: Convert2.uint8Array(point.x).toBase64Url(),
        y: Convert2.uint8Array(point.y).toBase64Url()
      };
      publicKey.kid = yield computeJwkThumbprint2({ jwk: publicKey });
      return publicKey;
    });
  }
  /**
   * Converts an ASN.1 DER encoded ECDSA signature to a compact R+S format.
   *
   * @remarks
   * This method is used for converting an ECDSA signature from the ASN.1 DER encoding to the more
   * compact R+S format. This conversion is often required when dealing with ECDSA signatures in
   * certain cryptographic standards such as JWS (JSON Web Signature).
   *
   * The method decodes the DER-encoded signature, extracts the R and S values, and concatenates
   * them into a single byte array. This process involves handling the ASN.1 structure to correctly
   * parse the R and S values, considering padding and integer encoding specifics of DER.
   *
   * @example
   * ```ts
   * const derSignature = new Uint8Array([...]); // Replace with your DER-encoded signature
   * const signature = await Secp256r1.convertDerToCompactSignature({ derSignature });
   * ```
   *
   * @param params - The parameters for the signature conversion.
   * @param params.derSignature - The signature in ASN.1 DER format as a `Uint8Array`.
   *
   * @returns A Promise that resolves to the signature in compact R+S format as a `Uint8Array`.
   */
  static convertDerToCompactSignature({ derSignature }) {
    return __awaiter30(this, void 0, void 0, function* () {
      const signatureObject = secp256r1.Signature.fromDER(derSignature);
      const compactSignature = signatureObject.toCompactRawBytes();
      return compactSignature;
    });
  }
  /**
   * Converts a public key to its uncompressed form.
   *
   * @remarks
   * This method takes a compressed public key represented as a byte array and decompresses it.
   * Public key decompression involves reconstructing the y-coordinate from the x-coordinate,
   * resulting in the full public key. This method is used when the uncompressed key format is
   * required for certain cryptographic operations or interoperability.
   *
   * @example
   * ```ts
   * const compressedPublicKeyBytes = new Uint8Array([...]); // Replace with actual compressed public key bytes
   * const decompressedPublicKey = await Secp256r1.decompressPublicKey({
   *   publicKeyBytes: compressedPublicKeyBytes
   * });
   * ```
   *
   * @param params - The parameters for the public key decompression.
   * @param params.publicKeyBytes - The public key as a Uint8Array.
   *
   * @returns A Promise that resolves to the uncompressed public key as a Uint8Array.
   */
  static decompressPublicKey({ publicKeyBytes }) {
    return __awaiter30(this, void 0, void 0, function* () {
      const point = secp256r1.ProjectivePoint.fromHex(publicKeyBytes);
      return point.toRawBytes(false);
    });
  }
  /**
   * Generates a secp256r1 private key in JSON Web Key (JWK) format.
   *
   * @remarks
   * This method creates a new private key suitable for use with the secp256r1
   * elliptic curve. The key is generated using cryptographically secure random
   * number generation to ensure its uniqueness and security. The resulting
   * private key adheres to the JWK format, specifically tailored for secp256r1,
   * making it compatible with common cryptographic standards and easy to use in
   * various cryptographic processes.
   *
   * The private key generated by this method includes the following components:
   * - `kty`: Key Type, set to 'EC' for Elliptic Curve.
   * - `crv`: Curve Name, set to 'P-256'.
   * - `d`: The private key component, base64url-encoded.
   * - `x`: The x-coordinate of the public key point, derived from the private key, base64url-encoded.
   * - `y`: The y-coordinate of the public key point, derived from the private key, base64url-encoded.
   *
   * The key is returned in a format suitable for direct use in signin and key agreement operations.
   *
   * @example
   * ```ts
   * const privateKey = await Secp256r1.generateKey();
   * ```
   *
   * @returns A Promise that resolves to the generated private key in JWK format.
   */
  static generateKey() {
    return __awaiter30(this, void 0, void 0, function* () {
      const privateKeyBytes = secp256r1.utils.randomPrivateKey();
      const privateKey = yield _Secp256r1.bytesToPrivateKey({ privateKeyBytes });
      privateKey.kid = yield computeJwkThumbprint2({ jwk: privateKey });
      return privateKey;
    });
  }
  /**
   * Retrieves the public key properties from a given private key in JWK format.
   *
   * @remarks
   * This method extracts the public key portion from a secp256r1 private key in JWK format. It does
   * so by removing the private key property 'd' and making a shallow copy, effectively yielding the
   * public key. The method sets the 'kid' (key ID) property using the JWK thumbprint if it is not
   * already defined. This approach is used under the assumption that a private key in JWK format
   * always contains the corresponding public key properties.
   *
   * Note: This method offers a significant performance advantage, being about 200 times faster
   * than `computePublicKey()`. However, it does not mathematically validate the private key, nor
   * does it derive the public key from the private key. It simply extracts existing public key
   * properties from the private key object. This makes it suitable for scenarios where speed is
   * critical and the private key's integrity is already assured.
   *
   * @example
   * ```ts
   * const privateKey = { ... }; // A Jwk object representing a secp256r1 private key
   * const publicKey = await Secp256r1.getPublicKey({ key: privateKey });
   * ```
   *
   * @param params - The parameters for retrieving the public key properties.
   * @param params.key - The private key in JWK format.
   *
   * @returns A Promise that resolves to the public key in JWK format.
   */
  static getPublicKey({ key }) {
    var _a;
    return __awaiter30(this, void 0, void 0, function* () {
      if (!(isEcPrivateJwk2(key) && key.crv === "P-256")) {
        throw new Error(`Secp256r1: The provided key is not a 'P-256' private JWK.`);
      }
      let { d } = key, publicKey = __rest7(key, ["d"]);
      (_a = publicKey.kid) !== null && _a !== void 0 ? _a : publicKey.kid = yield computeJwkThumbprint2({ jwk: publicKey });
      return publicKey;
    });
  }
  /**
   * Converts a private key from JSON Web Key (JWK) format to a raw byte array (Uint8Array).
   *
   * @remarks
   * This method takes a private key in JWK format and extracts its raw byte representation.
   * It specifically focuses on the 'd' parameter of the JWK, which represents the private
   * key component in base64url encoding. The method decodes this value into a byte array.
   *
   * This conversion is essential for operations that require the private key in its raw
   * binary form, such as certain low-level cryptographic operations or when interfacing
   * with systems and libraries that expect keys in a byte array format.
   *
   * @example
   * ```ts
   * const privateKey = { ... }; // An X25519 private key in JWK format
   * const privateKeyBytes = await Secp256r1.privateKeyToBytes({ privateKey });
   * ```
   *
   * @param params - The parameters for the private key conversion.
   * @param params.privateKey - The private key in JWK format.
   *
   * @returns A Promise that resolves to the private key as a Uint8Array.
   */
  static privateKeyToBytes({ privateKey }) {
    return __awaiter30(this, void 0, void 0, function* () {
      if (!isEcPrivateJwk2(privateKey)) {
        throw new Error(`Secp256r1: The provided key is not a valid EC private key.`);
      }
      const privateKeyBytes = Convert2.base64Url(privateKey.d).toUint8Array();
      return privateKeyBytes;
    });
  }
  /**
   * Converts a public key from JSON Web Key (JWK) format to a raw byte array (Uint8Array).
   *
   * @remarks
   * This method accepts a public key in JWK format and converts it into its raw binary
   * form. The conversion process involves decoding the 'x' and 'y' parameters of the JWK
   * (which represent the x and y coordinates of the elliptic curve point, respectively)
   * from base64url format into a byte array. The method then concatenates these values,
   * along with a prefix indicating the key format, to form the full public key.
   *
   * This function is particularly useful for use cases where the public key is needed
   * in its raw byte format, such as for certain cryptographic operations or when
   * interfacing with systems that require raw key formats.
   *
   * @example
   * ```ts
   * const publicKey = { ... }; // A Jwk public key object
   * const publicKeyBytes = await Secp256r1.publicKeyToBytes({ publicKey });
   * ```
   *
   * @param params - The parameters for the public key conversion.
   * @param params.publicKey - The public key in JWK format.
   *
   * @returns A Promise that resolves to the public key as a Uint8Array.
   */
  static publicKeyToBytes({ publicKey }) {
    return __awaiter30(this, void 0, void 0, function* () {
      if (!(isEcPublicJwk2(publicKey) && publicKey.y)) {
        throw new Error(`Secp256r1: The provided key is not a valid EC public key.`);
      }
      const prefix = new Uint8Array([4]);
      const x = Convert2.base64Url(publicKey.x).toUint8Array();
      const y = Convert2.base64Url(publicKey.y).toUint8Array();
      const publicKeyBytes = new Uint8Array([...prefix, ...x, ...y]);
      return publicKeyBytes;
    });
  }
  /**
   * Computes an RFC6090-compliant Elliptic Curve Diffie-Hellman (ECDH) shared secret
   * using secp256r1 private and public keys in JSON Web Key (JWK) format.
   *
   * @remarks
   * This method facilitates the ECDH key agreement protocol, which is a method of securely
   * deriving a shared secret between two parties based on their private and public keys.
   * It takes the private key of one party (privateKeyA) and the public key of another
   * party (publicKeyB) to compute a shared secret. The shared secret is derived from the
   * x-coordinate of the elliptic curve point resulting from the multiplication of the
   * public key with the private key.
   *
   * Note: When performing Elliptic Curve Diffie-Hellman (ECDH) key agreement,
   * the resulting shared secret is a point on the elliptic curve, which
   * consists of an x-coordinate and a y-coordinate. With a 256-bit curve like
   * secp256r1, each of these coordinates is 32 bytes (256 bits) long. However,
   * in the ECDH process, it's standard practice to use only the x-coordinate
   * of the shared secret point as the resulting shared key. This is because
   * the y-coordinate does not add to the entropy of the key, and both parties
   * can independently compute the x-coordinate.  Consquently, this implementation
   * omits the y-coordinate for simplicity and standard compliance.
   *
   * @example
   * ```ts
   * const privateKeyA = { ... }; // A Jwk private key object for party A
   * const publicKeyB = { ... }; // A Jwk public key object for party B
   * const sharedSecret = await Secp256r1.sharedSecret({
   *   privateKeyA,
   *   publicKeyB
   * });
   * ```
   *
   * @param params - The parameters for the shared secret computation.
   * @param params.privateKeyA - The private key in JWK format of one party.
   * @param params.publicKeyB - The public key in JWK format of the other party.
   *
   * @returns A Promise that resolves to the computed shared secret as a Uint8Array.
   */
  static sharedSecret({ privateKeyA, publicKeyB }) {
    return __awaiter30(this, void 0, void 0, function* () {
      if ("x" in privateKeyA && "x" in publicKeyB && privateKeyA.x === publicKeyB.x) {
        throw new Error(`Secp256r1: ECDH shared secret cannot be computed from a single key pair's public and private keys.`);
      }
      const privateKeyABytes = yield _Secp256r1.privateKeyToBytes({ privateKey: privateKeyA });
      const publicKeyBBytes = yield _Secp256r1.publicKeyToBytes({ publicKey: publicKeyB });
      const sharedSecret = secp256r1.getSharedSecret(privateKeyABytes, publicKeyBBytes, true);
      return sharedSecret.slice(1);
    });
  }
  /**
   * Generates an RFC6979-compliant ECDSA signature of given data using a secp256r1 private key.
   *
   * @remarks
   * This method signs the provided data with a specified private key using the ECDSA
   * (Elliptic Curve Digital Signature Algorithm) signature algorithm, as defined in RFC6979.
   * The data to be signed is first hashed using the SHA-256 algorithm, and this hash is then
   * signed using the private key. The output is a digital signature in the form of a
   * Uint8Array, which uniquely corresponds to both the data and the private key used for signing.
   *
   * This method is commonly used in cryptographic applications to ensure data integrity and
   * authenticity. The signature can later be verified by parties with access to the corresponding
   * public key, ensuring that the data has not been tampered with and was indeed signed by the
   * holder of the private key.
   *
   * @example
   * ```ts
   * const data = new TextEncoder().encode('Messsage'); // Data to be signed
   * const privateKey = { ... }; // A Jwk object representing a secp256r1 private key
   * const signature = await Secp256r1.sign({
   *   key: privateKey,
   *   data
   * });
   * ```
   *
   * @param params - The parameters for the signing operation.
   * @param params.key - The private key to use for signing, represented in JWK format.
   * @param params.data - The data to sign, represented as a Uint8Array.
   *
   * @returns A Promise that resolves to the signature as a Uint8Array.
   */
  static sign({ data, key }) {
    return __awaiter30(this, void 0, void 0, function* () {
      const privateKeyBytes = yield _Secp256r1.privateKeyToBytes({ privateKey: key });
      const digest = sha256(data);
      const signatureObject = secp256r1.sign(digest, privateKeyBytes);
      const signature = signatureObject.toCompactRawBytes();
      return signature;
    });
  }
  /**
   * Validates a given private key to ensure its compliance with the secp256r1 curve standards.
   *
   * @remarks
   * This method checks whether a provided private key is a valid 32-byte number and falls within
   * the range defined by the secp256r1 curve's order. It is essential for ensuring the private
   * key's mathematical correctness in the context of secp256r1-based cryptographic operations.
   *
   * Note that this validation strictly pertains to the key's format and numerical validity; it does
   * not assess whether the key corresponds to a known entity or its security status (e.g., whether
   * it has been compromised).
   *
   * @example
   * ```ts
   * const privateKeyBytes = new Uint8Array([...]); // A 32-byte private key
   * const isValid = await Secp256r1.validatePrivateKey({ privateKeyBytes });
   * console.log(isValid); // true or false based on the key's validity
   * ```
   *
   * @param params - The parameters for the key validation.
   * @param params.privateKeyBytes - The private key to validate, represented as a Uint8Array.
   *
   * @returns A Promise that resolves to a boolean indicating whether the private key is valid.
   */
  static validatePrivateKey({ privateKeyBytes }) {
    return __awaiter30(this, void 0, void 0, function* () {
      return secp256r1.utils.isValidPrivateKey(privateKeyBytes);
    });
  }
  /**
   * Validates a given public key to confirm its mathematical correctness on the secp256r1 curve.
   *
   * @remarks
   * This method checks if the provided public key represents a valid point on the secp256r1 curve.
   * It decodes the key's Weierstrass points (x and y coordinates) and verifies their validity
   * against the curve's parameters. A valid point must lie on the curve and meet specific
   * mathematical criteria defined by the curve's equation.
   *
   * It's important to note that this method does not verify the key's ownership or whether it has
   * been compromised; it solely focuses on the key's adherence to the curve's mathematical
   * principles.
   *
   * @example
   * ```ts
   * const publicKeyBytes = new Uint8Array([...]); // A public key in byte format
   * const isValid = await Secp256r1.validatePublicKey({ publicKeyBytes });
   * console.log(isValid); // true if the key is valid on the secp256r1 curve, false otherwise
   * ```
   *
   * @param params - The parameters for the key validation.
   * @param params.publicKeyBytes - The public key to validate, represented as a Uint8Array.
   *
   * @returns A Promise that resolves to a boolean indicating the public key's validity on
   *          the secp256r1 curve.
   */
  static validatePublicKey({ publicKeyBytes }) {
    return __awaiter30(this, void 0, void 0, function* () {
      try {
        const point = secp256r1.ProjectivePoint.fromHex(publicKeyBytes);
        point.assertValidity();
      } catch (error) {
        return false;
      }
      return true;
    });
  }
  /**
   * Verifies an RFC6979-compliant ECDSA signature against given data and a secp256r1 public key.
   *
   * @remarks
   * This method validates a digital signature to ensure that it was generated by the holder of the
   * corresponding private key and that the signed data has not been altered. The signature
   * verification is performed using the ECDSA (Elliptic Curve Digital Signature Algorithm) as
   * specified in RFC6979. The data to be verified is first hashed using the SHA-256 algorithm, and
   * this hash is then used along with the public key to verify the signature.
   *
   * The method returns a boolean value indicating whether the signature is valid. A valid signature
   * proves that the signed data was indeed signed by the owner of the private key corresponding to
   * the provided public key and that the data has not been tampered with since it was signed.
   *
   * Note: The verification process does not consider the malleability of low-s signatures, which
   * may be relevant in certain contexts, such as Bitcoin transactions.
   *
   * @example
   * ```ts
   * const data = new TextEncoder().encode('Messsage'); // Data that was signed
   * const publicKey = { ... }; // Public key in JWK format corresponding to the private key that signed the data
   * const signature = new Uint8Array([...]); // Signature to verify
   * const isSignatureValid = await Secp256r1.verify({
   *   key: publicKey,
   *   signature,
   *   data
   * });
   * console.log(isSignatureValid); // true if the signature is valid, false otherwise
   * ```
   *
   * @param params - The parameters for the signature verification.
   * @param params.key - The public key used for verification, represented in JWK format.
   * @param params.signature - The signature to verify, represented as a Uint8Array.
   * @param params.data - The data that was signed, represented as a Uint8Array.
   *
   * @returns A Promise that resolves to a boolean indicating whether the signature is valid.
   */
  static verify({ key, signature, data }) {
    return __awaiter30(this, void 0, void 0, function* () {
      const publicKeyBytes = yield _Secp256r1.publicKeyToBytes({ publicKey: key });
      const digest = sha256(data);
      const isValid3 = secp256r1.verify(signature, digest, publicKeyBytes, { lowS: false });
      return isValid3;
    });
  }
  /**
   * Returns the elliptic curve point (x and y coordinates) for a given secp256r1 key.
   *
   * @remarks
   * This method extracts the elliptic curve point from a given secp256r1 key, whether
   * it's a private or a public key. For a private key, the method first computes the
   * corresponding public key and then extracts the x and y coordinates. For a public key,
   * it directly returns these coordinates. The coordinates are represented as Uint8Array.
   *
   * The x and y coordinates represent the key's position on the elliptic curve and can be
   * used in various cryptographic operations, such as digital signatures or key agreement
   * protocols.
   *
   * @example
   * ```ts
   * // For a private key
   * const privateKey = new Uint8Array([...]); // A 32-byte private key
   * const { x: xFromPrivateKey, y: yFromPrivateKey } = await Secp256r1.getCurvePoint({ keyBytes: privateKey });
   *
   * // For a public key
   * const publicKey = new Uint8Array([...]); // A 33-byte or 65-byte public key
   * const { x: xFromPublicKey, y: yFromPublicKey } = await Secp256r1.getCurvePoint({ keyBytes: publicKey });
   * ```
   *
   * @param params - The parameters for the curve point decoding operation.
   * @param params.keyBytes - The key for which to get the elliptic curve point.
   *                          Can be either a private key or a public key.
   *                          The key should be passed as a `Uint8Array`.
   *
   * @returns A Promise that resolves to an object with properties 'x' and 'y',
   *          each being a Uint8Array representing the x and y coordinates of the key point on the
   *          elliptic curve.
   */
  static getCurvePoint({ keyBytes }) {
    return __awaiter30(this, void 0, void 0, function* () {
      if (keyBytes.byteLength === 32) {
        keyBytes = secp256r1.getPublicKey(keyBytes);
      }
      const point = secp256r1.ProjectivePoint.fromHex(keyBytes);
      const x = numberToBytesBE(point.x, 32);
      const y = numberToBytesBE(point.y, 32);
      return { x, y };
    });
  }
};

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/algorithms/ecdsa.js
var __awaiter31 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var EcdsaAlgorithm2 = class extends CryptoAlgorithm2 {
  /**
   * Derives the public key in JWK format from a given private key.
   *
   * @remarks
   * This method takes a private key in JWK format and derives its corresponding public key,
   * also in JWK format. The process ensures that the derived public key correctly corresponds to
   * the given private key.
   *
   * @example
   * ```ts
   * const ecdsa = new EcdsaAlgorithm();
   * const privateKey = { ... }; // A Jwk object representing a private key
   * const publicKey = await ecdsa.computePublicKey({ key: privateKey });
   * ```
   *
   * @param params - The parameters for the public key derivation.
   * @param params.key - The private key in JWK format from which to derive the public key.
   *
   * @returns A Promise that resolves to the derived public key in JWK format.
   */
  computePublicKey({ key }) {
    return __awaiter31(this, void 0, void 0, function* () {
      if (!isEcPrivateJwk2(key))
        throw new TypeError("Invalid key provided. Must be an elliptic curve (EC) private key.");
      switch (key.crv) {
        case "secp256k1": {
          const publicKey = yield Secp256k12.computePublicKey({ key });
          publicKey.alg = "ES256K";
          return publicKey;
        }
        case "P-256": {
          const publicKey = yield Secp256r12.computePublicKey({ key });
          publicKey.alg = "ES256";
          return publicKey;
        }
        default: {
          throw new Error(`Unsupported curve: ${key.crv}`);
        }
      }
    });
  }
  /**
   * Generates a new private key with the specified algorithm in JSON Web Key (JWK) format.
   *
   * @example
   * ```ts
   * const ecdsa = new EcdsaAlgorithm();
   * const privateKey = await ecdsa.generateKey({ algorithm: 'ES256K' });
   * ```
   *
   * @param params - The parameters for key generation.
   * @param params.algorithm - The algorithm to use for key generation.
   *
   * @returns A Promise that resolves to the generated private key in JWK format.
   */
  generateKey({ algorithm }) {
    return __awaiter31(this, void 0, void 0, function* () {
      switch (algorithm) {
        case "ES256K":
        case "secp256k1": {
          const privateKey = yield Secp256k12.generateKey();
          privateKey.alg = "ES256K";
          return privateKey;
        }
        case "ES256":
        case "secp256r1": {
          const privateKey = yield Secp256r12.generateKey();
          privateKey.alg = "ES256";
          return privateKey;
        }
      }
    });
  }
  /**
   * Retrieves the public key properties from a given private key in JWK format.
   *
   * @remarks
   * This method extracts the public key portion from an ECDSA private key in JWK format. It does
   * so by removing the private key property 'd' and making a shallow copy, effectively yielding the
   * public key.
   *
   * Note: This method offers a significant performance advantage, being about 200 times faster
   * than `computePublicKey()`. However, it does not mathematically validate the private key, nor
   * does it derive the public key from the private key. It simply extracts existing public key
   * properties from the private key object. This makes it suitable for scenarios where speed is
   * critical and the private key's integrity is already assured.
   *
   * @example
   * ```ts
   * const ecdsa = new EcdsaAlgorithm();
   * const privateKey = { ... }; // A Jwk object representing a private key
   * const publicKey = await ecdsa.getPublicKey({ key: privateKey });
   * ```
   *
   * @param params - The parameters for retrieving the public key properties.
   * @param params.key - The private key in JWK format.
   *
   * @returns A Promise that resolves to the public key in JWK format.
   */
  getPublicKey({ key }) {
    return __awaiter31(this, void 0, void 0, function* () {
      if (!isEcPrivateJwk2(key))
        throw new TypeError("Invalid key provided. Must be an elliptic curve (EC) private key.");
      switch (key.crv) {
        case "secp256k1": {
          const publicKey = yield Secp256k12.getPublicKey({ key });
          publicKey.alg = "ES256K";
          return publicKey;
        }
        case "P-256": {
          const publicKey = yield Secp256r12.getPublicKey({ key });
          publicKey.alg = "ES256";
          return publicKey;
        }
        default: {
          throw new Error(`Unsupported curve: ${key.crv}`);
        }
      }
    });
  }
  /**
   * Generates an ECDSA signature of given data using a private key.
   *
   * @remarks
   * This method uses the signature algorithm determined by the given `algorithm` to sign the
   * provided data.
   *
   * The signature can later be verified by parties with access to the corresponding
   * public key, ensuring that the data has not been tampered with and was indeed signed by the
   * holder of the private key.
   *
   * @example
   * ```ts
   * const ecdsa = new EcdsaAlgorithm();
   * const data = new TextEncoder().encode('Message');
   * const privateKey = { ... }; // A Jwk object representing a private key
   * const signature = await ecdsa.sign({
   *   key: privateKey,
   *   data
   * });
   * ```
   *
   * @param params - The parameters for the signing operation.
   * @param params.key - The private key to use for signing, represented in JWK format.
   * @param params.data - The data to sign.
   *
   * @returns A Promise resolving to the digital signature as a `Uint8Array`.
   */
  sign({ key, data }) {
    return __awaiter31(this, void 0, void 0, function* () {
      if (!isEcPrivateJwk2(key))
        throw new TypeError("Invalid key provided. Must be an elliptic curve (EC) private key.");
      switch (key.crv) {
        case "secp256k1": {
          return yield Secp256k12.sign({ key, data });
        }
        case "P-256": {
          return yield Secp256r12.sign({ key, data });
        }
        default: {
          throw new Error(`Unsupported curve: ${key.crv}`);
        }
      }
    });
  }
  /**
   * Verifies an ECDSA signature associated with the provided data using the provided key.
   *
   * @remarks
   * This method uses the signature algorithm determined by the `crv` property of the provided key
   * to check the validity of a digital signature against the original data. It confirms whether the
   * signature was created by the holder of the corresponding private key and that the data has not
   * been tampered with.
   *s
   * @example
   * ```ts
   * const ecdsa = new EcdsaAlgorithm();
   * const publicKey = { ... }; // Public key in JWK format corresponding to the private key that signed the data
   * const signature = new Uint8Array([...]); // Signature to verify
   * const data = new TextEncoder().encode('Message');
   * const isValid = await ecdsa.verify({
   *   key: publicKey,
   *   signature,
   *   data
   * });
   * ```
   *
   * @param params - The parameters for the verification operation.
   * @param params.key - The key to use for verification.
   * @param params.signature - The signature to verify.
   * @param params.data - The data to verify.
   *
   * @returns A Promise resolving to a boolean indicating whether the signature is valid.
   */
  verify({ key, signature, data }) {
    return __awaiter31(this, void 0, void 0, function* () {
      if (!isEcPublicJwk2(key))
        throw new TypeError("Invalid key provided. Must be an elliptic curve (EC) public key.");
      switch (key.crv) {
        case "secp256k1": {
          return yield Secp256k12.verify({ key, signature, data });
        }
        case "P-256": {
          return yield Secp256r12.verify({ key, signature, data });
        }
        default: {
          throw new Error(`Unsupported curve: ${key.crv}`);
        }
      }
    });
  }
};

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/algorithms/eddsa.js
var import_dist111 = __toESM(require_dist(), 1);

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/primitives/ed25519.js
var import_dist110 = __toESM(require_dist(), 1);
var __awaiter32 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest8 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Ed255192 = class _Ed25519 {
  /**
   * Converts a raw private key in bytes to its corresponding JSON Web Key (JWK) format.
   *
   * @remarks
   * This method accepts a private key as a byte array (Uint8Array) for the Curve25519 curve in
   * Twisted Edwards form and transforms it into a JWK object. The process involves first deriving
   * the public key from the private key, then encoding both the private and public keys into
   * base64url format.
   *
   * The resulting JWK object includes the following properties:
   * - `kty`: Key Type, set to 'OKP' for Octet Key Pair.
   * - `crv`: Curve Name, set to 'Ed25519'.
   * - `d`: The private key component, base64url-encoded.
   * - `x`: The computed public key, base64url-encoded.
   *
   * @example
   * ```ts
   * const privateKeyBytes = new Uint8Array([...]); // Replace with actual private key bytes
   * const privateKey = await Ed25519.bytesToPrivateKey({ privateKeyBytes });
   * ```
   *
   * @param params - The parameters for the private key conversion.
   * @param params.privateKeyBytes - The raw private key as a Uint8Array.
   *
   * @returns A Promise that resolves to the private key in JWK format.
   */
  static bytesToPrivateKey({ privateKeyBytes }) {
    return __awaiter32(this, void 0, void 0, function* () {
      const publicKeyBytes = ed25519.getPublicKey(privateKeyBytes);
      const privateKey = {
        crv: "Ed25519",
        d: Convert2.uint8Array(privateKeyBytes).toBase64Url(),
        kty: "OKP",
        x: Convert2.uint8Array(publicKeyBytes).toBase64Url()
      };
      privateKey.kid = yield computeJwkThumbprint2({ jwk: privateKey });
      return privateKey;
    });
  }
  /**
   * Converts a raw private key in bytes to its corresponding JSON Web Key (JWK) format.
   *
   * @remarks
   * This method accepts a public key as a byte array (Uint8Array) for the Curve25519 curve in
   * Twisted Edwards form and transforms it into a JWK object. The process involves encoding the
   * public key bytes into base64url format.
   *
   * The resulting JWK object includes the following properties:
   * - `kty`: Key Type, set to 'OKP' for Octet Key Pair.
   * - `crv`: Curve Name, set to 'X25519'.
   * - `x`: The public key, base64url-encoded.
   *
   * @example
   * ```ts
   * const publicKeyBytes = new Uint8Array([...]); // Replace with actual public key bytes
   * const publicKey = await X25519.bytesToPublicKey({ publicKeyBytes });
   * ```
   *
   * @param params - The parameters for the public key conversion.
   * @param params.publicKeyBytes - The raw public key as a `Uint8Array`.
   *
   * @returns A Promise that resolves to the public key in JWK format.
   */
  static bytesToPublicKey({ publicKeyBytes }) {
    return __awaiter32(this, void 0, void 0, function* () {
      const publicKey = {
        kty: "OKP",
        crv: "Ed25519",
        x: Convert2.uint8Array(publicKeyBytes).toBase64Url()
      };
      publicKey.kid = yield computeJwkThumbprint2({ jwk: publicKey });
      return publicKey;
    });
  }
  /**
   * Derives the public key in JWK format from a given Ed25519 private key.
   *
   * @remarks
   * This method takes a private key in JWK format and derives its corresponding public key,
   * also in JWK format.  The derivation process involves converting the private key to a
   * raw byte array and then computing the corresponding public key on the Curve25519 curve in
   * Twisted Edwards form. The public key is then encoded into base64url format to construct
   * a JWK representation.
   *
   * @example
   * ```ts
   * const privateKey = { ... }; // A Jwk object representing an Ed25519 private key
   * const publicKey = await Ed25519.computePublicKey({ key: privateKey });
   * ```
   *
   * @param params - The parameters for the public key derivation.
   * @param params.key - The private key in JWK format from which to derive the public key.
   *
   * @returns A Promise that resolves to the computed public key in JWK format.
   */
  static computePublicKey({ key }) {
    return __awaiter32(this, void 0, void 0, function* () {
      const privateKeyBytes = yield _Ed25519.privateKeyToBytes({ privateKey: key });
      const publicKeyBytes = ed25519.getPublicKey(privateKeyBytes);
      const publicKey = {
        kty: "OKP",
        crv: "Ed25519",
        x: Convert2.uint8Array(publicKeyBytes).toBase64Url()
      };
      publicKey.kid = yield computeJwkThumbprint2({ jwk: publicKey });
      return publicKey;
    });
  }
  /**
   * Converts an Ed25519 private key to its X25519 counterpart.
   *
   * @remarks
   * This method enables the use of the same key pair for both digital signature (Ed25519)
   * and key exchange (X25519) operations. It takes an Ed25519 private key and converts it
   * to the corresponding X25519 format, facilitating interoperability between signing
   * and encryption protocols.
   *
   * @example
   * ```ts
   * const ed25519PrivateKey = { ... }; // An Ed25519 private key in JWK format
   * const x25519PrivateKey = await Ed25519.convertPrivateKeyToX25519({
   *   privateKey: ed25519PrivateKey
   * });
   * ```
   *
   * @param params - The parameters for the private key conversion.
   * @param params.privateKey - The Ed25519 private key to convert, in JWK format.
   *
   * @returns A Promise that resolves to the X25519 private key in JWK format.
   */
  static convertPrivateKeyToX25519({ privateKey }) {
    return __awaiter32(this, void 0, void 0, function* () {
      const ed25519PrivateKeyBytes = yield _Ed25519.privateKeyToBytes({ privateKey });
      const x25519PrivateKeyBytes = edwardsToMontgomeryPriv(ed25519PrivateKeyBytes);
      const x25519PublicKeyBytes = x25519.getPublicKey(x25519PrivateKeyBytes);
      const x25519PrivateKey = {
        kty: "OKP",
        crv: "X25519",
        d: Convert2.uint8Array(x25519PrivateKeyBytes).toBase64Url(),
        x: Convert2.uint8Array(x25519PublicKeyBytes).toBase64Url()
      };
      x25519PrivateKey.kid = yield computeJwkThumbprint2({ jwk: x25519PrivateKey });
      return x25519PrivateKey;
    });
  }
  /**
   * Converts an Ed25519 public key to its X25519 counterpart.
   *
   * @remarks
   * This method enables the use of the same key pair for both digital signature (Ed25519)
   * and key exchange (X25519) operations. It takes an Ed25519 public key and converts it
   * to the corresponding X25519 format, facilitating interoperability between signing
   * and encryption protocols.
   *
   * @example
   * ```ts
   * const ed25519PublicKey = { ... }; // An Ed25519 public key in JWK format
   * const x25519PublicKey = await Ed25519.convertPublicKeyToX25519({
   *   publicKey: ed25519PublicKey
   * });
   * ```
   *
   * @param params - The parameters for the public key conversion.
   * @param params.publicKey - The Ed25519 public key to convert, in JWK format.
   *
   * @returns A Promise that resolves to the X25519 public key in JWK format.
   */
  static convertPublicKeyToX25519({ publicKey }) {
    return __awaiter32(this, void 0, void 0, function* () {
      const ed25519PublicKeyBytes = yield _Ed25519.publicKeyToBytes({ publicKey });
      const isValid3 = yield _Ed25519.validatePublicKey({ publicKeyBytes: ed25519PublicKeyBytes });
      if (!isValid3) {
        throw new Error("Ed25519: Invalid public key.");
      }
      const x25519PublicKeyBytes = edwardsToMontgomeryPub(ed25519PublicKeyBytes);
      const x25519PublicKey = {
        kty: "OKP",
        crv: "X25519",
        x: Convert2.uint8Array(x25519PublicKeyBytes).toBase64Url()
      };
      x25519PublicKey.kid = yield computeJwkThumbprint2({ jwk: x25519PublicKey });
      return x25519PublicKey;
    });
  }
  /**
   * Generates an Ed25519 private key in JSON Web Key (JWK) format.
   *
   * @remarks
   * This method creates a new private key suitable for use with the Curve25519 elliptic curve in
   * Twisted Edwards form. The key generation process involves using cryptographically secure
   * random number generation to ensure the uniqueness and security of the key. The resulting
   * private key adheres to the JWK format making it compatible with common cryptographic
   * standards and easy to use in various cryptographic processes.
   *
   * The generated private key in JWK format includes the following components:
   * - `kty`: Key Type, set to 'OKP' for Octet Key Pair.
   * - `crv`: Curve Name, set to 'Ed25519'.
   * - `d`: The private key component, base64url-encoded.
   * - `x`: The derived public key, base64url-encoded.
   *
   * @example
   * ```ts
   * const privateKey = await Ed25519.generateKey();
   * ```
   *
   * @returns A Promise that resolves to the generated private key in JWK format.
   */
  static generateKey() {
    return __awaiter32(this, void 0, void 0, function* () {
      const privateKeyBytes = ed25519.utils.randomPrivateKey();
      const privateKey = yield _Ed25519.bytesToPrivateKey({ privateKeyBytes });
      privateKey.kid = yield computeJwkThumbprint2({ jwk: privateKey });
      return privateKey;
    });
  }
  /**
   * Retrieves the public key properties from a given private key in JWK format.
   *
   * @remarks
   * This method extracts the public key portion from an Ed25519 private key in JWK format. It does
   * so by removing the private key property 'd' and making a shallow copy, effectively yielding the
   * public key. The method sets the 'kid' (key ID) property using the JWK thumbprint if it is not
   * already defined. This approach is used under the assumption that a private key in JWK format
   * always contains the corresponding public key properties.
   *
   * Note: This method offers a significant performance advantage, being about 100 times faster
   * than `computePublicKey()`. However, it does not mathematically validate the private key, nor
   * does it derive the public key from the private key. It simply extracts existing public key
   * properties from the private key object. This makes it suitable for scenarios where speed is
   * critical and the private key's integrity is already assured.
   *
   * @example
   * ```ts
   * const privateKey = { ... }; // A Jwk object representing an Ed25519 private key
   * const publicKey = await Ed25519.getPublicKey({ key: privateKey });
   * ```
   *
   * @param params - The parameters for retrieving the public key properties.
   * @param params.key - The private key in JWK format.
   *
   * @returns A Promise that resolves to the public key in JWK format.
   */
  static getPublicKey({ key }) {
    var _a;
    return __awaiter32(this, void 0, void 0, function* () {
      if (!(isOkpPrivateJwk2(key) && key.crv === "Ed25519")) {
        throw new Error(`Ed25519: The provided key is not an Ed25519 private JWK.`);
      }
      let { d } = key, publicKey = __rest8(key, ["d"]);
      (_a = publicKey.kid) !== null && _a !== void 0 ? _a : publicKey.kid = yield computeJwkThumbprint2({ jwk: publicKey });
      return publicKey;
    });
  }
  /**
   * Converts a private key from JSON Web Key (JWK) format to a raw byte array (Uint8Array).
   *
   * @remarks
   * This method accepts a private key in JWK format and extracts its raw byte representation.
   *
   * This method accepts a public key in JWK format and converts it into its raw binary
   * form. The conversion process involves decoding the 'd' parameter of the JWK
   * from base64url format into a byte array.
   *
   * @example
   * ```ts
   * const privateKey = { ... }; // An Ed25519 private key in JWK format
   * const privateKeyBytes = await Ed25519.privateKeyToBytes({ privateKey });
   * ```
   *
   * @param params - The parameters for the private key conversion.
   * @param params.privateKey - The private key in JWK format.
   *
   * @returns A Promise that resolves to the private key as a Uint8Array.
   */
  static privateKeyToBytes({ privateKey }) {
    return __awaiter32(this, void 0, void 0, function* () {
      if (!isOkpPrivateJwk2(privateKey)) {
        throw new Error(`Ed25519: The provided key is not a valid OKP private key.`);
      }
      const privateKeyBytes = Convert2.base64Url(privateKey.d).toUint8Array();
      return privateKeyBytes;
    });
  }
  /**
   * Converts a public key from JSON Web Key (JWK) format to a raw byte array (Uint8Array).
   *
   * @remarks
   * This method accepts a public key in JWK format and converts it into its raw binary form.
   * The conversion process involves decoding the 'x' parameter of the JWK (which represent the
   * x coordinate of the elliptic curve point) from base64url format into a byte array.
   *
   * @example
   * ```ts
   * const publicKey = { ... }; // An Ed25519 public key in JWK format
   * const publicKeyBytes = await Ed25519.publicKeyToBytes({ publicKey });
   * ```
   *
   * @param params - The parameters for the public key conversion.
   * @param params.publicKey - The public key in JWK format.
   *
   * @returns A Promise that resolves to the public key as a Uint8Array.
   */
  static publicKeyToBytes({ publicKey }) {
    return __awaiter32(this, void 0, void 0, function* () {
      if (!isOkpPublicJwk2(publicKey)) {
        throw new Error(`Ed25519: The provided key is not a valid OKP public key.`);
      }
      const publicKeyBytes = Convert2.base64Url(publicKey.x).toUint8Array();
      return publicKeyBytes;
    });
  }
  /**
   * Generates an RFC8032-compliant EdDSA signature of given data using an Ed25519 private key.
   *
   * @remarks
   * This method signs the provided data with a specified private key using the EdDSA
   * (Edwards-curve Digital Signature Algorithm) as defined in RFC8032. It
   * involves converting the private key from JWK format to a byte array and then employing
   * the Ed25519 algorithm to sign the data. The output is a digital signature in the form
   * of a Uint8Array, uniquely corresponding to both the data and the private key used for
   * signing.
   *
   * @example
   * ```ts
   * const data = new TextEncoder().encode('Messsage'); // Data to be signed
   * const privateKey = { ... }; // A Jwk object representing an Ed25519 private key
   * const signature = await Ed25519.sign({ key: privateKey, data });
   * ```
   *
   * @param params - The parameters for the signing operation.
   * @param params.key - The private key to use for signing, represented in JWK format.
   * @param params.data - The data to sign, represented as a Uint8Array.
   *
   * @returns A Promise that resolves to the signature as a Uint8Array.
   */
  static sign({ key, data }) {
    return __awaiter32(this, void 0, void 0, function* () {
      const privateKeyBytes = yield _Ed25519.privateKeyToBytes({ privateKey: key });
      const signature = ed25519.sign(data, privateKeyBytes);
      return signature;
    });
  }
  /**
   * Validates a given public key to confirm its mathematical correctness on the Edwards curve.
   *
   * @remarks
   * This method decodes the Edwards points from the key bytes and asserts their validity on the
   * Curve25519 curve in Twisted Edwards form. If the points are not valid, the method returns
   * false. If the points are valid, the method returns true.
   *
   * Note that this validation strictly pertains to the key's format and numerical validity; it does
   * not assess whether the key corresponds to a known entity or its security status (e.g., whether
   * it has been compromised).
   *
   * @example
   * ```ts
   * const publicKeyBytes = new Uint8Array([...]); // A public key in byte format
   * const isValid = await Ed25519.validatePublicKey({ publicKeyBytes });
   * console.log(isValid); // true if the key is valid on the Edwards curve, false otherwise
   * ```
   *
   * @param params - The parameters for the public key validation.
   * @param params.publicKeyBytes - The public key to validate, represented as a Uint8Array.
   *
   * @returns A Promise that resolves to a boolean indicating whether the key
   *          corresponds to a valid point on the Edwards curve.
   */
  static validatePublicKey({ publicKeyBytes }) {
    return __awaiter32(this, void 0, void 0, function* () {
      try {
        const point = ed25519.ExtendedPoint.fromHex(publicKeyBytes);
        point.assertValidity();
      } catch (error) {
        return false;
      }
      return true;
    });
  }
  /**
   * Verifies an RFC8032-compliant EdDSA signature against given data using an Ed25519 public key.
   *
   * @remarks
   * This method validates a digital signature to ensure its authenticity and integrity.
   * It uses the EdDSA (Edwards-curve Digital Signature Algorithm) as specified in RFC8032.
   * The verification process involves converting the public key from JWK format to a raw
   * byte array and using the Ed25519 algorithm to validate the signature against the provided data.
   *
   * @example
   * ```ts
   * const data = new TextEncoder().encode('Messsage'); // Data that was signed
   * const publicKey = { ... }; // A Jwk object representing an Ed25519 public key
   * const signature = new Uint8Array([...]); // Signature to verify
   * const isValid = await Ed25519.verify({ key: publicKey, signature, data });
   * console.log(isValid); // true if the signature is valid, false otherwise
   * ```
   *
   * @param params - The parameters for the signature verification.
   * @param params.key - The public key in JWK format used for verification.
   * @param params.signature - The signature to verify, represented as a Uint8Array.
   * @param params.data - The data that was signed, represented as a Uint8Array.
   *
   * @returns A Promise that resolves to a boolean indicating whether the signature is valid.
   */
  static verify({ key, signature, data }) {
    return __awaiter32(this, void 0, void 0, function* () {
      const publicKeyBytes = yield _Ed25519.publicKeyToBytes({ publicKey: key });
      const isValid3 = ed25519.verify(signature, data, publicKeyBytes);
      return isValid3;
    });
  }
};

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/algorithms/eddsa.js
var __awaiter33 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var EdDsaAlgorithm2 = class extends CryptoAlgorithm2 {
  /**
   * Derives the public key in JWK format from a given private key.
   *
   * @remarks
   * This method takes a private key in JWK format and derives its corresponding public key,
   * also in JWK format. The process ensures that the derived public key correctly corresponds to
   * the given private key.
   *
   * @example
   * ```ts
   * const eddsa = new EdDsaAlgorithm();
   * const privateKey = { ... }; // A Jwk object representing a private key
   * const publicKey = await eddsa.computePublicKey({ key: privateKey });
   * ```
   *
   * @param params - The parameters for the public key derivation.
   * @param params.key - The private key in JWK format from which to derive the public key.
   *
   * @returns A Promise that resolves to the derived public key in JWK format.
   */
  computePublicKey({ key }) {
    return __awaiter33(this, void 0, void 0, function* () {
      if (!isOkpPrivateJwk2(key))
        throw new TypeError("Invalid key provided. Must be an octet key pair (OKP) private key.");
      switch (key.crv) {
        case "Ed25519": {
          const publicKey = yield Ed255192.computePublicKey({ key });
          publicKey.alg = "EdDSA";
          return publicKey;
        }
        default: {
          throw new Error(`Unsupported curve: ${key.crv}`);
        }
      }
    });
  }
  /**
   * Generates a new private key with the specified algorithm in JSON Web Key (JWK) format.
   *
   * @example
   * ```ts
   * const eddsa = new EdDsaAlgorithm();
   * const privateKey = await eddsa.generateKey({ algorithm: 'Ed25519' });
   * ```
   *
   * @param params - The parameters for key generation.
   * @param params.algorithm - The algorithm to use for key generation.
   *
   * @returns A Promise that resolves to the generated private key in JWK format.
   */
  generateKey({ algorithm }) {
    return __awaiter33(this, void 0, void 0, function* () {
      switch (algorithm) {
        case "Ed25519": {
          const privateKey = yield Ed255192.generateKey();
          privateKey.alg = "EdDSA";
          return privateKey;
        }
      }
    });
  }
  /**
   * Retrieves the public key properties from a given private key in JWK format.
   *
   * @remarks
   * This method extracts the public key portion from an EdDSA private key in JWK format. It does
   * so by removing the private key property 'd' and making a shallow copy, effectively yielding the
   * public key.
   *
   * Note: This method offers a significant performance advantage, being about 100 times faster
   * than `computePublicKey()`. However, it does not mathematically validate the private key, nor
   * does it derive the public key from the private key. It simply extracts existing public key
   * properties from the private key object. This makes it suitable for scenarios where speed is
   * critical and the private key's integrity is already assured.
   *
   * @example
   * ```ts
   * const eddsa = new EdDsaAlgorithm();
   * const privateKey = { ... }; // A Jwk object representing a private key
   * const publicKey = await eddsa.getPublicKey({ key: privateKey });
   * ```
   *
   * @param params - The parameters for retrieving the public key properties.
   * @param params.key - The private key in JWK format.
   *
   * @returns A Promise that resolves to the public key in JWK format.
   */
  getPublicKey({ key }) {
    return __awaiter33(this, void 0, void 0, function* () {
      if (!isOkpPrivateJwk2(key))
        throw new TypeError("Invalid key provided. Must be an octet key pair (OKP) private key.");
      switch (key.crv) {
        case "Ed25519": {
          const publicKey = yield Ed255192.getPublicKey({ key });
          publicKey.alg = "EdDSA";
          return publicKey;
        }
        default: {
          throw new Error(`Unsupported curve: ${key.crv}`);
        }
      }
    });
  }
  /**
   * Generates an EdDSA signature of given data using a private key.
   *
   * @remarks
   * This method uses the signature algorithm determined by the given `algorithm` to sign the
   * provided data.
   *
   * The signature can later be verified by parties with access to the corresponding
   * public key, ensuring that the data has not been tampered with and was indeed signed by the
   * holder of the private key.
   *
   * @example
   * ```ts
   * const eddsa = new EdDsaAlgorithm();
   * const data = new TextEncoder().encode('Message');
   * const privateKey = { ... }; // A Jwk object representing a private key
   * const signature = await eddsa.sign({
   *   key: privateKey,
   *   data
   * });
   * ```
   *
   * @param params - The parameters for the signing operation.
   * @param params.key - The private key to use for signing, represented in JWK format.
   * @param params.data - The data to sign.
   *
   * @returns A Promise resolving to the digital signature as a `Uint8Array`.
   */
  sign({ key, data }) {
    return __awaiter33(this, void 0, void 0, function* () {
      if (!isOkpPrivateJwk2(key))
        throw new TypeError("Invalid key provided. Must be an octet key pair (OKP) private key.");
      switch (key.crv) {
        case "Ed25519": {
          return yield Ed255192.sign({ key, data });
        }
        default: {
          throw new Error(`Unsupported curve: ${key.crv}`);
        }
      }
    });
  }
  /**
   * Verifies an EdDSA signature associated with the provided data using the provided key.
   *
   * @remarks
   * This method uses the signature algorithm determined by the `crv` property of the provided key
   * to check the validity of a digital signature against the original data. It confirms whether the
   * signature was created by the holder of the corresponding private key and that the data has not
   * been tampered with.
   *s
   * @example
   * ```ts
   * const eddsa = new EdDsaAlgorithm();
   * const publicKey = { ... }; // Public key in JWK format corresponding to the private key that signed the data
   * const signature = new Uint8Array([...]); // Signature to verify
   * const data = new TextEncoder().encode('Message');
   * const isValid = await eddsa.verify({
   *   key: publicKey,
   *   signature,
   *   data
   * });
   * ```
   *
   * @param params - The parameters for the verification operation.
   * @param params.key - The key to use for verification.
   * @param params.signature - The signature to verify.
   * @param params.data - The data to verify.
   *
   * @returns A Promise resolving to a boolean indicating whether the signature is valid.
   */
  verify({ key, signature, data }) {
    return __awaiter33(this, void 0, void 0, function* () {
      if (!isOkpPublicJwk2(key))
        throw new TypeError("Invalid key provided. Must be an octet key pair (OKP) public key.");
      switch (key.crv) {
        case "Ed25519": {
          return yield Ed255192.verify({ key, signature, data });
        }
        default: {
          throw new Error(`Unsupported curve: ${key.crv}`);
        }
      }
    });
  }
};

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/local-key-manager.js
var __awaiter34 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var supportedAlgorithms2 = {
  "Ed25519": {
    implementation: EdDsaAlgorithm2,
    names: ["Ed25519"]
  },
  "secp256k1": {
    implementation: EcdsaAlgorithm2,
    names: ["ES256K", "secp256k1"]
  },
  "secp256r1": {
    implementation: EcdsaAlgorithm2,
    names: ["ES256", "secp256r1"]
  },
  "SHA-256": {
    implementation: Sha2Algorithm2,
    names: ["SHA-256"]
  }
};
var LocalKeyManager2 = class {
  constructor(params) {
    var _a;
    this._algorithmInstances = /* @__PURE__ */ new Map();
    this._keyStore = (_a = params === null || params === void 0 ? void 0 : params.keyStore) !== null && _a !== void 0 ? _a : new MemoryStore2();
  }
  /**
   * Generates a hash digest of the provided data.
   *
   * @remarks
   * A digest is the output of the hash function. It's a fixed-size string of bytes
   * that uniquely represents the data input into the hash function. The digest is often used for
   * data integrity checks, as any alteration in the input data results in a significantly
   * different digest.
   *
   * It takes the algorithm identifier of the hash function and data to digest as input and returns
   * the digest of the data.
   *
   * @example
   * ```ts
   * const keyManager = new LocalKeyManager();
   * const data = new Uint8Array([...]);
   * const digest = await keyManager.digest({ algorithm: 'SHA-256', data });
   * ```
   *
   * @param params - The parameters for the digest operation.
   * @param params.algorithm - The name of hash function to use.
   * @param params.data - The data to digest.
   *
   * @returns A Promise which will be fulfilled with the hash digest.
   */
  digest({ algorithm, data }) {
    return __awaiter34(this, void 0, void 0, function* () {
      const hasher = this.getAlgorithm({ algorithm });
      const hash = yield hasher.digest({ algorithm, data });
      return hash;
    });
  }
  /**
   * Exports a private key identified by the provided key URI from the local KMS.
   *
   * @remarks
   * This method retrieves the key from the key store and returns it. It is primarily used
   * for extracting keys for backup or transfer purposes.
   *
   * @example
   * ```ts
   * const keyManager = new LocalKeyManager();
   * const keyUri = await keyManager.generateKey({ algorithm: 'Ed25519' });
   * const privateKey = await keyManager.exportKey({ keyUri });
   * ```
   *
   * @param params - Parameters for exporting the key.
   * @param params.keyUri - The key URI identifying the key to export.
   *
   * @returns A Promise resolving to the JWK representation of the exported key.
   */
  exportKey({ keyUri }) {
    return __awaiter34(this, void 0, void 0, function* () {
      const privateKey = yield this.getPrivateKey({ keyUri });
      return privateKey;
    });
  }
  /**
   * Generates a new cryptographic key in the local KMS with the specified algorithm and returns a
   * unique key URI which can be used to reference the key in subsequent operations.
   *
   * @example
   * ```ts
   * const keyManager = new LocalKeyManager();
   * const keyUri = await keyManager.generateKey({ algorithm: 'Ed25519' });
   * console.log(keyUri); // Outputs the key URI
   * ```
   *
   * @param params - The parameters for key generation.
   * @param params.algorithm - The algorithm to use for key generation, defined in `SupportedAlgorithm`.
   *
   * @returns A Promise that resolves to the key URI, a unique identifier for the generated key.
   */
  generateKey({ algorithm }) {
    return __awaiter34(this, void 0, void 0, function* () {
      const keyGenerator = this.getAlgorithm({ algorithm });
      const key = yield keyGenerator.generateKey({ algorithm });
      if ((key === null || key === void 0 ? void 0 : key.kid) === void 0) {
        throw new Error("Generated key is missing a required property: kid");
      }
      const keyUri = `${KEY_URI_PREFIX_JWK2}${key.kid}`;
      yield this._keyStore.set(keyUri, key);
      return keyUri;
    });
  }
  /**
   * Computes the Key URI for a given public JWK (JSON Web Key).
   *
   * @remarks
   * This method generates a {@link https://datatracker.ietf.org/doc/html/rfc3986 | URI}
   * (Uniform Resource Identifier) for the given JWK, which uniquely identifies the key across all
   * `CryptoApi` implementations. The key URI is constructed by appending the
   * {@link https://datatracker.ietf.org/doc/html/rfc7638 | JWK thumbprint} to the prefix
   * `urn:jwk:`. The JWK thumbprint is deterministically computed from the JWK and is consistent
   * regardless of property order or optional property inclusion in the JWK. This ensures that the
   * same key material represented as a JWK will always yield the same thumbprint, and therefore,
   * the same key URI.
   *
   * @example
   * ```ts
   * const keyManager = new LocalKeyManager();
   * const keyUri = await keyManager.generateKey({ algorithm: 'Ed25519' });
   * const publicKey = await keyManager.getPublicKey({ keyUri });
   * const keyUriFromPublicKey = await keyManager.getKeyUri({ key: publicKey });
   * console.log(keyUri === keyUriFromPublicKey); // Outputs `true`
   * ```
   *
   * @param params - The parameters for getting the key URI.
   * @param params.key - The JWK for which to compute the key URI.
   *
   * @returns A Promise that resolves to the key URI as a string.
   */
  getKeyUri({ key }) {
    return __awaiter34(this, void 0, void 0, function* () {
      const jwkThumbprint = yield computeJwkThumbprint2({ jwk: key });
      const keyUri = `${KEY_URI_PREFIX_JWK2}${jwkThumbprint}`;
      return keyUri;
    });
  }
  /**
   * Retrieves the public key associated with a previously generated private key, identified by
   * the provided key URI.
   *
   * @example
   * ```ts
   * const keyManager = new LocalKeyManager();
   * const keyUri = await keyManager.generateKey({ algorithm: 'Ed25519' });
   * const publicKey = await keyManager.getPublicKey({ keyUri });
   * ```
   *
   * @param params - The parameters for retrieving the public key.
   * @param params.keyUri - The key URI of the private key to retrieve the public key for.
   *
   * @returns A Promise that resolves to the public key in JWK format.
   */
  getPublicKey({ keyUri }) {
    return __awaiter34(this, void 0, void 0, function* () {
      const privateKey = yield this.getPrivateKey({ keyUri });
      const algorithm = this.getAlgorithmName({ key: privateKey });
      const keyGenerator = this.getAlgorithm({ algorithm });
      const publicKey = yield keyGenerator.getPublicKey({ key: privateKey });
      return publicKey;
    });
  }
  /**
   * Imports a private key into the local KMS.
   *
   * @remarks
   * This method stores the provided JWK in the key store, making it available for subsequent
   * cryptographic operations. It is particularly useful for initializing the KMS with pre-existing
   * keys or for restoring keys from backups.
   *
   * Note that, if defined, the `kid` (key ID) property of the JWK is used as the key URI for the
   * imported key. If the `kid` property is not provided, the key URI is computed from the JWK
   * thumbprint of the key.
   *
   * @example
   * ```ts
   * const keyManager = new LocalKeyManager();
   * const privateKey = { ... } // A private key in JWK format
   * const keyUri = await keyManager.importKey({ key: privateKey });
   * ```
   *
   * @param params - Parameters for importing the key.
   * @param params.key - The private key to import to in JWK format.
   *
   * @returns A Promise resolving to the key URI, uniquely identifying the imported key.
   */
  importKey({ key }) {
    var _a;
    return __awaiter34(this, void 0, void 0, function* () {
      if (!isPrivateJwk2(key))
        throw new TypeError("Invalid key provided. Must be a private key in JWK format.");
      const privateKey = structuredClone(key);
      (_a = privateKey.kid) !== null && _a !== void 0 ? _a : privateKey.kid = yield computeJwkThumbprint2({ jwk: privateKey });
      const keyUri = yield this.getKeyUri({ key: privateKey });
      yield this._keyStore.set(keyUri, privateKey);
      return keyUri;
    });
  }
  /**
   * Signs the provided data using the private key identified by the provided key URI.
   *
   * @remarks
   * This method uses the signature algorithm determined by the `alg` and/or `crv` properties of the
   * private key identified by the provided key URI to sign the provided data. The signature can
   * later be verified by parties with access to the corresponding public key, ensuring that the
   * data has not been tampered with and was indeed signed by the holder of the private key.
   *
   * @example
   * ```ts
   * const keyManager = new LocalKeyManager();
   * const keyUri = await keyManager.generateKey({ algorithm: 'Ed25519' });
   * const data = new TextEncoder().encode('Message to sign');
   * const signature = await keyManager.sign({ keyUri, data });
   * ```
   *
   * @param params - The parameters for the signing operation.
   * @param params.keyUri - The key URI of the private key to use for signing.
   * @param params.data - The data to sign.
   *
   * @returns A Promise resolving to the digital signature as a `Uint8Array`.
   */
  sign({ keyUri, data }) {
    return __awaiter34(this, void 0, void 0, function* () {
      const privateKey = yield this.getPrivateKey({ keyUri });
      const algorithm = this.getAlgorithmName({ key: privateKey });
      const signer = this.getAlgorithm({ algorithm });
      const signature = signer.sign({ data, key: privateKey });
      return signature;
    });
  }
  /**
   * Verifies a digital signature associated the provided data using the provided key.
   *
   * @remarks
   * This method uses the signature algorithm determined by the `alg` and/or `crv` properties of the
   * provided key to check the validity of a digital signature against the original data. It
   * confirms whether the signature was created by the holder of the corresponding private key and
   * that the data has not been tampered with.
   *
   * @example
   * ```ts
   * const keyManager = new LocalKeyManager();
   * const keyUri = await keyManager.generateKey({ algorithm: 'Ed25519' });
   * const data = new TextEncoder().encode('Message to sign');
   * const signature = await keyManager.sign({ keyUri, data });
   * const isSignatureValid = await keyManager.verify({ keyUri, data, signature });
   * ```
   *
   * @param params - The parameters for the verification operation.
   * @param params.key - The key to use for verification.
   * @param params.signature - The signature to verify.
   * @param params.data - The data to verify.
   *
   * @returns A Promise resolving to a boolean indicating whether the signature is valid.
   */
  verify({ key, signature, data }) {
    return __awaiter34(this, void 0, void 0, function* () {
      const algorithm = this.getAlgorithmName({ key });
      const signer = this.getAlgorithm({ algorithm });
      const isSignatureValid = signer.verify({ key, signature, data });
      return isSignatureValid;
    });
  }
  /**
   * Retrieves an algorithm implementation instance based on the provided algorithm name.
   *
   * @remarks
   * This method checks if the requested algorithm is supported and returns a cached instance
   * if available. If an instance does not exist, it creates and caches a new one. This approach
   * optimizes performance by reusing algorithm instances across cryptographic operations.
   *
   * @example
   * ```ts
   * const signer = this.getAlgorithm({ algorithm: 'Ed25519' });
   * ```
   *
   * @param params - The parameters for retrieving the algorithm implementation.
   * @param params.algorithm - The name of the algorithm to retrieve.
   *
   * @returns An instance of the requested algorithm implementation.
   *
   * @throws Error if the requested algorithm is not supported.
   */
  getAlgorithm({ algorithm }) {
    var _a;
    const AlgorithmImplementation = (_a = supportedAlgorithms2[algorithm]) === null || _a === void 0 ? void 0 : _a["implementation"];
    if (!AlgorithmImplementation) {
      throw new Error(`Algorithm not supported: ${algorithm}`);
    }
    if (!this._algorithmInstances.has(AlgorithmImplementation)) {
      this._algorithmInstances.set(AlgorithmImplementation, new AlgorithmImplementation());
    }
    return this._algorithmInstances.get(AlgorithmImplementation);
  }
  /**
   * Determines the name of the algorithm based on the key's properties.
   *
   * @remarks
   * This method facilitates the identification of the correct algorithm for cryptographic
   * operations based on the `alg` or `crv` properties of a {@link Jwk | JWK}.
   *
   * @example
   * ```ts
   * const publicKey = { ... }; // Public key in JWK format
   * const algorithm = this.getAlgorithmName({ key: publicKey });
   * ```
   *
   * @param params - The parameters for determining the algorithm name.
   * @param params.key - A JWK containing the `alg` or `crv` properties.
   *
   * @returns The name of the algorithm associated with the key.
   *
   * @throws Error if the algorithm cannot be determined from the provided input.
   */
  getAlgorithmName({ key }) {
    const algProperty = key.alg;
    const crvProperty = key.crv;
    for (const algName in supportedAlgorithms2) {
      const algorithmInfo = supportedAlgorithms2[algName];
      if (algProperty && algorithmInfo.names.includes(algProperty)) {
        return algName;
      } else if (crvProperty && algorithmInfo.names.includes(crvProperty)) {
        return algName;
      }
    }
    throw new Error(`Unable to determine algorithm based on provided input: alg=${algProperty}, crv=${crvProperty}`);
  }
  /**
   * Retrieves a private key from the key store based on the provided key URI.
   *
   * @example
   * ```ts
   * const privateKey = this.getPrivateKey({ keyUri: 'urn:jwk:...' });
   * ```
   *
   * @param params - Parameters for retrieving the private key.
   * @param params.keyUri - The key URI identifying the private key to retrieve.
   *
   * @returns A Promise resolving to the JWK representation of the private key.
   *
   * @throws Error if the key is not found in the key store.
   */
  getPrivateKey({ keyUri }) {
    return __awaiter34(this, void 0, void 0, function* () {
      const privateKey = yield this._keyStore.get(keyUri);
      if (!privateKey) {
        throw new Error(`Key not found: ${keyUri}`);
      }
      return privateKey;
    });
  }
};

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/utils.js
var utils_exports4 = {};
__export(utils_exports4, {
  checkRequiredProperty: () => checkRequiredProperty2,
  checkValidProperty: () => checkValidProperty2,
  getJoseSignatureAlgorithmFromPublicKey: () => getJoseSignatureAlgorithmFromPublicKey2,
  isWebCryptoSupported: () => isWebCryptoSupported2,
  randomBytes: () => randomBytes3,
  randomUuid: () => randomUuid2
});
var import_dist113 = __toESM(require_dist(), 1);
function checkRequiredProperty2(params) {
  if (!params || params.property === void 0 || params.inObject === void 0) {
    throw new TypeError(`One or more required parameters missing: 'property, properties'`);
  }
  const { property, inObject } = params;
  if (!(property in inObject)) {
    throw new TypeError(`Required parameter missing: '${property}'`);
  }
}
function checkValidProperty2(params) {
  if (!params || params.property === void 0 || params.allowedProperties === void 0) {
    throw new TypeError(`One or more required parameters missing: 'property, allowedProperties'`);
  }
  const { property, allowedProperties } = params;
  if (Array.isArray(allowedProperties) && !allowedProperties.includes(property) || allowedProperties instanceof Set && !allowedProperties.has(property) || allowedProperties instanceof Map && !allowedProperties.has(property)) {
    const validProperties = Array.from(allowedProperties instanceof Map ? allowedProperties.keys() : allowedProperties).join(", ");
    throw new TypeError(`Out of range: '${property}'. Must be one of '${validProperties}'`);
  }
}
function getJoseSignatureAlgorithmFromPublicKey2(publicKey) {
  const curveToJoseAlgorithm = {
    "Ed25519": "EdDSA",
    "P-256": "ES256",
    "P-384": "ES384",
    "P-521": "ES512",
    "secp256k1": "ES256K"
  };
  if (publicKey.alg && Object.values(curveToJoseAlgorithm).includes(publicKey.alg)) {
    return publicKey.alg;
  }
  if (publicKey.crv && Object.keys(curveToJoseAlgorithm).includes(publicKey.crv)) {
    return curveToJoseAlgorithm[publicKey.crv];
  }
  throw new Error(`Unable to determine algorithm based on provided input: alg=${publicKey.alg}, crv=${publicKey.crv}. Supported 'alg' values: ${Object.values(curveToJoseAlgorithm).join(", ")}. Supported 'crv' values: ${Object.keys(curveToJoseAlgorithm).join(", ")}.`);
}
function isWebCryptoSupported2() {
  if (globalThis.crypto && globalThis.crypto.subtle) {
    return true;
  } else {
    return false;
  }
}
function randomBytes3(bytesLength) {
  return randomBytes(bytesLength);
}
function randomUuid2() {
  const uuid = crypto2.randomUUID();
  return uuid;
}

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/algorithms/aes-ctr.js
var import_dist115 = __toESM(require_dist(), 1);

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/primitives/aes-ctr.js
var import_dist114 = __toESM(require_dist(), 1);

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/algorithms/aes-gcm.js
var import_dist117 = __toESM(require_dist(), 1);

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/primitives/aes-gcm.js
var import_dist116 = __toESM(require_dist(), 1);

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/jose/jwe.js
var import_dist118 = __toESM(require_dist(), 1);

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/jose/jws.js
var import_dist119 = __toESM(require_dist(), 1);

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/jose/jwt.js
var import_dist120 = __toESM(require_dist(), 1);

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/primitives/concat-kdf.js
var import_dist121 = __toESM(require_dist(), 1);

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/primitives/pbkdf2.js
var import_dist122 = __toESM(require_dist(), 1);

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/primitives/x25519.js
var import_dist123 = __toESM(require_dist(), 1);
var __awaiter35 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest9 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var X255192 = class _X25519 {
  /**
   * Converts a raw private key in bytes to its corresponding JSON Web Key (JWK) format.
   *
   * @remarks
   * This method accepts a private key as a byte array (Uint8Array) for the X25519 elliptic curve
   * and transforms it into a JWK object. The process involves first deriving the public key from
   * the private key, then encoding both the private and public keys into base64url format.
   *
   * The resulting JWK object includes the following properties:
   * - `kty`: Key Type, set to 'OKP' for Octet Key Pair.
   * - `crv`: Curve Name, set to 'X25519'.
   * - `d`: The private key component, base64url-encoded.
   * - `x`: The derived public key, base64url-encoded.
   *
   * This method is useful for converting raw public keys into a standardized
   * JSON format, facilitating their use in cryptographic operations and making
   * them easy to share and store.
   *
   * @example
   * ```ts
   * const privateKeyBytes = new Uint8Array([...]); // Replace with actual private key bytes
   * const privateKey = await X25519.bytesToPrivateKey({ privateKeyBytes });
   * ```
   *
   * @param params - The parameters for the private key conversion.
   * @param params.privateKeyBytes - The raw private key as a Uint8Array.
   *
   * @returns A Promise that resolves to the private key in JWK format.
   */
  static bytesToPrivateKey({ privateKeyBytes }) {
    return __awaiter35(this, void 0, void 0, function* () {
      const publicKeyBytes = x25519.getPublicKey(privateKeyBytes);
      const privateKey = {
        kty: "OKP",
        crv: "X25519",
        d: Convert2.uint8Array(privateKeyBytes).toBase64Url(),
        x: Convert2.uint8Array(publicKeyBytes).toBase64Url()
      };
      privateKey.kid = yield computeJwkThumbprint2({ jwk: privateKey });
      return privateKey;
    });
  }
  /**
   * Converts a raw public key in bytes to its corresponding JSON Web Key (JWK) format.
   *
   * @remarks
   * This method accepts a public key as a byte array (Uint8Array) for the X25519 elliptic curve
   * and transforms it into a JWK object. The conversion process involves encoding the public
   * key bytes into base64url format.
   *
   * The resulting JWK object includes the following properties:
   * - `kty`: Key Type, set to 'OKP' for Octet Key Pair.
   * - `crv`: Curve Name, set to 'X25519'.
   * - `x`: The public key, base64url-encoded.
   *
   * This method is useful for converting raw public keys into a standardized
   * JSON format, facilitating their use in cryptographic operations and making
   * them easy to share and store.
   *
   * @example
   * ```ts
   * const publicKeyBytes = new Uint8Array([...]); // Replace with actual public key bytes
   * const publicKey = await X25519.bytesToPublicKey({ publicKeyBytes });
   * ```
   *
   * @param params - The parameters for the public key conversion.
   * @param params.publicKeyBytes - The raw public key as a Uint8Array.
   *
   * @returns A Promise that resolves to the public key in JWK format.
   */
  static bytesToPublicKey({ publicKeyBytes }) {
    return __awaiter35(this, void 0, void 0, function* () {
      const publicKey = {
        kty: "OKP",
        crv: "X25519",
        x: Convert2.uint8Array(publicKeyBytes).toBase64Url()
      };
      publicKey.kid = yield computeJwkThumbprint2({ jwk: publicKey });
      return publicKey;
    });
  }
  /**
   * Derives the public key in JWK format from a given X25519 private key.
   *
   * @remarks
   * This method takes a private key in JWK format and derives its corresponding public key,
   * also in JWK format.  The derivation process involves converting the private key to a
   * raw byte array and then computing the corresponding public key on the Curve25519 curve.
   * The public key is then encoded into base64url format to construct a JWK representation.
   *
   * The process ensures that the derived public key correctly corresponds to the given private key,
   * adhering to the Curve25519 elliptic curve in Twisted Edwards form standards. This method is
   * useful in cryptographic operations where a public key is needed for operations like signature
   * verification, but only the private key is available.
   *
   * @example
   * ```ts
   * const privateKey = { ... }; // A Jwk object representing an X25519 private key
   * const publicKey = await X25519.computePublicKey({ key: privateKey });
   * ```
   *
   * @param params - The parameters for the public key derivation.
   * @param params.key - The private key in JWK format from which to derive the public key.
   *
   * @returns A Promise that resolves to the derived public key in JWK format.
   */
  static computePublicKey({ key }) {
    return __awaiter35(this, void 0, void 0, function* () {
      const privateKeyBytes = yield _X25519.privateKeyToBytes({ privateKey: key });
      const publicKeyBytes = x25519.getPublicKey(privateKeyBytes);
      const publicKey = {
        kty: "OKP",
        crv: "X25519",
        x: Convert2.uint8Array(publicKeyBytes).toBase64Url()
      };
      publicKey.kid = yield computeJwkThumbprint2({ jwk: publicKey });
      return publicKey;
    });
  }
  /**
   * Generates an X25519 private key in JSON Web Key (JWK) format.
   *
   * @remarks
   * This method creates a new private key suitable for use with the X25519 elliptic curve.
   * The key generation process involves using cryptographically secure random number generation
   * to ensure the uniqueness and security of the key. The resulting private key adheres to the
   * JWK format making it compatible with common cryptographic standards and easy to use in various
   * cryptographic processes.
   *
   * The generated private key in JWK format includes the following components:
   * - `kty`: Key Type, set to 'OKP' for Octet Key Pair.
   * - `crv`: Curve Name, set to 'X25519'.
   * - `d`: The private key component, base64url-encoded.
   * - `x`: The derived public key, base64url-encoded.
   *
   * The key is returned in a format suitable for direct use in key agreement operations.
   *
   * @example
   * ```ts
   * const privateKey = await X25519.generateKey();
   * ```
   *
   * @returns A Promise that resolves to the generated private key in JWK format.
   */
  static generateKey() {
    return __awaiter35(this, void 0, void 0, function* () {
      const privateKeyBytes = x25519.utils.randomPrivateKey();
      const privateKey = yield _X25519.bytesToPrivateKey({ privateKeyBytes });
      privateKey.kid = yield computeJwkThumbprint2({ jwk: privateKey });
      return privateKey;
    });
  }
  /**
   * Retrieves the public key properties from a given private key in JWK format.
   *
   * @remarks
   * This method extracts the public key portion from an X25519 private key in JWK format. It does
   * so by removing the private key property 'd' and making a shallow copy, effectively yielding the
   * public key. The method sets the 'kid' (key ID) property using the JWK thumbprint if it is not
   * already defined. This approach is used under the assumption that a private key in JWK format
   * always contains the corresponding public key properties.
   *
   * Note: This method offers a significant performance advantage, being about 500 times faster
   * than `computePublicKey()`. However, it does not mathematically validate the private key, nor
   * does it derive the public key from the private key. It simply extracts existing public key
   * properties from the private key object. This makes it suitable for scenarios where speed is
   * critical and the private key's integrity is already assured.
   *
   * @example
   * ```ts
   * const privateKey = { ... }; // A Jwk object representing an X25519 private key
   * const publicKey = await X25519.getPublicKey({ key: privateKey });
   * ```
   *
   * @param params - The parameters for retrieving the public key properties.
   * @param params.key - The private key in JWK format.
   *
   * @returns A Promise that resolves to the public key in JWK format.
   */
  static getPublicKey({ key }) {
    var _a;
    return __awaiter35(this, void 0, void 0, function* () {
      if (!(isOkpPrivateJwk2(key) && key.crv === "X25519")) {
        throw new Error(`X25519: The provided key is not an X25519 private JWK.`);
      }
      let { d } = key, publicKey = __rest9(key, ["d"]);
      (_a = publicKey.kid) !== null && _a !== void 0 ? _a : publicKey.kid = yield computeJwkThumbprint2({ jwk: publicKey });
      return publicKey;
    });
  }
  /**
   * Converts a private key from JSON Web Key (JWK) format to a raw byte array (Uint8Array).
   *
   * @remarks
   * This method accepts a private key in JWK format and extracts its raw byte representation.
   *
   * This method accepts a public key in JWK format and converts it into its raw binary
   * form. The conversion process involves decoding the 'd' parameter of the JWK
   * from base64url format into a byte array.
   *
   * This conversion is essential for operations that require the private key in its raw
   * binary form, such as certain low-level cryptographic operations or when interfacing
   * with systems and libraries that expect keys in a byte array format.
   *
   * @example
   * ```ts
   * const privateKey = { ... }; // An X25519 private key in JWK format
   * const privateKeyBytes = await X25519.privateKeyToBytes({ privateKey });
   * ```
   *
   * @param params - The parameters for the private key conversion.
   * @param params.privateKey - The private key in JWK format.
   *
   * @returns A Promise that resolves to the private key as a Uint8Array.
   */
  static privateKeyToBytes({ privateKey }) {
    return __awaiter35(this, void 0, void 0, function* () {
      if (!isOkpPrivateJwk2(privateKey)) {
        throw new Error(`X25519: The provided key is not a valid OKP private key.`);
      }
      const privateKeyBytes = Convert2.base64Url(privateKey.d).toUint8Array();
      return privateKeyBytes;
    });
  }
  /**
   * Converts a public key from JSON Web Key (JWK) format to a raw byte array (Uint8Array).
   *
   * @remarks
   * This method accepts a public key in JWK format and converts it into its raw binary form.
   * The conversion process involves decoding the 'x' parameter of the JWK (which represent the
   * x coordinate of the elliptic curve point) from base64url format into a byte array.
   *
   * This conversion is essential for operations that require the public key in its raw
   * binary form, such as certain low-level cryptographic operations or when interfacing
   * with systems and libraries that expect keys in a byte array format.
   *
   * @example
   * ```ts
   * const publicKey = { ... }; // An X25519 public key in JWK format
   * const publicKeyBytes = await X25519.publicKeyToBytes({ publicKey });
   * ```
   *
   * @param params - The parameters for the public key conversion.
   * @param params.publicKey - The public key in JWK format.
   *
   * @returns A Promise that resolves to the public key as a Uint8Array.
   */
  static publicKeyToBytes({ publicKey }) {
    return __awaiter35(this, void 0, void 0, function* () {
      if (!isOkpPublicJwk2(publicKey)) {
        throw new Error(`X25519: The provided key is not a valid OKP public key.`);
      }
      const publicKeyBytes = Convert2.base64Url(publicKey.x).toUint8Array();
      return publicKeyBytes;
    });
  }
  /**
   * Computes an RFC6090-compliant Elliptic Curve Diffie-Hellman (ECDH) shared secret
   * using secp256k1 private and public keys in JSON Web Key (JWK) format.
   *
   * @remarks
   * This method facilitates the ECDH key agreement protocol, which is a method of securely
   * deriving a shared secret between two parties based on their private and public keys.
   * It takes the private key of one party (privateKeyA) and the public key of another
   * party (publicKeyB) to compute a shared secret. The shared secret is derived from the
   * x-coordinate of the elliptic curve point resulting from the multiplication of the
   * public key with the private key.
   *
   * Note: When performing Elliptic Curve Diffie-Hellman (ECDH) key agreement,
   * the resulting shared secret is a point on the elliptic curve, which
   * consists of an x-coordinate and a y-coordinate. With a 256-bit curve like
   * secp256k1, each of these coordinates is 32 bytes (256 bits) long. However,
   * in the ECDH process, it's standard practice to use only the x-coordinate
   * of the shared secret point as the resulting shared key. This is because
   * the y-coordinate does not add to the entropy of the key, and both parties
   * can independently compute the x-coordinate.  Consquently, this implementation
   * omits the y-coordinate for simplicity and standard compliance.
   *
   * @example
   * ```ts
   * const privateKeyA = { ... }; // A Jwk object for party A
   * const publicKeyB = { ... }; // A PublicKeyJwk object for party B
   * const sharedSecret = await Secp256k1.sharedSecret({
   *   privateKeyA,
   *   publicKeyB
   * });
   * ```
   *
   * @param params - The parameters for the shared secret computation.
   * @param params.privateKeyA - The private key in JWK format of one party.
   * @param params.publicKeyB - The public key in JWK format of the other party.
   *
   * @returns A Promise that resolves to the computed shared secret as a Uint8Array.
   */
  static sharedSecret({ privateKeyA, publicKeyB }) {
    return __awaiter35(this, void 0, void 0, function* () {
      if ("x" in privateKeyA && "x" in publicKeyB && privateKeyA.x === publicKeyB.x) {
        throw new Error(`X25519: ECDH shared secret cannot be computed from a single key pair's public and private keys.`);
      }
      const privateKeyABytes = yield _X25519.privateKeyToBytes({ privateKey: privateKeyA });
      const publicKeyBBytes = yield _X25519.publicKeyToBytes({ publicKey: publicKeyB });
      const sharedSecret = x25519.getSharedSecret(privateKeyABytes, publicKeyBBytes);
      return sharedSecret;
    });
  }
};

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/primitives/xchacha20.js
var import_dist124 = __toESM(require_dist(), 1);

// node_modules/@tbdex/http-client/node_modules/@web5/crypto/dist/esm/primitives/xchacha20-poly1305.js
var import_dist125 = __toESM(require_dist(), 1);

// node_modules/@tbdex/http-client/node_modules/@web5/dids/dist/esm/utils.js
var utils_exports5 = {};
__export(utils_exports5, {
  extractDidFragment: () => extractDidFragment2,
  getServices: () => getServices2,
  getVerificationMethodByKey: () => getVerificationMethodByKey2,
  getVerificationMethodTypes: () => getVerificationMethodTypes2,
  getVerificationMethods: () => getVerificationMethods2,
  getVerificationRelationshipsById: () => getVerificationRelationshipsById2,
  isDidService: () => isDidService2,
  isDidVerificationMethod: () => isDidVerificationMethod2,
  isDwnDidService: () => isDwnDidService2,
  keyBytesToMultibaseId: () => keyBytesToMultibaseId2,
  multibaseIdToKeyBytes: () => multibaseIdToKeyBytes2
});
var import_dist127 = __toESM(require_dist(), 1);
var __awaiter36 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function extractDidFragment2(input) {
  if (typeof input !== "string")
    return void 0;
  if (input.length === 0)
    return void 0;
  return input.split("#").pop();
}
function getServices2({ didDocument, id, type }) {
  var _a, _b;
  return (_b = (_a = didDocument === null || didDocument === void 0 ? void 0 : didDocument.service) === null || _a === void 0 ? void 0 : _a.filter((service) => {
    if (id && service.id !== id)
      return false;
    if (type && service.type !== type)
      return false;
    return true;
  })) !== null && _b !== void 0 ? _b : [];
}
function getVerificationMethodByKey2({ didDocument, publicKeyJwk, publicKeyMultibase }) {
  return __awaiter36(this, void 0, void 0, function* () {
    const verificationMethods = getVerificationMethods2({ didDocument });
    for (let method of verificationMethods) {
      if (publicKeyJwk && method.publicKeyJwk) {
        const publicKeyThumbprint = yield computeJwkThumbprint2({ jwk: publicKeyJwk });
        if (publicKeyThumbprint === (yield computeJwkThumbprint2({ jwk: method.publicKeyJwk }))) {
          return method;
        }
      } else if (publicKeyMultibase && method.publicKeyMultibase) {
        if (publicKeyMultibase === method.publicKeyMultibase) {
          return method;
        }
      }
    }
    return null;
  });
}
function getVerificationMethods2({ didDocument }) {
  var _a, _b;
  if (!didDocument)
    throw new TypeError(`Required parameter missing: 'didDocument'`);
  const verificationMethods = [];
  verificationMethods.push(...(_b = (_a = didDocument.verificationMethod) === null || _a === void 0 ? void 0 : _a.filter(isDidVerificationMethod2)) !== null && _b !== void 0 ? _b : []);
  Object.keys(DidVerificationRelationship2).forEach((relationship) => {
    var _a2, _b2;
    verificationMethods.push(...(_b2 = (_a2 = didDocument[relationship]) === null || _a2 === void 0 ? void 0 : _a2.filter(isDidVerificationMethod2)) !== null && _b2 !== void 0 ? _b2 : []);
  });
  return verificationMethods;
}
function getVerificationMethodTypes2({ didDocument }) {
  const verificationMethods = getVerificationMethods2({ didDocument });
  const types = verificationMethods.map((method) => method.type);
  return [...new Set(types)];
}
function getVerificationRelationshipsById2({ didDocument, methodId }) {
  const relationships = [];
  Object.keys(DidVerificationRelationship2).forEach((relationship) => {
    if (Array.isArray(didDocument[relationship])) {
      const relationshipMethods = didDocument[relationship];
      const methodIdFragment = extractDidFragment2(methodId);
      const containsMethodId = relationshipMethods.some((method) => {
        const isByReferenceMatch = extractDidFragment2(method) === methodIdFragment;
        const isEmbeddedMethodMatch = isDidVerificationMethod2(method) && extractDidFragment2(method.id) === methodIdFragment;
        return isByReferenceMatch || isEmbeddedMethodMatch;
      });
      if (containsMethodId) {
        relationships.push(relationship);
      }
    }
  });
  return relationships;
}
function isDidService2(obj) {
  if (!obj || typeof obj !== "object" || obj === null)
    return false;
  return "id" in obj && "type" in obj && "serviceEndpoint" in obj;
}
function isDwnDidService2(obj) {
  if (!isDidService2(obj))
    return false;
  if (obj.type !== "DecentralizedWebNode")
    return false;
  if (!("enc" in obj && "sig" in obj))
    return false;
  const isStringOrStringArray = (prop) => typeof prop === "string" || Array.isArray(prop) && prop.every((item) => typeof item === "string");
  return isStringOrStringArray(obj.enc) && isStringOrStringArray(obj.sig);
}
function isDidVerificationMethod2(obj) {
  if (!obj || typeof obj !== "object" || obj === null)
    return false;
  if (!("id" in obj && "type" in obj && "controller" in obj))
    return false;
  if (typeof obj.id !== "string")
    return false;
  if (typeof obj.type !== "string")
    return false;
  if (typeof obj.controller !== "string")
    return false;
  return true;
}
function keyBytesToMultibaseId2({ keyBytes, multicodecCode, multicodecName }) {
  const prefixedKey = Multicodec2.addPrefix({
    code: multicodecCode,
    data: keyBytes,
    name: multicodecName
  });
  const prefixedKeyB58 = Convert2.uint8Array(prefixedKey).toBase58Btc();
  const multibaseKeyId = Convert2.base58Btc(prefixedKeyB58).toMultibase();
  return multibaseKeyId;
}
function multibaseIdToKeyBytes2({ multibaseKeyId }) {
  try {
    const prefixedKeyB58 = Convert2.multibase(multibaseKeyId).toBase58Btc();
    const prefixedKey = Convert2.base58Btc(prefixedKeyB58).toUint8Array();
    const { code, data, name } = Multicodec2.removePrefix({ prefixedData: prefixedKey });
    return { keyBytes: data, multicodecCode: code, multicodecName: name };
  } catch (error) {
    throw new DidError2(DidErrorCode2.InvalidDid, `Invalid multibase identifier: ${multibaseKeyId}`);
  }
}

// node_modules/@tbdex/http-client/node_modules/@web5/dids/dist/esm/bearer-did.js
var __awaiter37 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var BearerDid2 = class _BearerDid {
  constructor({ uri, document, metadata, keyManager: keyManager2 }) {
    this.uri = uri;
    this.document = document;
    this.metadata = metadata;
    this.keyManager = keyManager2;
  }
  /**
   * Converts a `BearerDid` object to a portable format containing the URI and verification methods
   * associated with the DID.
   *
   * This method is useful when you need to represent the key material and metadata associated with
   * a DID in format that can be used independently of the specific DID method implementation. It
   * extracts both public and private keys from the DID's key manager and organizes them into a
   * `PortableDid` structure.
   *
   * @remarks
   * If the DID's key manager does not allow private keys to be exported, the `PortableDid` returned
   * will not contain a `privateKeys` property. This enables the importing and exporting DIDs that
   * use the same underlying KMS even if the KMS does not support exporting private keys. Examples
   * include hardware security modules (HSMs) and cloud-based KMS services like AWS KMS.
   *
   * If the DID's key manager does support exporting private keys, the resulting `PortableDid` will
   * include a `privateKeys` property which contains the same number of entries as there are
   * verification methods as the DID document, each with its associated private key and the
   * purpose(s) for which the key can be used (e.g., `authentication`, `assertionMethod`, etc.).
   *
   * @example
   * ```ts
   * // Assuming `did` is an instance of BearerDid
   * const portableDid = await did.export();
   * // portableDid now contains the DID URI, document, metadata, and optionally, private keys.
   * ```
   *
   * @returns A `PortableDid` containing the URI, DID document, metadata, and optionally private
   *          keys associated with the `BearerDid`.
   * @throws An error if the DID document does not contain any verification methods or the keys for
   *         any verification method are missing in the key manager.
   */
  export() {
    return __awaiter37(this, void 0, void 0, function* () {
      if (!(Array.isArray(this.document.verificationMethod) && this.document.verificationMethod.length > 0)) {
        throw new Error(`DID document for '${this.uri}' is missing verification methods`);
      }
      let portableDid = {
        uri: this.uri,
        document: this.document,
        metadata: this.metadata
      };
      if ("exportKey" in this.keyManager && typeof this.keyManager.exportKey === "function") {
        const privateKeys = [];
        for (let vm of this.document.verificationMethod) {
          if (!vm.publicKeyJwk) {
            throw new Error(`Verification method '${vm.id}' does not contain a public key in JWK format`);
          }
          const keyUri = yield this.keyManager.getKeyUri({ key: vm.publicKeyJwk });
          const privateKey = yield this.keyManager.exportKey({ keyUri });
          privateKeys.push(Object.assign({}, privateKey));
        }
        portableDid.privateKeys = privateKeys;
      }
      return portableDid;
    });
  }
  /**
   * Return a {@link Signer} that can be used to sign messages, credentials, or arbitrary data.
   *
   * If given, the `methodId` parameter is used to select a key from the verification methods
   * present in the DID Document.
   *
   * If `methodID` is not given, the first verification method intended for signing claims is used.
   *
   * @param params - The parameters for the `getSigner` operation.
   * @param params.methodId - ID of the verification method key that will be used for sign and
   *                          verify operations. Optional.
   * @returns An instantiated {@link Signer} that can be used to sign and verify data.
   */
  getSigner(params) {
    var _a;
    return __awaiter37(this, void 0, void 0, function* () {
      const verificationMethod = (_a = this.document.verificationMethod) === null || _a === void 0 ? void 0 : _a.find((vm) => {
        var _a2, _b;
        return extractDidFragment2(vm.id) === ((_a2 = extractDidFragment2(params === null || params === void 0 ? void 0 : params.methodId)) !== null && _a2 !== void 0 ? _a2 : extractDidFragment2((_b = this.document.assertionMethod) === null || _b === void 0 ? void 0 : _b[0]));
      });
      if (!(verificationMethod && verificationMethod.publicKeyJwk)) {
        throw new DidError2(DidErrorCode2.InternalError, "A verification method intended for signing could not be determined from the DID Document");
      }
      const keyUri = yield this.keyManager.getKeyUri({ key: verificationMethod.publicKeyJwk });
      const publicKey = yield this.keyManager.getPublicKey({ keyUri });
      const keyManager2 = this.keyManager;
      const algorithm = utils_exports4.getJoseSignatureAlgorithmFromPublicKey(publicKey);
      return {
        algorithm,
        keyId: verificationMethod.id,
        sign({ data }) {
          return __awaiter37(this, void 0, void 0, function* () {
            const signature = yield keyManager2.sign({ data, keyUri });
            return signature;
          });
        },
        verify({ data, signature }) {
          return __awaiter37(this, void 0, void 0, function* () {
            const isValid3 = yield keyManager2.verify({ data, key: publicKey, signature });
            return isValid3;
          });
        }
      };
    });
  }
  /**
   * Instantiates a {@link BearerDid} object from a given {@link PortableDid}.
   *
   * This method allows for the creation of a `BearerDid` object using a previously created DID's
   * key material, DID document, and metadata.
   *
   * @example
   * ```ts
   * // Export an existing BearerDid to PortableDid format.
   * const portableDid = await did.export();
   * // Reconstruct a BearerDid object from the PortableDid.
   * const did = await BearerDid.import({ portableDid });
   * ```
   *
   * @param params - The parameters for the import operation.
   * @param params.portableDid - The PortableDid object to import.
   * @param params.keyManager - Optionally specify an external Key Management System (KMS) used to
   *                            generate keys and sign data. If not given, a new
   *                            {@link LocalKeyManager} instance will be created and
   *                            used.
   * @returns A Promise resolving to a `BearerDid` object representing the DID formed from the
   *          provided PortableDid.
   * @throws An error if the PortableDid document does not contain any verification methods or the
   *         keys for any verification method are missing in the key manager.
   */
  static import({ portableDid, keyManager: keyManager2 = new LocalKeyManager2() }) {
    var _a;
    return __awaiter37(this, void 0, void 0, function* () {
      const verificationMethods = getVerificationMethods2({ didDocument: portableDid.document });
      if (verificationMethods.length === 0) {
        throw new DidError2(DidErrorCode2.InvalidDidDocument, `At least one verification method is required but 0 were given`);
      }
      for (let key of (_a = portableDid.privateKeys) !== null && _a !== void 0 ? _a : []) {
        yield keyManager2.importKey({ key });
      }
      for (let vm of verificationMethods) {
        if (!vm.publicKeyJwk) {
          throw new Error(`Verification method '${vm.id}' does not contain a public key in JWK format`);
        }
        const keyUri = yield keyManager2.getKeyUri({ key: vm.publicKeyJwk });
        yield keyManager2.getPublicKey({ keyUri });
      }
      const did = new _BearerDid({
        uri: portableDid.uri,
        document: portableDid.document,
        metadata: portableDid.metadata,
        keyManager: keyManager2
      });
      return did;
    });
  }
};

// node_modules/@tbdex/http-client/node_modules/@web5/dids/dist/esm/methods/did-dht.js
var import_dist130 = __toESM(require_dist(), 1);

// node_modules/@tbdex/http-client/node_modules/@web5/dids/dist/esm/methods/did-method.js
var import_dist129 = __toESM(require_dist(), 1);
var __awaiter38 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DidMethod2 = class {
  /**
   * MUST be implemented by all DID method implementations that extend {@link DidMethod}.
   *
   * Given the W3C DID Document of a DID, return the verification method that will be used for
   * signing messages and credentials. If given, the `methodId` parameter is used to select the
   * verification method. If not given, each DID method implementation will select a default
   * verification method from the DID Document.
   *
   * @param _params - The parameters for the `getSigningMethod` operation.
   * @param _params.didDocument - DID Document to get the verification method from.
   * @param _params.methodId - ID of the verification method to use for signing.
   * @returns Verification method to use for signing.
   */
  static getSigningMethod(_params) {
    return __awaiter38(this, void 0, void 0, function* () {
      throw new Error(`Not implemented: Classes extending DidMethod must implement getSigningMethod()`);
    });
  }
  /**
   * MUST be implemented by all DID method implementations that extend {@link DidMethod}.
   *
   * Resolves a DID URI to a DID Document.
   *
   * @param _didUri - The DID to be resolved.
   * @param _options - Optional parameters for resolving the DID.
   * @returns A Promise resolving to a {@link DidResolutionResult} object representing the result of the resolution.
   */
  static resolve(_didUri, _options) {
    return __awaiter38(this, void 0, void 0, function* () {
      throw new Error(`Not implemented: Classes extending DidMethod must implement resolve()`);
    });
  }
};

// node_modules/@tbdex/http-client/node_modules/@web5/dids/dist/esm/methods/did-dht.js
var __awaiter39 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest10 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var DEFAULT_GATEWAY_URI3 = "https://diddht.tbddev.org";
var DID_DHT_SPECIFICATION_VERSION2 = 0;
var DNS_RECORD_TTL2 = 7200;
var PROPERTY_SEPARATOR2 = ";";
var VALUE_SEPARATOR2 = ",";
var DidDhtRegisteredDidType2;
(function(DidDhtRegisteredDidType3) {
  DidDhtRegisteredDidType3[DidDhtRegisteredDidType3["Discoverable"] = 0] = "Discoverable";
  DidDhtRegisteredDidType3[DidDhtRegisteredDidType3["Organization"] = 1] = "Organization";
  DidDhtRegisteredDidType3[DidDhtRegisteredDidType3["Government"] = 2] = "Government";
  DidDhtRegisteredDidType3[DidDhtRegisteredDidType3["Corporation"] = 3] = "Corporation";
  DidDhtRegisteredDidType3[DidDhtRegisteredDidType3["LocalBusiness"] = 4] = "LocalBusiness";
  DidDhtRegisteredDidType3[DidDhtRegisteredDidType3["SoftwarePackage"] = 5] = "SoftwarePackage";
  DidDhtRegisteredDidType3[DidDhtRegisteredDidType3["WebApp"] = 6] = "WebApp";
  DidDhtRegisteredDidType3[DidDhtRegisteredDidType3["FinancialInstitution"] = 7] = "FinancialInstitution";
})(DidDhtRegisteredDidType2 || (DidDhtRegisteredDidType2 = {}));
var DidDhtRegisteredKeyType2;
(function(DidDhtRegisteredKeyType3) {
  DidDhtRegisteredKeyType3[DidDhtRegisteredKeyType3["Ed25519"] = 0] = "Ed25519";
  DidDhtRegisteredKeyType3[DidDhtRegisteredKeyType3["secp256k1"] = 1] = "secp256k1";
  DidDhtRegisteredKeyType3[DidDhtRegisteredKeyType3["secp256r1"] = 2] = "secp256r1";
})(DidDhtRegisteredKeyType2 || (DidDhtRegisteredKeyType2 = {}));
var DidDhtVerificationRelationship2;
(function(DidDhtVerificationRelationship3) {
  DidDhtVerificationRelationship3["authentication"] = "auth";
  DidDhtVerificationRelationship3["assertionMethod"] = "asm";
  DidDhtVerificationRelationship3["capabilityDelegation"] = "del";
  DidDhtVerificationRelationship3["capabilityInvocation"] = "inv";
  DidDhtVerificationRelationship3["keyAgreement"] = "agm";
})(DidDhtVerificationRelationship2 || (DidDhtVerificationRelationship2 = {}));
var AlgorithmToKeyTypeMap4 = {
  Ed25519: DidDhtRegisteredKeyType2.Ed25519,
  ES256K: DidDhtRegisteredKeyType2.secp256k1,
  ES256: DidDhtRegisteredKeyType2.secp256r1,
  "P-256": DidDhtRegisteredKeyType2.secp256r1,
  secp256k1: DidDhtRegisteredKeyType2.secp256k1,
  secp256r1: DidDhtRegisteredKeyType2.secp256r1
};
var DidDht2 = class _DidDht extends DidMethod2 {
  /**
   * Creates a new DID using the `did:dht` method formed from a newly generated key.
   *
   * @remarks
   * The DID URI is formed by z-base-32 encoding the Identity Key public key and prefixing with
   * `did:dht:`.
   *
   * Notes:
   * - If no `options` are given, by default a new Ed25519 key will be generated which serves as the
   *   Identity Key.
   *
   * @example
   * ```ts
   * // DID Creation
   * const did = await DidDht.create();
   *
   * // DID Creation with a KMS
   * const keyManager = new LocalKeyManager();
   * const did = await DidDht.create({ keyManager });
   * ```
   *
   * @param params - The parameters for the create operation.
   * @param params.keyManager - Optionally specify a Key Management System (KMS) used to generate
   *                            keys and sign data.
   * @param params.options - Optional parameters that can be specified when creating a new DID.
   * @returns A Promise resolving to a {@link BearerDid} object representing the new DID.
   */
  static create({ keyManager: keyManager2 = new LocalKeyManager2(), options = {} } = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    return __awaiter39(this, void 0, void 0, function* () {
      if ((_a = options.verificationMethods) === null || _a === void 0 ? void 0 : _a.some((vm) => !(vm.algorithm in AlgorithmToKeyTypeMap4))) {
        throw new Error("One or more verification method algorithms are not supported");
      }
      const methodIds = (_b = options.verificationMethods) === null || _b === void 0 ? void 0 : _b.filter((vm) => "id" in vm).map((vm) => vm.id);
      if (methodIds && methodIds.length !== new Set(methodIds).size) {
        throw new Error("One or more verification method IDs are not unique");
      }
      if ((_c = options.services) === null || _c === void 0 ? void 0 : _c.some((s) => !s.id || !s.type || !s.serviceEndpoint)) {
        throw new Error("One or more services are missing required properties");
      }
      const identityKeyUri = yield keyManager2.generateKey({ algorithm: "Ed25519" });
      const identityKey = yield keyManager2.getPublicKey({ keyUri: identityKeyUri });
      const didUri = yield DidDhtUtils2.identityKeyToIdentifier({ identityKey });
      const document = Object.assign(Object.assign({ id: didUri }, options.alsoKnownAs && { alsoKnownAs: options.alsoKnownAs }), options.controllers && { controller: options.controllers });
      const verificationMethodsToAdd = [...(_d = options.verificationMethods) !== null && _d !== void 0 ? _d : []];
      if (!(verificationMethodsToAdd === null || verificationMethodsToAdd === void 0 ? void 0 : verificationMethodsToAdd.some((vm) => {
        var _a2;
        return ((_a2 = vm.id) === null || _a2 === void 0 ? void 0 : _a2.split("#").pop()) === "0";
      }))) {
        verificationMethodsToAdd.unshift({
          algorithm: "Ed25519",
          id: "0",
          purposes: ["authentication", "assertionMethod", "capabilityDelegation", "capabilityInvocation"]
        });
      }
      for (const vm of verificationMethodsToAdd) {
        const keyUri = vm.id && vm.id.split("#").pop() === "0" ? identityKeyUri : yield keyManager2.generateKey({ algorithm: vm.algorithm });
        const publicKey = yield keyManager2.getPublicKey({ keyUri });
        let methodId = (_f = (_e = vm.id) !== null && _e !== void 0 ? _e : publicKey.kid) !== null && _f !== void 0 ? _f : yield computeJwkThumbprint2({ jwk: publicKey });
        methodId = `${didUri}#${extractDidFragment2(methodId)}`;
        (_g = document.verificationMethod) !== null && _g !== void 0 ? _g : document.verificationMethod = [];
        document.verificationMethod.push({
          id: methodId,
          type: "JsonWebKey",
          controller: (_h = vm.controller) !== null && _h !== void 0 ? _h : didUri,
          publicKeyJwk: publicKey
        });
        for (const purpose of (_j = vm.purposes) !== null && _j !== void 0 ? _j : []) {
          if (!document[purpose])
            document[purpose] = [];
          document[purpose].push(methodId);
        }
      }
      (_k = options.services) === null || _k === void 0 ? void 0 : _k.forEach((service) => {
        var _a2;
        (_a2 = document.service) !== null && _a2 !== void 0 ? _a2 : document.service = [];
        service.id = `${didUri}#${service.id.split("#").pop()}`;
        document.service.push(service);
      });
      const did = new BearerDid2({
        uri: didUri,
        document,
        metadata: Object.assign({ published: false }, options.types && { types: options.types }),
        keyManager: keyManager2
      });
      if ((_l = options.publish) !== null && _l !== void 0 ? _l : true) {
        const registrationResult = yield _DidDht.publish({ did, gatewayUri: options.gatewayUri });
        did.metadata = registrationResult.didDocumentMetadata;
      }
      return did;
    });
  }
  /**
   * Instantiates a {@link BearerDid} object for the DID DHT method from a given {@link PortableDid}.
   *
   * This method allows for the creation of a `BearerDid` object using a previously created DID's
   * key material, DID document, and metadata.
   *
   * @example
   * ```ts
   * // Export an existing BearerDid to PortableDid format.
   * const portableDid = await did.export();
   * // Reconstruct a BearerDid object from the PortableDid.
   * const did = await DidDht.import({ portableDid });
   * ```
   *
   * @param params - The parameters for the import operation.
   * @param params.portableDid - The PortableDid object to import.
   * @param params.keyManager - Optionally specify an external Key Management System (KMS) used to
   *                            generate keys and sign data. If not given, a new
   *                            {@link LocalKeyManager} instance will be created and
   *                            used.
   * @returns A Promise resolving to a `BearerDid` object representing the DID formed from the
   *          provided PortableDid.
   * @throws An error if the PortableDid document does not contain any verification methods, lacks
   *         an Identity Key, or the keys for any verification method are missing in the key
   *         manager.
   */
  static import({ portableDid, keyManager: keyManager2 = new LocalKeyManager2() }) {
    var _a;
    return __awaiter39(this, void 0, void 0, function* () {
      const parsedDid = Did2.parse(portableDid.uri);
      if ((parsedDid === null || parsedDid === void 0 ? void 0 : parsedDid.method) !== _DidDht.methodName) {
        throw new DidError2(DidErrorCode2.MethodNotSupported, `Method not supported`);
      }
      const did = yield BearerDid2.import({ portableDid, keyManager: keyManager2 });
      if (!((_a = did.document.verificationMethod) === null || _a === void 0 ? void 0 : _a.some((vm) => {
        var _a2;
        return ((_a2 = vm.id) === null || _a2 === void 0 ? void 0 : _a2.split("#").pop()) === "0";
      }))) {
        throw new DidError2(DidErrorCode2.InvalidDidDocument, `DID document must contain an Identity Key`);
      }
      return did;
    });
  }
  /**
   * Given the W3C DID Document of a `did:dht` DID, return the verification method that will be used
   * for signing messages and credentials. If given, the `methodId` parameter is used to select the
   * verification method. If not given, the Identity Key's verification method with an ID fragment
   * of '#0' is used.
   *
   * @param params - The parameters for the `getSigningMethod` operation.
   * @param params.didDocument - DID Document to get the verification method from.
   * @param params.methodId - ID of the verification method to use for signing.
   * @returns Verification method to use for signing.
   */
  static getSigningMethod({ didDocument, methodId = "#0" }) {
    var _a;
    return __awaiter39(this, void 0, void 0, function* () {
      const parsedDid = Did2.parse(didDocument.id);
      if (parsedDid && parsedDid.method !== this.methodName) {
        throw new DidError2(DidErrorCode2.MethodNotSupported, `Method not supported: ${parsedDid.method}`);
      }
      const verificationMethod = (_a = didDocument.verificationMethod) === null || _a === void 0 ? void 0 : _a.find((vm) => {
        var _a2, _b;
        return extractDidFragment2(vm.id) === ((_a2 = extractDidFragment2(methodId)) !== null && _a2 !== void 0 ? _a2 : extractDidFragment2((_b = didDocument.assertionMethod) === null || _b === void 0 ? void 0 : _b[0]));
      });
      if (!(verificationMethod && verificationMethod.publicKeyJwk)) {
        throw new DidError2(DidErrorCode2.InternalError, "A verification method intended for signing could not be determined from the DID Document");
      }
      return verificationMethod;
    });
  }
  /**
   * Publishes a DID to the DHT, making it publicly discoverable and resolvable.
   *
   * This method handles the publication of a DID Document associated with a `did:dht` DID to the
   * Mainline DHT network. The publication process involves storing the DID Document in Mainline DHT
   * via a Pkarr relay server.
   *
   * @remarks
   * - This method is typically invoked automatically during the creation of a new DID unless the
   *   `publish` option is set to `false`.
   * - For existing, unpublished DIDs, it can be used to publish the DID Document to Mainline DHT.
   * - The method relies on the specified Pkarr relay server to interface with the DHT network.
   *
   * @example
   * ```ts
   * // Generate a new DID and keys but explicitly disable publishing.
   * const did = await DidDht.create({ options: { publish: false } });
   * // Publish the DID to the DHT.
   * const registrationResult = await DidDht.publish({ did });
   * // `registrationResult.didDocumentMetadata.published` is true if the DID was successfully published.
   * ```
   *
   * @param params - The parameters for the `publish` operation.
   * @param params.did - The `BearerDid` object representing the DID to be published.
   * @param params.gatewayUri - Optional. The URI of a server involved in executing DID method
   *                            operations. In the context of publishing, the endpoint is expected
   *                            to be a DID DHT Gateway or Pkarr Relay. If not specified, a default
   *                            gateway node is used.
   * @returns A promise that resolves to a {@link DidRegistrationResult} object that contains
   *          the result of registering the DID with a DID DHT Gateway or Pkarr relay.
   */
  static publish({ did, gatewayUri = DEFAULT_GATEWAY_URI3 }) {
    return __awaiter39(this, void 0, void 0, function* () {
      const registrationResult = yield DidDhtDocument2.put({ did, gatewayUri });
      return registrationResult;
    });
  }
  /**
   * Resolves a `did:dht` identifier to its corresponding DID document.
   *
   * This method performs the resolution of a `did:dht` DID, retrieving its DID Document from the
   * Mainline DHT network. The process involves querying the DHT network via a Pkarr relay server to
   * retrieve the DID Document that corresponds to the given DID identifier.
   *
   * @remarks
   * - If a `gatewayUri` option is not specified, a default Pkarr relay is used to access the DHT
   *   network.
   * - It decodes the DID identifier and retrieves the associated DID Document and metadata.
   * - In case of resolution failure, appropriate error information is returned.
   *
   * @example
   * ```ts
   * const resolutionResult = await DidDht.resolve('did:dht:example');
   * ```
   *
   * @param didUri - The DID to be resolved.
   * @param options - Optional parameters for resolving the DID. Unused by this DID method.
   * @returns A Promise resolving to a {@link DidResolutionResult} object representing the result of
   *          the resolution.
   */
  static resolve(didUri, options = {}) {
    var _a;
    return __awaiter39(this, void 0, void 0, function* () {
      const gatewayUri = (_a = options === null || options === void 0 ? void 0 : options.gatewayUri) !== null && _a !== void 0 ? _a : DEFAULT_GATEWAY_URI3;
      try {
        yield DidDhtUtils2.identifierToIdentityKey({ didUri });
        const { didDocument, didDocumentMetadata } = yield DidDhtDocument2.get({ didUri, gatewayUri });
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT2), {
          didDocument,
          didDocumentMetadata
        });
      } catch (error) {
        if (!(error instanceof DidError2))
          throw new Error(error);
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT2), { didResolutionMetadata: Object.assign({ error: error.code }, error.message && { errorMessage: error.message }) });
      }
    });
  }
};
DidDht2.methodName = "dht";
var DidDhtDocument2 = class _DidDhtDocument {
  /**
   * Retrieves a DID document and its metadata from the DHT network.
   *
   * @param params - The parameters for the get operation.
   * @param params.didUri - The DID URI containing the Identity Key.
   * @param params.gatewayUri - The DID DHT Gateway or Pkarr Relay URI.
   * @returns A Promise resolving to a {@link DidResolutionResult} object containing the DID
   *          document and its metadata.
   */
  static get({ didUri, gatewayUri }) {
    return __awaiter39(this, void 0, void 0, function* () {
      const publicKeyBytes = DidDhtUtils2.identifierToIdentityKeyBytes({ didUri });
      const bep44Message = yield _DidDhtDocument.pkarrGet({ gatewayUri, publicKeyBytes });
      const dnsPacket = yield DidDhtUtils2.parseBep44GetMessage({ bep44Message });
      const resolutionResult = yield _DidDhtDocument.fromDnsPacket({ didUri, dnsPacket });
      resolutionResult.didDocumentMetadata.versionId = bep44Message.seq.toString();
      return resolutionResult;
    });
  }
  /**
   * Publishes a DID document to the DHT network.
   *
   * @param params - The parameters to use when publishing the DID document to the DHT network.
   * @param params.did - The DID object whose DID document will be published.
   * @param params.gatewayUri - The DID DHT Gateway or Pkarr Relay URI.
   * @returns A promise that resolves to a {@link DidRegistrationResult} object that contains
   *          the result of registering the DID with a DID DHT Gateway or Pkarr relay.
   */
  static put({ did, gatewayUri }) {
    return __awaiter39(this, void 0, void 0, function* () {
      const dnsPacket = yield _DidDhtDocument.toDnsPacket({
        didDocument: did.document,
        didMetadata: did.metadata
      });
      const bep44Message = yield DidDhtUtils2.createBep44PutMessage({
        dnsPacket,
        publicKeyBytes: DidDhtUtils2.identifierToIdentityKeyBytes({ didUri: did.uri }),
        signer: yield did.getSigner({ methodId: "0" })
      });
      const putResult = yield _DidDhtDocument.pkarrPut({ gatewayUri, bep44Message });
      return {
        didDocument: did.document,
        didDocumentMetadata: Object.assign(Object.assign({}, did.metadata), { published: putResult, versionId: bep44Message.seq.toString() }),
        didRegistrationMetadata: {}
      };
    });
  }
  /**
   * Retrieves a signed BEP44 message from a DID DHT Gateway or Pkarr Relay server.
   *
   * @see {@link https://github.com/Nuhvi/pkarr/blob/main/design/relays.md | Pkarr Relay design}
   *
   * @param params
   * @param params.gatewayUri - The DID DHT Gateway or Pkarr Relay URI.
   * @param params.publicKeyBytes - The public key bytes of the Identity Key, z-base-32 encoded.
   * @returns A promise resolving to a BEP44 message containing the signed DNS packet.
  */
  static pkarrGet({ gatewayUri, publicKeyBytes }) {
    return __awaiter39(this, void 0, void 0, function* () {
      const identifier = Convert2.uint8Array(publicKeyBytes).toBase32Z();
      const url = new URL(identifier, gatewayUri).href;
      let response;
      try {
        response = yield fetch(url, { method: "GET" });
        if (!response.ok) {
          throw new DidError2(DidErrorCode2.NotFound, `Pkarr record not found for: ${identifier}`);
        }
      } catch (error) {
        if (error instanceof DidError2)
          throw error;
        throw new DidError2(DidErrorCode2.InternalError, `Failed to fetch Pkarr record: ${error.message}`);
      }
      const messageBytes = yield response.arrayBuffer();
      if (!messageBytes) {
        throw new DidError2(DidErrorCode2.NotFound, `Pkarr record not found for: ${identifier}`);
      }
      if (messageBytes.byteLength < 72) {
        throw new DidError2(DidErrorCode2.InvalidDidDocumentLength, `Pkarr response must be at least 72 bytes but got: ${messageBytes.byteLength}`);
      }
      if (messageBytes.byteLength > 1072) {
        throw new DidError2(DidErrorCode2.InvalidDidDocumentLength, `Pkarr response exceeds 1000 byte limit: ${messageBytes.byteLength}`);
      }
      const bep44Message = {
        k: publicKeyBytes,
        seq: Number(new DataView(messageBytes).getBigUint64(64)),
        sig: new Uint8Array(messageBytes, 0, 64),
        v: new Uint8Array(messageBytes, 72)
      };
      return bep44Message;
    });
  }
  /**
   * Publishes a signed BEP44 message to a DID DHT Gateway or Pkarr Relay server.
   *
   * @see {@link https://github.com/Nuhvi/pkarr/blob/main/design/relays.md | Pkarr Relay design}
   *
   * @param params - The parameters to use when publishing a signed BEP44 message to a Pkarr relay server.
   * @param params.gatewayUri - The DID DHT Gateway or Pkarr Relay URI.
   * @param params.bep44Message - The BEP44 message to be published, containing the signed DNS packet.
   * @returns A promise resolving to `true` if the message was successfully published, otherwise `false`.
   */
  static pkarrPut({ gatewayUri, bep44Message }) {
    return __awaiter39(this, void 0, void 0, function* () {
      const identifier = Convert2.uint8Array(bep44Message.k).toBase32Z();
      const url = new URL(identifier, gatewayUri).href;
      const body = new Uint8Array(bep44Message.v.length + 72);
      body.set(bep44Message.sig, 0);
      new DataView(body.buffer).setBigUint64(bep44Message.sig.length, BigInt(bep44Message.seq));
      body.set(bep44Message.v, bep44Message.sig.length + 8);
      let response;
      try {
        response = yield fetch(url, {
          method: "PUT",
          headers: { "Content-Type": "application/octet-stream" },
          body
        });
      } catch (error) {
        throw new DidError2(DidErrorCode2.InternalError, `Failed to put Pkarr record: ${error.message}`);
      }
      return response.ok;
    });
  }
  /**
   * Converts a DNS packet to a DID document according to the DID DHT specification.
   *
   * @see {@link https://did-dht.com/#dids-as-dns-records | DID DHT Specification, § DIDs as DNS Records}
   *
   * @param params - The parameters to use when converting a DNS packet to a DID document.
   * @param params.didUri - The DID URI of the DID document.
   * @param params.dnsPacket - The DNS packet to convert to a DID document.
   * @returns A Promise resolving to a {@link DidResolutionResult} object containing the DID
   *          document and its metadata.
   */
  static fromDnsPacket({ didUri, dnsPacket }) {
    var _a, _b, _c;
    return __awaiter39(this, void 0, void 0, function* () {
      const didDocument = { id: didUri };
      const didDocumentMetadata = {
        published: true
      };
      const idLookup = /* @__PURE__ */ new Map();
      for (const answer of (_a = dnsPacket === null || dnsPacket === void 0 ? void 0 : dnsPacket.answers) !== null && _a !== void 0 ? _a : []) {
        if (answer.type !== "TXT")
          continue;
        const dnsRecordId = answer.name.split(".")[0].substring(1);
        switch (true) {
          case dnsRecordId.startsWith("aka"): {
            const data = DidDhtUtils2.parseTxtDataToString(answer.data);
            didDocument.alsoKnownAs = data.split(VALUE_SEPARATOR2);
            break;
          }
          case dnsRecordId.startsWith("cnt"): {
            const data = DidDhtUtils2.parseTxtDataToString(answer.data);
            didDocument.controller = data.includes(VALUE_SEPARATOR2) ? data.split(VALUE_SEPARATOR2) : data;
            break;
          }
          case dnsRecordId.startsWith("k"): {
            const { id, t, k, c } = DidDhtUtils2.parseTxtDataToObject(answer.data);
            const publicKeyBytes = Convert2.base64Url(k).toUint8Array();
            const namedCurve = DidDhtRegisteredKeyType2[Number(t)];
            let publicKey = yield DidDhtUtils2.keyConverter(namedCurve).bytesToPublicKey({ publicKeyBytes });
            (_b = didDocument.verificationMethod) !== null && _b !== void 0 ? _b : didDocument.verificationMethod = [];
            const methodId = `${didUri}#${id}`;
            didDocument.verificationMethod.push({
              id: methodId,
              type: "JsonWebKey",
              controller: c !== null && c !== void 0 ? c : didUri,
              publicKeyJwk: publicKey
            });
            idLookup.set(dnsRecordId, methodId);
            break;
          }
          case dnsRecordId.startsWith("s"): {
            const _d = DidDhtUtils2.parseTxtDataToObject(answer.data), { id, t, se } = _d, customProperties = __rest10(_d, ["id", "t", "se"]);
            const serviceEndpoint = se.includes(VALUE_SEPARATOR2) ? se.split(VALUE_SEPARATOR2) : se;
            const serviceProperties = Object.fromEntries(Object.entries(customProperties).map(([k, v]) => [k, v.includes(VALUE_SEPARATOR2) ? v.split(VALUE_SEPARATOR2) : v]));
            (_c = didDocument.service) !== null && _c !== void 0 ? _c : didDocument.service = [];
            didDocument.service.push(Object.assign(Object.assign({}, serviceProperties), { id: `${didUri}#${id}`, type: t, serviceEndpoint }));
            break;
          }
          case dnsRecordId.startsWith("typ"): {
            const { id: types } = DidDhtUtils2.parseTxtDataToObject(answer.data);
            didDocumentMetadata.types = types.split(VALUE_SEPARATOR2).map((typeInteger) => Number(typeInteger));
            break;
          }
          case dnsRecordId.startsWith("did"): {
            const recordIdsToMethodIds = (data) => data.split(VALUE_SEPARATOR2).map((dnsRecordId2) => idLookup.get(dnsRecordId2)).filter((id) => typeof id === "string");
            const { auth, asm, del, inv, agm } = DidDhtUtils2.parseTxtDataToObject(answer.data);
            if (auth)
              didDocument.authentication = recordIdsToMethodIds(auth);
            if (asm)
              didDocument.assertionMethod = recordIdsToMethodIds(asm);
            if (del)
              didDocument.capabilityDelegation = recordIdsToMethodIds(del);
            if (inv)
              didDocument.capabilityInvocation = recordIdsToMethodIds(inv);
            if (agm)
              didDocument.keyAgreement = recordIdsToMethodIds(agm);
            break;
          }
        }
      }
      return { didDocument, didDocumentMetadata, didResolutionMetadata: {} };
    });
  }
  /**
   * Converts a DID document to a DNS packet according to the DID DHT specification.
   *
   * @see {@link https://did-dht.com/#dids-as-dns-records | DID DHT Specification, § DIDs as DNS Records}
   *
   * @param params - The parameters to use when converting a DID document to a DNS packet.
   * @param params.didDocument - The DID document to convert to a DNS packet.
   * @param params.didMetadata - The DID metadata to include in the DNS packet.
   * @returns A promise that resolves to a DNS packet.
   */
  static toDnsPacket({ didDocument, didMetadata }) {
    var _a, _b, _c, _d, _e;
    return __awaiter39(this, void 0, void 0, function* () {
      const dnsAnswerRecords = [];
      const idLookup = /* @__PURE__ */ new Map();
      const serviceIds = [];
      const verificationMethodIds = [];
      if (didDocument.alsoKnownAs) {
        dnsAnswerRecords.push({
          type: "TXT",
          name: "_aka.did.",
          ttl: DNS_RECORD_TTL2,
          data: didDocument.alsoKnownAs.join(VALUE_SEPARATOR2)
        });
      }
      if (didDocument.controller) {
        const controller = Array.isArray(didDocument.controller) ? didDocument.controller.join(VALUE_SEPARATOR2) : didDocument.controller;
        dnsAnswerRecords.push({
          type: "TXT",
          name: "_cnt.did.",
          ttl: DNS_RECORD_TTL2,
          data: controller
        });
      }
      for (const [index, vm] of (_b = (_a = didDocument.verificationMethod) === null || _a === void 0 ? void 0 : _a.entries()) !== null && _b !== void 0 ? _b : []) {
        const dnsRecordId = `k${index}`;
        verificationMethodIds.push(dnsRecordId);
        let methodId = vm.id.split("#").pop();
        idLookup.set(methodId, dnsRecordId);
        const publicKey = vm.publicKeyJwk;
        if (!((publicKey === null || publicKey === void 0 ? void 0 : publicKey.crv) && publicKey.crv in AlgorithmToKeyTypeMap4)) {
          throw new DidError2(DidErrorCode2.InvalidPublicKeyType, `Verification method '${vm.id}' contains an unsupported key type: ${(_c = publicKey === null || publicKey === void 0 ? void 0 : publicKey.crv) !== null && _c !== void 0 ? _c : "undefined"}`);
        }
        const keyType = DidDhtRegisteredKeyType2[publicKey.crv];
        const publicKeyBytes = yield DidDhtUtils2.keyConverter(publicKey.crv).publicKeyToBytes({ publicKey });
        const publicKeyBase64Url = Convert2.uint8Array(publicKeyBytes).toBase64Url();
        const txtData = [`id=${methodId}`, `t=${keyType}`, `k=${publicKeyBase64Url}`];
        if (vm.controller !== didDocument.id)
          txtData.push(`c=${vm.controller}`);
        dnsAnswerRecords.push({
          type: "TXT",
          name: `_${dnsRecordId}._did.`,
          ttl: DNS_RECORD_TTL2,
          data: txtData.join(PROPERTY_SEPARATOR2)
        });
      }
      (_d = didDocument.service) === null || _d === void 0 ? void 0 : _d.forEach((service, index) => {
        const dnsRecordId = `s${index}`;
        serviceIds.push(dnsRecordId);
        let { id, type: t, serviceEndpoint: se } = service, customProperties = __rest10(service, ["id", "type", "serviceEndpoint"]);
        id = extractDidFragment2(id);
        se = Array.isArray(se) ? se.join(",") : se;
        const txtData = Object.entries(Object.assign({ id, t, se }, customProperties)).map(([key, value]) => `${key}=${value}`);
        dnsAnswerRecords.push({
          type: "TXT",
          name: `_${dnsRecordId}._did.`,
          ttl: DNS_RECORD_TTL2,
          data: txtData.join(PROPERTY_SEPARATOR2)
        });
      });
      const rootRecord = [`v=${DID_DHT_SPECIFICATION_VERSION2}`];
      if (verificationMethodIds.length) {
        rootRecord.push(`vm=${verificationMethodIds.join(VALUE_SEPARATOR2)}`);
      }
      Object.keys(DidVerificationRelationship2).forEach((relationship) => {
        var _a2;
        const dnsRecordIds = (_a2 = didDocument[relationship]) === null || _a2 === void 0 ? void 0 : _a2.map((id) => idLookup.get(id.split("#").pop()));
        if (dnsRecordIds) {
          const recordName = DidDhtVerificationRelationship2[relationship];
          rootRecord.push(`${recordName}=${dnsRecordIds.join(VALUE_SEPARATOR2)}`);
        }
      });
      if (serviceIds.length) {
        rootRecord.push(`svc=${serviceIds.join(VALUE_SEPARATOR2)}`);
      }
      if ((_e = didMetadata.types) === null || _e === void 0 ? void 0 : _e.length) {
        const types = didMetadata.types;
        const typeIntegers = types.map((type) => typeof type === "string" ? DidDhtRegisteredDidType2[type] : type);
        dnsAnswerRecords.push({
          type: "TXT",
          name: "_typ._did.",
          ttl: DNS_RECORD_TTL2,
          data: `id=${typeIntegers.join(VALUE_SEPARATOR2)}`
        });
      }
      dnsAnswerRecords.push({
        type: "TXT",
        name: "_did.",
        ttl: DNS_RECORD_TTL2,
        data: rootRecord.join(PROPERTY_SEPARATOR2)
      });
      const [, , identifier] = didDocument.id.split(":");
      dnsAnswerRecords.forEach((record) => record.name += identifier);
      const dnsPacket = {
        id: 0,
        type: "response",
        flags: AUTHORITATIVE_ANSWER,
        answers: dnsAnswerRecords
      };
      return dnsPacket;
    });
  }
};
var DidDhtUtils2 = class _DidDhtUtils {
  /**
   * Creates a BEP44 put message, which is used to publish a DID document to the DHT network.
   *
   * @param params - The parameters to use when creating the BEP44 put message
   * @param params.dnsPacket - The DNS packet to encode in the BEP44 message.
   * @param params.publicKeyBytes - The public key bytes of the Identity Key.
   * @param params.signer - Signer that can sign and verify data using the Identity Key.
   * @returns A promise that resolves to a BEP44 put message.
   */
  static createBep44PutMessage({ dnsPacket, publicKeyBytes, signer }) {
    return __awaiter39(this, void 0, void 0, function* () {
      const sequenceNumber = Math.ceil(Date.now() / 1e3);
      const encodedDnsPacket = encode(dnsPacket);
      const bencodedData = bencode_default.encode({ seq: sequenceNumber, v: encodedDnsPacket }).subarray(1, -1);
      if (bencodedData.length > 1e3) {
        throw new DidError2(DidErrorCode2.InvalidDidDocumentLength, `DNS packet exceeds the 1000 byte maximum size: ${bencodedData.length} bytes`);
      }
      const signature = yield signer.sign({ data: bencodedData });
      return { k: publicKeyBytes, seq: sequenceNumber, sig: signature, v: encodedDnsPacket };
    });
  }
  /**
   * Converts a DID URI to a JSON Web Key (JWK) representing the Identity Key.
   *
   * @param params - The parameters to use for the conversion.
   * @param params.didUri - The DID URI containing the Identity Key.
   * @returns A promise that resolves to a JWK representing the Identity Key.
   */
  static identifierToIdentityKey({ didUri }) {
    return __awaiter39(this, void 0, void 0, function* () {
      let identityKeyBytes = _DidDhtUtils.identifierToIdentityKeyBytes({ didUri });
      const identityKey = yield Ed255192.bytesToPublicKey({ publicKeyBytes: identityKeyBytes });
      return identityKey;
    });
  }
  /**
   * Converts a DID URI to the byte array representation of the Identity Key.
   *
   * @param params - The parameters to use for the conversion.
   * @param params.didUri - The DID URI containing the Identity Key.
   * @returns A byte array representation of the Identity Key.
   */
  static identifierToIdentityKeyBytes({ didUri }) {
    const parsedDid = Did2.parse(didUri);
    if (!parsedDid) {
      throw new DidError2(DidErrorCode2.InvalidDid, `Invalid DID URI: ${didUri}`);
    }
    if (parsedDid.method !== DidDht2.methodName) {
      throw new DidError2(DidErrorCode2.MethodNotSupported, `Method not supported: ${parsedDid.method}`);
    }
    let identityKeyBytes;
    try {
      identityKeyBytes = Convert2.base32Z(parsedDid.id).toUint8Array();
    } catch (_a) {
      throw new DidError2(DidErrorCode2.InvalidPublicKey, `Failed to decode method-specific identifier`);
    }
    if (identityKeyBytes.length !== 32) {
      throw new DidError2(DidErrorCode2.InvalidPublicKeyLength, `Invalid public key length: ${identityKeyBytes.length}`);
    }
    return identityKeyBytes;
  }
  /**
   * Encodes a DID DHT Identity Key into a DID identifier.
   *
   * This method first z-base-32 encodes the Identity Key. The resulting string is prefixed with
   * `did:dht:` to form the DID identifier.
   *
   * @param params - The parameters to use for the conversion.
   * @param params.identityKey The Identity Key from which the DID identifier is computed.
   * @returns A promise that resolves to a string containing the DID identifier.
   */
  static identityKeyToIdentifier({ identityKey }) {
    return __awaiter39(this, void 0, void 0, function* () {
      const publicKeyBytes = yield Ed255192.publicKeyToBytes({ publicKey: identityKey });
      const identifier = Convert2.uint8Array(publicKeyBytes).toBase32Z();
      return `did:${DidDht2.methodName}:${identifier}`;
    });
  }
  /**
   * Returns the appropriate key converter for the specified cryptographic curve.
   *
   * @param curve - The cryptographic curve to use for the key conversion.
   * @returns An `AsymmetricKeyConverter` for the specified curve.
   */
  static keyConverter(curve) {
    const converters = {
      "Ed25519": Ed255192,
      "P-256": Secp256r12,
      "secp256k1": Secp256k12
    };
    const converter = converters[curve];
    if (!converter)
      throw new DidError2(DidErrorCode2.InvalidPublicKeyType, `Unsupported curve: ${curve}`);
    return converter;
  }
  /**
   * Parses and verifies a BEP44 Get message, converting it to a DNS packet.
   *
   * @param params - The parameters to use when verifying and parsing the BEP44 Get response message.
   * @param params.bep44Message - The BEP44 message to verify and parse.
   * @returns A promise that resolves to a DNS packet.
   */
  static parseBep44GetMessage({ bep44Message }) {
    return __awaiter39(this, void 0, void 0, function* () {
      const publicKey = yield Ed255192.bytesToPublicKey({ publicKeyBytes: bep44Message.k });
      const bencodedData = bencode_default.encode({ seq: bep44Message.seq, v: bep44Message.v }).subarray(1, -1);
      const isValid3 = yield Ed255192.verify({
        key: publicKey,
        signature: bep44Message.sig,
        data: bencodedData
      });
      if (!isValid3) {
        throw new DidError2(DidErrorCode2.InvalidSignature, `Invalid signature for DHT BEP44 message`);
      }
      return decode(bep44Message.v);
    });
  }
  /**
   * Decodes and parses the data value of a DNS TXT record into a key-value object.
   *
   * @param txtData - The data value of a DNS TXT record.
   * @returns An object containing the key/value pairs of the TXT record data.
   */
  static parseTxtDataToObject(txtData) {
    return this.parseTxtDataToString(txtData).split(PROPERTY_SEPARATOR2).reduce((acc, pair) => {
      const [key, value] = pair.split("=");
      acc[key] = value;
      return acc;
    }, {});
  }
  /**
   * Decodes and parses the data value of a DNS TXT record into a string.
   *
   * @param txtData - The data value of a DNS TXT record.
   * @returns A string representation of the TXT record data.
   */
  static parseTxtDataToString(txtData) {
    if (typeof txtData === "string") {
      return txtData;
    } else if (txtData instanceof Uint8Array) {
      return Convert2.uint8Array(txtData).toString();
    } else if (Array.isArray(txtData)) {
      return txtData.map((item) => this.parseTxtDataToString(item)).join("");
    } else {
      throw new DidError2(DidErrorCode2.InternalError, "Pkarr returned DNS TXT record with invalid data type");
    }
  }
};

// node_modules/@tbdex/http-client/node_modules/@web5/dids/dist/esm/methods/did-ion.js
var import_dist131 = __toESM(require_dist(), 1);
var __awaiter40 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DidIonRegisteredKeyType2;
(function(DidIonRegisteredKeyType3) {
  DidIonRegisteredKeyType3["Ed25519"] = "Ed25519";
  DidIonRegisteredKeyType3["secp256k1"] = "secp256k1";
  DidIonRegisteredKeyType3["secp256r1"] = "secp256r1";
  DidIonRegisteredKeyType3["X25519"] = "X25519";
})(DidIonRegisteredKeyType2 || (DidIonRegisteredKeyType2 = {}));
var AlgorithmToKeyTypeMap5 = {
  Ed25519: DidIonRegisteredKeyType2.Ed25519,
  ES256K: DidIonRegisteredKeyType2.secp256k1,
  ES256: DidIonRegisteredKeyType2.secp256r1,
  "P-256": DidIonRegisteredKeyType2.secp256r1,
  secp256k1: DidIonRegisteredKeyType2.secp256k1,
  secp256r1: DidIonRegisteredKeyType2.secp256r1
};
var DEFAULT_GATEWAY_URI4 = "https://ion.tbd.engineering";
var DidIon2 = class _DidIon extends DidMethod2 {
  /**
   * Creates a new DID using the `did:ion` method formed from a newly generated key.
   *
   * Notes:
   * - If no `options` are given, by default a new Ed25519 key will be generated.
   *
   * @example
   * ```ts
   * // DID Creation
   * const did = await DidIon.create();
   *
   * // DID Creation with a KMS
   * const keyManager = new LocalKeyManager();
   * const did = await DidIon.create({ keyManager });
   * ```
   *
   * @param params - The parameters for the create operation.
   * @param params.keyManager - Optionally specify a Key Management System (KMS) used to generate
   *                            keys and sign data.
   * @param params.options - Optional parameters that can be specified when creating a new DID.
   * @returns A Promise resolving to a {@link BearerDid} object representing the new DID.
   */
  static create({ keyManager: keyManager2 = new LocalKeyManager2(), options = {} } = {}) {
    var _a, _b, _c, _d, _e, _f, _g;
    return __awaiter40(this, void 0, void 0, function* () {
      if ((_a = options.verificationMethods) === null || _a === void 0 ? void 0 : _a.some((vm) => !(vm.algorithm in AlgorithmToKeyTypeMap5))) {
        throw new Error("One or more verification method algorithms are not supported");
      }
      const methodIds = (_b = options.verificationMethods) === null || _b === void 0 ? void 0 : _b.filter((vm) => "id" in vm).map((vm) => vm.id);
      if (methodIds && methodIds.length !== new Set(methodIds).size) {
        throw new Error("One or more verification method IDs are not unique");
      }
      if ((_c = options.services) === null || _c === void 0 ? void 0 : _c.some((s) => !s.id || !s.type || !s.serviceEndpoint)) {
        throw new Error("One or more services are missing required properties");
      }
      const defaultVerificationMethod = {
        algorithm: "Ed25519",
        purposes: ["authentication", "assertionMethod", "capabilityDelegation", "capabilityInvocation"]
      };
      const verificationMethodsToAdd = [];
      for (const vm of (_d = options.verificationMethods) !== null && _d !== void 0 ? _d : [defaultVerificationMethod]) {
        const keyUri = yield keyManager2.generateKey({ algorithm: vm.algorithm });
        const publicKey = yield keyManager2.getPublicKey({ keyUri });
        verificationMethodsToAdd.push({
          id: vm.id,
          publicKeyJwk: publicKey,
          purposes: (_e = vm.purposes) !== null && _e !== void 0 ? _e : ["authentication", "assertionMethod", "capabilityDelegation", "capabilityInvocation"]
        });
      }
      const recoveryKeyUri = yield keyManager2.generateKey({ algorithm: DidIonRegisteredKeyType2.secp256k1 });
      const recoveryKey = yield keyManager2.getPublicKey({ keyUri: recoveryKeyUri });
      const updateKeyUri = yield keyManager2.generateKey({ algorithm: DidIonRegisteredKeyType2.secp256k1 });
      const updateKey = yield keyManager2.getPublicKey({ keyUri: updateKeyUri });
      const longFormDidUri = yield DidIonUtils2.computeLongFormDidUri({
        recoveryKey,
        updateKey,
        services: (_f = options.services) !== null && _f !== void 0 ? _f : [],
        verificationMethods: verificationMethodsToAdd
      });
      const { didDocument, didResolutionMetadata } = yield _DidIon.resolve(longFormDidUri, { gatewayUri: options.gatewayUri });
      if (didDocument === null) {
        throw new Error(`Unable to resolve DID during creation: ${didResolutionMetadata === null || didResolutionMetadata === void 0 ? void 0 : didResolutionMetadata.error}`);
      }
      const did = new BearerDid2({
        uri: longFormDidUri,
        document: didDocument,
        metadata: {
          published: false,
          canonicalId: longFormDidUri.split(":", 3).join(":"),
          recoveryKey,
          updateKey
        },
        keyManager: keyManager2
      });
      if ((_g = options.publish) !== null && _g !== void 0 ? _g : true) {
        const registrationResult = yield _DidIon.publish({ did, gatewayUri: options.gatewayUri });
        did.metadata = registrationResult.didDocumentMetadata;
      }
      return did;
    });
  }
  /**
   * Given the W3C DID Document of a `did:ion` DID, return the verification method that will be used
   * for signing messages and credentials. If given, the `methodId` parameter is used to select the
   * verification method. If not given, the first verification method in the authentication property
   * in the DID Document is used.
   *
   * @param params - The parameters for the `getSigningMethod` operation.
   * @param params.didDocument - DID Document to get the verification method from.
   * @param params.methodId - ID of the verification method to use for signing.
   * @returns Verification method to use for signing.
   */
  static getSigningMethod({ didDocument, methodId }) {
    var _a;
    return __awaiter40(this, void 0, void 0, function* () {
      const parsedDid = Did2.parse(didDocument.id);
      if (parsedDid && parsedDid.method !== this.methodName) {
        throw new DidError2(DidErrorCode2.MethodNotSupported, `Method not supported: ${parsedDid.method}`);
      }
      const verificationMethod = (_a = didDocument.verificationMethod) === null || _a === void 0 ? void 0 : _a.find((vm) => {
        var _a2;
        return vm.id === (methodId !== null && methodId !== void 0 ? methodId : (_a2 = didDocument.assertionMethod) === null || _a2 === void 0 ? void 0 : _a2[0]);
      });
      if (!(verificationMethod && verificationMethod.publicKeyJwk)) {
        throw new DidError2(DidErrorCode2.InternalError, "A verification method intended for signing could not be determined from the DID Document");
      }
      return verificationMethod;
    });
  }
  /**
   * Instantiates a {@link BearerDid} object for the DID ION method from a given {@link PortableDid}.
   *
   * This method allows for the creation of a `BearerDid` object using a previously created DID's
   * key material, DID document, and metadata.
   *
   * @example
   * ```ts
   * // Export an existing BearerDid to PortableDid format.
   * const portableDid = await did.export();
   * // Reconstruct a BearerDid object from the PortableDid.
   * const did = await DidIon.import({ portableDid });
   * ```
   *
   * @param params - The parameters for the import operation.
   * @param params.portableDid - The PortableDid object to import.
   * @param params.keyManager - Optionally specify an external Key Management System (KMS) used to
   *                            generate keys and sign data. If not given, a new
   *                            {@link LocalKeyManager} instance will be created and
   *                            used.
   * @returns A Promise resolving to a `BearerDid` object representing the DID formed from the
   *          provided PortableDid.
   * @throws An error if the DID document does not contain any verification methods or the keys for
   *         any verification method are missing in the key manager.
   */
  static import({ portableDid, keyManager: keyManager2 = new LocalKeyManager2() }) {
    return __awaiter40(this, void 0, void 0, function* () {
      const parsedDid = Did2.parse(portableDid.uri);
      if ((parsedDid === null || parsedDid === void 0 ? void 0 : parsedDid.method) !== _DidIon.methodName) {
        throw new DidError2(DidErrorCode2.MethodNotSupported, `Method not supported`);
      }
      const did = yield BearerDid2.import({ portableDid, keyManager: keyManager2 });
      return did;
    });
  }
  /**
   * Publishes a DID to a Sidetree node, making it publicly discoverable and resolvable.
   *
   * This method handles the publication of a DID Document associated with a `did:ion` DID to a
   * Sidetree node.
   *
   * @remarks
   * - This method is typically invoked automatically during the creation of a new DID unless the
   *   `publish` option is set to `false`.
   * - For existing, unpublished DIDs, it can be used to publish the DID Document to a Sidetree node.
   * - The method relies on the specified Sidetree node to interface with the network.
   *
   * @param params - The parameters for the `publish` operation.
   * @param params.did - The `BearerDid` object representing the DID to be published.
   * @param params.gatewayUri - Optional. The URI of a server involved in executing DID
   *                                    method operations. In the context of publishing, the
   *                                    endpoint is expected to be a Sidetree node. If not
   *                                    specified, a default node is used.
   * @returns A Promise resolving to a boolean indicating whether the publication was successful.
   *
   * @example
   * ```ts
   * // Generate a new DID and keys but explicitly disable publishing.
   * const did = await DidIon.create({ options: { publish: false } });
   * // Publish the DID to the Sidetree network.
   * const isPublished = await DidIon.publish({ did });
   * // `isPublished` is true if the DID was successfully published.
   * ```
   */
  static publish({ did, gatewayUri = DEFAULT_GATEWAY_URI4 }) {
    var _a, _b, _c;
    return __awaiter40(this, void 0, void 0, function* () {
      const verificationMethods = (_b = (_a = did.document.verificationMethod) === null || _a === void 0 ? void 0 : _a.map((vm) => ({
        id: vm.id,
        publicKeyJwk: vm.publicKeyJwk,
        purposes: getVerificationRelationshipsById2({ didDocument: did.document, methodId: vm.id })
      }))) !== null && _b !== void 0 ? _b : [];
      const ionDocument = yield DidIonUtils2.createIonDocument({
        services: (_c = did.document.service) !== null && _c !== void 0 ? _c : [],
        verificationMethods
      });
      const createOperation = yield DidIonUtils2.constructCreateRequest({
        ionDocument,
        recoveryKey: did.metadata.recoveryKey,
        updateKey: did.metadata.updateKey
      });
      try {
        const operationsUrl = DidIonUtils2.appendPathToUrl({
          baseUrl: gatewayUri,
          path: `/operations`
        });
        const response = yield fetch(operationsUrl, {
          method: "POST",
          mode: "cors",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(createOperation)
        });
        return {
          didDocument: did.document,
          didDocumentMetadata: Object.assign(Object.assign({}, did.metadata), { published: response.ok }),
          didRegistrationMetadata: {}
        };
      } catch (error) {
        return {
          didDocument: null,
          didDocumentMetadata: {
            published: false
          },
          didRegistrationMetadata: {
            error: DidErrorCode2.InternalError,
            errorMessage: `Failed to publish DID document for: ${did.uri}`
          }
        };
      }
    });
  }
  /**
   * Resolves a `did:ion` identifier to its corresponding DID document.
   *
   * This method performs the resolution of a `did:ion` DID, retrieving its DID Document from the
   * Sidetree-based DID overlay network. The process involves querying a Sidetree node to retrieve
   * the DID Document that corresponds to the given DID identifier.
   *
   * @remarks
   * - If a `gatewayUri` option is not specified, a default node is used to access the Sidetree
   *   network.
   * - It decodes the DID identifier and retrieves the associated DID Document and metadata.
   * - In case of resolution failure, appropriate error information is returned.
   *
   * @example
   * ```ts
   * const resolutionResult = await DidIon.resolve('did:ion:example');
   * ```
   *
   * @param didUri - The DID to be resolved.
   * @param options - Optional parameters for resolving the DID. Unused by this DID method.
   * @returns A Promise resolving to a {@link DidResolutionResult} object representing the result of the resolution.
   */
  static resolve(didUri, options = {}) {
    var _a, _b;
    return __awaiter40(this, void 0, void 0, function* () {
      const parsedDid = Did2.parse(didUri);
      if (!parsedDid) {
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT2), { didResolutionMetadata: { error: "invalidDid" } });
      }
      if (parsedDid.method !== _DidIon.methodName) {
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT2), { didResolutionMetadata: { error: "methodNotSupported" } });
      }
      const gatewayUri = (_a = options === null || options === void 0 ? void 0 : options.gatewayUri) !== null && _a !== void 0 ? _a : DEFAULT_GATEWAY_URI4;
      try {
        const resolutionUrl = DidIonUtils2.appendPathToUrl({
          baseUrl: gatewayUri,
          path: `/identifiers/${didUri}`
        });
        const response = yield fetch(resolutionUrl);
        if (!response.ok) {
          throw new DidError2(DidErrorCode2.NotFound, `Unable to find DID document for: ${didUri}`);
        }
        const { didDocument, didDocumentMetadata } = yield response.json();
        return Object.assign(Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT2), didDocument && { didDocument }), { didDocumentMetadata: Object.assign({ published: (_b = didDocumentMetadata === null || didDocumentMetadata === void 0 ? void 0 : didDocumentMetadata.method) === null || _b === void 0 ? void 0 : _b.published }, didDocumentMetadata) });
      } catch (error) {
        if (!(error instanceof DidError2))
          throw new Error(error);
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT2), { didResolutionMetadata: Object.assign({ error: error.code }, error.message && { errorMessage: error.message }) });
      }
    });
  }
};
DidIon2.methodName = "ion";
var DidIonUtils2 = class _DidIonUtils {
  /**
   * Appends a specified path to a base URL, ensuring proper formatting of the resulting URL.
   *
   * This method is useful for constructing URLs for accessing various endpoints, such as Sidetree
   * nodes in the ION network. It handles the nuances of URL path concatenation, including the
   * addition or removal of leading/trailing slashes, to create a well-formed URL.
   *
   * @param params - The parameters for URL construction.
   * @param params.baseUrl - The base URL to which the path will be appended.
   * @param params.path - The path to append to the base URL.
   * @returns The fully constructed URL string with the path appended to the base URL.
   */
  static appendPathToUrl({ baseUrl, path }) {
    const url = new URL(baseUrl);
    url.pathname = url.pathname.endsWith("/") ? url.pathname : url.pathname + "/";
    url.pathname += path.startsWith("/") ? path.substring(1) : path;
    return url.toString();
  }
  /**
   * Computes the Long Form DID URI given an ION DID's recovery key, update key, services, and
   * verification methods.
   *
   * @param params - The parameters for computing the Long Form DID URI.
   * @param params.recoveryKey - The ION Recovery Key.
   * @param params.updateKey - The ION Update Key.
   * @param params.services - An array of services associated with the DID.
   * @param params.verificationMethods - An array of verification methods associated with the DID.
   * @returns A Promise resolving to the Long Form DID URI.
   */
  static computeLongFormDidUri({ recoveryKey, updateKey, services, verificationMethods }) {
    return __awaiter40(this, void 0, void 0, function* () {
      const ionDocument = yield _DidIonUtils.createIonDocument({ services, verificationMethods });
      const normalizedRecoveryKey = _DidIonUtils.normalizeJwk(recoveryKey);
      const normalizedUpdateKey = _DidIonUtils.normalizeJwk(updateKey);
      const longFormDidUri = yield IonDid.createLongFormDid({
        document: ionDocument,
        recoveryKey: normalizedRecoveryKey,
        updateKey: normalizedUpdateKey
      });
      return longFormDidUri;
    });
  }
  /**
   * Constructs a Sidetree Create Operation request for a DID document within the ION network.
   *
   * This method prepares the necessary payload for submitting a Create Operation to a Sidetree
   * node, encapsulating the details of the DID document, recovery key, and update key.
   *
   * @param params - Parameters required to construct the Create Operation request.
   * @param params.ionDocument - The DID document model containing public keys and service endpoints.
   * @param params.recoveryKey - The recovery public key in JWK format.
   * @param params.updateKey - The update public key in JWK format.
   * @returns A promise resolving to the ION Create Operation request model, ready for submission to a Sidetree node.
   */
  static constructCreateRequest({ ionDocument, recoveryKey, updateKey }) {
    return __awaiter40(this, void 0, void 0, function* () {
      const createRequest = yield IonRequest.createCreateRequest({
        document: ionDocument,
        recoveryKey: _DidIonUtils.normalizeJwk(recoveryKey),
        updateKey: _DidIonUtils.normalizeJwk(updateKey)
      });
      return createRequest;
    });
  }
  /**
   * Assembles an ION document model from provided services and verification methods
   *
   * This model serves as the foundation for a DID document in the ION network, facilitating the
   * creation and management of decentralized identities. It translates service endpoints and
   * public keys into a format compatible with the Sidetree protocol, ensuring the resulting DID
   * document adheres to the required specifications for ION DIDs. This method is essential for
   * constructing the payload needed to register or update DIDs within the ION network.
   *
   * @param params - The parameters containing the services and verification methods to include in the ION document.
   * @param params.services - A list of service endpoints to be included in the DID document, specifying ways to interact with the DID subject.
   * @param params.verificationMethods - A list of verification methods to be included, detailing the cryptographic keys and their intended uses within the DID document.
   * @returns A Promise resolving to an `IonDocumentModel`, ready for use in Sidetree operations like DID creation and updates.
   */
  static createIonDocument({ services, verificationMethods }) {
    var _a, _b;
    return __awaiter40(this, void 0, void 0, function* () {
      const ionPublicKeys = [];
      for (const vm of verificationMethods) {
        let methodId = (_b = (_a = vm.id) !== null && _a !== void 0 ? _a : vm.publicKeyJwk.kid) !== null && _b !== void 0 ? _b : yield computeJwkThumbprint2({ jwk: vm.publicKeyJwk });
        methodId = `${methodId.split("#").pop()}`;
        const publicKey = {
          id: methodId,
          publicKeyJwk: _DidIonUtils.normalizeJwk(vm.publicKeyJwk),
          purposes: vm.purposes,
          type: "JsonWebKey2020"
        };
        ionPublicKeys.push(publicKey);
      }
      const ionServices = services.map((service) => Object.assign(Object.assign({}, service), {
        id: `${service.id.split("#").pop()}`
        // Remove fragment prefix, if any.
      }));
      const ionDocumentModel = {
        publicKeys: ionPublicKeys,
        services: ionServices
      };
      return ionDocumentModel;
    });
  }
  /**
   * Normalize the given JWK to include only specific members and in lexicographic order.
   *
   * @param jwk - The JWK to normalize.
   * @returns The normalized JWK.
   */
  static normalizeJwk(jwk) {
    const keyType = jwk.kty;
    let normalizedJwk;
    if (keyType === "EC") {
      normalizedJwk = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };
    } else if (keyType === "oct") {
      normalizedJwk = { k: jwk.k, kty: jwk.kty };
    } else if (keyType === "OKP") {
      normalizedJwk = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };
    } else if (keyType === "RSA") {
      normalizedJwk = { e: jwk.e, kty: jwk.kty, n: jwk.n };
    } else {
      throw new Error(`Unsupported key type: ${keyType}`);
    }
    return normalizedJwk;
  }
};

// node_modules/@tbdex/http-client/node_modules/@web5/dids/dist/esm/methods/did-jwk.js
var import_dist132 = __toESM(require_dist(), 1);
var __awaiter41 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DidJwk2 = class _DidJwk extends DidMethod2 {
  /**
   * Creates a new DID using the `did:jwk` method formed from a newly generated key.
   *
   * @remarks
   * The DID URI is formed by Base64URL-encoding the JWK and prefixing with `did:jwk:`.
   *
   * Notes:
   * - If no `options` are given, by default a new Ed25519 key will be generated.
   * - The `algorithm` and `verificationMethods` options are mutually exclusive. If both are given,
   *   an error will be thrown.
   *
   * @example
   * ```ts
   * // DID Creation
   * const did = await DidJwk.create();
   *
   * // DID Creation with a KMS
   * const keyManager = new LocalKeyManager();
   * const did = await DidJwk.create({ keyManager });
   * ```
   *
   * @param params - The parameters for the create operation.
   * @param params.keyManager - Optionally specify a Key Management System (KMS) used to generate
   *                            keys and sign data.
   * @param params.options - Optional parameters that can be specified when creating a new DID.
   * @returns A Promise resolving to a {@link BearerDid} object representing the new DID.
   */
  static create({ keyManager: keyManager2 = new LocalKeyManager2(), options = {} } = {}) {
    var _a, _b, _c, _d;
    return __awaiter41(this, void 0, void 0, function* () {
      if (options.algorithm && options.verificationMethods) {
        throw new Error(`The 'algorithm' and 'verificationMethods' options are mutually exclusive`);
      }
      if (options.verificationMethods && options.verificationMethods.length !== 1) {
        throw new Error(`The 'verificationMethods' option must contain exactly one entry`);
      }
      const algorithm = (_d = (_a = options.algorithm) !== null && _a !== void 0 ? _a : (_c = (_b = options.verificationMethods) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.algorithm) !== null && _d !== void 0 ? _d : "Ed25519";
      const keyUri = yield keyManager2.generateKey({ algorithm });
      const publicKey = yield keyManager2.getPublicKey({ keyUri });
      const identifier = Convert2.object(publicKey).toBase64Url();
      const didUri = `did:${_DidJwk.methodName}:${identifier}`;
      const didResolutionResult = yield _DidJwk.resolve(didUri);
      const document = didResolutionResult.didDocument;
      const did = new BearerDid2({
        uri: didUri,
        document,
        metadata: {},
        keyManager: keyManager2
      });
      return did;
    });
  }
  /**
   * Given the W3C DID Document of a `did:jwk` DID, return the verification method that will be used
   * for signing messages and credentials. If given, the `methodId` parameter is used to select the
   * verification method. If not given, the first verification method in the DID Document is used.
   *
   * Note that for DID JWK, only one verification method can exist so specifying `methodId` could be
   * considered redundant or unnecessary. The option is provided for consistency with other DID
   * method implementations.
   *
   * @param params - The parameters for the `getSigningMethod` operation.
   * @param params.didDocument - DID Document to get the verification method from.
   * @param params.methodId - ID of the verification method to use for signing.
   * @returns Verification method to use for signing.
   */
  static getSigningMethod({ didDocument }) {
    var _a;
    return __awaiter41(this, void 0, void 0, function* () {
      const parsedDid = Did2.parse(didDocument.id);
      if (parsedDid && parsedDid.method !== this.methodName) {
        throw new DidError2(DidErrorCode2.MethodNotSupported, `Method not supported: ${parsedDid.method}`);
      }
      const [verificationMethod] = (_a = didDocument.verificationMethod) !== null && _a !== void 0 ? _a : [];
      if (!(verificationMethod && verificationMethod.publicKeyJwk)) {
        throw new DidError2(DidErrorCode2.InternalError, "A verification method intended for signing could not be determined from the DID Document");
      }
      return verificationMethod;
    });
  }
  /**
   * Instantiates a {@link BearerDid} object for the DID JWK method from a given {@link PortableDid}.
   *
   * This method allows for the creation of a `BearerDid` object using a previously created DID's
   * key material, DID document, and metadata.
   *
   * @remarks
   * The `verificationMethod` array of the DID document must contain exactly one key since the
   * `did:jwk` method only supports a single verification method.
   *
   * @example
   * ```ts
   * // Export an existing BearerDid to PortableDid format.
   * const portableDid = await did.export();
   * // Reconstruct a BearerDid object from the PortableDid.
   * const did = await DidJwk.import({ portableDid });
   * ```
   *
   * @param params - The parameters for the import operation.
   * @param params.portableDid - The PortableDid object to import.
   * @param params.keyManager - Optionally specify an external Key Management System (KMS) used to
   *                            generate keys and sign data. If not given, a new
   *                            {@link LocalKeyManager} instance will be created and
   *                            used.
   * @returns A Promise resolving to a `BearerDid` object representing the DID formed from the provided keys.
   * @throws An error if the DID document does not contain exactly one verification method.
   */
  static import({ portableDid, keyManager: keyManager2 = new LocalKeyManager2() }) {
    return __awaiter41(this, void 0, void 0, function* () {
      const parsedDid = Did2.parse(portableDid.uri);
      if ((parsedDid === null || parsedDid === void 0 ? void 0 : parsedDid.method) !== _DidJwk.methodName) {
        throw new DidError2(DidErrorCode2.MethodNotSupported, `Method not supported`);
      }
      const did = yield BearerDid2.import({ portableDid, keyManager: keyManager2 });
      if (did.document.verificationMethod.length !== 1) {
        throw new DidError2(DidErrorCode2.InvalidDidDocument, `DID document must contain exactly one verification method`);
      }
      return did;
    });
  }
  /**
   * Resolves a `did:jwk` identifier to a DID Document.
   *
   * @param didUri - The DID to be resolved.
   * @param _options - Optional parameters for resolving the DID. Unused by this DID method.
   * @returns A Promise resolving to a {@link DidResolutionResult} object representing the result of the resolution.
   */
  static resolve(didUri, _options) {
    return __awaiter41(this, void 0, void 0, function* () {
      const parsedDid = Did2.parse(didUri);
      let publicKey;
      try {
        publicKey = Convert2.base64Url(parsedDid.id).toObject();
      } catch (_a) {
      }
      if (!parsedDid || !publicKey) {
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT2), { didResolutionMetadata: { error: "invalidDid" } });
      }
      if (parsedDid.method !== _DidJwk.methodName) {
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT2), { didResolutionMetadata: { error: "methodNotSupported" } });
      }
      const didDocument = {
        "@context": [
          "https://www.w3.org/ns/did/v1"
        ],
        id: parsedDid.uri
      };
      const keyUri = `${didDocument.id}#0`;
      didDocument.verificationMethod = [{
        id: keyUri,
        type: "JsonWebKey",
        controller: didDocument.id,
        publicKeyJwk: publicKey
      }];
      didDocument.authentication = [keyUri];
      didDocument.assertionMethod = [keyUri];
      didDocument.capabilityInvocation = [keyUri];
      didDocument.capabilityDelegation = [keyUri];
      didDocument.keyAgreement = [keyUri];
      switch (publicKey.use) {
        case "sig": {
          delete didDocument.keyAgreement;
          break;
        }
        case "enc": {
          delete didDocument.authentication;
          delete didDocument.assertionMethod;
          delete didDocument.capabilityInvocation;
          delete didDocument.capabilityDelegation;
          break;
        }
      }
      return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT2), { didDocument });
    });
  }
};
DidJwk2.methodName = "jwk";

// node_modules/@tbdex/http-client/node_modules/@web5/dids/dist/esm/methods/did-key.js
var import_dist133 = __toESM(require_dist(), 1);
var __awaiter42 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DidKeyRegisteredKeyType2;
(function(DidKeyRegisteredKeyType3) {
  DidKeyRegisteredKeyType3["Ed25519"] = "Ed25519";
  DidKeyRegisteredKeyType3["secp256k1"] = "secp256k1";
  DidKeyRegisteredKeyType3["secp256r1"] = "secp256r1";
  DidKeyRegisteredKeyType3["X25519"] = "X25519";
})(DidKeyRegisteredKeyType2 || (DidKeyRegisteredKeyType2 = {}));
var DidKeyVerificationMethodType2 = {
  /** Represents an Ed25519 public key used for digital signatures. */
  Ed25519VerificationKey2020: "https://w3id.org/security/suites/ed25519-2020/v1",
  /** Represents a JSON Web Key (JWK) used for digital signatures and key agreement protocols. */
  JsonWebKey2020: "https://w3id.org/security/suites/jws-2020/v1",
  /** Represents an X25519 public key used for key agreement protocols. */
  X25519KeyAgreementKey2020: "https://w3id.org/security/suites/x25519-2020/v1"
};
var AlgorithmToKeyTypeMap6 = {
  Ed25519: DidKeyRegisteredKeyType2.Ed25519,
  ES256K: DidKeyRegisteredKeyType2.secp256k1,
  ES256: DidKeyRegisteredKeyType2.secp256r1,
  "P-256": DidKeyRegisteredKeyType2.secp256r1,
  secp256k1: DidKeyRegisteredKeyType2.secp256k1,
  secp256r1: DidKeyRegisteredKeyType2.secp256r1,
  X25519: DidKeyRegisteredKeyType2.X25519
};
var DidKey2 = class _DidKey extends DidMethod2 {
  /**
   * Creates a new DID using the `did:key` method formed from a newly generated key.
   *
   * @remarks
   * The DID URI is formed by
   * {@link https://datatracker.ietf.org/doc/html/draft-multiformats-multibase#name-base-58-bitcoin-encoding | Multibase base58-btc}
   * encoding the
   * {@link https://github.com/multiformats/multicodec/blob/master/README.md | Multicodec}-encoded
   * public key and prefixing with `did:key:`.
   *
   * This method can optionally derive an encryption key from the public key used to create the DID
   * if and only if the public key algorithm is `Ed25519`. This feature enables the same DID to be
   * used for encrypted communication, in addition to signature verification. To enable this
   * feature, specify an `algorithm` of `Ed25519` as either a top-level option or in a
   * `verificationMethod` and set the `enableEncryptionKeyDerivation` option to `true`.
   *
   * Notes:
   * - If no `options` are given, by default a new Ed25519 key will be generated.
   * - The `algorithm` and `verificationMethods` options are mutually exclusive. If both are given,
   *   an error will be thrown.
   *
   * @example
   * ```ts
   * // DID Creation
   * const did = await DidKey.create();
   *
   * // DID Creation with a KMS
   * const keyManager = new LocalKeyManager();
   * const did = await DidKey.create({ keyManager });
   * ```
   *
   * @param params - The parameters for the create operation.
   * @param params.keyManager - Key Management System (KMS) used to generate keys and sign data.
   * @param params.options - Optional parameters that can be specified when creating a new DID.
   * @returns A Promise resolving to a {@link BearerDid} object representing the new DID.
   */
  static create({ keyManager: keyManager2 = new LocalKeyManager2(), options = {} } = {}) {
    var _a, _b, _c, _d;
    return __awaiter42(this, void 0, void 0, function* () {
      if (options.algorithm && options.verificationMethods) {
        throw new Error(`The 'algorithm' and 'verificationMethods' options are mutually exclusive`);
      }
      if (options.verificationMethods && options.verificationMethods.length !== 1) {
        throw new Error(`The 'verificationMethods' option must contain exactly one entry`);
      }
      const algorithm = (_d = (_a = options.algorithm) !== null && _a !== void 0 ? _a : (_c = (_b = options.verificationMethods) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.algorithm) !== null && _d !== void 0 ? _d : "Ed25519";
      const keyUri = yield keyManager2.generateKey({ algorithm });
      const publicKey = yield keyManager2.getPublicKey({ keyUri });
      const identifier = yield DidKeyUtils2.publicKeyToMultibaseId({ publicKey });
      const didUri = `did:${_DidKey.methodName}:${identifier}`;
      const didResolutionResult = yield _DidKey.resolve(didUri, options);
      const document = didResolutionResult.didDocument;
      const did = new BearerDid2({
        uri: didUri,
        document,
        metadata: {},
        keyManager: keyManager2
      });
      return did;
    });
  }
  /**
   * Given the W3C DID Document of a `did:key` DID, return the verification method that will be used
   * for signing messages and credentials. With DID Key, the first verification method in the
   * authentication property in the DID Document is used.
   *
   * Note that for DID Key, only one verification method intended for signing can exist so
   * specifying `methodId` could be considered redundant or unnecessary. The option is provided for
   * consistency with other DID method implementations.
   *
   * @param params - The parameters for the `getSigningMethod` operation.
   * @param params.didDocument - DID Document to get the verification method from.
   * @param params.methodId - ID of the verification method to use for signing.
   * @returns Verification method to use for signing.
   */
  static getSigningMethod({ didDocument }) {
    var _a;
    return __awaiter42(this, void 0, void 0, function* () {
      const parsedDid = Did2.parse(didDocument.id);
      if (parsedDid && parsedDid.method !== this.methodName) {
        throw new DidError2(DidErrorCode2.MethodNotSupported, `Method not supported: ${parsedDid.method}`);
      }
      const [methodId] = didDocument.assertionMethod || [];
      const verificationMethod = (_a = didDocument.verificationMethod) === null || _a === void 0 ? void 0 : _a.find((vm) => vm.id === methodId);
      if (!(verificationMethod && verificationMethod.publicKeyJwk)) {
        throw new DidError2(DidErrorCode2.InternalError, "A verification method intended for signing could not be determined from the DID Document");
      }
      return verificationMethod;
    });
  }
  /**
   * Instantiates a {@link BearerDid} object for the DID Key method from a given {@link PortableDid}.
   *
   * This method allows for the creation of a `BearerDid` object using a previously created DID's
   * key material, DID document, and metadata.
   *
   * @remarks
   * The `verificationMethod` array of the DID document must contain exactly one key since the
   * `did:key` method only supports a single verification method.
   *
   * @example
   * ```ts
   * // Export an existing BearerDid to PortableDid format.
   * const portableDid = await did.export();
   * // Reconstruct a BearerDid object from the PortableDid.
   * const did = await DidKey.import({ portableDid });
   * ```
   *
   * @param params - The parameters for the import operation.
   * @param params.portableDid - The PortableDid object to import.
   * @param params.keyManager - Optionally specify an external Key Management System (KMS) used to
   *                            generate keys and sign data. If not given, a new
   *                            {@link LocalKeyManager} instance will be created and
   *                            used.
   * @returns A Promise resolving to a `BearerDid` object representing the DID formed from the provided keys.
   * @throws An error if the DID document does not contain exactly one verification method.
   */
  static import({ portableDid, keyManager: keyManager2 = new LocalKeyManager2() }) {
    return __awaiter42(this, void 0, void 0, function* () {
      const parsedDid = Did2.parse(portableDid.uri);
      if ((parsedDid === null || parsedDid === void 0 ? void 0 : parsedDid.method) !== _DidKey.methodName) {
        throw new DidError2(DidErrorCode2.MethodNotSupported, `Method not supported`);
      }
      const did = yield BearerDid2.import({ portableDid, keyManager: keyManager2 });
      if (did.document.verificationMethod.length !== 1) {
        throw new DidError2(DidErrorCode2.InvalidDidDocument, `DID document must contain exactly one verification method`);
      }
      return did;
    });
  }
  /**
   * Resolves a `did:key` identifier to a DID Document.
   *
   * @param didUri - The DID to be resolved.
   * @param options - Optional parameters for resolving the DID.
   * @returns A Promise resolving to a {@link DidResolutionResult} object representing the result of the resolution.
   */
  static resolve(didUri, options) {
    return __awaiter42(this, void 0, void 0, function* () {
      try {
        const didDocument = yield _DidKey.createDocument({ didUri, options });
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT2), { didDocument });
      } catch (error) {
        if (!(error instanceof DidError2))
          throw new Error(error);
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT2), { didResolutionMetadata: Object.assign({ error: error.code }, error.message && { errorMessage: error.message }) });
      }
    });
  }
  /**
   * Expands a did:key identifier to a DID Document.
   *
   * Reference: https://w3c-ccg.github.io/did-method-key/#document-creation-algorithm
   *
   * @param options
   * @returns - A DID dodcument.
   */
  static createDocument({ didUri, options = {} }) {
    return __awaiter42(this, void 0, void 0, function* () {
      const { defaultContext = "https://www.w3.org/ns/did/v1", enableEncryptionKeyDerivation = false, enableExperimentalPublicKeyTypes = false, publicKeyFormat = "JsonWebKey2020" } = options;
      const didDocument = { id: "" };
      const parsedDid = Did2.parse(didUri);
      if (!parsedDid) {
        throw new DidError2(DidErrorCode2.InvalidDid, `Invalid DID URI: ${didUri}`);
      }
      const multibaseValue = parsedDid.id;
      if (parsedDid.method !== _DidKey.methodName) {
        throw new DidError2(DidErrorCode2.MethodNotSupported, `Method not supported: ${parsedDid.method}`);
      }
      if (!_DidKey.validateIdentifier(parsedDid)) {
        throw new DidError2(DidErrorCode2.InvalidDid, `Invalid DID URI: ${didUri}`);
      }
      const signatureVerificationMethod = yield _DidKey.createSignatureMethod({
        didUri,
        multibaseValue,
        options: { enableExperimentalPublicKeyTypes, publicKeyFormat }
      });
      didDocument.id = parsedDid.uri;
      didDocument.verificationMethod = [signatureVerificationMethod];
      didDocument.authentication = [signatureVerificationMethod.id];
      didDocument.assertionMethod = [signatureVerificationMethod.id];
      didDocument.capabilityInvocation = [signatureVerificationMethod.id];
      didDocument.capabilityDelegation = [signatureVerificationMethod.id];
      if (enableEncryptionKeyDerivation === true) {
        const encryptionPublicKeyFormat = publicKeyFormat === "Ed25519VerificationKey2020" ? "X25519KeyAgreementKey2020" : "JsonWebKey2020";
        const encryptionVerificationMethod = yield this.createEncryptionMethod({
          didUri,
          multibaseValue,
          options: { enableExperimentalPublicKeyTypes, publicKeyFormat: encryptionPublicKeyFormat }
        });
        didDocument.verificationMethod.push(encryptionVerificationMethod);
        didDocument.keyAgreement = [encryptionVerificationMethod.id];
      }
      const contextArray = [defaultContext];
      const verificationMethodTypes = getVerificationMethodTypes2({ didDocument });
      verificationMethodTypes.forEach((typeName) => {
        const typeUrl = DidKeyVerificationMethodType2[typeName];
        contextArray.push(typeUrl);
      });
      didDocument["@context"] = contextArray;
      return didDocument;
    });
  }
  /**
   * Decoding a multibase-encoded multicodec value into a verification method
   * that is suitable for verifying that encrypted information will be
   * received by the intended recipient.
   */
  static createEncryptionMethod({ didUri, multibaseValue, options }) {
    return __awaiter42(this, void 0, void 0, function* () {
      const { enableExperimentalPublicKeyTypes, publicKeyFormat } = options;
      const verificationMethod = { id: "", type: "", controller: "" };
      const { keyBytes: publicKeyBytes, multicodecCode: multicodecValue } = yield _DidKey.deriveEncryptionKey({ multibaseValue });
      const actualLength = publicKeyBytes.byteLength;
      const expectedLength = DidKeyUtils2.MULTICODEC_PUBLIC_KEY_LENGTH[multicodecValue];
      if (actualLength !== expectedLength) {
        throw new DidError2(DidErrorCode2.InvalidPublicKeyLength, `Expected ${actualLength} bytes. Actual: ${expectedLength}`);
      }
      const kemMultibaseValue = keyBytesToMultibaseId2({
        keyBytes: publicKeyBytes,
        multicodecCode: multicodecValue
      });
      verificationMethod.id = `${didUri}#${kemMultibaseValue}`;
      try {
        new URL(verificationMethod.id);
      } catch (error) {
        throw new DidError2(DidErrorCode2.InvalidDidUrl, "Verification Method ID is not a valid DID URL.");
      }
      if (!(publicKeyFormat in DidKeyVerificationMethodType2)) {
        throw new DidError2(DidErrorCode2.UnsupportedPublicKeyType, `Unsupported format: ${publicKeyFormat}`);
      }
      const StandardPublicKeyTypes = ["Multikey", "JsonWebKey2020", "X25519KeyAgreementKey2020"];
      if (enableExperimentalPublicKeyTypes === false && !StandardPublicKeyTypes.includes(publicKeyFormat)) {
        throw new DidError2(DidErrorCode2.InvalidPublicKeyType, `Specified '${publicKeyFormat}' without setting enableExperimentalPublicKeyTypes to true.`);
      }
      verificationMethod.type = publicKeyFormat;
      verificationMethod.controller = didUri;
      if (publicKeyFormat === "X25519KeyAgreementKey2020") {
        verificationMethod.publicKeyMultibase = kemMultibaseValue;
      }
      if (publicKeyFormat === "JsonWebKey2020") {
        const { crv } = yield DidKeyUtils2.multicodecToJwk({ code: multicodecValue });
        verificationMethod.publicKeyJwk = yield DidKeyUtils2.keyConverter(crv).bytesToPublicKey({ publicKeyBytes });
      }
      return verificationMethod;
    });
  }
  /**
   * Decodes a multibase-encoded multicodec value into a verification method
   * that is suitable for verifying digital signatures.
   * @param options - Signature method creation algorithm inputs.
   * @returns - A verification method.
   */
  static createSignatureMethod({ didUri, multibaseValue, options }) {
    return __awaiter42(this, void 0, void 0, function* () {
      const { enableExperimentalPublicKeyTypes, publicKeyFormat } = options;
      const verificationMethod = { id: "", type: "", controller: "" };
      const { keyBytes: publicKeyBytes, multicodecCode: multicodecValue, multicodecName } = multibaseIdToKeyBytes2({ multibaseKeyId: multibaseValue });
      const actualLength = publicKeyBytes.byteLength;
      const expectedLength = DidKeyUtils2.MULTICODEC_PUBLIC_KEY_LENGTH[multicodecValue];
      if (actualLength !== expectedLength) {
        throw new DidError2(DidErrorCode2.InvalidPublicKeyLength, `Expected ${actualLength} bytes. Actual: ${expectedLength}`);
      }
      let isValid3 = false;
      switch (multicodecName) {
        case "secp256k1-pub":
          isValid3 = yield Secp256k12.validatePublicKey({ publicKeyBytes });
          break;
        case "ed25519-pub":
          isValid3 = yield Ed255192.validatePublicKey({ publicKeyBytes });
          break;
        case "x25519-pub":
          isValid3 = true;
          break;
      }
      if (!isValid3) {
        throw new DidError2(DidErrorCode2.InvalidPublicKey, "Invalid public key detected.");
      }
      verificationMethod.id = `${didUri}#${multibaseValue}`;
      try {
        new URL(verificationMethod.id);
      } catch (error) {
        throw new DidError2(DidErrorCode2.InvalidDidUrl, "Verification Method ID is not a valid DID URL.");
      }
      if (!(publicKeyFormat in DidKeyVerificationMethodType2)) {
        throw new DidError2(DidErrorCode2.UnsupportedPublicKeyType, `Unsupported format: ${publicKeyFormat}`);
      }
      const StandardPublicKeyTypes = ["Multikey", "JsonWebKey2020", "Ed25519VerificationKey2020"];
      if (enableExperimentalPublicKeyTypes === false && !StandardPublicKeyTypes.includes(publicKeyFormat)) {
        throw new DidError2(DidErrorCode2.InvalidPublicKeyType, `Specified '${publicKeyFormat}' without setting enableExperimentalPublicKeyTypes to true.`);
      }
      verificationMethod.type = publicKeyFormat;
      verificationMethod.controller = didUri;
      if (publicKeyFormat === "Ed25519VerificationKey2020") {
        verificationMethod.publicKeyMultibase = multibaseValue;
      }
      if (publicKeyFormat === "JsonWebKey2020") {
        const { crv } = yield DidKeyUtils2.multicodecToJwk({ code: multicodecValue });
        verificationMethod.publicKeyJwk = yield DidKeyUtils2.keyConverter(crv).bytesToPublicKey({ publicKeyBytes });
      }
      return verificationMethod;
    });
  }
  /**
   * Transform a multibase-encoded multicodec value to public encryption key
   * components that are suitable for encrypting messages to a receiver. A
   * mathematical proof elaborating on the safety of performing this operation
   * is available in:
   * {@link https://eprint.iacr.org/2021/509.pdf | On using the same key pair for Ed25519 and an X25519 based KEM}
   */
  static deriveEncryptionKey({ multibaseValue }) {
    return __awaiter42(this, void 0, void 0, function* () {
      let publicEncryptionKey = {
        keyBytes: new Uint8Array(),
        multicodecCode: 0
      };
      const { keyBytes: publicKeyBytes, multicodecCode: multicodecValue } = multibaseIdToKeyBytes2({ multibaseKeyId: multibaseValue });
      if (multicodecValue === 237) {
        const ed25519PublicKey = yield DidKeyUtils2.keyConverter("Ed25519").bytesToPublicKey({
          publicKeyBytes
        });
        const generatedPublicEncryptionKey = yield Ed255192.convertPublicKeyToX25519({
          publicKey: ed25519PublicKey
        });
        const generatedPublicEncryptionKeyBytes = yield DidKeyUtils2.keyConverter("Ed25519").publicKeyToBytes({
          publicKey: generatedPublicEncryptionKey
        });
        publicEncryptionKey = {
          keyBytes: generatedPublicEncryptionKeyBytes,
          multicodecCode: 236
        };
      }
      return publicEncryptionKey;
    });
  }
  /**
   * Validates the structure and components of a DID URI against the `did:key` method specification.
   *
   * @param parsedDid - An object representing the parsed components of a DID URI, including the
   *                    scheme, method, and method-specific identifier.
   * @returns `true` if the DID URI meets the `did:key` method's structural requirements, `false` otherwise.
   *
   */
  static validateIdentifier(parsedDid) {
    const { method, id: multibaseValue } = parsedDid;
    const [scheme] = parsedDid.uri.split(":", 1);
    const version = "1";
    return scheme === "did" && method === "key" && Number(version) > 0 && universalTypeOf2(multibaseValue) === "String" && multibaseValue.startsWith("z");
  }
};
DidKey2.methodName = "key";
var DidKeyUtils2 = class _DidKeyUtils {
  /**
   * Converts a JWK (JSON Web Key) to a Multicodec code and name.
   *
   * @example
   * ```ts
   * const jwk: Jwk = { crv: 'Ed25519', kty: 'OKP', x: '...' };
   * const { code, name } = await DidKeyUtils.jwkToMulticodec({ jwk });
   * ```
   *
   * @param params - The parameters for the conversion.
   * @param params.jwk - The JSON Web Key to be converted.
   * @returns A promise that resolves to a Multicodec definition.
   */
  static jwkToMulticodec({ jwk }) {
    return __awaiter42(this, void 0, void 0, function* () {
      const params = [];
      if (jwk.crv) {
        params.push(jwk.crv);
        if (jwk.d) {
          params.push("private");
        } else {
          params.push("public");
        }
      }
      const lookupKey = params.join(":");
      const name = _DidKeyUtils.JWK_TO_MULTICODEC[lookupKey];
      if (name === void 0) {
        throw new Error(`Unsupported JWK to Multicodec conversion: '${lookupKey}'`);
      }
      const code = Multicodec2.getCodeFromName({ name });
      return { code, name };
    });
  }
  /**
   * Returns the appropriate public key compressor for the specified cryptographic curve.
   *
   * @param curve - The cryptographic curve to use for the key conversion.
   * @returns A public key compressor for the specified curve.
   */
  static keyCompressor(curve) {
    const compressors = {
      "P-256": Secp256r12.compressPublicKey,
      "secp256k1": Secp256k12.compressPublicKey
    };
    const compressor = compressors[curve];
    if (!compressor)
      throw new DidError2(DidErrorCode2.InvalidPublicKeyType, `Unsupported curve: ${curve}`);
    return compressor;
  }
  /**
   * Returns the appropriate key converter for the specified cryptographic curve.
   *
   * @param curve - The cryptographic curve to use for the key conversion.
   * @returns An `AsymmetricKeyConverter` for the specified curve.
   */
  static keyConverter(curve) {
    const converters = {
      "Ed25519": Ed255192,
      "P-256": Secp256r12,
      "secp256k1": Secp256k12,
      "X25519": X255192
    };
    const converter = converters[curve];
    if (!converter)
      throw new DidError2(DidErrorCode2.InvalidPublicKeyType, `Unsupported curve: ${curve}`);
    return converter;
  }
  /**
   * Converts a Multicodec code or name to parial JWK (JSON Web Key).
   *
   * @example
   * ```ts
   * const partialJwk = await DidKeyUtils.multicodecToJwk({ name: 'ed25519-pub' });
   * ```
   *
   * @param params - The parameters for the conversion.
   * @param params.code - Optional Multicodec code to convert.
   * @param params.name - Optional Multicodec name to convert.
   * @returns A promise that resolves to a JOSE format key.
   */
  static multicodecToJwk({ code, name }) {
    return __awaiter42(this, void 0, void 0, function* () {
      if (!(name ? !code : code)) {
        throw new Error(`Either 'name' or 'code' must be defined, but not both.`);
      }
      name = name === void 0 ? Multicodec2.getNameFromCode({ code }) : name;
      const lookupKey = name;
      const jose = _DidKeyUtils.MULTICODEC_TO_JWK[lookupKey];
      if (jose === void 0) {
        throw new Error(`Unsupported Multicodec to JWK conversion`);
      }
      return Object.assign({}, jose);
    });
  }
  /**
   * Converts a public key in JWK (JSON Web Key) format to a multibase identifier.
   *
   * @remarks
   * Note: All secp public keys are converted to compressed point encoding
   *       before the multibase identifier is computed.
   *
   * Per {@link https://github.com/multiformats/multicodec/blob/master/table.csv | Multicodec table}:
   *    Public keys for Elliptic Curve cryptography algorithms (e.g., secp256k1,
   *    secp256k1r1, secp384r1, etc.) are always represented with compressed point
   *    encoding (e.g., secp256k1-pub, p256-pub, p384-pub, etc.).
   *
   * Per {@link https://datatracker.ietf.org/doc/html/rfc8812#name-jose-and-cose-secp256k1-cur | RFC 8812}:
   *    "As a compressed point encoding representation is not defined for JWK
   *    elliptic curve points, the uncompressed point encoding defined there
   *    MUST be used. The x and y values represented MUST both be exactly
   *    256 bits, with any leading zeros preserved."
   *
   * @example
   * ```ts
   * const publicKey = { crv: 'Ed25519', kty: 'OKP', x: '...' };
   * const multibaseId = await DidKeyUtils.publicKeyToMultibaseId({ publicKey });
   * ```
   *
   * @param params - The parameters for the conversion.
   * @param params.publicKey - The public key in JWK format.
   * @returns A promise that resolves to the multibase identifier.
   */
  static publicKeyToMultibaseId({ publicKey }) {
    var _a;
    return __awaiter42(this, void 0, void 0, function* () {
      if (!((publicKey === null || publicKey === void 0 ? void 0 : publicKey.crv) && publicKey.crv in AlgorithmToKeyTypeMap6)) {
        throw new DidError2(DidErrorCode2.InvalidPublicKeyType, `Public key contains an unsupported key type: ${(_a = publicKey === null || publicKey === void 0 ? void 0 : publicKey.crv) !== null && _a !== void 0 ? _a : "undefined"}`);
      }
      let publicKeyBytes = yield _DidKeyUtils.keyConverter(publicKey.crv).publicKeyToBytes({ publicKey });
      if (/^(secp256k1|P-256|P-384|P-521)$/.test(publicKey.crv)) {
        publicKeyBytes = yield _DidKeyUtils.keyCompressor(publicKey.crv)({ publicKeyBytes });
      }
      const { name: multicodecName } = yield _DidKeyUtils.jwkToMulticodec({ jwk: publicKey });
      const multibaseId = keyBytesToMultibaseId2({
        keyBytes: publicKeyBytes,
        multicodecName
      });
      return multibaseId;
    });
  }
};
DidKeyUtils2.JWK_TO_MULTICODEC = {
  "Ed25519:public": "ed25519-pub",
  "Ed25519:private": "ed25519-priv",
  "secp256k1:public": "secp256k1-pub",
  "secp256k1:private": "secp256k1-priv",
  "X25519:public": "x25519-pub",
  "X25519:private": "x25519-priv"
};
DidKeyUtils2.MULTICODEC_PUBLIC_KEY_LENGTH = {
  // secp256k1-pub - Secp256k1 public key (compressed) - 33 bytes
  231: 33,
  // x25519-pub - Curve25519 public key - 32 bytes
  236: 32,
  // ed25519-pub - Ed25519 public key - 32 bytes
  237: 32
};
DidKeyUtils2.MULTICODEC_TO_JWK = {
  "ed25519-pub": { crv: "Ed25519", kty: "OKP", x: "" },
  "ed25519-priv": { crv: "Ed25519", kty: "OKP", x: "", d: "" },
  "secp256k1-pub": { crv: "secp256k1", kty: "EC", x: "", y: "" },
  "secp256k1-priv": { crv: "secp256k1", kty: "EC", x: "", y: "", d: "" },
  "x25519-pub": { crv: "X25519", kty: "OKP", x: "" },
  "x25519-priv": { crv: "X25519", kty: "OKP", x: "", d: "" }
};

// node_modules/@tbdex/http-client/node_modules/@web5/dids/dist/esm/methods/did-web.js
var import_dist134 = __toESM(require_dist(), 1);
var __awaiter43 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DidWeb2 = class _DidWeb extends DidMethod2 {
  /**
   * Resolves a `did:web` identifier to a DID Document.
   *
   * @param didUri - The DID to be resolved.
   * @param _options - Optional parameters for resolving the DID. Unused by this DID method.
   * @returns A Promise resolving to a {@link DidResolutionResult} object representing the result of the resolution.
   */
  static resolve(didUri, _options) {
    return __awaiter43(this, void 0, void 0, function* () {
      const parsedDid = Did2.parse(didUri);
      if (!parsedDid) {
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT2), { didResolutionMetadata: { error: "invalidDid" } });
      }
      if (parsedDid.method !== _DidWeb.methodName) {
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT2), { didResolutionMetadata: { error: "methodNotSupported" } });
      }
      let baseUrl = `https://${parsedDid.id.replace(/:/g, "/")}`;
      baseUrl = decodeURIComponent(baseUrl);
      const didDocumentUrl = parsedDid.id.includes(":") ? `${baseUrl}/did.json` : `${baseUrl}/.well-known/did.json`;
      try {
        const response = yield fetch(didDocumentUrl);
        if (!response.ok)
          throw new Error("HTTP error status code returned");
        const didDocument = yield response.json();
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT2), { didDocument });
      } catch (error) {
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT2), { didResolutionMetadata: { error: "notFound" } });
      }
    });
  }
};
DidWeb2.methodName = "web";

// node_modules/@tbdex/http-client/node_modules/@web5/dids/dist/esm/resolver/resolver-cache-level.js
var import_dist135 = __toESM(require_dist(), 1);
var import_ms2 = __toESM(require_ms2(), 1);
var import_level4 = __toESM(require_browser2(), 1);

// node_modules/@tbdex/http-client/node_modules/@web5/dids/dist/esm/resolver/resolver-cache-noop.js
var import_dist136 = __toESM(require_dist(), 1);
var DidResolverCacheNoop2 = {
  get: function(_key) {
    return null;
  },
  set: function(_key, _value) {
    return null;
  },
  delete: function(_key) {
    return null;
  },
  clear: function() {
    return null;
  },
  close: function() {
    return null;
  }
};

// node_modules/@tbdex/http-client/node_modules/@web5/dids/dist/esm/resolver/universal-resolver.js
var import_dist137 = __toESM(require_dist(), 1);
var __awaiter44 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var UniversalResolver2 = class {
  /**
   * Constructs a new `DidResolver`.
   *
   * @param params - The parameters for constructing the `DidResolver`.
   */
  constructor({ cache, didResolvers }) {
    this.didResolvers = /* @__PURE__ */ new Map();
    this.cache = cache || DidResolverCacheNoop2;
    for (const resolver of didResolvers) {
      this.didResolvers.set(resolver.methodName, resolver);
    }
  }
  /**
   * Resolves a DID to a DID Resolution Result.
   *
   * If the DID Resolution Result is present in the cache, it returns the cached result. Otherwise,
   * it uses the appropriate method resolver to resolve the DID, stores the resolution result in the
   * cache, and returns the resolultion result.
   *
   * @param didUri - The DID or DID URL to resolve.
   * @returns A promise that resolves to the DID Resolution Result.
   */
  resolve(didUri, options) {
    return __awaiter44(this, void 0, void 0, function* () {
      const parsedDid = Did2.parse(didUri);
      if (!parsedDid) {
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT2), { didResolutionMetadata: {
          error: DidErrorCode2.InvalidDid,
          errorMessage: `Invalid DID URI: ${didUri}`
        } });
      }
      const resolver = this.didResolvers.get(parsedDid.method);
      if (!resolver) {
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT2), { didResolutionMetadata: {
          error: DidErrorCode2.MethodNotSupported,
          errorMessage: `Method not supported: ${parsedDid.method}`
        } });
      }
      const cachedResolutionResult = yield this.cache.get(parsedDid.uri);
      if (cachedResolutionResult) {
        return cachedResolutionResult;
      } else {
        const resolutionResult = yield resolver.resolve(parsedDid.uri, options);
        yield this.cache.set(parsedDid.uri, resolutionResult);
        return resolutionResult;
      }
    });
  }
  /**
   * Dereferences a DID (Decentralized Identifier) URL to a corresponding DID resource.
   *
   * This method interprets the DID URL's components, which include the DID method, method-specific
   * identifier, path, query, and fragment, and retrieves the related resource as per the DID Core
   * specifications.
   *
   * The dereferencing process involves resolving the DID contained in the DID URL to a DID document,
   * and then extracting the specific part of the document identified by the fragment in the DID URL.
   * If no fragment is specified, the entire DID document is returned.
   *
   * This method supports resolution of different components within a DID document such as service
   * endpoints and verification methods, based on their IDs. It accommodates both full and
   * DID URLs as specified in the DID Core specification.
   *
   * More information on DID URL dereferencing can be found in the
   * {@link https://www.w3.org/TR/did-core/#did-url-dereferencing | DID Core specification}.
   *
   * TODO: This is a partial implementation and does not fully implement DID URL dereferencing. (https://github.com/TBD54566975/web5-js/issues/387)
   *
   * @param didUrl - The DID URL string to dereference.
   * @param [_options] - Input options to the dereference function. Optional.
   * @returns a {@link DidDereferencingResult}
   */
  dereference(didUrl, _options) {
    return __awaiter44(this, void 0, void 0, function* () {
      const parsedDidUrl = Did2.parse(didUrl);
      if (!parsedDidUrl) {
        return {
          dereferencingMetadata: { error: DidErrorCode2.InvalidDidUrl },
          contentStream: null,
          contentMetadata: {}
        };
      }
      const { didDocument, didResolutionMetadata, didDocumentMetadata } = yield this.resolve(parsedDidUrl.uri);
      if (!didDocument) {
        return {
          dereferencingMetadata: { error: didResolutionMetadata.error },
          contentStream: null,
          contentMetadata: {}
        };
      }
      if (!parsedDidUrl.fragment || parsedDidUrl.query) {
        return {
          dereferencingMetadata: { contentType: "application/did+json" },
          contentStream: didDocument,
          contentMetadata: didDocumentMetadata
        };
      }
      const { service = [], verificationMethod = [] } = didDocument;
      const idSet = /* @__PURE__ */ new Set([didUrl, parsedDidUrl.fragment, `#${parsedDidUrl.fragment}`]);
      let didResource;
      for (let vm of verificationMethod) {
        if (idSet.has(vm.id)) {
          didResource = vm;
          break;
        }
      }
      for (let svc of service) {
        if (idSet.has(svc.id)) {
          didResource = svc;
          break;
        }
      }
      if (didResource) {
        return {
          dereferencingMetadata: { contentType: "application/did+json" },
          contentStream: didResource,
          contentMetadata: didResolutionMetadata
        };
      } else {
        return {
          dereferencingMetadata: { error: DidErrorCode2.NotFound },
          contentStream: null,
          contentMetadata: {}
        };
      }
    });
  }
};

// node_modules/@tbdex/http-client/node_modules/typeid-js/dist/index.mjs
var import_dist143 = __toESM(require_dist(), 1);

// node_modules/@tbdex/http-client/node_modules/typeid-js/dist/chunk-FOHWUNKU.mjs
var import_dist142 = __toESM(require_dist(), 1);

// node_modules/@tbdex/http-client/node_modules/typeid-js/dist/chunk-4WQUCFGE.mjs
var import_dist139 = __toESM(require_dist(), 1);
var alphabet2 = "0123456789abcdefghjkmnpqrstvwxyz";
var dec2 = new Uint8Array([
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  255,
  18,
  19,
  255,
  20,
  21,
  255,
  22,
  23,
  24,
  25,
  26,
  255,
  27,
  28,
  29,
  30,
  31,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255
]);
function encode3(src) {
  const dst = new Array(26).fill("");
  if (src.length !== 16) {
    throw new Error("Invalid length");
  }
  dst[0] = alphabet2[(src[0] & 224) >> 5];
  dst[1] = alphabet2[src[0] & 31];
  dst[2] = alphabet2[(src[1] & 248) >> 3];
  dst[3] = alphabet2[(src[1] & 7) << 2 | (src[2] & 192) >> 6];
  dst[4] = alphabet2[(src[2] & 62) >> 1];
  dst[5] = alphabet2[(src[2] & 1) << 4 | (src[3] & 240) >> 4];
  dst[6] = alphabet2[(src[3] & 15) << 1 | (src[4] & 128) >> 7];
  dst[7] = alphabet2[(src[4] & 124) >> 2];
  dst[8] = alphabet2[(src[4] & 3) << 3 | (src[5] & 224) >> 5];
  dst[9] = alphabet2[src[5] & 31];
  dst[10] = alphabet2[(src[6] & 248) >> 3];
  dst[11] = alphabet2[(src[6] & 7) << 2 | (src[7] & 192) >> 6];
  dst[12] = alphabet2[(src[7] & 62) >> 1];
  dst[13] = alphabet2[(src[7] & 1) << 4 | (src[8] & 240) >> 4];
  dst[14] = alphabet2[(src[8] & 15) << 1 | (src[9] & 128) >> 7];
  dst[15] = alphabet2[(src[9] & 124) >> 2];
  dst[16] = alphabet2[(src[9] & 3) << 3 | (src[10] & 224) >> 5];
  dst[17] = alphabet2[src[10] & 31];
  dst[18] = alphabet2[(src[11] & 248) >> 3];
  dst[19] = alphabet2[(src[11] & 7) << 2 | (src[12] & 192) >> 6];
  dst[20] = alphabet2[(src[12] & 62) >> 1];
  dst[21] = alphabet2[(src[12] & 1) << 4 | (src[13] & 240) >> 4];
  dst[22] = alphabet2[(src[13] & 15) << 1 | (src[14] & 128) >> 7];
  dst[23] = alphabet2[(src[14] & 124) >> 2];
  dst[24] = alphabet2[(src[14] & 3) << 3 | (src[15] & 224) >> 5];
  dst[25] = alphabet2[src[15] & 31];
  return dst.join("");
}
function decode3(s) {
  if (s.length !== 26) {
    throw new Error("Invalid length");
  }
  const encoder = new TextEncoder();
  const v = encoder.encode(s);
  if (dec2[v[0]] === 255 || dec2[v[1]] === 255 || dec2[v[2]] === 255 || dec2[v[3]] === 255 || dec2[v[4]] === 255 || dec2[v[5]] === 255 || dec2[v[6]] === 255 || dec2[v[7]] === 255 || dec2[v[8]] === 255 || dec2[v[9]] === 255 || dec2[v[10]] === 255 || dec2[v[11]] === 255 || dec2[v[12]] === 255 || dec2[v[13]] === 255 || dec2[v[14]] === 255 || dec2[v[15]] === 255 || dec2[v[16]] === 255 || dec2[v[17]] === 255 || dec2[v[18]] === 255 || dec2[v[19]] === 255 || dec2[v[20]] === 255 || dec2[v[21]] === 255 || dec2[v[22]] === 255 || dec2[v[23]] === 255 || dec2[v[24]] === 255 || dec2[v[25]] === 255) {
    throw new Error("Invalid base32 character");
  }
  const id = new Uint8Array(16);
  id[0] = dec2[v[0]] << 5 | dec2[v[1]];
  id[1] = dec2[v[2]] << 3 | dec2[v[3]] >> 2;
  id[2] = (dec2[v[3]] & 3) << 6 | dec2[v[4]] << 1 | dec2[v[5]] >> 4;
  id[3] = (dec2[v[5]] & 15) << 4 | dec2[v[6]] >> 1;
  id[4] = (dec2[v[6]] & 1) << 7 | dec2[v[7]] << 2 | dec2[v[8]] >> 3;
  id[5] = (dec2[v[8]] & 7) << 5 | dec2[v[9]];
  id[6] = dec2[v[10]] << 3 | dec2[v[11]] >> 2;
  id[7] = (dec2[v[11]] & 3) << 6 | dec2[v[12]] << 1 | dec2[v[13]] >> 4;
  id[8] = (dec2[v[13]] & 15) << 4 | dec2[v[14]] >> 1;
  id[9] = (dec2[v[14]] & 1) << 7 | dec2[v[15]] << 2 | dec2[v[16]] >> 3;
  id[10] = (dec2[v[16]] & 7) << 5 | dec2[v[17]];
  id[11] = dec2[v[18]] << 3 | dec2[v[19]] >> 2;
  id[12] = (dec2[v[19]] & 3) << 6 | dec2[v[20]] << 1 | dec2[v[21]] >> 4;
  id[13] = (dec2[v[21]] & 15) << 4 | dec2[v[22]] >> 1;
  id[14] = (dec2[v[22]] & 1) << 7 | dec2[v[23]] << 2 | dec2[v[24]] >> 3;
  id[15] = (dec2[v[24]] & 7) << 5 | dec2[v[25]];
  return id;
}

// node_modules/@tbdex/http-client/node_modules/typeid-js/dist/chunk-5QL2QZCM.mjs
var import_dist140 = __toESM(require_dist(), 1);
function parseUUID2(uuid) {
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}

// node_modules/@tbdex/http-client/node_modules/typeid-js/dist/chunk-R5Q6Z3GN.mjs
var import_dist141 = __toESM(require_dist(), 1);
var __pow2 = Math.pow;

// node_modules/@tbdex/http-client/node_modules/typeid-js/dist/chunk-FOHWUNKU.mjs
var DIGITS2 = "0123456789abcdef";
var UUID2 = class {
  /** @param bytes - The 16-byte byte array representation. */
  constructor(bytes) {
    this.bytes = bytes;
    if (bytes.length !== 16) {
      throw new TypeError("not 128-bit length");
    }
  }
  /**
   * Builds a byte array from UUIDv7 field values.
   *
   * @param unixTsMs - A 48-bit `unix_ts_ms` field value.
   * @param randA - A 12-bit `rand_a` field value.
   * @param randBHi - The higher 30 bits of 62-bit `rand_b` field value.
   * @param randBLo - The lower 32 bits of 62-bit `rand_b` field value.
   */
  static fromFieldsV7(unixTsMs, randA, randBHi, randBLo) {
    if (!Number.isInteger(unixTsMs) || !Number.isInteger(randA) || !Number.isInteger(randBHi) || !Number.isInteger(randBLo) || unixTsMs < 0 || randA < 0 || randBHi < 0 || randBLo < 0 || unixTsMs > 281474976710655 || randA > 4095 || randBHi > 1073741823 || randBLo > 4294967295) {
      throw new RangeError("invalid field value");
    }
    const bytes = new Uint8Array(16);
    bytes[0] = unixTsMs / __pow2(2, 40);
    bytes[1] = unixTsMs / __pow2(2, 32);
    bytes[2] = unixTsMs / __pow2(2, 24);
    bytes[3] = unixTsMs / __pow2(2, 16);
    bytes[4] = unixTsMs / __pow2(2, 8);
    bytes[5] = unixTsMs;
    bytes[6] = 112 | randA >>> 8;
    bytes[7] = randA;
    bytes[8] = 128 | randBHi >>> 24;
    bytes[9] = randBHi >>> 16;
    bytes[10] = randBHi >>> 8;
    bytes[11] = randBHi;
    bytes[12] = randBLo >>> 24;
    bytes[13] = randBLo >>> 16;
    bytes[14] = randBLo >>> 8;
    bytes[15] = randBLo;
    return new UUID2(bytes);
  }
  /** @returns The 8-4-4-4-12 canonical hexadecimal string representation. */
  toString() {
    let text = "";
    for (let i = 0; i < this.bytes.length; i++) {
      text += DIGITS2.charAt(this.bytes[i] >>> 4);
      text += DIGITS2.charAt(this.bytes[i] & 15);
      if (i === 3 || i === 5 || i === 7 || i === 9) {
        text += "-";
      }
    }
    return text;
  }
  /** Creates an object from `this`. */
  clone() {
    return new UUID2(this.bytes.slice(0));
  }
  /** Returns true if `this` is equivalent to `other`. */
  equals(other) {
    return this.compareTo(other) === 0;
  }
  /**
   * Returns a negative integer, zero, or positive integer if `this` is less
   * than, equal to, or greater than `other`, respectively.
   */
  compareTo(other) {
    for (let i = 0; i < 16; i++) {
      const diff = this.bytes[i] - other.bytes[i];
      if (diff !== 0) {
        return Math.sign(diff);
      }
    }
    return 0;
  }
};
var V7Generator2 = class {
  constructor() {
    this.timestamp = 0;
    this.counter = 0;
    this.random = new DefaultRandom2();
  }
  /**
   * Generates a new UUIDv7 object from the current timestamp, or resets the
   * generator upon significant timestamp rollback.
   *
   * This method returns monotonically increasing UUIDs unless the up-to-date
   * timestamp is significantly (by ten seconds or more) smaller than the one
   * embedded in the immediately preceding UUID. If such a significant clock
   * rollback is detected, this method resets the generator and returns a new
   * UUID based on the current timestamp.
   */
  generate() {
    const value = this.generateOrAbort();
    if (value !== void 0) {
      return value;
    } else {
      this.timestamp = 0;
      return this.generateOrAbort();
    }
  }
  /**
   * Generates a new UUIDv7 object from the current timestamp, or returns
   * `undefined` upon significant timestamp rollback.
   *
   * This method returns monotonically increasing UUIDs unless the up-to-date
   * timestamp is significantly (by ten seconds or more) smaller than the one
   * embedded in the immediately preceding UUID. If such a significant clock
   * rollback is detected, this method aborts and returns `undefined`.
   */
  generateOrAbort() {
    const MAX_COUNTER = 4398046511103;
    const ROLLBACK_ALLOWANCE = 1e4;
    const ts = Date.now();
    if (ts > this.timestamp) {
      this.timestamp = ts;
      this.resetCounter();
    } else if (ts + ROLLBACK_ALLOWANCE > this.timestamp) {
      this.counter++;
      if (this.counter > MAX_COUNTER) {
        this.timestamp++;
        this.resetCounter();
      }
    } else {
      return void 0;
    }
    return UUID2.fromFieldsV7(this.timestamp, Math.trunc(this.counter / __pow2(2, 30)), this.counter & __pow2(2, 30) - 1, this.random.nextUint32());
  }
  /** Initializes the counter at a 42-bit random integer. */
  resetCounter() {
    this.counter = this.random.nextUint32() * 1024 + (this.random.nextUint32() & 1023);
  }
};
var getRandomValues2 = (buffer) => {
  if (typeof UUIDV7_DENY_WEAK_RNG !== "undefined" && UUIDV7_DENY_WEAK_RNG) {
    throw new Error("no cryptographically strong RNG available");
  }
  for (let i = 0; i < buffer.length; i++) {
    buffer[i] = Math.trunc(Math.random() * 65536) * 65536 + Math.trunc(Math.random() * 65536);
  }
  return buffer;
};
if (typeof crypto !== "undefined" && crypto.getRandomValues) {
  getRandomValues2 = (buffer) => crypto.getRandomValues(buffer);
}
var DefaultRandom2 = class {
  constructor() {
    this.buffer = new Uint32Array(8);
    this.cursor = 99;
  }
  nextUint32() {
    if (this.cursor >= this.buffer.length) {
      getRandomValues2(this.buffer);
      this.cursor = 0;
    }
    return this.buffer[this.cursor++];
  }
};
var defaultGenerator2;
var uuidv7obj2 = () => (defaultGenerator2 || (defaultGenerator2 = new V7Generator2())).generate();
function isValidPrefix2(str) {
  if (str.length > 63) {
    return false;
  }
  let code;
  let i;
  let len;
  for (i = 0, len = str.length; i < len; i += 1) {
    code = str.charCodeAt(i);
    if (!(code > 96 && code < 123)) {
      return false;
    }
  }
  return true;
}
var TypeID2 = class {
  constructor(prefix, suffix = "") {
    this.prefix = prefix;
    this.suffix = suffix;
    if (!isValidPrefix2(prefix)) {
      throw new Error("Invalid prefix. Must be at most 63 ascii letters [a-z]");
    }
    this.prefix = prefix;
    if (suffix) {
      this.suffix = suffix;
    } else {
      const uuid = uuidv7obj2();
      this.suffix = encode3(uuid.bytes);
    }
    if (this.suffix.length !== 26) {
      throw new Error(`Invalid length. Suffix should have 26 characters, got ${suffix.length}`);
    }
    if (this.suffix[0] > "7") {
      throw new Error("Invalid suffix. First character must be in the range [0-7]");
    }
    const unused = decode3(this.suffix);
  }
  getType() {
    return this.prefix;
  }
  getSuffix() {
    return this.suffix;
  }
  asType(prefix) {
    const self = this;
    if (self.prefix !== prefix) {
      throw new Error(`Cannot convert TypeID of type ${self.prefix} to type ${prefix}`);
    }
    return self;
  }
  toUUIDBytes() {
    return decode3(this.suffix);
  }
  toUUID() {
    const uuid = new UUID2(this.toUUIDBytes());
    return uuid.toString();
  }
  toString() {
    if (this.prefix === "") {
      return this.suffix;
    }
    return `${this.prefix}_${this.suffix}`;
  }
  static fromString(str) {
    const parts = str.split("_");
    if (parts.length === 1) {
      return new TypeID2("", parts[0]);
    }
    if (parts.length === 2) {
      if (parts[0] === "") {
        throw new Error(`Invalid TypeID. Prefix cannot be empty when there's a separator: ${str}`);
      }
      return new TypeID2(parts[0], parts[1]);
    }
    throw new Error(`Invalid TypeID string: ${str}`);
  }
  static fromUUIDBytes(prefix, bytes) {
    const suffix = encode3(bytes);
    return new TypeID2(prefix, suffix);
  }
  static fromUUID(prefix, uuid) {
    const suffix = encode3(parseUUID2(uuid));
    return new TypeID2(prefix, suffix);
  }
};
function typeid2(prefix = "", suffix = "") {
  return new TypeID2(prefix, suffix);
}

// node_modules/@tbdex/http-client/node_modules/@web5/credentials/dist/esm/index.js
var import_dist150 = __toESM(require_dist());

// node_modules/@tbdex/http-client/node_modules/@web5/credentials/dist/esm/jwt.js
var import_dist144 = __toESM(require_dist(), 1);
var __awaiter45 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var crypto4 = new LocalKeyManager2();
var Jwt2 = class _Jwt {
  /**
   * Creates a signed JWT.
   *
   * @example
   * ```ts
   * const jwt = await Jwt.sign({ signerDid: myDid, payload: myPayload });
   * ```
   *
   * @param options - Parameters for JWT creation including signer DID and payload.
   * @returns The compact JWT as a string.
   */
  static sign(options) {
    return __awaiter45(this, void 0, void 0, function* () {
      const { signerDid, payload } = options;
      const signer = yield signerDid.getSigner();
      let vmId = signer.keyId;
      if (vmId.charAt(0) === "#") {
        vmId = `${signerDid.uri}${vmId}`;
      }
      const header = {
        typ: "JWT",
        alg: signer.algorithm,
        kid: vmId
      };
      const base64UrlEncodedHeader = Convert2.object(header).toBase64Url();
      const base64UrlEncodedPayload = Convert2.object(payload).toBase64Url();
      const toSign = `${base64UrlEncodedHeader}.${base64UrlEncodedPayload}`;
      const toSignBytes = Convert2.string(toSign).toUint8Array();
      const signatureBytes = yield signer.sign({ data: toSignBytes });
      const base64UrlEncodedSignature = Convert2.uint8Array(signatureBytes).toBase64Url();
      return `${toSign}.${base64UrlEncodedSignature}`;
    });
  }
  /**
   * Verifies a JWT.
   *
   * @example
   * ```ts
   * const verifiedJwt = await Jwt.verify({ jwt: myJwt });
   * ```
   *
   * @param options - Parameters for JWT verification
   * @returns Verified JWT information including signer DID, header, and payload.
   */
  static verify(options) {
    return __awaiter45(this, void 0, void 0, function* () {
      const { decoded: decodedJwt, encoded: encodedJwt } = _Jwt.parse({ jwt: options.jwt });
      if (decodedJwt.payload.exp && Math.floor(Date.now() / 1e3) > decodedJwt.payload.exp) {
        throw new Error(`Verification failed: JWT is expired`);
      }
      const dereferenceResult = yield _Jwt.didResolver.dereference(decodedJwt.header.kid);
      if (dereferenceResult.dereferencingMetadata.error) {
        throw new Error(`Failed to resolve ${decodedJwt.header.kid}`);
      }
      const verificationMethod = dereferenceResult.contentStream;
      if (!verificationMethod || !utils_exports5.isDidVerificationMethod(verificationMethod)) {
        throw new Error("Verification failed: Expected kid in JWT header to dereference a DID Document Verification Method");
      }
      const publicKeyJwk = verificationMethod.publicKeyJwk;
      if (!publicKeyJwk) {
        throw new Error("Verification failed: Expected kid in JWT header to dereference to a DID Document Verification Method with publicKeyJwk");
      }
      if (publicKeyJwk.alg && publicKeyJwk.alg !== decodedJwt.header.alg) {
        throw new Error("Verification failed: Expected alg in JWT header to match DID Document Verification Method alg");
      }
      const signedData = `${encodedJwt.header}.${encodedJwt.payload}`;
      const signedDataBytes = Convert2.string(signedData).toUint8Array();
      const signatureBytes = Convert2.base64Url(encodedJwt.signature).toUint8Array();
      const isSignatureValid = yield crypto4.verify({
        key: publicKeyJwk,
        signature: signatureBytes,
        data: signedDataBytes
      });
      if (!isSignatureValid) {
        throw new Error("Signature verification failed: Integrity mismatch");
      }
      return decodedJwt;
    });
  }
  /**
   * Parses a JWT without verifying its signature.
   *
   * @example
   * ```ts
   * const { encoded: encodedJwt, decoded: decodedJwt } = Jwt.parse({ jwt: myJwt });
   * ```
   *
   * @param options - Parameters for JWT decoding, including the JWT string.
   * @returns both encoded and decoded JWT parts
   */
  static parse(options) {
    const splitJwt = options.jwt.split(".");
    if (splitJwt.length !== 3) {
      throw new Error(`Verification failed: Malformed JWT. expected 3 parts. got ${splitJwt.length}`);
    }
    const [base64urlEncodedJwtHeader, base64urlEncodedJwtPayload, base64urlEncodedSignature] = splitJwt;
    let jwtHeader;
    let jwtPayload;
    try {
      jwtHeader = Convert2.base64Url(base64urlEncodedJwtHeader).toObject();
    } catch (e) {
      throw new Error("Verification failed: Malformed JWT. Invalid base64url encoding for JWT header");
    }
    if (!jwtHeader.typ || jwtHeader.typ !== "JWT") {
      throw new Error("Verification failed: Expected JWT header to contain typ property set to JWT");
    }
    if (!jwtHeader.alg || !jwtHeader.kid) {
      throw new Error("Verification failed: Expected JWT header to contain alg and kid");
    }
    try {
      jwtPayload = Convert2.base64Url(base64urlEncodedJwtPayload).toObject();
    } catch (e) {
      throw new Error("Verification failed: Malformed JWT. Invalid base64url encoding for JWT payload");
    }
    return {
      decoded: {
        header: jwtHeader,
        payload: jwtPayload
      },
      encoded: {
        header: base64urlEncodedJwtHeader,
        payload: base64urlEncodedJwtPayload,
        signature: base64urlEncodedSignature
      }
    };
  }
};
Jwt2.didResolver = new UniversalResolver2({ didResolvers: [DidDht2, DidIon2, DidKey2, DidJwk2, DidWeb2] });

// node_modules/@tbdex/http-client/node_modules/@web5/credentials/dist/esm/presentation-exchange.js
var import_dist145 = __toESM(require_dist(), 1);
var PresentationExchange2 = class {
  /**
   * Selects credentials that satisfy a given presentation definition.
   *
   * @param params - The parameters for the credential selection.
   * @param params.vcJwts  The list of Verifiable Credentials to select from.
   * @param params.presentationDefinition The Presentation Definition to match against.
   * @returns {string[]} selectedVcJwts A list of Verifiable Credentials that satisfy the Presentation Definition.
   */
  static selectCredentials({ vcJwts, presentationDefinition }) {
    var _a, _b;
    this.resetPex();
    const selectResults = this.pex.selectFrom(presentationDefinition, vcJwts);
    if (((_a = selectResults.errors) === null || _a === void 0 ? void 0 : _a.length) !== 0) {
      return [];
    }
    return Array.from(new Set((_b = selectResults.verifiableCredential) !== null && _b !== void 0 ? _b : []));
  }
  /**
   * Validates if a list of VC JWTs satisfies the given presentation definition.
   *
   * @param params - The parameters for the satisfaction check.
   * @param params.vcJwts - An array of VC JWTs as strings.
   * @param params.presentationDefinition - The criteria to validate against.
   * @throws Error if the evaluation results in warnings or errors.
   */
  static satisfiesPresentationDefinition({ vcJwts, presentationDefinition }) {
    var _a, _b, _c;
    this.resetPex();
    const evaluationResults = this.pex.evaluateCredentials(presentationDefinition, vcJwts);
    if ((_a = evaluationResults.warnings) === null || _a === void 0 ? void 0 : _a.length) {
      console.warn("Warnings were generated during the evaluation process: " + JSON.stringify(evaluationResults.warnings));
    }
    if (evaluationResults.areRequiredCredentialsPresent.toString() !== "info" || ((_b = evaluationResults.errors) === null || _b === void 0 ? void 0 : _b.length)) {
      let errorMessage = "Failed to create Verifiable Presentation JWT due to: ";
      if (evaluationResults.areRequiredCredentialsPresent) {
        errorMessage += "Required Credentials Not Present: " + JSON.stringify(evaluationResults.areRequiredCredentialsPresent);
      }
      if ((_c = evaluationResults.errors) === null || _c === void 0 ? void 0 : _c.length) {
        errorMessage += "Errors: " + JSON.stringify(evaluationResults.errors);
      }
      throw new Error(errorMessage);
    }
  }
  /**
   * Creates a presentation from a list of Verifiable Credentials that satisfy a given presentation definition.
   * This function initializes the Presentation Exchange (PEX) process, validates the presentation definition,
   * evaluates the credentials against the definition, and finally constructs the presentation result if the
   * evaluation is successful.
   *
   * @param params - The parameters for the presentation creation.
   * @param params.vcJwts The list of Verifiable Credentials (VCs) in JWT format to be evaluated.
   * @param params.presentationDefinition The Presentation Definition V2 to match the VCs against.
   * @returns {PresentationResult} The result of the presentation creation process, containing a presentation submission
   *                               that satisfies the presentation definition criteria.
   * @throws {Error} If the evaluation results in warnings or errors, or if the required credentials are not present,
   *                 an error is thrown with a descriptive message.
   */
  static createPresentationFromCredentials({ vcJwts, presentationDefinition }) {
    var _a, _b, _c;
    this.resetPex();
    const pdValidated = PEX.validateDefinition(presentationDefinition);
    isValid2(pdValidated);
    const evaluationResults = this.pex.evaluateCredentials(presentationDefinition, vcJwts);
    if ((_a = evaluationResults.warnings) === null || _a === void 0 ? void 0 : _a.length) {
      console.warn("Warnings were generated during the evaluation process: " + JSON.stringify(evaluationResults.warnings));
    }
    if (evaluationResults.areRequiredCredentialsPresent.toString() !== "info" || ((_b = evaluationResults.errors) === null || _b === void 0 ? void 0 : _b.length)) {
      let errorMessage = "Failed to create Verifiable Presentation JWT due to: ";
      if (evaluationResults.areRequiredCredentialsPresent) {
        errorMessage += "Required Credentials Not Present: " + JSON.stringify(evaluationResults.areRequiredCredentialsPresent);
      }
      if ((_c = evaluationResults.errors) === null || _c === void 0 ? void 0 : _c.length) {
        errorMessage += "Errors: " + JSON.stringify(evaluationResults.errors);
      }
      throw new Error(errorMessage);
    }
    const presentationResult = this.pex.presentationFrom(presentationDefinition, vcJwts);
    const submissionValidated = PEX.validateSubmission(presentationResult.presentationSubmission);
    isValid2(submissionValidated);
    return presentationResult;
  }
  /**
   * This method validates whether an object is usable as a presentation definition or not.
   *
   * @param {PresentationDefinitionV2} presentationDefinition: presentationDefinition to be validated.
   * @returns {Validated} the validation results to reveal what is acceptable/unacceptable about the passed object to be considered a valid presentation definition
   */
  static validateDefinition({ presentationDefinition }) {
    return PEX.validateDefinition(presentationDefinition);
  }
  /**
   * This method validates whether an object is usable as a presentation submission or not.
   *
   * @param {PresentationSubmission} presentationSubmission the object to be validated.
   * @returns {Validated} the validation results to reveal what is acceptable/unacceptable about the passed object to be considered a valid presentation submission
   */
  static validateSubmission({ presentationSubmission }) {
    return PEX.validateSubmission(presentationSubmission);
  }
  /**
   * Evaluates a presentation against a presentation definition.
   *
   * @returns {EvaluationResults} The result of the evaluation process.
   */
  static evaluatePresentation({ presentationDefinition, presentation }) {
    this.resetPex();
    return this.pex.evaluatePresentation(presentationDefinition, presentation);
  }
  /** Resets the PEX instance. */
  static resetPex() {
    this.pex = new PEX();
  }
};
PresentationExchange2.pex = new PEX();
function isValid2(validated) {
  let errorMessage = "Failed to pass validation check due to: ";
  if (Array.isArray(validated)) {
    if (!validated.every((item) => item.status === "info")) {
      errorMessage += "Validation Errors: " + JSON.stringify(validated);
      throw new Error(errorMessage);
    }
  } else {
    if (validated.status !== "info") {
      errorMessage += "Validation Errors: " + JSON.stringify(validated);
      throw new Error(errorMessage);
    }
  }
}

// node_modules/@tbdex/http-client/node_modules/@web5/credentials/dist/esm/verifiable-credential.js
var import_dist149 = __toESM(require_dist(), 1);

// node_modules/@tbdex/http-client/node_modules/@web5/credentials/dist/esm/validators.js
var import_dist148 = __toESM(require_dist(), 1);

// node_modules/@tbdex/http-client/node_modules/@web5/credentials/dist/esm/utils.js
var utils_exports6 = {};
__export(utils_exports6, {
  getCurrentXmlSchema112Timestamp: () => getCurrentXmlSchema112Timestamp2,
  getFutureXmlSchema112Timestamp: () => getFutureXmlSchema112Timestamp2,
  getXmlSchema112Timestamp: () => getXmlSchema112Timestamp2,
  isValidRFC3339Timestamp: () => isValidRFC3339Timestamp2,
  isValidXmlSchema112Timestamp: () => isValidXmlSchema112Timestamp2
});
var import_dist146 = __toESM(require_dist(), 1);
function getCurrentXmlSchema112Timestamp2() {
  return (/* @__PURE__ */ new Date()).toISOString().replace(/\.\d+Z$/, "Z");
}
function getXmlSchema112Timestamp2(timestampInSeconds) {
  const date = new Date(timestampInSeconds * 1e3);
  return date.toISOString().replace(/\.\d{3}/, "");
}
function getFutureXmlSchema112Timestamp2(secondsInFuture) {
  const futureDate = new Date(Date.now() + secondsInFuture * 1e3);
  return futureDate.toISOString().replace(/\.\d+Z$/, "Z");
}
function isValidXmlSchema112Timestamp2(timestamp) {
  const regex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z$/;
  if (!regex.test(timestamp)) {
    return false;
  }
  const date = new Date(timestamp);
  return !isNaN(date.getTime());
}
function isValidRFC3339Timestamp2(timestamp) {
  const regex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[+-]\d{2}:\d{2})$/;
  if (!regex.test(timestamp)) {
    return false;
  }
  const date = new Date(timestamp);
  return !isNaN(date.getTime());
}

// node_modules/@tbdex/http-client/node_modules/@web5/credentials/dist/esm/verifiable-presentation.js
var import_dist147 = __toESM(require_dist(), 1);

// node_modules/query-string/index.js
var import_dist155 = __toESM(require_dist());

// node_modules/query-string/base.js
var base_exports = {};
__export(base_exports, {
  exclude: () => exclude,
  extract: () => extract,
  parse: () => parse,
  parseUrl: () => parseUrl,
  pick: () => pick,
  stringify: () => stringify,
  stringifyUrl: () => stringifyUrl
});
var import_dist154 = __toESM(require_dist(), 1);

// node_modules/decode-uri-component/index.js
var import_dist151 = __toESM(require_dist());
var token = "%[a-f0-9]{2}";
var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
var multiMatcher = new RegExp("(" + token + ")+", "gi");
function decodeComponents(components, split) {
  try {
    return [decodeURIComponent(components.join(""))];
  } catch {
  }
  if (components.length === 1) {
    return components;
  }
  split = split || 1;
  const left = components.slice(0, split);
  const right = components.slice(split);
  return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}
function decode4(input) {
  try {
    return decodeURIComponent(input);
  } catch {
    let tokens = input.match(singleMatcher) || [];
    for (let i = 1; i < tokens.length; i++) {
      input = decodeComponents(tokens, i).join("");
      tokens = input.match(singleMatcher) || [];
    }
    return input;
  }
}
function customDecodeURIComponent(input) {
  const replaceMap = {
    "%FE%FF": "��",
    "%FF%FE": "��"
  };
  let match = multiMatcher.exec(input);
  while (match) {
    try {
      replaceMap[match[0]] = decodeURIComponent(match[0]);
    } catch {
      const result = decode4(match[0]);
      if (result !== match[0]) {
        replaceMap[match[0]] = result;
      }
    }
    match = multiMatcher.exec(input);
  }
  replaceMap["%C2"] = "�";
  const entries = Object.keys(replaceMap);
  for (const key of entries) {
    input = input.replace(new RegExp(key, "g"), replaceMap[key]);
  }
  return input;
}
function decodeUriComponent(encodedURI) {
  if (typeof encodedURI !== "string") {
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
  }
  try {
    return decodeURIComponent(encodedURI);
  } catch {
    return customDecodeURIComponent(encodedURI);
  }
}

// node_modules/split-on-first/index.js
var import_dist152 = __toESM(require_dist());
function splitOnFirst(string, separator) {
  if (!(typeof string === "string" && typeof separator === "string")) {
    throw new TypeError("Expected the arguments to be of type `string`");
  }
  if (string === "" || separator === "") {
    return [];
  }
  const separatorIndex = string.indexOf(separator);
  if (separatorIndex === -1) {
    return [];
  }
  return [
    string.slice(0, separatorIndex),
    string.slice(separatorIndex + separator.length)
  ];
}

// node_modules/filter-obj/index.js
var import_dist153 = __toESM(require_dist());
function includeKeys(object, predicate) {
  const result = {};
  if (Array.isArray(predicate)) {
    for (const key of predicate) {
      const descriptor = Object.getOwnPropertyDescriptor(object, key);
      if (descriptor == null ? void 0 : descriptor.enumerable) {
        Object.defineProperty(result, key, descriptor);
      }
    }
  } else {
    for (const key of Reflect.ownKeys(object)) {
      const descriptor = Object.getOwnPropertyDescriptor(object, key);
      if (descriptor.enumerable) {
        const value = object[key];
        if (predicate(key, value, object)) {
          Object.defineProperty(result, key, descriptor);
        }
      }
    }
  }
  return result;
}

// node_modules/query-string/base.js
var isNullOrUndefined = (value) => value === null || value === void 0;
var strictUriEncode = (string) => encodeURIComponent(string).replace(/[!'()*]/g, (x) => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);
var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
function encoderForArrayFormat(options) {
  switch (options.arrayFormat) {
    case "index": {
      return (key) => (result, value) => {
        const index = result.length;
        if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
          return result;
        }
        if (value === null) {
          return [
            ...result,
            [encode4(key, options), "[", index, "]"].join("")
          ];
        }
        return [
          ...result,
          [encode4(key, options), "[", encode4(index, options), "]=", encode4(value, options)].join("")
        ];
      };
    }
    case "bracket": {
      return (key) => (result, value) => {
        if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
          return result;
        }
        if (value === null) {
          return [
            ...result,
            [encode4(key, options), "[]"].join("")
          ];
        }
        return [
          ...result,
          [encode4(key, options), "[]=", encode4(value, options)].join("")
        ];
      };
    }
    case "colon-list-separator": {
      return (key) => (result, value) => {
        if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
          return result;
        }
        if (value === null) {
          return [
            ...result,
            [encode4(key, options), ":list="].join("")
          ];
        }
        return [
          ...result,
          [encode4(key, options), ":list=", encode4(value, options)].join("")
        ];
      };
    }
    case "comma":
    case "separator":
    case "bracket-separator": {
      const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
      return (key) => (result, value) => {
        if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
          return result;
        }
        value = value === null ? "" : value;
        if (result.length === 0) {
          return [[encode4(key, options), keyValueSep, encode4(value, options)].join("")];
        }
        return [[result, encode4(value, options)].join(options.arrayFormatSeparator)];
      };
    }
    default: {
      return (key) => (result, value) => {
        if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
          return result;
        }
        if (value === null) {
          return [
            ...result,
            encode4(key, options)
          ];
        }
        return [
          ...result,
          [encode4(key, options), "=", encode4(value, options)].join("")
        ];
      };
    }
  }
}
function parserForArrayFormat(options) {
  let result;
  switch (options.arrayFormat) {
    case "index": {
      return (key, value, accumulator) => {
        result = /\[(\d*)]$/.exec(key);
        key = key.replace(/\[\d*]$/, "");
        if (!result) {
          accumulator[key] = value;
          return;
        }
        if (accumulator[key] === void 0) {
          accumulator[key] = {};
        }
        accumulator[key][result[1]] = value;
      };
    }
    case "bracket": {
      return (key, value, accumulator) => {
        result = /(\[])$/.exec(key);
        key = key.replace(/\[]$/, "");
        if (!result) {
          accumulator[key] = value;
          return;
        }
        if (accumulator[key] === void 0) {
          accumulator[key] = [value];
          return;
        }
        accumulator[key] = [...accumulator[key], value];
      };
    }
    case "colon-list-separator": {
      return (key, value, accumulator) => {
        result = /(:list)$/.exec(key);
        key = key.replace(/:list$/, "");
        if (!result) {
          accumulator[key] = value;
          return;
        }
        if (accumulator[key] === void 0) {
          accumulator[key] = [value];
          return;
        }
        accumulator[key] = [...accumulator[key], value];
      };
    }
    case "comma":
    case "separator": {
      return (key, value, accumulator) => {
        const isArray = typeof value === "string" && value.includes(options.arrayFormatSeparator);
        const isEncodedArray = typeof value === "string" && !isArray && decode5(value, options).includes(options.arrayFormatSeparator);
        value = isEncodedArray ? decode5(value, options) : value;
        const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode5(item, options)) : value === null ? value : decode5(value, options);
        accumulator[key] = newValue;
      };
    }
    case "bracket-separator": {
      return (key, value, accumulator) => {
        const isArray = /(\[])$/.test(key);
        key = key.replace(/\[]$/, "");
        if (!isArray) {
          accumulator[key] = value ? decode5(value, options) : value;
          return;
        }
        const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode5(item, options));
        if (accumulator[key] === void 0) {
          accumulator[key] = arrayValue;
          return;
        }
        accumulator[key] = [...accumulator[key], ...arrayValue];
      };
    }
    default: {
      return (key, value, accumulator) => {
        if (accumulator[key] === void 0) {
          accumulator[key] = value;
          return;
        }
        accumulator[key] = [...[accumulator[key]].flat(), value];
      };
    }
  }
}
function validateArrayFormatSeparator(value) {
  if (typeof value !== "string" || value.length !== 1) {
    throw new TypeError("arrayFormatSeparator must be single character string");
  }
}
function encode4(value, options) {
  if (options.encode) {
    return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
  }
  return value;
}
function decode5(value, options) {
  if (options.decode) {
    return decodeUriComponent(value);
  }
  return value;
}
function keysSorter(input) {
  if (Array.isArray(input)) {
    return input.sort();
  }
  if (typeof input === "object") {
    return keysSorter(Object.keys(input)).sort((a, b) => Number(a) - Number(b)).map((key) => input[key]);
  }
  return input;
}
function removeHash(input) {
  const hashStart = input.indexOf("#");
  if (hashStart !== -1) {
    input = input.slice(0, hashStart);
  }
  return input;
}
function getHash(url) {
  let hash = "";
  const hashStart = url.indexOf("#");
  if (hashStart !== -1) {
    hash = url.slice(hashStart);
  }
  return hash;
}
function parseValue(value, options) {
  if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
    value = Number(value);
  } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
    value = value.toLowerCase() === "true";
  }
  return value;
}
function extract(input) {
  input = removeHash(input);
  const queryStart = input.indexOf("?");
  if (queryStart === -1) {
    return "";
  }
  return input.slice(queryStart + 1);
}
function parse(query, options) {
  options = {
    decode: true,
    sort: true,
    arrayFormat: "none",
    arrayFormatSeparator: ",",
    parseNumbers: false,
    parseBooleans: false,
    ...options
  };
  validateArrayFormatSeparator(options.arrayFormatSeparator);
  const formatter = parserForArrayFormat(options);
  const returnValue = /* @__PURE__ */ Object.create(null);
  if (typeof query !== "string") {
    return returnValue;
  }
  query = query.trim().replace(/^[?#&]/, "");
  if (!query) {
    return returnValue;
  }
  for (const parameter of query.split("&")) {
    if (parameter === "") {
      continue;
    }
    const parameter_ = options.decode ? parameter.replace(/\+/g, " ") : parameter;
    let [key, value] = splitOnFirst(parameter_, "=");
    if (key === void 0) {
      key = parameter_;
    }
    value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode5(value, options);
    formatter(decode5(key, options), value, returnValue);
  }
  for (const [key, value] of Object.entries(returnValue)) {
    if (typeof value === "object" && value !== null) {
      for (const [key2, value2] of Object.entries(value)) {
        value[key2] = parseValue(value2, options);
      }
    } else {
      returnValue[key] = parseValue(value, options);
    }
  }
  if (options.sort === false) {
    return returnValue;
  }
  return (options.sort === true ? Object.keys(returnValue).sort() : Object.keys(returnValue).sort(options.sort)).reduce((result, key) => {
    const value = returnValue[key];
    result[key] = Boolean(value) && typeof value === "object" && !Array.isArray(value) ? keysSorter(value) : value;
    return result;
  }, /* @__PURE__ */ Object.create(null));
}
function stringify(object, options) {
  if (!object) {
    return "";
  }
  options = {
    encode: true,
    strict: true,
    arrayFormat: "none",
    arrayFormatSeparator: ",",
    ...options
  };
  validateArrayFormatSeparator(options.arrayFormatSeparator);
  const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
  const formatter = encoderForArrayFormat(options);
  const objectCopy = {};
  for (const [key, value] of Object.entries(object)) {
    if (!shouldFilter(key)) {
      objectCopy[key] = value;
    }
  }
  const keys = Object.keys(objectCopy);
  if (options.sort !== false) {
    keys.sort(options.sort);
  }
  return keys.map((key) => {
    const value = object[key];
    if (value === void 0) {
      return "";
    }
    if (value === null) {
      return encode4(key, options);
    }
    if (Array.isArray(value)) {
      if (value.length === 0 && options.arrayFormat === "bracket-separator") {
        return encode4(key, options) + "[]";
      }
      return value.reduce(formatter(key), []).join("&");
    }
    return encode4(key, options) + "=" + encode4(value, options);
  }).filter((x) => x.length > 0).join("&");
}
function parseUrl(url, options) {
  var _a;
  options = {
    decode: true,
    ...options
  };
  let [url_, hash] = splitOnFirst(url, "#");
  if (url_ === void 0) {
    url_ = url;
  }
  return {
    url: ((_a = url_ == null ? void 0 : url_.split("?")) == null ? void 0 : _a[0]) ?? "",
    query: parse(extract(url), options),
    ...options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode5(hash, options) } : {}
  };
}
function stringifyUrl(object, options) {
  options = {
    encode: true,
    strict: true,
    [encodeFragmentIdentifier]: true,
    ...options
  };
  const url = removeHash(object.url).split("?")[0] || "";
  const queryFromUrl = extract(object.url);
  const query = {
    ...parse(queryFromUrl, { sort: false }),
    ...object.query
  };
  let queryString = stringify(query, options);
  if (queryString) {
    queryString = `?${queryString}`;
  }
  let hash = getHash(object.url);
  if (object.fragmentIdentifier) {
    const urlObjectForFragmentEncode = new URL(url);
    urlObjectForFragmentEncode.hash = object.fragmentIdentifier;
    hash = options[encodeFragmentIdentifier] ? urlObjectForFragmentEncode.hash : `#${object.fragmentIdentifier}`;
  }
  return `${url}${queryString}${hash}`;
}
function pick(input, filter, options) {
  options = {
    parseFragmentIdentifier: true,
    [encodeFragmentIdentifier]: false,
    ...options
  };
  const { url, query, fragmentIdentifier } = parseUrl(input, options);
  return stringifyUrl({
    url,
    query: includeKeys(query, filter),
    fragmentIdentifier
  }, options);
}
function exclude(input, filter, options) {
  const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
  return pick(input, exclusionFilter, options);
}

// node_modules/query-string/index.js
var query_string_default = base_exports;

// node_modules/@tbdex/http-client/dist/esm/src/client.js
var import_ms3 = __toESM(require_ms2(), 1);
var requestTokenRequiredClaims = ["aud", "iss", "exp", "iat", "jti"];
var TbdexHttpClient = class _TbdexHttpClient {
  /**
   * Sends an RFQ and options to the PFI to initiate an exchange
   * @param rfq - The RFQ message that will be sent to the PFI
   * @param opts.replyTo A callback URL where the PFI will send subsequent messages
   * @throws if message verification fails
   * @throws if recipient DID resolution fails
   * @throws if recipient DID does not have a PFI service entry
   */
  static async createExchange(rfq2, opts) {
    await rfq2.verify();
    const { to: pfiDid } = rfq2.metadata;
    const requestBody = JSON.stringify({ rfq: rfq2, replyTo: opts == null ? void 0 : opts.replyTo });
    await _TbdexHttpClient.sendMessage(pfiDid, "POST", `/exchanges`, requestBody);
  }
  /**
   * Sends the Order message to the PFI
   * @param - order The Order message that will be sent to the PFI
   * @throws if message verification fails
   * @throws if recipient DID resolution fails
   * @throws if recipient DID does not have a PFI service entry
   */
  static async submitOrder(order2) {
    await order2.verify();
    const { to: pfiDid, exchangeId } = order2.metadata;
    const requestBody = JSON.stringify(order2);
    await _TbdexHttpClient.sendMessage(pfiDid, "PUT", `/exchanges/${exchangeId}`, requestBody);
  }
  /**
   * Sends the Close message to the PFI
   * @param - close The Close message that will be sent to the PFI
   * @throws if message verification fails
   * @throws if recipient DID resolution fails
   * @throws if recipient DID does not have a PFI service entry
   */
  static async submitClose(close2) {
    await close2.verify();
    const { to: pfiDid, exchangeId } = close2.metadata;
    const requestBody = JSON.stringify(close2);
    await _TbdexHttpClient.sendMessage(pfiDid, "PUT", `/exchanges/${exchangeId}`, requestBody);
  }
  static async sendMessage(pfiDid, verb, path, requestBody) {
    const pfiServiceEndpoint = await _TbdexHttpClient.getPfiServiceEndpoint(pfiDid);
    const apiRoute = `${pfiServiceEndpoint}${path}`;
    let response;
    try {
      response = await fetch(apiRoute, {
        method: verb,
        headers: { "content-type": "application/json" },
        body: requestBody
      });
    } catch (e) {
      throw new RequestError({ message: `Failed to send message to ${pfiDid}`, recipientDid: pfiDid, url: apiRoute, cause: e });
    }
    if (!response.ok) {
      const errorDetails = await response.json();
      throw new ResponseError({ statusCode: response.status, details: errorDetails, recipientDid: pfiDid, url: apiRoute });
    }
  }
  /**
   * gets offerings from the pfi provided
   * @param opts - options
   * @beta
   */
  static async getOfferings(opts) {
    const { pfiDid } = opts;
    const pfiServiceEndpoint = await _TbdexHttpClient.getPfiServiceEndpoint(pfiDid);
    const apiRoute = `${pfiServiceEndpoint}/offerings`;
    let response;
    try {
      response = await fetch(apiRoute);
    } catch (e) {
      throw new RequestError({ message: `Failed to get offerings from ${pfiDid}`, recipientDid: pfiDid, url: apiRoute, cause: e });
    }
    const offerings = [];
    if (!response.ok) {
      const errorDetails = await response.json();
      throw new ResponseError({ statusCode: response.status, details: errorDetails, recipientDid: pfiDid, url: apiRoute });
    }
    const responseBody = await response.json();
    const jsonOfferings = responseBody.data;
    for (let jsonOffering of jsonOfferings) {
      const offering2 = await Offering.parse(jsonOffering);
      offerings.push(offering2);
    }
    return offerings;
  }
  /**
   * gets balances from the pfi provided
   * @param opts - options
   * @beta
   */
  static async getBalances(opts) {
    const { pfiDid, did } = opts;
    const pfiServiceEndpoint = await _TbdexHttpClient.getPfiServiceEndpoint(pfiDid);
    const apiRoute = `${pfiServiceEndpoint}/balances`;
    const requestToken = await _TbdexHttpClient.generateRequestToken({ requesterDid: did, pfiDid });
    let response;
    try {
      response = await fetch(apiRoute, {
        headers: {
          authorization: `Bearer ${requestToken}`
        }
      });
    } catch (e) {
      throw new RequestError({ message: `Failed to get balances from ${pfiDid}`, recipientDid: pfiDid, url: apiRoute, cause: e });
    }
    if (!response.ok) {
      const errorDetails = await response.json();
      throw new ResponseError({ statusCode: response.status, details: errorDetails, recipientDid: pfiDid, url: apiRoute });
    }
    const responseBody = await response.json();
    const data = responseBody.data;
    return data;
  }
  /**
   * get a specific exchange from the pfi provided
   * @param opts - options
   */
  static async getExchange(opts) {
    const { pfiDid, exchangeId, did } = opts;
    const pfiServiceEndpoint = await _TbdexHttpClient.getPfiServiceEndpoint(pfiDid);
    const apiRoute = `${pfiServiceEndpoint}/exchanges/${exchangeId}`;
    const requestToken = await _TbdexHttpClient.generateRequestToken({ requesterDid: did, pfiDid });
    let response;
    try {
      response = await fetch(apiRoute, {
        headers: {
          authorization: `Bearer ${requestToken}`
        }
      });
    } catch (e) {
      throw new RequestError({ message: `Failed to get exchange from ${pfiDid}`, recipientDid: pfiDid, url: apiRoute, cause: e });
    }
    const messages = [];
    if (!response.ok) {
      const errorDetails = await response.json();
      throw new ResponseError({ statusCode: response.status, details: errorDetails, recipientDid: pfiDid, url: apiRoute });
    }
    const responseBody = await response.json();
    for (let jsonMessage of responseBody.data) {
      const message2 = await Parser.parseMessage(jsonMessage);
      messages.push(message2);
    }
    return messages;
  }
  // TODO: Wrap Message[] in Exchange object and verify each message
  /**
   * returns all exchanges created by requester
   * @param opts - options
   */
  static async getExchanges(opts) {
    const { pfiDid, filter, did } = opts;
    const pfiServiceEndpoint = await _TbdexHttpClient.getPfiServiceEndpoint(pfiDid);
    const queryParams = filter ? `?${query_string_default.stringify(filter)}` : "";
    const apiRoute = `${pfiServiceEndpoint}/exchanges${queryParams}`;
    const requestToken = await _TbdexHttpClient.generateRequestToken({ requesterDid: did, pfiDid });
    let response;
    try {
      response = await fetch(apiRoute, {
        headers: {
          authorization: `Bearer ${requestToken}`
        }
      });
    } catch (e) {
      throw new RequestError({ message: `Failed to get exchanges from ${pfiDid}`, recipientDid: pfiDid, url: apiRoute, cause: e });
    }
    const exchanges = [];
    if (!response.ok) {
      const errorDetails = await response.json();
      throw new ResponseError({ statusCode: response.status, details: errorDetails, recipientDid: pfiDid, url: apiRoute });
    }
    const responseBody = await response.json();
    for (let jsonExchange of responseBody.data) {
      const exchange = [];
      for (let jsonMessage of jsonExchange) {
        const message2 = await Parser.parseMessage(jsonMessage);
        exchange.push(message2);
      }
      exchanges.push(exchange);
    }
    return exchanges;
  }
  /**
   * returns the PFI service entry from the DID Doc of the DID provided
   * @param did - the pfi's DID
   */
  static async getPfiServiceEndpoint(did) {
    let didDocument;
    try {
      didDocument = await resolveDid(did);
    } catch (e) {
      throw new InvalidDidError(e.message);
    }
    const [didService] = utils_exports5.getServices({ didDocument, type: "PFI" });
    if (!(didService == null ? void 0 : didService.serviceEndpoint)) {
      throw new MissingServiceEndpointError(`${did} has no PFI service entry`);
    }
    return didService.serviceEndpoint;
  }
  /**
  * Creates and signs a request token ([JWT](https://datatracker.ietf.org/doc/html/rfc7519))
  * that's included as the value of Authorization header for requests sent to a PFI API's
  * endpoints that require authentication
  *
  * JWT payload with the following claims:
  *  * `aud`
  *  * `iss`
  *  * `exp`
  *  * `iat`
  *  * `jti` The JWT is then signed and returned.
  *
  * @returns the request token (JWT)
  * @throws {@link RequestTokenSigningError} If an error occurs during the token generation.
  */
  static async generateRequestToken(params) {
    const { pfiDid, requesterDid } = params;
    const now = Date.now();
    const exp = now + (0, import_ms3.default)("1m");
    const jwtPayload = {
      aud: pfiDid,
      iss: requesterDid.uri,
      exp: Math.floor(exp / 1e3),
      iat: Math.floor(now / 1e3),
      jti: typeid2().getSuffix()
    };
    try {
      return await Jwt2.sign({ signerDid: requesterDid, payload: jwtPayload });
    } catch (e) {
      throw new RequestTokenSigningError({ message: e.message, cause: e });
    }
  }
  /**
   * Validates and verifies the integrity of a request token ([JWT](https://datatracker.ietf.org/doc/html/rfc7519))
   * generated by {@link TbdexHttpClient.generateRequestToken}. Specifically:
   *   * verifies integrity of the JWT
   *   * ensures all required claims are present and valid.
   *   * ensures the token has not expired
   *   * ensures token audience matches the expected PFI DID.
   *
   * @returns the requester's DID as a string if the token is valid.
   * @throws {@link RequestTokenVerificationError} If the token is invalid, expired, or has been tampered with
   * @throws {@link RequestTokenMissingClaimsError} If the token does not contain all required claims
   * @throws {@link RequestTokenAudienceMismatchError} If the token's `aud` property does not match the PFI's DID
  */
  static async verifyRequestToken(params) {
    let result;
    try {
      result = await Jwt2.verify({ jwt: params.requestToken });
    } catch (e) {
      throw new RequestTokenVerificationError({ message: e.message, cause: e });
    }
    const { header: requestTokenHeader, payload: requestTokenPayload } = result;
    for (let claim of requestTokenRequiredClaims) {
      if (!requestTokenPayload[claim]) {
        throw new RequestTokenMissingClaimsError({ message: `Request token missing ${claim} claim. Expected ${requestTokenRequiredClaims}.` });
      }
    }
    if (requestTokenPayload.aud !== params.pfiDid) {
      throw new RequestTokenAudienceMismatchError({ message: "Request token contains invalid audience. Expected aud property to be PFI DID." });
    }
    const signerKid = requestTokenHeader.kid;
    const issuerDid = requestTokenPayload.iss;
    if (!signerKid.includes(issuerDid)) {
      throw new RequestTokenIssuerSignerMismatchError({ message: "Request token issuer does not match signer" });
    }
    return issuerDid;
  }
};

// node_modules/@tbdex/http-client/dist/esm/src/types.js
var import_dist157 = __toESM(require_dist(), 1);
export {
  Balance,
  Close,
  Crypto,
  DevTools,
  DidResolver,
  Exchange,
  InvalidDidError,
  Message,
  MissingServiceEndpointError,
  Offering,
  Order,
  OrderStatus,
  Parser,
  Quote,
  RequestError,
  RequestTokenAudienceMismatchError,
  RequestTokenError,
  RequestTokenIssuerSignerMismatchError,
  RequestTokenMissingClaimsError,
  RequestTokenSigningError,
  RequestTokenVerificationError,
  Resource,
  ResponseError,
  Rfq,
  TbdexHttpClient,
  ValidationError,
  isVerificationMethod,
  requestTokenRequiredClaims,
  resolveDid
};
/*! Bundled license information:

typeid-js/dist/chunk-FOHWUNKU.mjs:
  (*! Bundled license information:
  
  uuidv7/dist/index.js:
    (**
     * uuidv7: An experimental implementation of the proposed UUID Version 7
     *
     * @license Apache-2.0
     * @copyright 2021-2023 LiosK
     * @packageDocumentation
     *)
  *)

typeid-js/dist/chunk-FOHWUNKU.mjs:
  (*! Bundled license information:
  
  uuidv7/dist/index.js:
    (**
     * uuidv7: An experimental implementation of the proposed UUID Version 7
     *
     * @license Apache-2.0
     * @copyright 2021-2023 LiosK
     * @packageDocumentation
     *)
  *)
*/
//# sourceMappingURL=@tbdex_http-client.js.map
