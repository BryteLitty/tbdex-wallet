{
  "version": 3,
  "sources": ["../../@web5/credentials/node_modules/ms/index.js", "../../@web5/credentials/src/index.ts", "../../@web5/credentials/node_modules/@web5/dids/src/index.ts", "../../@web5/credentials/node_modules/@web5/dids/src/types/did-core.ts", "../../@web5/credentials/node_modules/@web5/dids/src/did.ts", "../../@web5/credentials/node_modules/@web5/dids/src/did-error.ts", "../../@web5/credentials/node_modules/@web5/dids/src/utils.ts", "../../@web5/credentials/node_modules/@web5/dids/src/bearer-did.ts", "../../@web5/credentials/node_modules/@web5/dids/src/methods/did-method.ts", "../../@web5/credentials/node_modules/@web5/dids/src/resolver/resolver-cache-noop.ts", "../../@web5/credentials/node_modules/@web5/dids/src/resolver/did-resolver.ts", "../../@web5/credentials/node_modules/@web5/dids/src/methods/did-dht.ts", "../../@web5/credentials/node_modules/@web5/dids/src/methods/did-ion.ts", "../../@web5/credentials/node_modules/@web5/dids/src/methods/did-jwk.ts", "../../@web5/credentials/node_modules/@web5/dids/src/methods/did-key.ts", "../../@web5/credentials/node_modules/@web5/dids/src/methods/did-web.ts", "../../@web5/credentials/node_modules/@web5/dids/src/resolver/resolver-cache-level.ts", "../../@web5/credentials/src/jwt.ts", "../../@web5/credentials/src/presentation-exchange.ts", "../../@web5/credentials/src/validators.ts", "../../@web5/credentials/src/utils.ts", "../../@web5/credentials/src/verifiable-presentation.ts", "../../@web5/credentials/src/verifiable-credential.ts"],
  "sourcesContent": ["/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n", "export * from './jwt.js';\nexport * from './presentation-exchange.js';\nexport * from './verifiable-credential.js';\nexport * as utils from './utils.js';", "export * from './types/did-core.js';\nexport type * from './types/multibase.js';\nexport type * from './types/portable-did.js';\n\nexport * from './did.js';\nexport * from './did-error.js';\nexport * from './bearer-did.js';\n\nexport * from './methods/did-dht.js';\nexport * from './methods/did-ion.js';\nexport * from './methods/did-jwk.js';\nexport * from './methods/did-key.js';\nexport * from './methods/did-method.js';\nexport * from './methods/did-web.js';\n\nexport * from './resolver/did-resolver.js';\nexport * from './resolver/resolver-cache-level.js';\nexport * from './resolver/resolver-cache-noop.js';\n\nexport * as utils from './utils.js';", "import { Jwk } from '@web5/crypto';\n\n/**\n * Represents metadata related to the process of DID dereferencing.\n *\n * This type includes fields that provide information about the outcome of a DID dereferencing operation,\n * including the content type of the returned resource and any errors that occurred during the dereferencing process.\n *\n * @see {@link https://www.w3.org/TR/did-core/#did-url-dereferencing-metadata | DID Core Specification, ยง DID URL Dereferencing Metadata}\n */\nexport type DidDereferencingMetadata = {\n  /**\n   * The Media Type of the returned contentStream SHOULD be expressed using this property if\n   * dereferencing is successful.\n   */\n  contentType?: string;\n\n  /**\n   * The error code from the dereferencing process. This property is REQUIRED when there is an\n   * error in the dereferencing process. The value of this property MUST be a single keyword\n   * expressed as an ASCII string. The possible property values of this field SHOULD be registered\n   * in the {@link https://www.w3.org/TR/did-spec-registries/ | DID Specification Registries}.\n   * The DID Core specification defines the following common error values:\n   *\n   * - `invalidDidUrl`: The DID URL supplied to the DID URL dereferencing function does not conform\n   *                    to valid syntax.\n   * - `notFound`: The DID URL dereferencer was unable to find the `contentStream` resulting from\n   *               this dereferencing request.\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#did-url-dereferencing-metadata | DID Core Specification, ยง DID URL Dereferencing Metadata}\n   */\n  error?: string;\n\n  // Additional output metadata generated during DID Resolution.\n  [key: string]: any;\n}\n\n/**\n * Represents the options that can be used during the process of DID dereferencing.\n *\n * This interface allows the caller to specify preferences and additional parameters for the DID\n * dereferencing operation.\n *\n * @see {@link https://www.w3.org/TR/did-core/#did-url-dereferencing-options}\n */\nexport interface DidDereferencingOptions {\n  /** The Media Type that the caller prefers for contentStream. */\n  accept?: string;\n\n  /** Additional properties used during DID dereferencing. */\n  [key: string]: any;\n}\n\n/**\n * Represents the result of a DID dereferencing operation.\n *\n * This type encapsulates the outcomes of the DID URL dereferencing process, including metadata\n * about the dereferencing operation, the content stream retrieved (if any), and metadata about the\n * content stream.\n *\n * @see {@link https://www.w3.org/TR/did-core/#did-url-dereferencing | DID Core Specification, ยง DID URL Dereferencing}\n */\nexport type DidDereferencingResult = {\n  /**\n   * A metadata structure consisting of values relating to the results of the DID URL dereferencing\n   * process. This structure is REQUIRED, and in the case of an error in the dereferencing process,\n   * this MUST NOT be empty. Properties defined by this specification are in 7.2.2 DID URL\n   * Dereferencing Metadata. If the dereferencing is not successful, this structure MUST contain an\n   * `error` property describing the error.\n   */\n  dereferencingMetadata: DidDereferencingMetadata;\n\n  /**\n   * If the `dereferencing` function was called and successful, this MUST contain a resource\n   * corresponding to the DID URL. The contentStream MAY be a resource such as:\n   *   - a DID document that is serializable in one of the conformant representations\n   *   - a Verification Method\n   *   - a service.\n   *   - any other resource format that can be identified via a Media Type and obtained through the\n   *     resolution process.\n   *\n   * If the dereferencing is unsuccessful, this value MUST be empty.\n   */\n  contentStream: DidResource | null;\n\n  /**\n   * If the dereferencing is successful, this MUST be a metadata structure, but the structure MAY be\n   * empty. This structure contains metadata about the contentStream. If the contentStream is a DID\n   * document, this MUST be a didDocumentMetadata structure as described in DID Resolution. If the\n   * dereferencing is unsuccessful, this output MUST be an empty metadata structure.\n   */\n  contentMetadata: DidDocumentMetadata;\n}\n\n/**\n * A set of data describing the Decentralized Identifierr (DID) subject.\n *\n * A DID Document contains information associated with the DID, such as cryptographic public keys\n * and service endpoints, enabling trustable interactions associated with the DID subject.\n *\n * - Cryptographic public keys - Used by the DID subject or a DID delegate to authenticate itself\n *                               and prove its association with the DID.\n * - Service endpoints - Used to communicate or interact with the DID subject or associated\n *                       entities. Examples include discovery, agent, social networking, file\n *                       storage, and verifiable credential repository services.\n *\n * A DID Document can be retrieved by resolving a DID, as described in\n * {@link https://www.w3.org/TR/did-core/#did-resolution | DID Core Specification, ยง DID Resolution}.\n */\nexport interface DidDocument {\n  /**\n   * A JSON-LD context link, which provides a JSON-LD processor with the information necessary to\n   * interpret the DID document JSON. The default context URL is 'https://www.w3.org/ns/did/v1'.\n   */\n  '@context'?: 'https://www.w3.org/ns/did/v1' | string | (string | Record<string, any>)[];\n\n  /**\n   * The DID Subject to which this DID Document pertains.\n   *\n   * The `id` property is REQUIRED and must be a valid DID.\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#did-subject | DID Core Specification, ยง DID Subject}\n   */\n  id: string;\n\n  /**\n   * A DID subject can have multiple identifiers for different purposes, or at different times.\n   * The assertion that two or more DIDs (or other types of URI) refer to the same DID subject can\n   * be made using the `alsoKnownAs` property.\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#also-known-as | DID Core Specification, ยง Also Known As}\n   */\n  alsoKnownAs?: string[];\n\n  /**\n   * A DID controller is an entity that is authorized to make changes to a DID document. Typically,\n   * only the DID Subject (i.e., the value of `id` property in the DID document) is authoritative.\n   * However, another DID can be specified as the DID controller, and when doing so, any\n   * verification methods contained in the DID document for the other DID should be accepted as\n   * authoritative.  In other words, proofs created by the controller DID should be considered\n   * equivalent to proofs created by the DID Subject.\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#did-controller | DID Core Specification, ยง DID Controller}\n   */\n  controller?: string | string[];\n\n  /**\n   * A DID document can express verification methods, such as cryptographic public keys, which can\n   * be used to authenticate or authorize interactions with the DID subject or associated parties.\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#verification-methods | DID Core Specification, ยง Verification Methods}\n   */\n  verificationMethod?: DidVerificationMethod[];\n\n  /**\n   * The `assertionMethod` verification relationship is used to specify how the DID subject is\n   * expected to express claims, such as for the purposes of issuing a Verifiable Credential.\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#assertion | DID Core Specification, ยง Assertion}\n   */\n  assertionMethod?: (DidVerificationMethod | string)[];\n\n  /**\n   * The `authentication` verification relationship is used to specify how the DID subject is expected\n   * to be authenticated, for purposes such as logging into a website or engaging in any sort of\n   * challenge-response protocol.\n\n   * @see {@link https://www.w3.org/TR/did-core/#authentication | DID Core Specification, ยง Authentication}\n   */\n  authentication?: (DidVerificationMethod | string)[];\n\n  /**\n   * The `keyAgreement` verification relationship is used to specify how an entity can generate\n   * encryption material in order to transmit confidential  information intended for the DID\n   * subject, such as for the purposes of establishing a secure communication channel with the\n   * recipient.\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#key-agreement | DID Core Specification, ยง Key Agreement}\n   */\n  keyAgreement?: (DidVerificationMethod | string)[];\n\n  /**\n   *  The `capabilityDelegation` verification relationship is used to specify a mechanism that might\n   * be used by the DID subject to delegate a cryptographic capability to another party, such as\n   * delegating the authority to access a specific HTTP API to a subordinate.\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#capability-delegation | DID Core Specification, ยง Capability Delegation}\n   */\n  capabilityDelegation?: (DidVerificationMethod | string)[];\n\n  /**\n   * The `capabilityInvocation` verification relationship is used to specify a verification method\n   * that might be used by the DID subject to invoke a cryptographic capability, such as the\n   * authorization to update the DID Document.\n   */\n  capabilityInvocation?: (DidVerificationMethod | string)[];\n\n  /**\n   * Services are used in DID documents to express ways of communicating with the DID subject or\n   * associated entities. A service can be any type of service the DID subject wants to advertise,\n   * including decentralized identity management services for further discovery, authentication,\n   * authorization, or interaction.\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#services | DID Core Specification, ยง Services}\n   */\n  service?: DidService[];\n}\n\n/**\n * Represents metadata about the DID document resulting from a DID resolution operation.\n *\n * This metadata typically does not change between invocations of the `resolve` and\n * `resolveRepresentation` functions unless the DID document changes, as it represents metadata\n * about the DID document.\n *\n * @see {@link https://www.w3.org/TR/did-core/#did-document-metadata | DID Core Specification, ยง DID Document Metadata}\n */\nexport interface DidDocumentMetadata {\n  /**\n   * Timestamp of the Create operation.\n   *\n   * The value of the property MUST be a string formatted as an XML Datetime normalized to\n   * UTC 00:00:00 and  without sub-second decimal precision. For example: `2020-12-20T19:17:47Z`.\n   */\n  created?: string;\n\n  /**\n   * Timestamp of the last Update operation for the document version which was resolved.\n   *\n   * The value of the property MUST follow the same formatting rules as the `created` property.\n   * The `updated` property is omitted if an Update operation has never been performed on the DID\n   * document. If an `updated` property exists, it can be the same value as the `created` property\n   * when the difference between the two timestamps is less than one second.\n   */\n  updated?: string;\n\n  /**\n   * Whether the DID has been deactivated.\n   *\n   * If a DID has been deactivated, DID document metadata MUST include this property with the\n   * boolean value `true`. If a DID has not been deactivated, this properrty is OPTIONAL, but if\n   * present, MUST have the boolean value `false`.\n   */\n  deactivated?: boolean;\n\n  /**\n   * Version ID of the last Update operation for the document version which was resolved.\n   */\n  versionId?: string;\n\n  /**\n   * Timestamp of the next Update operation if the resolved document version is not the latest\n   * version of the document.\n   *\n   * The value of the property MUST follow the same formatting rules as the `created` property.\n   */\n  nextUpdate?: string;\n\n  /**\n   * Version ID of the next Update operation if the resolved document version is not the latest\n   * version of the document.\n   */\n  nextVersionId?: string;\n\n  /**\n   * A DID method can define different forms of a DID that are logically equivalent. An example is\n   * when a DID takes one form prior to registration in a verifiable data registry and another form\n   * after such registration. In this case, the DID method specification might need to express one\n   * or more DIDs that are logically equivalent to the resolved DID as a property of the DID\n   * document. This is the purpose of the `equivalentId` property.\n   *\n   * A requesting party is expected to retain the values from the id and equivalentId properties to\n   * ensure any subsequent interactions with any of the values they contain are correctly handled as\n   * logically equivalent (e.g., retain all variants in a database so an interaction with any one\n   * maps to the same underlying account).\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#dfn-equivalentid | DID Core Specification, ยง DID Document Metadata}\n  */\n equivalentId?: string[];\n\n /**\n  * The `canonicalId` property is identical to the `equivalentId` property except:\n  * - it is associated with a single value rather than a set\n  * - the DID is defined to be the canonical ID for the DID subject within the scope of the\n  *   containing DID document.\n  *\n  * A requesting party is expected to use the `canonicalId` value as its primary ID value for the\n  * DID subject and treat all other equivalent values as secondary aliases (e.g., update\n  * corresponding primary references in their systems to reflect the new canonical ID directive).\n  *\n   * @see {@link https://www.w3.org/TR/did-core/#dfn-canonicalid | DID Core Specification, ยง DID Document Metadata}\n   */\n  canonicalId?: string;\n\n  // Additional output metadata generated during DID Resolution.\n  [key: string]: any;\n}\n\n/**\n * Represents metadata related to the result of a DID resolution operation.\n *\n * This type includes fields that provide information about the outcome of a DID resolution process,\n * including the content type of the returned DID document and any errors that occurred during the\n * resolution process.\n *\n * This metadata typically changes between invocations of the `resolve` and `resolveRepresentation`\n * functions, as it represents data about the resolution process itself.\n *\n * @see {@link https://www.w3.org/TR/did-core/#did-resolution-metadata | DID Core Specification, ยง DID Resolution Metadata}\n */\nexport type DidResolutionMetadata = {\n  /**\n   * The Media Type of the returned `didDocumentStream`.\n   *\n   * This property is REQUIRED if resolution is successful and if the `resolveRepresentation`\n   * function was called. This property MUST NOT be present if the `resolve` function was called.\n   * The value of this property MUST be an ASCII string that is the Media Type of the conformant\n   * representations. The caller of the `resolveRepresentation` function MUST use this value when\n   * determining how to parse and process the `didDocumentStream` returned by this function into the\n   * data model.\n   */\n  contentType?: string;\n\n  /**\n   * An error code indicating issues encountered during the DID Resolution or DID URL\n   * Dereferencing process.\n   *\n   * Defined error codes include:\n   *   - `internalError`: An unexpected error occurred during DID Resolution or DID URL\n   *                      dereferencing process.\n   *   - `invalidDid`: The provided DID is invalid.\n   *   - `methodNotSupported`: The DID method specified is not supported.\n   *   - `notFound`: The DID or DID URL does not exist.\n   *   - `representationNotSupported`: The DID document representation is not supported.\n   *   - Custom error codes can also be provided as strings.\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#did-resolution-metadata | DID Core Specification, ยง DID Resolution Metadata}\n   * @see {@link https://www.w3.org/TR/did-spec-registries/#error | DID Specification Registries, ยง Error}\n   */\n  error?: string;\n\n  // Additional output metadata generated during DID Resolution.\n  [key: string]: any;\n};\n\n/**\n * DID Resolution input metadata.\n*\n* The DID Core specification defines the following common properties:\n*  - `accept`: The Media Type that the caller prefers for the returned representation of the DID\n*              Document.\n*\n* The possible properties within this structure and their possible values are registered in the\n* {@link https://www.w3.org/TR/did-spec-registries/#did-resolution-options | DID Specification Registries}.\n *\n * @see {@link https://www.w3.org/TR/did-core/#did-resolution-options | DID Core Specification, ยง DID Resolution Options}\n */\nexport interface DidResolutionOptions {\n  /**\n   * The Media Type that the caller prefers for the returned representation of the DID Document.\n   *\n   * This property is REQUIRED if the `resolveRepresentation` function was called. This property\n   * MUST NOT be present if the `resolve` function was called.\n   *\n   * The value of this property MUST be an ASCII string that is the Media Type of the conformant\n   * representations. The caller of the `resolveRepresentation` function MUST use this value when\n   * determining how to parse and process the `didDocumentStream` returned by this function into the\n   * data model.\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#did-resolution-options | DID Core Specification, ยง DID Resolution Options}\n   */\n  accept?: string;\n\n  // Additional properties used during DID Resolution.\n  [key: string]: any;\n}\n\n/**\n * Represents the result of a Decentralized Identifier (DID) resolution operation.\n *\n * This type encapsulates the complete outcome of resolving a DID, including the resolution metadata,\n * the DID document (if resolution is successful), and metadata about the DID document.\n *\n * @see {@link https://www.w3.org/TR/did-core/#did-resolution | DID Core Specification, ยง DID Resolution}\n */\nexport type DidResolutionResult = {\n  /**\n   * A JSON-LD context link, which provides the JSON-LD processor with the information necessary to\n   * interpret the resolution result JSON. The default context URL is\n   * 'https://w3id.org/did-resolution/v1'.\n   */\n  '@context'?: 'https://w3id.org/did-resolution/v1' | string | (string | Record<string, any>)[];\n\n  /**\n   * A metadata structure consisting of values relating to the results of the DID resolution\n   * process.\n   *\n   * This structure is REQUIRED, and in the case of an error in the resolution process,\n   * this MUST NOT be empty. If the resolution is not successful, this structure MUST contain an\n   * `error` property describing the error.\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#dfn-didresolutionmetadata | DID Core Specification, ยง DID Resolution Metadata}\n   */\n  didResolutionMetadata: DidResolutionMetadata;\n\n  /**\n   * The DID document resulting from the resolution process, if successful.\n   *\n   * If the `resolve` function was called and successful, this MUST contain a DID document\n   * corresponding to the DID. If the resolution is unsuccessful, this value MUST be empty.\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#dfn-diddocument | DID Core Specification, ยง DID Document}\n   */\n  didDocument: DidDocument | null;\n\n  /**\n   * Metadata about the DID Document.\n   *\n   * This structure contains information about the DID Document like creation and update timestamps,\n   * deactivation status, versioning information, and other details relevant to the DID Document.\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#dfn-diddocumentmetadata | DID Core Specification, ยง DID Document Metadata}\n   */\n  didDocumentMetadata: DidDocumentMetadata;\n};\n\n/**\n * A DID Resource is either a DID Document, a DID Verification method or a DID Service\n */\nexport type DidResource = DidDocument | DidService | DidVerificationMethod;\n\n/**\n * Services are used in DID documents to express ways of communicating with the DID subject or\n * associated entities. A service can be any type of service the DID subject wants to advertise.\n *\n * @see {@link https://www.w3.org/TR/did-core/#services}\n */\nexport type DidService = {\n  /**\n   * Identifier of the service.\n   *\n   * The `id` property is REQUIRED. It MUST be a URI conforming to\n   * {@link https://datatracker.ietf.org/doc/html/rfc3986 | RFC3986} and MUST be unique within the\n   * DID document.\n   */\n  id: string;\n\n  /**\n   * The type of service being described.\n   *\n   * The `type` property is REQUIRED. It MUST be a string. To maximize interoperability, the value\n   * SHOULD be registered in the\n   * {@link https://www.w3.org/TR/did-spec-registries/ | DID Specification Registries}. Examples of\n   * service types can be found in\n   * {@link https://www.w3.org/TR/did-spec-registries/#service-types | ยง Service Types}.\n   */\n  type: string;\n\n  /**\n   * A URI that can be used to interact with the DID service.\n   *\n   * The value of the `serviceEndpoint` property MUST be a string, an object containing key/value\n   * pairs, or an array composed of strings or objects. All string values MUST be valid URIs\n   * conforming to {@link https://datatracker.ietf.org/doc/html/rfc3986 | RFC3986}.\n   */\n  serviceEndpoint: DidServiceEndpoint | DidServiceEndpoint[];\n\n  // DID methods MAY include additional service properties.\n  [key: string]: any;\n};\n\n/**\n * A service endpoint is a URI (Uniform Resource Identifier) that can be used to interact with the\n * DID service.\n *\n * The value of the `serviceEndpoint` property MUST be a string or an object containing key/value\n * pairs. All string values MUST be valid URIs conforming to\n * {@link https://datatracker.ietf.org/doc/html/rfc3986 | RFC3986}.\n *\n * @see {@link https://www.w3.org/TR/did-core/#dfn-serviceendpoint | RFC3986, ยง 5.4 Services}\n */\nexport type DidServiceEndpoint = string | Record<string, any>;\n\n/**\n * Represents a verification method in the context of a DID document.\n *\n * A verification method is a mechanism by which a DID controller can cryptographically assert proof\n * of ownership or control over a DID or DID document. This can include, but is not limited to,\n * cryptographic public keys or other data that can be used to authenticate or authorize actions.\n *\n * @see {@link https://www.w3.org/TR/did-core/#verification-methods | DID Core Specification, ยง Verification Methods}\n */\nexport interface DidVerificationMethod {\n  /**\n   * The identifier of the verification method, which must be a URI.\n   */\n  id: string;\n\n  /**\n   * The type of the verification method.\n   *\n   * To maximize interoperability this value SHOULD be one of the valid verification method types\n   * registered in the {@link https://www.w3.org/TR/did-spec-registries/#verification-method-types | DID Specification Registries}.\n   */\n  type: string;\n\n  /**\n   * The DID of the entity that controls this verification method.\n   */\n  controller: string;\n\n  /**\n   * (Optional) A public key in JWK format.\n   *\n   * A JSON Web Key (JWK) that conforms to {@link https://datatracker.ietf.org/doc/html/rfc7517 | RFC 7517}.\n   */\n  publicKeyJwk?: Jwk;\n\n  /**\n   * (Optional) A public key in Multibase format.\n   *\n   * A multibase key that conforms to the draft\n   * {@link https://datatracker.ietf.org/doc/draft-multiformats-multibase/ | Multibase specification}.\n   */\n  publicKeyMultibase?: string;\n}\n\n/**\n * Represents the various verification relationships defined in a DID document.\n *\n * These verification relationships indicate the intended usage of verification methods within a DID\n * document. Each relationship signifies a different purpose or context in which a verification\n * method can be used, such as authentication, assertionMethod, keyAgreement, capabilityDelegation,\n * and capabilityInvocation. The array provides a standardized set of relationship names for\n * consistent referencing and implementation across different DID methods.\n *\n * @see {@link https://www.w3.org/TR/did-core/#verification-relationships | DID Core Specification, ยง Verification Relationships}\n */\nexport enum DidVerificationRelationship {\n  /**\n   * Specifies how the DID subject is expected to be authenticated. This is commonly used for\n   * purposes like logging into a website or participating in challenge-response protocols.\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#authentication | DID Core Specification, ยง Authentication}\n   */\n  authentication = 'authentication',\n\n  /**\n   * Specifies how the DID subject is expected to express claims, such as for issuing Verifiable\n   * Credentials. This relationship is typically used when the DID subject is the issuer of a\n   * credential.\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#assertion | DID Core Specification, ยง Assertion}\n   */\n  assertionMethod = 'assertionMethod',\n\n  /**\n   * Specifies how an entity can generate encryption material to communicate confidentially with the\n   * DID subject. Often used in scenarios requiring secure communication channels.\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#key-agreement | DID Core Specification, ยง Key Agreement}\n   */\n  keyAgreement = 'keyAgreement',\n\n  /**\n   * Specifies a mechanism used by the DID subject to delegate a cryptographic capability to another\n   * party. This can include delegating access to a specific resource or API.\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#capability-delegation | DID Core Specification, ยง Capability Delegation}\n   */\n  capabilityDelegation = 'capabilityDelegation',\n\n  /**\n   * Specifies a verification method used by the DID subject to invoke a cryptographic capability.\n   * This is frequently associated with authorization actions, like updating the DID Document.\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#capability-invocation | DID Core Specification, ยง Capability Invocation}\n   */\n  capabilityInvocation = 'capabilityInvocation'\n}", "/**\n * The `Did` class represents a Decentralized Identifier (DID) Uniform Resource Identifier (URI).\n *\n * This class provides a method for parsing a DID URI string into its component parts, as well as a\n * method for serializing a DID URI object into a string.\n *\n * A DID URI is composed of the following components:\n * - scheme\n * - method\n * - id\n * - path\n * - query\n * - fragment\n * - params\n *\n * @see {@link https://www.w3.org/TR/did-core/#did-syntax | DID Core Specification, ยง DID Syntax}\n */\nexport class Did {\n  /** Regular expression pattern for matching the method component of a DID URI. */\n  static readonly METHOD_PATTERN = '([a-z0-9]+)';\n  /** Regular expression pattern for matching percent-encoded characters in a method identifier. */\n  static readonly PCT_ENCODED_PATTERN = '(?:%[0-9a-fA-F]{2})';\n  /** Regular expression pattern for matching the characters allowed in a method identifier. */\n  static readonly ID_CHAR_PATTERN = `(?:[a-zA-Z0-9._-]|${Did.PCT_ENCODED_PATTERN})`;\n  /** Regular expression pattern for matching the method identifier component of a DID URI. */\n  static readonly METHOD_ID_PATTERN = `((?:${Did.ID_CHAR_PATTERN}*:)*(${Did.ID_CHAR_PATTERN}+))`;\n  /** Regular expression pattern for matching the path component of a DID URI. */\n  static readonly PATH_PATTERN = `(/[^#?]*)?`;\n  /** Regular expression pattern for matching the query component of a DID URI. */\n  static readonly QUERY_PATTERN = `([?][^#]*)?`;\n  /** Regular expression pattern for matching the fragment component of a DID URI. */\n  static readonly FRAGMENT_PATTERN = `(#.*)?`;\n  /** Regular expression pattern for matching all of the components of a DID URI. */\n  static readonly DID_URI_PATTERN = new RegExp(\n    `^did:(?<method>${Did.METHOD_PATTERN}):(?<id>${Did.METHOD_ID_PATTERN})(?<path>${Did.PATH_PATTERN})(?<query>${Did.QUERY_PATTERN})(?<fragment>${Did.FRAGMENT_PATTERN})$`\n  );\n\n  /**\n   * A string representation of the DID.\n   *\n   * A DID is a URI composed of three parts: the scheme `did:`, a method identifier, and a unique,\n   * method-specific identifier specified by the DID method.\n   *\n   * @example\n   * did:dht:h4d3ixkwt6q5a455tucw7j14jmqyghdtbr6cpiz6on5oxj5bpr3o\n   */\n  uri: string;\n\n  /**\n   * The name of the DID method.\n   *\n   * Examples of DID method names are `dht`, `jwk`, and `web`, among others.\n   */\n  method: string;\n\n  /**\n   * The DID method identifier.\n   *\n   * @example\n   * h4d3ixkwt6q5a455tucw7j14jmqyghdtbr6cpiz6on5oxj5bpr3o\n   */\n  id: string;\n\n  /**\n      * Optional path component of the DID URI.\n      *\n      * @example\n      * did:web:tbd.website/path\n      */\n  path?: string;\n\n  /**\n      * Optional query component of the DID URI.\n      *\n      * @example\n      * did:web:tbd.website?versionId=1\n      */\n  query?: string;\n\n  /**\n   * Optional fragment component of the DID URI.\n   *\n   * @example\n   * did:web:tbd.website#key-1\n   */\n  fragment?: string;\n\n  /**\n    * Optional query parameters in the DID URI.\n    *\n    * @example\n    * did:web:tbd.website?service=files&relativeRef=/whitepaper.pdf\n    */\n  params?: Record<string, string>;\n\n  /**\n   * Constructs a new `Did` instance from individual components.\n   *\n   * @param params - An object containing the parameters to be included in the DID URI.\n   * @param params.method - The name of the DID method.\n   * @param params.id - The DID method identifier.\n   * @param params.path - Optional. The path component of the DID URI.\n   * @param params.query - Optional. The query component of the DID URI.\n   * @param params.fragment - Optional. The fragment component of the DID URI.\n   * @param params.params - Optional. The query parameters in the DID URI.\n   */\n  constructor({ method, id, path, query, fragment, params }: {\n    method: string,\n    id: string,\n    path?: string,\n    query?: string,\n    fragment?: string,\n    params?: Record<string, string>\n  }) {\n    this.uri = `did:${method}:${id}`;\n    this.method = method;\n    this.id = id;\n    this.path = path;\n    this.query = query;\n    this.fragment = fragment;\n    this.params = params;\n  }\n\n  /**\n   * Parses a DID URI string into its individual components.\n   *\n   * @example\n   * ```ts\n   * const did = Did.parse('did:example:123?service=agent&relativeRef=/credentials#degree');\n   *\n   * console.log(did.uri)      // Output: 'did:example:123'\n   * console.log(did.method)   // Output: 'example'\n   * console.log(did.id)       // Output: '123'\n   * console.log(did.query)    // Output: 'service=agent&relativeRef=/credentials'\n   * console.log(did.fragment) // Output: 'degree'\n   * console.log(did.params)   // Output: { service: 'agent', relativeRef: '/credentials' }\n   * ```\n   *\n   * @params didUri - The DID URI string to be parsed.\n   * @returns A `Did` object representing the parsed DID URI, or `null` if the input string is not a valid DID URI.\n   */\n  static parse(didUri: string): Did | null {\n    // Return null if the input string is empty or not provided.\n    if (!didUri) return null;\n\n    // Execute the regex pattern on the input string to extract URI components.\n    const match = Did.DID_URI_PATTERN.exec(didUri);\n\n    // If the pattern does not match, or if the required groups are not found, return null.\n    if (!match || !match.groups) return null;\n\n    // Extract the method, id, params, path, query, and fragment from the regex match groups.\n    const { method, id, path, query, fragment } = match.groups;\n\n    // Initialize a new Did object with the uri, method and id.\n    const did: Did = {\n      uri: `did:${method}:${id}`,\n      method,\n      id,\n    };\n\n    // If path is present, add it to the Did object.\n    if (path) did.path = path;\n\n    // If query is present, add it to the Did object, removing the leading '?'.\n    if (query) did.query = query.slice(1);\n\n    // If fragment is present, add it to the Did object, removing the leading '#'.\n    if (fragment) did.fragment = fragment.slice(1);\n\n    // If query params are present, parse them into a key-value object and add to the Did object.\n    if (query) {\n      const parsedParams = {} as Record<string, string>;\n      // Split the query string by '&' to get individual parameter strings.\n      const paramPairs = query.slice(1).split('&');\n      for (const pair of paramPairs) {\n        // Split each parameter string by '=' to separate keys and values.\n        const [key, value] = pair.split('=');\n        parsedParams[key] = value;\n      }\n      did.params = parsedParams;\n    }\n\n    return did;\n  }\n}", "/**\n * A custom error class for DID-related errors.\n */\nexport class DidError extends Error {\n  /**\n   * Constructs an instance of DidError, a custom error class for handling DID-related errors.\n   *\n   * @param code - A {@link DidErrorCode} representing the specific type of error encountered.\n   * @param message - A human-readable description of the error.\n   */\n  constructor(public code: DidErrorCode, message: string) {\n    super(message);\n    this.name = 'DidError';\n\n    // Ensures that instanceof works properly, the correct prototype chain when using inheritance,\n    // and that V8 stack traces (like Chrome, Edge, and Node.js) are more readable and relevant.\n    Object.setPrototypeOf(this, new.target.prototype);\n\n    // Captures the stack trace in V8 engines (like Chrome, Edge, and Node.js).\n    // In non-V8 environments, the stack trace will still be captured.\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, DidError);\n    }\n  }\n}\n\n/**\n * An enumeration of possible DID error codes.\n */\nexport enum DidErrorCode {\n  /** The DID supplied does not conform to valid syntax. */\n  InvalidDid = 'invalidDid',\n\n  /** The supplied method name is not supported by the DID method and/or DID resolver implementation. */\n  MethodNotSupported = 'methodNotSupported',\n\n  /** An unexpected error occurred during the requested DID operation. */\n  InternalError = 'internalError',\n\n  /** The DID document supplied does not conform to valid syntax. */\n  InvalidDidDocument = 'invalidDidDocument',\n\n  /** The byte length of a DID document does not match the expected value. */\n  InvalidDidDocumentLength = 'invalidDidDocumentLength',\n\n  /** The DID URL supplied to the dereferencing function does not conform to valid syntax. */\n  InvalidDidUrl = 'invalidDidUrl',\n\n  /** An invalid public key is detected during a DID operation. */\n  InvalidPublicKey = 'invalidPublicKey',\n\n  /** The byte length of a public key does not match the expected value. */\n  InvalidPublicKeyLength = 'invalidPublicKeyLength',\n\n  /** An invalid public key type was detected during a DID operation. */\n  InvalidPublicKeyType = 'invalidPublicKeyType',\n\n  /** Verification of a signature failed during a DID operation. */\n  InvalidSignature = 'invalidSignature',\n\n  /** The DID resolver was unable to find the DID document resulting from the resolution request. */\n  NotFound = 'notFound',\n\n  /**\n   * The representation requested via the `accept` input metadata property is not supported by the\n   * DID method and/or DID resolver implementation.\n   */\n  RepresentationNotSupported = 'representationNotSupported',\n\n  /** The type of a public key is not supported by the DID method and/or DID resolver implementation. */\n  UnsupportedPublicKeyType = 'unsupportedPublicKeyType',\n}", "import type { Jwk } from '@web5/crypto';\nimport type { RequireOnly } from '@web5/common';\n\nimport { Convert, Multicodec } from '@web5/common';\nimport { computeJwkThumbprint } from '@web5/crypto';\n\nimport type { KeyWithMulticodec } from './types/multibase.js';\n\nimport { DidError, DidErrorCode } from './did-error.js';\nimport {\n  DidService,\n  DidDocument,\n  DidVerificationMethod,\n  DidVerificationRelationship,\n} from './types/did-core.js';\n\n/**\n * Represents a Decentralized Web Node (DWN) service in a DID Document.\n *\n * A DWN DID service is a specialized type of DID service with the `type` set to\n * `DecentralizedWebNode`. It includes specific properties `enc` and `sig` that are used to identify\n * the public keys that can be used to interact with the DID Subject. The values of these properties\n * are strings or arrays of strings containing one or more verification method `id` values present in\n * the same DID document. If the `enc` and/or `sig` properties are an array of strings, an entity\n * interacting with the DID subject is expected to use the verification methods in the order they\n * are listed.\n *\n * @example\n * ```ts\n * const service: DwnDidService = {\n *   id: 'did:example:123#dwn',\n *   type: 'DecentralizedWebNode',\n *   serviceEndpoint: 'https://dwn.tbddev.org/dwn0',\n *   enc: 'did:example:123#key-1',\n *   sig: 'did:example:123#key-2'\n * }\n * ```\n *\n * @see {@link https://identity.foundation/decentralized-web-node/spec/ | DIF Decentralized Web Node (DWN) Specification}\n */\nexport interface DwnDidService extends DidService {\n  /**\n   * One or more verification method `id` values that can be used to encrypt information\n   * intended for the DID subject.\n   */\n  enc?: string | string[];\n\n  /**\n   * One or more verification method `id` values that will be used by the DID subject to sign data\n   * or by another entity to verify signatures created by the DID subject.\n   */\n  sig: string | string[];\n}\n\n/**\n * Extracts the fragment part of a Decentralized Identifier (DID) verification method identifier.\n *\n * This function takes any input and aims to return only the fragment of a DID identifier,\n * which comes after the '#' symbol in a DID string. It's designed specifically for handling\n * DID verification method identifiers. The function returns undefined for non-string inputs, inputs\n * that do not contain a '#', or complex data structures like objects or arrays, ensuring that only\n * the fragment part of a DID string is extracted when present.\n *\n * @example\n * ```ts\n * console.log(extractDidFragment(\"did:example:123#key-1\")); // Output: \"key-1\"\n * console.log(extractDidFragment(\"did:example:123\")); // Output: undefined\n * console.log(extractDidFragment({ id: \"did:example:123#0\", type: \"JsonWebKey\" })); // Output: undefined\n * console.log(extractDidFragment(undefined)); // Output: undefined\n * ```\n *\n * @param input - The input to be processed. Can be of any type, but the function is designed\n *                to work with strings that represent DID verification method identifiers.\n * @returns The fragment part of the DID identifier if the input is a string containing a '#'.\n *          Returns an empty string for all other inputs, including non-string types, strings\n *          without a '#', and complex data structures.\n */\nexport function extractDidFragment(input: unknown): string | undefined {\n  if (typeof input !== 'string') return undefined;\n  if (input.length === 0) return undefined;\n  return input.split('#').pop();\n}\n\n/**\n * Retrieves services from a given DID document, optionally filtered by `id` or `type`.\n *\n * If no `id` or `type` filters are provided, all defined services are returned.\n *\n * The given DID Document must adhere to the\n * {@link https://www.w3.org/TR/did-core/ | W3C DID Core Specification}.\n *\n * @example\n * ```ts\n * const didDocument = { ... }; // W3C DID document\n * const services = getServices({ didDocument, type: 'DecentralizedWebNode' });\n * ```\n *\n * @param params - An object containing input parameters for retrieving services.\n * @param params.didDocument - The DID document from which services are retrieved.\n * @param params.id - Optional. A string representing the specific service ID to match. If provided, only the service with this ID will be returned.\n * @param params.type - Optional. A string representing the specific service type to match. If provided, only the service(s) of this type will be returned.\n * @returns An array of services. If no matching service is found, an empty array is returned.\n */\nexport function getServices({ didDocument, id, type }: {\n  didDocument: DidDocument;\n  id?: string;\n  type?: string;\n}): DidService[] {\n  return didDocument?.service?.filter(service => {\n    if (id && service.id !== id) return false;\n    if (type && service.type !== type) return false;\n    return true;\n  }) ?? [];\n}\n\n/**\n * Retrieves a verification method object from a DID document if there is a match for the given\n * public key.\n *\n * This function searches the verification methods in a given DID document for a match with the\n * provided public key (either in JWK or multibase format). If a matching verification method is\n * found it is returned. If no match is found `null` is returned.\n *\n *\n * @example\n * ```ts\n * const didDocument = {\n *   // ... contents of a DID document ...\n * };\n * const publicKeyJwk = { kty: 'OKP', crv: 'Ed25519', x: '...' };\n *\n * const verificationMethod = await getVerificationMethodByKey({\n *   didDocument,\n *   publicKeyJwk\n * });\n * ```\n *\n * @param params - An object containing input parameters for retrieving the verification method ID.\n * @param params.didDocument - The DID document to search for the verification method.\n * @param params.publicKeyJwk - The public key in JSON Web Key (JWK) format to match against the verification methods in the DID document.\n * @param params.publicKeyMultibase - The public key as a multibase encoded string to match against the verification methods in the DID document.\n * @returns A promise that resolves with the matching verification method, or `null` if no match is found.\n * @throws Throws an `Error` if the `didDocument` parameter is missing or if the `didDocument` does not contain any verification methods.\n */\nexport async function getVerificationMethodByKey({ didDocument, publicKeyJwk, publicKeyMultibase }: {\n  didDocument: DidDocument;\n  publicKeyJwk?: Jwk;\n  publicKeyMultibase?: string;\n}): Promise<DidVerificationMethod | null> {\n  // Collect all verification methods from the DID document.\n  const verificationMethods = getVerificationMethods({ didDocument });\n\n  for (let method of verificationMethods) {\n    if (publicKeyJwk && method.publicKeyJwk) {\n      const publicKeyThumbprint = await computeJwkThumbprint({ jwk: publicKeyJwk });\n      if (publicKeyThumbprint === await computeJwkThumbprint({ jwk: method.publicKeyJwk })) {\n        return method;\n      }\n    } else if (publicKeyMultibase && method.publicKeyMultibase) {\n      if (publicKeyMultibase === method.publicKeyMultibase) {\n        return method;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Retrieves all verification methods from a given DID document, including embedded methods.\n *\n * This function consolidates all verification methods into a single array for easy access and\n * processing. It checks both the primary `verificationMethod` array and the individual verification\n * relationship properties `authentication`, `assertionMethod`, `keyAgreement`,\n * `capabilityInvocation`, and `capabilityDelegation` for embedded methods.\n *\n * The given DID Document must adhere to the\n * {@link https://www.w3.org/TR/did-core/ | W3C DID Core Specification}.\n *\n * @example\n * ```ts\n * const didDocument = { ... }; // W3C DID document\n * const verificationMethods = getVerificationMethods({ didDocument });\n * ```\n *\n * @param params - An object containing input parameters for retrieving verification methods.\n * @param params.didDocument - The DID document from which verification methods are retrieved.\n * @returns An array of `DidVerificationMethod`. If no verification methods are found, an empty array is returned.\n * @throws Throws an `TypeError` if the `didDocument` parameter is missing.\n */\nexport function getVerificationMethods({ didDocument }: {\n  didDocument: DidDocument;\n}): DidVerificationMethod[] {\n  if (!didDocument) throw new TypeError(`Required parameter missing: 'didDocument'`);\n\n  const verificationMethods: DidVerificationMethod[] = [];\n\n  // Check the 'verificationMethod' array.\n  verificationMethods.push(...didDocument.verificationMethod?.filter(isDidVerificationMethod) ?? []);\n\n  // Check verification relationship properties for embedded verification methods.\n  Object.keys(DidVerificationRelationship).forEach((relationship) => {\n    verificationMethods.push(\n      ...(didDocument[relationship as keyof DidDocument] as (string | DidVerificationMethod)[])\n        ?.filter(isDidVerificationMethod) ?? []\n    );\n  });\n\n  return verificationMethods;\n}\n\n/**\n * Retrieves all DID verification method types from a given DID document.\n *\n * The given DID Document must adhere to the\n * {@link https://www.w3.org/TR/did-core/ | W3C DID Core Specification}.\n *\n * @example\n * ```ts\n * const didDocument = {\n *   verificationMethod: [\n *     {\n *       'id'              : 'did:example:123#key-0',\n *       'type'            : 'Ed25519VerificationKey2018',\n *       'controller'      : 'did:example:123',\n *       'publicKeyBase58' : '3M5RCDjPTWPkKSN3sxUmmMqHbmRPegYP1tjcKyrDbt9J'\n *     },\n *     {\n *       'id'              : 'did:example:123#key-1',\n *       'type'            : 'X25519KeyAgreementKey2019',\n *       'controller'      : 'did:example:123',\n *       'publicKeyBase58' : 'FbQWLPRhTH95MCkQUeFYdiSoQt8zMwetqfWoxqPgaq7x'\n *     },\n *     {\n *       'id'           : 'did:example:123#key-3',\n *       'type'         : 'JsonWebKey2020',\n *       'controller'   : 'did:example:123',\n *       'publicKeyJwk' : {\n *         'kty' : 'EC',\n *         'crv' : 'P-256',\n *         'x'   : 'Er6KSSnAjI70ObRWhlaMgqyIOQYrDJTE94ej5hybQ2M',\n *         'y'   : 'pPVzCOTJwgikPjuUE6UebfZySqEJ0ZtsWFpj7YSPGEk'\n *       }\n *     }\n *   ]\n * },\n * const vmTypes = getVerificationMethodTypes({ didDocument });\n * console.log(vmTypes);\n * // Output: ['Ed25519VerificationKey2018', 'X25519KeyAgreementKey2019', 'JsonWebKey2020']\n * ```\n *\n * @param params - An object containing input parameters for retrieving types.\n * @param params.didDocument - The DID document from which types are retrieved.\n * @returns An array of types. If no types were found, an empty array is returned.\n */\nexport function getVerificationMethodTypes({ didDocument }: {\n  didDocument: DidDocument;\n}): string[] {\n  // Collect all verification methods from the DID document.\n  const verificationMethods = getVerificationMethods({ didDocument });\n\n  // Map to extract 'type' from each verification method.\n  const types = verificationMethods.map(method => method.type);\n\n  return [...new Set(types)]; // Return only unique types.\n}\n\n/**\n * Retrieves a list of DID verification relationships by a specific method ID from a DID document.\n *\n * This function examines the specified DID document to identify any verification relationships\n * (e.g., `authentication`, `assertionMethod`) that reference a verification method by its method ID\n * or contain an embedded verification method matching the method ID. The method ID is typically a\n * fragment of a DID (e.g., `did:example:123#key-1`) that uniquely identifies a verification method\n * within the DID document.\n *\n * The search considers both direct references to verification methods by their IDs and verification\n * methods embedded within the verification relationship arrays. It returns an array of\n * `DidVerificationRelationship` enums corresponding to the verification relationships that contain\n * the specified method ID.\n *\n * @param params - An object containing input parameters for retrieving verification relationships.\n * @param params.didDocument - The DID document to search for verification relationships.\n * @param params.methodId - The method ID to search for within the verification relationships.\n * @returns An array of `DidVerificationRelationship` enums representing the types of verification\n *          relationships that reference the specified method ID.\n *\n * @example\n * ```ts\n * const didDocument: DidDocument = {\n *   // ...contents of a DID document...\n * };\n *\n * const relationships = getVerificationRelationshipsById({\n *   didDocument,\n *   methodId: 'key-1'\n * });\n * console.log(relationships);\n * // Output might include ['authentication', 'assertionMethod'] if those relationships\n * // reference or contain the specified method ID.\n * ```\n */\nexport function getVerificationRelationshipsById({ didDocument, methodId }: {\n  didDocument: DidDocument;\n  methodId: string;\n}): DidVerificationRelationship[] {\n  const relationships: DidVerificationRelationship[] = [];\n\n  Object.keys(DidVerificationRelationship).forEach((relationship) => {\n    if (Array.isArray(didDocument[relationship as keyof DidDocument])) {\n      const relationshipMethods = didDocument[relationship as keyof DidDocument] as (string | DidVerificationMethod)[];\n\n      const methodIdFragment = extractDidFragment(methodId);\n\n      // Check if the verification relationship property contains a matching method ID either\n      // directly referenced or as an embedded verification method.\n      const containsMethodId = relationshipMethods.some(method => {\n        const isByReferenceMatch = extractDidFragment(method) === methodIdFragment;\n        const isEmbeddedMethodMatch = isDidVerificationMethod(method) && extractDidFragment(method.id) === methodIdFragment;\n        return isByReferenceMatch || isEmbeddedMethodMatch;\n      });\n\n      if (containsMethodId) {\n        relationships.push(relationship as DidVerificationRelationship);\n      }\n    }\n  });\n\n  return relationships;\n}\n\n/**\n * Checks if a given object is a {@link DidService}.\n *\n * A {@link DidService} in the context of DID resources must include the properties `id`, `type`,\n * and `serviceEndpoint`. The `serviceEndpoint` can be a `DidServiceEndpoint` or an array of\n * `DidServiceEndpoint` objects.\n *\n * @example\n * ```ts\n * const service = {\n *   id: \"did:example:123#service-1\",\n *   type: \"OidcService\",\n *   serviceEndpoint: \"https://example.com/oidc\"\n * };\n *\n * if (isDidService(service)) {\n *   console.log('The object is a DidService');\n * } else {\n *   console.log('The object is not a DidService');\n * }\n * ```\n *\n * @param obj - The object to be checked.\n * @returns `true` if `obj` is a `DidService`; otherwise, `false`.\n */\nexport function isDidService(obj: unknown): obj is DidService {\n  // Validate that the given value is an object.\n  if (!obj || typeof obj !== 'object' || obj === null) return false;\n\n  // Validate that the object has the necessary properties of DidService.\n  return 'id' in obj && 'type' in obj && 'serviceEndpoint' in obj;\n}\n\n/**\n * Checks if a given object is a {@link DwnDidService}.\n *\n * A {@link DwnDidService} is defined as {@link DidService} object with a `type` of\n * \"DecentralizedWebNode\" and `enc` and `sig` properties, where both properties are either strings\n * or arrays of strings.\n *\n * @example\n * ```ts\n * const didDocument: DidDocument = {\n *   id: 'did:example:123',\n *   verificationMethod: [\n *     {\n *       id: 'did:example:123#key-1',\n *       type: 'JsonWebKey2020',\n *       controller: 'did:example:123',\n *       publicKeyJwk: { ... }\n *     },\n *     {\n *       id: 'did:example:123#key-2',\n *       type: 'JsonWebKey2020',\n *       controller: 'did:example:123',\n *       publicKeyJwk: { ... }\n *     }\n *   ],\n *   service: [\n *     {\n *       id: 'did:example:123#dwn',\n *       type: 'DecentralizedWebNode',\n *       serviceEndpoint: 'https://dwn.tbddev.org/dwn0',\n *       enc: 'did:example:123#key-1',\n *       sig: 'did:example:123#key-2'\n *     }\n *   ]\n * };\n *\n * if (isDwnService(didDocument.service[0])) {\n *   console.log('The object is a DwnDidService');\n * } else {\n *   console.log('The object is not a DwnDidService');\n * }\n * ```\n *\n * @see {@link https://identity.foundation/decentralized-web-node/spec/ | Decentralized Web Node (DWN) Specification}\n *\n * @param obj - The object to be checked.\n * @returns `true` if `obj` is a DwnDidService; otherwise, `false`.\n */\nexport function isDwnDidService(obj: unknown): obj is DwnDidService {\n  // Validate that the given value is a {@link DidService}.\n  if (!isDidService(obj)) return false;\n\n  // Validate that the `type` property is `DecentralizedWebNode`.\n  if (obj.type !== 'DecentralizedWebNode') return false;\n\n  // Validate that the given object has the `enc` and `sig` properties.\n  if (!('enc' in obj && 'sig' in obj)) return false;\n\n  // Validate that the `enc` and `sig` properties are either strings or arrays of strings.\n  const isStringOrStringArray = (prop: any): boolean =>\n    typeof prop === 'string' || Array.isArray(prop) && prop.every(item => typeof item === 'string');\n  return (isStringOrStringArray(obj.enc)) && (isStringOrStringArray(obj.sig));\n}\n\n/**\n * Checks if a given object is a DID Verification Method.\n *\n * A {@link DidVerificationMethod} in the context of DID resources must include the properties `id`,\n * `type`, and `controller`.\n *\n * @example\n * ```ts\n * const resource = {\n *  id           : \"did:example:123#0\",\n *  type         : \"JsonWebKey2020\",\n *  controller   : \"did:example:123\",\n *  publicKeyJwk : { ... }\n * };\n *\n * if (isDidVerificationMethod(resource)) {\n *   console.log('The resource is a DidVerificationMethod');\n * } else {\n *   console.log('The resource is not a DidVerificationMethod');\n * }\n * ```\n *\n * @param obj - The object to be checked.\n * @returns `true` if `obj` is a `DidVerificationMethod`; otherwise, `false`.\n */\nexport function isDidVerificationMethod(obj: unknown): obj is DidVerificationMethod {\n  // Validate that the given value is an object.\n  if (!obj || typeof obj !== 'object' || obj === null) return false;\n\n  // Validate that the object has the necessary properties of a DidVerificationMethod.\n  if (!('id' in obj && 'type' in obj && 'controller' in obj)) return false;\n\n  if (typeof obj.id !== 'string') return false;\n  if (typeof obj.type !== 'string') return false;\n  if (typeof obj.controller !== 'string') return false;\n\n  return true;\n}\n\n/**\n * Converts a cryptographic key to a multibase identifier.\n *\n * @remarks\n * This method provides a way to represent a cryptographic key as a multibase identifier.\n * It takes a `Uint8Array` representing the key, and either the multicodec code or multicodec name\n * as input. The method first adds the multicodec prefix to the key, then encodes it into Base58\n * format. Finally, it converts the Base58 encoded key into a multibase identifier.\n *\n * @example\n * ```ts\n * const key = new Uint8Array([...]); // Cryptographic key as Uint8Array\n * const multibaseId = keyBytesToMultibaseId({ key, multicodecName: 'ed25519-pub' });\n * ```\n *\n * @param params - The parameters for the conversion.\n * @returns The multibase identifier as a string.\n */\nexport function keyBytesToMultibaseId({ keyBytes, multicodecCode, multicodecName }:\n  RequireOnly<KeyWithMulticodec, 'keyBytes'>\n): string {\n  const prefixedKey = Multicodec.addPrefix({\n    code : multicodecCode,\n    data : keyBytes,\n    name : multicodecName\n  });\n  const prefixedKeyB58 = Convert.uint8Array(prefixedKey).toBase58Btc();\n  const multibaseKeyId = Convert.base58Btc(prefixedKeyB58).toMultibase();\n\n  return multibaseKeyId;\n}\n\n/**\n * Converts a multibase identifier to a cryptographic key.\n *\n * @remarks\n * This function decodes a multibase identifier back into a cryptographic key. It first decodes the\n * identifier from multibase format into Base58 format, and then converts it into a `Uint8Array`.\n * Afterward, it removes the multicodec prefix, extracting the raw key data along with the\n * multicodec code and name.\n *\n * @example\n * ```ts\n * const multibaseKeyId = '...'; // Multibase identifier of the key\n * const { key, multicodecCode, multicodecName } = multibaseIdToKey({ multibaseKeyId });\n * ```\n *\n * @param params - The parameters for the conversion.\n * @param params.multibaseKeyId - The multibase identifier string of the key.\n * @returns An object containing the key as a `Uint8Array` and its multicodec code and name.\n * @throws `DidError` if the multibase identifier is invalid.\n */\nexport function multibaseIdToKeyBytes({ multibaseKeyId }: {\n  multibaseKeyId: string\n}): Required<KeyWithMulticodec> {\n  try {\n    const prefixedKeyB58 = Convert.multibase(multibaseKeyId).toBase58Btc();\n    const prefixedKey = Convert.base58Btc(prefixedKeyB58).toUint8Array();\n    const { code, data, name } = Multicodec.removePrefix({ prefixedData: prefixedKey });\n\n    return { keyBytes: data, multicodecCode: code, multicodecName: name };\n  } catch (error: any) {\n    throw new DidError(DidErrorCode.InvalidDid, `Invalid multibase identifier: ${multibaseKeyId}`);\n  }\n}", "import { LocalKeyManager, type CryptoApi, type EnclosedSignParams, type EnclosedVerifyParams, type Jwk, type KeyIdentifier, type KeyImporterExporter, type KmsExportKeyParams, type KmsImportKeyParams, type Signer } from '@web5/crypto';\n\nimport type { DidDocument } from './types/did-core.js';\nimport type { DidMetadata, PortableDid } from './types/portable-did.js';\n\nimport { DidError, DidErrorCode } from './did-error.js';\nimport { extractDidFragment, getVerificationMethods } from './utils.js';\n\n/**\n * A `BearerDidSigner` extends the {@link Signer} interface to include specific properties for\n * signing with a Decentralized Identifier (DID). It encapsulates the algorithm and key identifier,\n * which are often needed when signing JWTs, JWSs, JWEs, and other data structures.\n *\n * Typically, the algorithm and key identifier are used to populate the `alg` and `kid` fields of a\n * JWT or JWS header.\n */\nexport interface BearerDidSigner extends Signer {\n  /**\n   * The cryptographic algorithm identifier used for signing operations.\n   *\n   * Typically, this value is used to populate the `alg` field of a JWT or JWS header. The\n   * registered algorithm names are defined in the\n   * {@link https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-algorithms | IANA JSON Web Signature and Encryption Algorithms registry}.\n   *\n   * @example\n   * \"ES256\" // ECDSA using P-256 and SHA-256\n   */\n  algorithm: string;\n\n  /**\n   * The unique identifier of the key within the DID document that is used for signing and\n   * verification operations.\n   *\n   * This identifier must be a DID URI with a fragment (e.g., did:method:123#key-0) that references\n   * a specific verification method in the DID document. It allows users of a `BearerDidSigner` to\n   * determine the DID and key that will be used for signing and verification operations.\n   *\n   * @example\n   * \"did:dht:123#key-1\" // A fragment identifier referring to a key in the DID document\n   */\n  keyId: string;\n}\n\n/**\n * Represents a Decentralized Identifier (DID) along with its DID document, key manager, metadata,\n * and convenience functions.\n */\nexport class BearerDid {\n  /** {@inheritDoc Did#uri} */\n  uri: string;\n\n  /**\n   * The DID document associated with this DID.\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#dfn-diddocument | DID Core Specification, ยง DID Document}\n   */\n  document: DidDocument;\n\n  /** {@inheritDoc DidMetadata} */\n  metadata: DidMetadata;\n\n  /**\n   * Key Management System (KMS) used to manage the DIDs keys and sign data.\n   *\n   * Each DID method requires at least one key be present in the provided `keyManager`.\n   */\n  keyManager: CryptoApi;\n\n  constructor({ uri, document, metadata, keyManager }: {\n    uri: string,\n    document: DidDocument,\n    metadata: DidMetadata,\n    keyManager: CryptoApi\n  }) {\n    this.uri = uri;\n    this.document = document;\n    this.metadata = metadata;\n    this.keyManager = keyManager;\n  }\n\n  /**\n   * Converts a `BearerDid` object to a portable format containing the URI and verification methods\n   * associated with the DID.\n   *\n   * This method is useful when you need to represent the key material and metadata associated with\n   * a DID in format that can be used independently of the specific DID method implementation. It\n   * extracts both public and private keys from the DID's key manager and organizes them into a\n   * `PortableDid` structure.\n   *\n   * @remarks\n   * This method requires that the DID's key manager supports the `exportKey` operation. If the DID\n   * document does not contain any verification methods, or if the key manager does not support key\n   * export, an error is thrown.\n   *\n   * The resulting `PortableDid` will contain the same number of verification methods as the DID\n   * document, each with its associated public and private keys and the purposes for which the key\n   * can be used.\n   *\n   * @example\n   * ```ts\n   * // Assuming `did` is an instance of BearerDid\n   * const portableDid = await did.export();\n   * // portableDid now contains the DID URI, document, metadata, and optionally, private keys.\n   * ```\n   *\n   * @returns A `PortableDid` containing the URI, DID document, metadata, and optionally private\n   *          keys associated with the `BearerDid`.\n   * @throws An error if the DID document does not contain any verification methods or the keys for\n   *         any verification method are missing in the key manager.\n   */\n  public async export(): Promise<PortableDid> {\n    // Verify the DID document contains at least one verification method.\n    if (!(Array.isArray(this.document.verificationMethod) && this.document.verificationMethod.length > 0)) {\n      throw new Error(`DID document for '${this.uri}' is missing verification methods`);\n    }\n\n    // Create a new `PortableDid` object to store the exported data.\n    let portableDid: PortableDid = {\n      uri      : this.uri,\n      document : this.document,\n      metadata : this.metadata\n    };\n\n    // If the BearerDid's key manager supports exporting private keys, add them to the portable DID.\n    if ('exportKey' in this.keyManager && typeof this.keyManager.exportKey === 'function') {\n      const privateKeys: Jwk[] = [];\n      for (let vm of this.document.verificationMethod) {\n        if (!vm.publicKeyJwk) {\n          throw new Error(`Verification method '${vm.id}' does not contain a public key in JWK format`);\n        }\n\n        // Compute the key URI of the verification method's public key.\n        const keyUri = await this.keyManager.getKeyUri({ key: vm.publicKeyJwk });\n\n        // Retrieve the private key from the key manager.\n        const privateKey = await this.keyManager.exportKey({ keyUri }) as Jwk;\n\n        // Add the verification method to the key set.\n        privateKeys.push({ ...privateKey });\n      }\n      portableDid.privateKeys = privateKeys;\n    }\n\n    return portableDid;\n  }\n\n  /**\n   * Return a {@link Signer} that can be used to sign messages, credentials, or arbitrary data.\n   *\n   * If given, the `methodId` parameter is used to select a key from the verification methods\n   * present in the DID Document.\n   *\n   * If `methodID` is not given, the first verification method intended for signing claims is used.\n   *\n   * @param params - The parameters for the `getSigner` operation.\n   * @param params.methodId - ID of the verification method key that will be used for sign and\n   *                          verify operations. Optional.\n   * @returns An instantiated {@link Signer} that can be used to sign and verify data.\n   */\n  public async getSigner(params?: { methodId: string }): Promise<BearerDidSigner> {\n    // Attempt to find a verification method that matches the given method ID, or if not given,\n    // find the first verification method intended for signing claims.\n    const verificationMethod = this.document.verificationMethod?.find(\n      vm => extractDidFragment(vm.id) === (extractDidFragment(params?.methodId) ?? extractDidFragment(this.document.assertionMethod?.[0]))\n    );\n\n    if (!(verificationMethod && verificationMethod.publicKeyJwk)) {\n      throw new DidError(DidErrorCode.InternalError, 'A verification method intended for signing could not be determined from the DID Document');\n    }\n\n    // Compute the expected key URI of the signing key.\n    const keyUri = await this.keyManager.getKeyUri({ key: verificationMethod.publicKeyJwk });\n\n    // Get the public key to be used for verify operations, which also verifies that the key is\n    // present in the key manager's store.\n    const publicKey = await this.keyManager.getPublicKey({ keyUri });\n\n    // Bind the DID's key manager to the signer.\n    const keyManager = this.keyManager;\n\n    // Determine the signing algorithm.\n    const algorithm = BearerDid.getAlgorithmFromPublicKey(publicKey);\n\n    return {\n      algorithm : algorithm,\n      keyId     : verificationMethod.id,\n\n      async sign({ data }: EnclosedSignParams): Promise<Uint8Array> {\n        const signature = await keyManager.sign({ data, keyUri: keyUri! }); // `keyUri` is guaranteed to be defined at this point.\n        return signature;\n      },\n\n      async verify({ data, signature }: EnclosedVerifyParams): Promise<boolean> {\n        const isValid = await keyManager.verify({ data, key: publicKey!, signature }); // `publicKey` is guaranteed to be defined at this point.\n        return isValid;\n      }\n    };\n  }\n\n  /**\n   * Instantiates a {@link BearerDid} object for the DID DHT method from a given {@link PortableDid}.\n   *\n   * This method allows for the creation of a `BearerDid` object using a previously created DID's\n   * key material, DID document, and metadata.\n   *\n   * @example\n   * ```ts\n   * // Export an existing BearerDid to PortableDid format.\n   * const portableDid = await did.export();\n   * // Reconstruct a BearerDid object from the PortableDid.\n   * const did = await DidDht.import({ portableDid });\n   * ```\n   *\n   * @param params - The parameters for the import operation.\n   * @param params.portableDid - The PortableDid object to import.\n   * @param params.keyManager - Optionally specify an external Key Management System (KMS) used to\n   *                            generate keys and sign data. If not given, a new\n   *                            {@link LocalKeyManager} instance will be created and\n   *                            used.\n   * @returns A Promise resolving to a `BearerDid` object representing the DID formed from the\n   *          provided PortableDid.\n   * @throws An error if the PortableDid document does not contain any verification methods or the\n   *         keys for any verification method are missing in the key manager.\n   */\n  public static async import({ portableDid, keyManager = new LocalKeyManager() }: {\n    keyManager?: CryptoApi & KeyImporterExporter<KmsImportKeyParams, KeyIdentifier, KmsExportKeyParams>;\n    portableDid: PortableDid;\n  }): Promise<BearerDid> {\n    // Get all verification methods from the given DID document, including embedded methods.\n    const verificationMethods = getVerificationMethods({ didDocument: portableDid.document });\n\n    // Validate that the DID document contains at least one verification method.\n    if (verificationMethods.length === 0) {\n      throw new DidError(DidErrorCode.InvalidDidDocument, `At least one verification method is required but 0 were given`);\n    }\n\n    // If given, import the private key material into the key manager.\n    for (let key of portableDid.privateKeys ?? []) {\n      await keyManager.importKey({ key });\n    }\n\n    // Validate that the key material for every verification method in the DID document is present\n    // in the key manager.\n    for (let vm of verificationMethods) {\n      if (!vm.publicKeyJwk) {\n        throw new Error(`Verification method '${vm.id}' does not contain a public key in JWK format`);\n      }\n\n      // Compute the key URI of the verification method's public key.\n      const keyUri = await keyManager.getKeyUri({ key: vm.publicKeyJwk });\n\n      // Verify that the key is present in the key manager. If not, an error is thrown.\n      await keyManager.getPublicKey({ keyUri });\n    }\n\n    // Use the given PortableDid to construct the BearerDid object.\n    const did = new BearerDid({\n      uri      : portableDid.uri,\n      document : portableDid.document,\n      metadata : portableDid.metadata,\n      keyManager\n    });\n\n    return did;\n  }\n\n  /**\n   * Determines the name of the algorithm based on the key's curve property.\n   *\n   * @remarks\n   * This method facilitates the identification of the correct algorithm for cryptographic\n   * operations based on the `alg` or `crv` properties of a {@link Jwk | JWK}.\n   *\n   * @example\n   * ```ts\n   * const publicKey = { ... }; // Public key in JWK format\n   * const algorithm = BearerDid.getAlgorithmFromPublicKey({ key: publicKey });\n   * ```\n   *\n   * @param publicKey - A JWK containing the `alg` and/or `crv` properties.\n   *\n   * @returns The name of the algorithm associated with the key.\n   *\n   * @throws Error if the algorithm cannot be determined from the provided input.\n   */\n  private static getAlgorithmFromPublicKey(publicKey: Jwk): string {\n    const registeredSigningAlgorithms: Record<string, string> = {\n      'Ed25519'   : 'EdDSA',\n      'P-256'     : 'ES256',\n      'P-384'     : 'ES384',\n      'P-521'     : 'ES512',\n      'secp256k1' : 'ES256K',\n    };\n\n    // If the key contains an `alg` property, return its value.\n    if (publicKey.alg) {\n      return publicKey.alg;\n    }\n\n    // If the key contains a `crv` property, return the corresponding algorithm.\n    if (publicKey.crv && Object.keys(registeredSigningAlgorithms).includes(publicKey.crv)) {\n      return registeredSigningAlgorithms[publicKey.crv];\n    }\n\n    throw new Error(`Unable to determine algorithm based on provided input: alg=${publicKey.alg}, crv=${publicKey.crv}`);\n  }\n}", "import type {\n  CryptoApi,\n  LocalKeyManager,\n  InferKeyGeneratorAlgorithm,\n} from '@web5/crypto';\n\nimport type { BearerDid } from '../bearer-did.js';\nimport type { DidMetadata } from '../types/portable-did.js';\nimport type {\n  DidDocument,\n  DidResolutionResult,\n  DidResolutionOptions,\n  DidVerificationMethod,\n} from '../types/did-core.js';\n\nimport { DidVerificationRelationship } from '../types/did-core.js';\n\n/**\n * Represents options during the creation of a Decentralized Identifier (DID).\n *\n * Implementations of this interface may contain properties and methods that provide specific\n * options or metadata during the DID creation processes following specific DID method\n * specifications.\n */\nexport interface DidCreateOptions<TKms> {\n  /**\n   * Optional. An array of verification methods to be included in the DID document.\n   */\n  verificationMethods?: DidCreateVerificationMethod<TKms>[];\n}\n\n/**\n * Options for additional verification methods added to the DID Document during the creation of a\n * new Decentralized Identifier (DID).\n */\nexport interface DidCreateVerificationMethod<TKms> extends Pick<Partial<DidVerificationMethod>, 'controller' | 'id' | 'type'> {\n  /**\n   * The name of the cryptographic algorithm to be used for key generation.\n   *\n   * Examples might include `Ed25519` and `ES256K` but will vary depending on the DID method\n   * specification and the key management system in use.\n   *\n   * @example\n   * ```ts\n   * const verificationMethod: DidCreateVerificationMethod = {\n   *   algorithm: 'Ed25519'\n   * };\n   * ```\n   */\n  algorithm: TKms extends CryptoApi\n    ? InferKeyGeneratorAlgorithm<TKms>\n    : InferKeyGeneratorAlgorithm<LocalKeyManager>;\n\n  /**\n   * Optionally specify the purposes for which a verification method is intended to be used in a DID\n   * document.\n   *\n   * The `purposes` property defines the specific\n   * {@link DidVerificationRelationship | verification relationships} between the DID subject and\n   * the verification method. This enables the verification method to be utilized for distinct\n   * actions such as authentication, assertion, key agreement, capability delegation, and others. It\n   * is important for verifiers to recognize that a verification method must be associated with the\n   * relevant purpose in the DID document to be valid for that specific use case.\n   *\n   * @example\n   * ```ts\n   * const verificationMethod: DidCreateVerificationMethod = {\n   *   algorithm: 'Ed25519',\n   *   controller: 'did:example:1234',\n   *   purposes: ['authentication', 'assertionMethod']\n   * };\n   * ```\n   */\n  purposes?: (DidVerificationRelationship | keyof typeof DidVerificationRelationship)[];\n}\n\n/**\n * Defines the API for a specific DID method. It includes functionalities for creating and resolving\n * DIDs.\n *\n * @typeparam T - The type of the DID instance associated with this method.\n * @typeparam O - The type of the options used for creating the DID.\n */\nexport interface DidMethodApi<\n    TDid extends BearerDid,\n    TOptions extends DidCreateOptions<TKms>,\n    TKms extends CryptoApi | undefined = undefined\n  > extends DidMethodResolver {\n  /**\n   * The name of the DID method.\n   *\n   * For example, in the DID `did:example:123456`, \"example\" would be the method name.\n   */\n  methodName: string;\n\n  new (): DidMethod;\n\n  /**\n   * Creates a new DID.\n   *\n   * This function should generate a new DID in accordance with the DID method specification being\n   * implemented, using the provided `keyManager`, and optionally, any provided `options`.\n   *\n   * @param params - The parameters used to create the DID.\n   * @param params.keyManager - Optional. The cryptographic API used for key management.\n   * @param params.options - Optional. The options used for creating the DID.\n   * @returns A promise that resolves to the newly created DID instance.\n   */\n  create(params: { keyManager?: TKms, options?: TOptions }): Promise<TDid>;\n}\n\n/**\n * Defines the interface for resolving a DID using a specific DID method.\n *\n * A DID resolver takes a DID URI as input and returns a {@link DidResolutionResult} object.\n *\n * @property {string} methodName - The name of the DID method.\n * @method resolve - Asynchronous method to resolve a DID URI. Takes the DID URI and optional resolution options.\n */\nexport interface DidMethodResolver {\n  /**\n   * The name of the DID method.\n   *\n   * For example, in the DID `did:example:123456`, \"example\" would be the method name.\n   */\n  methodName: string;\n\n  new (): DidMethod;\n\n  /**\n   * Resolves a DID URI.\n   *\n   * This function should resolve the DID URI in accordance with the DID method specification being\n   * implemented, using the provided `options`.\n   *\n   * @param didUri - The DID URI to be resolved.\n   * @param options - Optional. The options used for resolving the DID.\n   * @returns A {@link DidResolutionResult} object containing the DID document and metadata or an error.\n   */\n  resolve(didUri: string, options?: DidResolutionOptions): Promise<DidResolutionResult>;\n}\n\n/**\n * Represents the result of a Decentralized Identifier (DID) registration operation.\n *\n * This type encapsulates the complete outcome of registering a DID, including the registration\n * metadata, the DID document (if registration is successful), and metadata about the DID document.\n */\nexport interface DidRegistrationResult {\n  /**\n   * The DID document resulting from the registration process, if successful.\n   *\n   * If the registration operation was successful, this MUST contain a DID document\n   * corresponding to the DID. If the registration is unsuccessful, this value MUST be empty.\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#dfn-diddocument | DID Core Specification, ยง DID Document}\n   */\n  didDocument: DidDocument | null;\n\n  /**\n   * Metadata about the DID Document.\n   *\n   * This structure contains information about the DID Document like creation and update timestamps,\n   * deactivation status, versioning information, and other details relevant to the DID Document.\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#dfn-diddocumentmetadata | DID Core Specification, ยง DID Document Metadata}\n   */\n  didDocumentMetadata: DidMetadata;\n\n  /**\n   * A metadata structure consisting of values relating to the results of the DID registration\n   * process.\n   *\n   * This structure is REQUIRED, and in the case of an error in the registration process,\n   * this MUST NOT be empty. If the registration is not successful, this structure MUST contain an\n   * `error` property describing the error.\n   */\n  didRegistrationMetadata: DidRegistrationMetadata;\n}\n\n/**\n * Represents metadata related to the result of a DID registration operation.\n *\n * This type includes fields that provide information about the outcome of a DID registration\n * process (e.g., create, update, deactivate), including any errors that occurred.\n *\n * This metadata typically changes between invocations of the `create`, `update`, and `deactivate`\n * functions, as it represents data about the registration process itself.\n */\nexport type DidRegistrationMetadata = {\n  /**\n   * An error code indicating issues encountered during the DID registration process.\n   *\n   * While the DID Core specification does not define a specific set of error codes for the result\n   * returned by the `create`, `update`, or `deactivate` functions, it is recommended to use the\n   * error codes defined in the DID Specification Registries for\n   * {@link https://www.w3.org/TR/did-spec-registries/#error | DID Resolution Metadata }.\n   *\n   * Recommended error codes include:\n   *   - `internalError`: An unexpected error occurred during DID registration process.\n   *   - `invalidDid`: The provided DID is invalid.\n   *   - `invalidDidDocument`: The provided DID document does not conform to valid syntax.\n   *   - `invalidDidDocumentLength`: The byte length of the provided DID document does not match the expected value.\n   *   - `invalidSignature`: Verification of a signature failed.\n   *   - `methodNotSupported`: The DID method specified is not supported.\n   *   - Custom error codes can also be provided as strings.\n   */\n  error?: string;\n\n  // Additional output metadata generated during DID registration.\n  [key: string]: any;\n};\n\n/**\n * Base abstraction for all Decentralized Identifier (DID) method implementations.\n *\n * This base class serves as a foundational structure upon which specific DID methods\n * can be implemented. Subclasses should furnish particular method and data models adherent\n * to various DID methods, taking care to adhere to the\n * {@link https://www.w3.org/TR/did-core/ | W3C DID Core specification} and the\n * respective DID method specifications.\n */\nexport class DidMethod {\n  /**\n   * MUST be implemented by all DID method implementations that extend {@link DidMethod}.\n   *\n   * Given the W3C DID Document of a DID, return the verification method that will be used for\n   * signing messages and credentials. If given, the `methodId` parameter is used to select the\n   * verification method. If not given, each DID method implementation will select a default\n   * verification method from the DID Document.\n   *\n   * @param _params - The parameters for the `getSigningMethod` operation.\n   * @param _params.didDocument - DID Document to get the verification method from.\n   * @param _params.methodId - ID of the verification method to use for signing.\n   * @returns Verification method to use for signing.\n   */\n  public static async getSigningMethod(_params: {\n    didDocument: DidDocument;\n    methodId?: string;\n  }): Promise<DidVerificationMethod | undefined> {\n    throw new Error(`Not implemented: Classes extending DidMethod must implement getSigningMethod()`);\n  }\n\n  /**\n   * MUST be implemented by all DID method implementations that extend {@link DidMethod}.\n   *\n   * Resolves a DID URI to a DID Document.\n   *\n   * @param _didUri - The DID to be resolved.\n   * @param _options - Optional parameters for resolving the DID.\n   * @returns A Promise resolving to a {@link DidResolutionResult} object representing the result of the resolution.\n   */\n  public static async resolve(_didUri: string, _options?: DidResolutionOptions): Promise<DidResolutionResult> {\n    throw new Error(`Not implemented: Classes extending DidMethod must implement resolve()`);\n  }\n}", "import type { DidResolverCache } from './did-resolver.js';\nimport type { DidResolutionResult } from '../types/did-core.js';\n\n/**\n * No-op cache that is used as the default cache for did-resolver.\n *\n * The motivation behind using a no-op cache as the default stems from the desire to maximize the\n * potential for this library to be used in as many JS runtimes as possible.\n */\nexport const DidResolverCacheNoop: DidResolverCache = {\n  get: function (_key: string): Promise<DidResolutionResult> {\n    return null as any;\n  },\n  set: function (_key: string, _value: DidResolutionResult): Promise<void> {\n    return null as any;\n  },\n  delete: function (_key: string): Promise<void> {\n    return null as any;\n  },\n  clear: function (): Promise<void> {\n    return null as any;\n  },\n  close: function (): Promise<void> {\n    return null as any;\n  }\n};", "import type { KeyValueStore } from '@web5/common';\n\nimport type { DidMethodResolver } from '../methods/did-method.js';\nimport type { DidDereferencingOptions, DidDereferencingResult, DidResolutionOptions, DidResolutionResult, DidResource } from '../types/did-core.js';\n\nimport { Did } from '../did.js';\nimport { DidErrorCode } from '../did-error.js';\nimport { DidResolverCacheNoop } from './resolver-cache-noop.js';\n\n/**\n * Interface for cache implementations used by {@link DidResolver} to store resolved DID documents.\n */\nexport interface DidResolverCache extends KeyValueStore<string, DidResolutionResult | void> {}\n\n/**\n * Parameters for configuring the `DidResolver` class, which is responsible for resolving\n * decentralized identifiers (DIDs) to their corresponding DID documents.\n *\n * This type specifies the essential components required by the `DidResolver` to perform\n * DID resolution and dereferencing. It includes an array of `DidMethodResolver` instances,\n * each capable of resolving DIDs for a specific method, and optionally, a cache for storing\n * resolved DID documents to improve resolution efficiency.\n */\nexport type DidResolverParams = {\n  /**\n   * An array of `DidMethodResolver` instances.\n   *\n   * Each resolver in this array is designed to handle a specific DID method, enabling the\n   * `DidResolver` to support multiple DID methods simultaneously.\n   */\n  didResolvers: DidMethodResolver[];\n\n  /**\n   * An optional `DidResolverCache` instance used for caching resolved DID documents.\n   *\n   * Providing a cache implementation can significantly enhance resolution performance by avoiding\n   * redundant resolutions for previously resolved DIDs. If omitted, a no-operation cache is used,\n   * which effectively disables caching.\n   */\n  cache?: DidResolverCache;\n}\n\n/**\n * A constant representing an empty DID Resolution Result. This object is used as the basis for a\n * result of DID resolution and is typically augmented with additional properties by the\n * DID method resolver.\n */\nexport const EMPTY_DID_RESOLUTION_RESULT: DidResolutionResult = {\n  '@context'            : 'https://w3id.org/did-resolution/v1',\n  didResolutionMetadata : {},\n  didDocument           : null,\n  didDocumentMetadata   : {},\n};\n\n/**\n * The `DidResolver` class provides mechanisms for resolving Decentralized Identifiers (DIDs) to\n * their corresponding DID documents.\n *\n * The class is designed to handle various DID methods by utilizing an array of `DidMethodResolver`\n * instances, each responsible for a specific DID method.\n *\n * Providing a cache implementation can significantly enhance resolution performance by avoiding\n * redundant resolutions for previously resolved DIDs. If omitted, a no-operation cache is used,\n * which effectively disables caching.\n *\n * Usage:\n * - Construct the `DidResolver` with an array of `DidMethodResolver` instances and an optional cache.\n * - Use `resolve` to resolve a DID to its DID Resolution Result.\n * - Use `dereference` to extract specific resources from a DID URL, like service endpoints or verification methods.\n *\n * @example\n * ```ts\n * const resolver = new DidResolver({\n *   didResolvers: [<array of DidMethodResolver instances>],\n *   cache: new DidResolverCacheNoop()\n * });\n *\n * const resolutionResult = await resolver.resolve('did:example:123456');\n * const dereferenceResult = await resolver.dereference({ didUri: 'did:example:123456#key-1' });\n * ```\n */\nexport class DidResolver {\n  /**\n   * A cache for storing resolved DID documents.\n   */\n  private cache: DidResolverCache;\n\n  /**\n   * A map to store method resolvers against method names.\n   */\n  private didResolvers: Map<string, DidMethodResolver> = new Map();\n\n  /**\n   * Constructs a new `DidResolver`.\n   *\n   * @param params - The parameters for constructing the `DidResolver`.\n   */\n  constructor({ cache, didResolvers }: DidResolverParams) {\n    this.cache = cache || DidResolverCacheNoop;\n\n    for (const resolver of didResolvers) {\n      this.didResolvers.set(resolver.methodName, resolver);\n    }\n  }\n\n  /**\n   * Resolves a DID to a DID Resolution Result.\n   *\n   * If the DID Resolution Result is present in the cache, it returns the cached result. Otherwise,\n   * it uses the appropriate method resolver to resolve the DID, stores the resolution result in the\n   * cache, and returns the resolultion result.\n   *\n   * @param didUri - The DID or DID URL to resolve.\n   * @returns A promise that resolves to the DID Resolution Result.\n   */\n  public async resolve(didUri: string, options?: DidResolutionOptions): Promise<DidResolutionResult> {\n\n    const parsedDid = Did.parse(didUri);\n    if (!parsedDid) {\n      return {\n        ...EMPTY_DID_RESOLUTION_RESULT,\n        didResolutionMetadata: {\n          error        : DidErrorCode.InvalidDid,\n          errorMessage : `Invalid DID URI: ${didUri}`\n        }\n      };\n    }\n\n    const resolver = this.didResolvers.get(parsedDid.method);\n    if (!resolver) {\n      return {\n        ...EMPTY_DID_RESOLUTION_RESULT,\n        didResolutionMetadata: {\n          error        : DidErrorCode.MethodNotSupported,\n          errorMessage : `Method not supported: ${parsedDid.method}`\n        }\n      };\n    }\n\n    const cachedResolutionResult = await this.cache.get(parsedDid.uri);\n\n    if (cachedResolutionResult) {\n      return cachedResolutionResult;\n    } else {\n      const resolutionResult = await resolver.resolve(parsedDid.uri, options);\n\n      await this.cache.set(parsedDid.uri, resolutionResult);\n\n      return resolutionResult;\n    }\n  }\n\n  /**\n   * Dereferences a DID (Decentralized Identifier) URL to a corresponding DID resource.\n   *\n   *\n   * This method interprets the DID URL's components, which include the DID method, method-specific\n   * identifier, path, query, and fragment, and retrieves the related resource as per the DID Core\n   * specifications.\n   *\n   * The dereferencing process involves resolving the DID contained in the DID URL to a DID document,\n   * and then extracting the specific part of the document identified by the fragment in the DID URL.\n   * If no fragment is specified, the entire DID document is returned.\n   *\n   * This method supports resolution of different components within a DID document such as service\n   * endpoints and verification methods, based on their IDs. It accommodates both full and\n   * DID URLs as specified in the DID Core specification.\n   *\n   * More information on DID URL dereferencing can be found in the\n   * {@link https://www.w3.org/TR/did-core/#did-url-dereferencing | DID Core specification}.\n   *\n   * TODO: This is a partial implementation and does not fully implement DID URL dereferencing. (https://github.com/TBD54566975/web5-js/issues/387)\n   *\n   * @param didUrl - The DID URL string to dereference.\n   * @param [_options] - Input options to the dereference function. Optional.\n   * @returns a {@link DidDereferencingResult}\n   */\n  async dereference(\n    didUrl: string,\n    _options?: DidDereferencingOptions\n  ): Promise<DidDereferencingResult> {\n\n    // Validate the given `didUrl` confirms to the DID URL syntax.\n    const parsedDidUrl = Did.parse(didUrl);\n\n    if (!parsedDidUrl) {\n      return {\n        dereferencingMetadata : { error: DidErrorCode.InvalidDidUrl },\n        contentStream         : null,\n        contentMetadata       : {}\n      };\n    }\n\n    // Obtain the DID document for the input DID by executing DID resolution.\n    const { didDocument, didResolutionMetadata, didDocumentMetadata } = await this.resolve(parsedDidUrl.uri);\n\n    if (!didDocument) {\n      return {\n        dereferencingMetadata : { error: didResolutionMetadata.error },\n        contentStream         : null,\n        contentMetadata       : {}\n      };\n    }\n\n    // Return the entire DID Document if no query or fragment is present on the DID URL.\n    if (!parsedDidUrl.fragment || parsedDidUrl.query) {\n      return {\n        dereferencingMetadata : { contentType: 'application/did+json' },\n        contentStream         : didDocument,\n        contentMetadata       : didDocumentMetadata\n      };\n    }\n\n    const { service = [], verificationMethod = [] } = didDocument;\n\n    // Create a set of possible id matches. The DID spec allows for an id to be the entire\n    // did#fragment or just #fragment.\n    // @see {@link }https://www.w3.org/TR/did-core/#relative-did-urls | Section 3.2.2, Relative DID URLs}.\n    // Using a Set for fast string comparison since some DID methods have long identifiers.\n    const idSet = new Set([didUrl, parsedDidUrl.fragment, `#${parsedDidUrl.fragment}`]);\n\n    let didResource: DidResource | undefined;\n\n    // Find the first matching verification method in the DID document.\n    for (let vm of verificationMethod) {\n      if (idSet.has(vm.id)) {\n        didResource = vm;\n        break;\n      }\n    }\n\n    // Find the first matching service in the DID document.\n    for (let svc of service) {\n      if (idSet.has(svc.id)) {\n        didResource = svc;\n        break;\n      }\n    }\n\n    if (didResource) {\n      return {\n        dereferencingMetadata : { contentType: 'application/did+json' },\n        contentStream         : didResource,\n        contentMetadata       : didResolutionMetadata\n      };\n    } else {\n      return {\n        dereferencingMetadata : { error: DidErrorCode.NotFound },\n        contentStream         : null,\n        contentMetadata       : {},\n      };\n    }\n  }\n}", "import type { Packet, TxtAnswer, TxtData } from '@dnsquery/dns-packet';\nimport type {\n  Jwk,\n  Signer,\n  CryptoApi,\n  KeyIdentifier,\n  KmsExportKeyParams,\n  KmsImportKeyParams,\n  KeyImporterExporter,\n  AsymmetricKeyConverter,\n} from '@web5/crypto';\n\nimport bencode from 'bencode';\nimport { Convert } from '@web5/common';\nimport { computeJwkThumbprint, Ed25519, LocalKeyManager, Secp256k1, Secp256r1 } from '@web5/crypto';\nimport { AUTHORITATIVE_ANSWER, decode as dnsPacketDecode, encode as dnsPacketEncode } from '@dnsquery/dns-packet';\n\nimport type { DidMetadata, PortableDid } from '../types/portable-did.js';\nimport type { DidCreateOptions, DidCreateVerificationMethod, DidRegistrationResult } from './did-method.js';\nimport type {\n  DidService,\n  DidDocument,\n  DidResolutionResult,\n  DidResolutionOptions,\n  DidVerificationMethod,\n} from '../types/did-core.js';\n\nimport { Did } from '../did.js';\nimport { DidMethod } from './did-method.js';\nimport { BearerDid } from '../bearer-did.js';\nimport { extractDidFragment } from '../utils.js';\nimport { DidError, DidErrorCode } from '../did-error.js';\nimport { DidVerificationRelationship } from '../types/did-core.js';\nimport { EMPTY_DID_RESOLUTION_RESULT } from '../resolver/did-resolver.js';\n\n/**\n * Represents a BEP44 message, which is used for storing and retrieving data in the Mainline DHT\n * network.\n *\n * A BEP44 message is used primarily in the context of the DID DHT method for publishing and\n * resolving DID documents in the DHT network. This type encapsulates the data structure required\n * for such operations in accordance with BEP44.\n *\n * @see {@link https://www.bittorrent.org/beps/bep_0044.html | BEP44}\n */\nexport interface Bep44Message {\n  /**\n   * The public key bytes of the Identity Key, which serves as the identifier in the DHT network for\n   * the corresponding BEP44 message.\n   */\n  k: Uint8Array;\n\n  /**\n   * The sequence number of the message, used to ensure the latest version of the data is retrieved\n   * and updated. It's a monotonically increasing number.\n   */\n  seq: number;\n\n  /**\n   * The signature of the message, ensuring the authenticity and integrity of the data. It's\n   * computed over the bencoded sequence number and value.\n   */\n  sig: Uint8Array;\n\n  /**\n   * The actual data being stored or retrieved from the DHT network, typically encoded in a format\n   * suitable for DNS packet representation of a DID Document.\n   */\n  v: Uint8Array;\n}\n\n/**\n * Options for creating a Decentralized Identifier (DID) using the DID DHT method.\n */\nexport interface DidDhtCreateOptions<TKms> extends DidCreateOptions<TKms> {\n  /**\n   * Optionally specify that the DID Subject is also identified by one or more other DIDs or URIs.\n   *\n   * A DID subject can have multiple identifiers for different purposes, or at different times.\n   * The assertion that two or more DIDs (or other types of URI) refer to the same DID subject can\n   * be made using the `alsoKnownAs` property.\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#also-known-as | DID Core Specification, ยง Also Known As}\n   *\n   * @example\n   * ```ts\n   * const did = await DidDht.create({\n   *  options: {\n   *   alsoKnownAs: 'did:example:123'\n   * };\n   * ```\n   */\n  alsoKnownAs?: string[];\n\n  /**\n   * Optionally specify which DID (or DIDs) is authorized to make changes to the DID document.\n   *\n   * A DID controller is an entity that is authorized to make changes to a DID document. Typically,\n   * only the DID Subject (i.e., the value of `id` property in the DID document) is authoritative.\n   * However, another DID (or DIDs) can be specified as the DID controller, and when doing so, any\n   * verification methods contained in the DID document for the other DID should be accepted as\n   * authoritative. In other words, proofs created by the controller DID should be considered\n   * equivalent to proofs created by the DID Subject.\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#did-controller | DID Core Specification, ยง DID Controller}\n   *\n   * @example\n   * ```ts\n   * const did = await DidDht.create({\n   *  options: {\n   *   controller: 'did:example:123'\n   * };\n   * ```\n   */\n  controllers?: string | string[];\n\n  /**\n   * Optional. The URI of a server involved in executing DID method operations. In the context of\n   * DID creation, the endpoint is expected to be a DID DHT Gateway or Pkarr relay. If not\n   * specified, a default gateway node is used.\n   */\n  gatewayUri?: string;\n\n  /**\n   * Optional. Determines whether the created DID should be published to the DHT network.\n   *\n   * If set to `true` or omitted, the DID is publicly discoverable. If `false`, the DID is not\n   * published and cannot be resolved by others. By default, newly created DIDs are published.\n   *\n   * @see {@link https://did-dht.com | DID DHT Method Specification}\n   *\n   * @example\n   * ```ts\n   * const did = await DidDht.create({\n   *  options: {\n   *   publish: false\n   * };\n   * ```\n   */\n  publish?: boolean;\n\n  /**\n   * Optional. An array of service endpoints associated with the DID.\n   *\n   * Services are used in DID documents to express ways of communicating with the DID subject or\n   * associated entities. A service can be any type of service the DID subject wants to advertise,\n   * including decentralized identity management services for further discovery, authentication,\n   * authorization, or interaction.\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#services | DID Core Specification, ยง Services}\n   *\n   * @example\n   * ```ts\n   * const did = await DidDht.create({\n   *  options: {\n   *   services: [\n   *     {\n   *       id: 'did:dht:i9xkp8ddcbcg8jwq54ox699wuzxyifsqx4jru45zodqu453ksz6y#dwn',\n   *       type: 'DecentralizedWebNode',\n   *       serviceEndpoint: ['https://example.com/dwn1', 'https://example/dwn2']\n   *     }\n   *   ]\n   * };\n   * ```\n   */\n  services?: DidService[];\n\n  /**\n   * Optionally specify one or more registered DID DHT types to make the DID discovereable.\n   *\n   * Type indexing is an OPTIONAL feature that enables DIDs to become discoverable. DIDs that wish\n   * to be discoverable and resolveable by type can include one or more types when publishing their\n   * DID document to a DID DHT Gateway.\n   *\n   * The registered DID types are published in the {@link https://did-dht.com/registry/index.html#indexed-types | DID DHT Registry}.\n   */\n  types?: (DidDhtRegisteredDidType | keyof typeof DidDhtRegisteredDidType)[];\n\n  /**\n   * Optional. An array of verification methods to be included in the DID document.\n   *\n   * By default, a newly created DID DHT document will contain a single Ed25519 verification method,\n   * also known as the {@link https://did-dht.com/#term:identity-key | Identity Key}. Additional\n   * verification methods can be added to the DID document using the `verificationMethods` property.\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#verification-methods | DID Core Specification, ยง Verification Methods}\n   *\n   * @example\n   * ```ts\n   * const did = await DidDht.create({\n   *  options: {\n   *   verificationMethods: [\n   *     {\n   *       algorithm: 'Ed25519',\n   *       purposes: ['authentication', 'assertionMethod']\n   *     },\n   *     {\n   *       algorithm: 'Ed25519',\n   *       id: 'dwn-sig',\n   *       purposes: ['authentication', 'assertionMethod']\n   *     }\n   *   ]\n   * };\n   * ```\n   */\n  verificationMethods?: DidCreateVerificationMethod<TKms>[];\n}\n\n/**\n * The default DID DHT Gateway or Pkarr Relay server to use when publishing and resolving DID\n * documents.\n */\nconst DEFAULT_GATEWAY_URI = 'https://diddht.tbddev.org';\n\n/**\n * The version of the DID DHT specification that is implemented by this library.\n *\n * When a DID DHT document is published to the DHT network, the version of the specification that\n * was used to create the document is included in the DNS TXT record for the root record. This\n * allows clients to determine whether the DID DHT document is compatible with the client's\n * implementation of the DID DHT specification. The version number is not present in the\n * corresponding DID document.\n *\n * @see {@link https://did-dht.com | DID DHT Method Specification}\n */\nconst DID_DHT_SPECIFICATION_VERSION = 0;\n\n/**\n * The default TTL for DNS records published to the DHT network.\n *\n * The recommended TTL value is 7200 seconds (2 hours) since it matches the default TTL for\n * Mainline DHT records.\n */\nconst DNS_RECORD_TTL = 7200;\n\n/**\n * Character used to separate distinct elements or entries in the DNS packet representation\n * of a DID Document.\n *\n * For example, verification methods, verification relationships, and services are separated by\n * semicolons (`;`) in the root record:\n * ```\n * vm=k1;auth=k1;asm=k2;inv=k3;del=k3;srv=s1\n * ```\n */\nconst PROPERTY_SEPARATOR = ';';\n\n/**\n * Character used to separate distinct values within a single element or entry in the DNS packet\n * representation of a DID Document.\n *\n * For example, multiple key references for the `authentication` verification relationships are\n * separated by commas (`,`):\n * ```\n * auth=0,1,2\n * ```\n */\nconst VALUE_SEPARATOR = ',';\n\n/**\n * Represents an optional extension to a DID Documentโs DNS packet representation exposed as a\n * type index.\n *\n * Type indexing is an OPTIONAL feature that enables DIDs to become discoverable. DIDs that wish to\n * be discoverable and resolveable by type can include one or more types when publishing their DID\n * document to a DID DHT Gateway.\n *\n * The registered DID types are published in the {@link https://did-dht.com/registry/index.html#indexed-types | DID DHT Registry}.\n */\nexport enum DidDhtRegisteredDidType {\n  /**\n   * Type 0 is reserved for DIDs that do not wish to associate themselves with a specific type but\n   * wish to make themselves discoverable.\n   */\n  Discoverable = 0,\n\n  /**\n   * Organization\n   * @see {@link https://schema.org/Organization | schema definition}\n   */\n  Organization = 1,\n\n  /**\n   * Government Organization\n   * @see {@link https://schema.org/GovernmentOrganization | schema definition}\n   */\n  Government = 2,\n\n  /**\n   * Corporation\n   * @see {@link https://schema.org/Corporation | schema definition}\n   */\n  Corporation = 3,\n\n  /**\n   * Corporation\n   * @see {@link https://schema.org/Corporation | schema definition}\n   */\n  LocalBusiness = 4,\n\n  /**\n   * Software Package\n   * @see {@link https://schema.org/SoftwareSourceCode | schema definition}\n   */\n  SoftwarePackage = 5,\n\n  /**\n   * Web App\n   * @see {@link https://schema.org/WebApplication | schema definition}\n   */\n  WebApp = 6,\n\n  /**\n   * Financial Institution\n   * @see {@link https://schema.org/FinancialService | schema definition}\n   */\n  FinancialInstitution = 7\n}\n\n/**\n * Enumerates the types of keys that can be used in a DID DHT document.\n *\n * The DID DHT method supports various cryptographic key types. These key types are essential for\n * the creation and management of DIDs and their associated cryptographic operations like signing\n * and encryption. The registered key types are published in the DID DHT Registry and each is\n * assigned a unique numerical value for use by client and gateway implementations.\n *\n * The registered key types are published in the {@link https://did-dht.com/registry/index.html#key-type-index | DID DHT Registry}.\n */\nexport enum DidDhtRegisteredKeyType {\n  /**\n   * Ed25519: A public-key signature system using the EdDSA (Edwards-curve Digital Signature\n   * Algorithm) and Curve25519.\n   */\n  Ed25519   = 0,\n\n  /**\n   * secp256k1: A cryptographic curve used for digital signatures in a range of decentralized\n   * systems.\n   */\n  secp256k1 = 1,\n\n  /**\n   * secp256r1: Also known as P-256 or prime256v1, this curve is used for cryptographic operations\n   * and is widely supported in various cryptographic libraries and standards.\n   */\n  secp256r1 = 2\n}\n\n/**\n * Maps {@link https://www.w3.org/TR/did-core/#verification-relationships | DID Core Verification Relationship}\n * values to the corresponding record name in the DNS packet representation of a DHT DID document.\n */\nexport enum DidDhtVerificationRelationship {\n  /**\n   * Specifies how the DID subject is expected to be authenticated.\n   */\n  authentication = 'auth',\n\n  /**\n   * Specifies how the DID subject is expected to express claims, such as for issuing Verifiable\n   * Credentials.\n   */\n  assertionMethod = 'asm',\n\n  /**\n   * Specifies a mechanism used by the DID subject to delegate a cryptographic capability to another\n   * party\n   */\n  capabilityDelegation = 'del',\n\n  /**\n   * Specifies a verification method used by the DID subject to invoke a cryptographic capability.\n   */\n  capabilityInvocation = 'inv',\n\n  /**\n   * Specifies how an entity can generate encryption material to communicate confidentially with the\n   * DID subject.\n   */\n  keyAgreement = 'agm'\n}\n\n/**\n * Private helper that maps algorithm identifiers to their corresponding DID DHT\n * {@link DidDhtRegisteredKeyType | registered key type}.\n */\nconst AlgorithmToKeyTypeMap = {\n  Ed25519   : DidDhtRegisteredKeyType.Ed25519,\n  ES256K    : DidDhtRegisteredKeyType.secp256k1,\n  ES256     : DidDhtRegisteredKeyType.secp256r1,\n  'P-256'   : DidDhtRegisteredKeyType.secp256r1,\n  secp256k1 : DidDhtRegisteredKeyType.secp256k1,\n  secp256r1 : DidDhtRegisteredKeyType.secp256r1\n} as const;\n\n/**\n * The `DidDht` class provides an implementation of the `did:dht` DID method.\n *\n * Features:\n * - DID Creation: Create new `did:dht` DIDs.\n * - DID Key Management: Instantiate a DID object from an existing verification method keys or\n *                       or a key in a Key Management System (KMS). If supported by the KMS, a DID's\n *                       key can be exported to a portable DID format.\n * - DID Resolution: Resolve a `did:dht` to its corresponding DID Document stored in the DHT network.\n * - Signature Operations: Sign and verify messages using keys associated with a DID.\n *\n * @remarks\n * The `did:dht` method leverages the distributed nature of the Mainline DHT network for\n * decentralized identity management. This method allows DIDs to be resolved without relying on\n * centralized registries or ledgers, enhancing privacy and control for users. The DID Document is\n * stored and retrieved from the DHT network, and the method includes optional mechanisms for\n * discovering DIDs by type.\n *\n * The DID URI in the `did:dht` method includes a method-specific identifier called the Identity Key\n * which corresponds to the DID's entry in the DHT network. The Identity Key required to make\n * changes to the DID Document since Mainline DHT nodes validate the signature of each message\n * before storing the value in the DHT.\n *\n * @see {@link https://did-dht.com | DID DHT Method Specification}\n *\n * @example\n * ```ts\n * // DID Creation\n * const did = await DidDht.create();\n *\n * // DID Creation with a KMS\n * const keyManager = new LocalKeyManager();\n * const did = await DidDht.create({ keyManager });\n *\n * // DID Resolution\n * const resolutionResult = await DidDht.resolve({ did: did.uri });\n *\n * // Signature Operations\n * const signer = await did.getSigner();\n * const signature = await signer.sign({ data: new TextEncoder().encode('Message') });\n * const isValid = await signer.verify({ data: new TextEncoder().encode('Message'), signature });\n *\n * // Import / Export\n *\n * // Export a BearerDid object to the PortableDid format.\n * const portableDid = await did.export();\n *\n * // Reconstruct a BearerDid object from a PortableDid\n * const did = await DidDht.import(portableDid);\n * ```\n */\nexport class DidDht extends DidMethod {\n\n  /**\n   * Name of the DID method, as defined in the DID DHT specification.\n   */\n  public static methodName = 'dht';\n\n  /**\n   * Creates a new DID using the `did:dht` method formed from a newly generated key.\n   *\n   * @remarks\n   * The DID URI is formed by z-base-32 encoding the Identity Key public key and prefixing with\n   * `did:dht:`.\n   *\n   * Notes:\n   * - If no `options` are given, by default a new Ed25519 key will be generated which serves as the\n   *   Identity Key.\n   *\n   * @example\n   * ```ts\n   * // DID Creation\n   * const did = await DidDht.create();\n   *\n   * // DID Creation with a KMS\n   * const keyManager = new LocalKeyManager();\n   * const did = await DidDht.create({ keyManager });\n   * ```\n   *\n   * @param params - The parameters for the create operation.\n   * @param params.keyManager - Optionally specify a Key Management System (KMS) used to generate\n   *                            keys and sign data.\n   * @param params.options - Optional parameters that can be specified when creating a new DID.\n   * @returns A Promise resolving to a {@link BearerDid} object representing the new DID.\n   */\n  public static async create<TKms extends CryptoApi | undefined = undefined>({\n    keyManager = new LocalKeyManager(),\n    options = {}\n  }: {\n    keyManager?: TKms;\n    options?: DidDhtCreateOptions<TKms>;\n  } = {}): Promise<BearerDid> {\n    // Before processing the create operation, validate DID-method-specific requirements to prevent\n    // keys from being generated unnecessarily.\n\n    // Check 1: Validate that the algorithm for any given verification method is supported by the\n    // DID DHT specification.\n    if (options.verificationMethods?.some(vm => !(vm.algorithm in AlgorithmToKeyTypeMap))) {\n      throw new Error('One or more verification method algorithms are not supported');\n    }\n\n    // Check 2: Validate that the ID for any given verification method is unique.\n    const methodIds = options.verificationMethods?.filter(vm => 'id' in vm).map(vm => vm.id);\n    if (methodIds && methodIds.length !== new Set(methodIds).size) {\n      throw new Error('One or more verification method IDs are not unique');\n    }\n\n    // Check 3: Validate that the required properties for any given services are present.\n    if (options.services?.some(s => !s.id || !s.type || !s.serviceEndpoint)) {\n      throw new Error('One or more services are missing required properties');\n    }\n\n    // Generate random key material for the Identity Key.\n    const identityKeyUri = await keyManager.generateKey({ algorithm: 'Ed25519' });\n    const identityKey = await keyManager.getPublicKey({ keyUri: identityKeyUri });\n\n    // Compute the DID URI from the Identity Key.\n    const didUri = await DidDhtUtils.identityKeyToIdentifier({ identityKey });\n\n    // Begin constructing the DID Document.\n    const document: DidDocument = {\n      id: didUri,\n      ...options.alsoKnownAs && { alsoKnownAs: options.alsoKnownAs },\n      ...options.controllers && { controller: options.controllers }\n    };\n\n    // If the given verification methods do not contain an Identity Key, add one.\n    const verificationMethodsToAdd = [...options.verificationMethods ?? []];\n    if (!verificationMethodsToAdd?.some(vm => vm.id?.split('#').pop() === '0')) {\n      // Add the Identity Key to the beginning of the key set.\n      verificationMethodsToAdd.unshift({\n        algorithm : 'Ed25519' as any,\n        id        : '0',\n        purposes  : ['authentication', 'assertionMethod', 'capabilityDelegation', 'capabilityInvocation']\n      });\n    }\n\n    // Generate random key material for the Identity Key and any additional verification methods.\n    // Add verification methods to the DID document.\n    for (const vm of verificationMethodsToAdd) {\n      // Generate a random key for the verification method, or if its the Identity Key's\n      // verification method (`id` is 0) use the key previously generated.\n      const keyUri = (vm.id && vm.id.split('#').pop() === '0')\n        ? identityKeyUri\n        : await keyManager.generateKey({ algorithm: vm.algorithm });\n\n      const publicKey = await keyManager.getPublicKey({ keyUri });\n\n      // Use the given ID, the key's ID, or the key's thumbprint as the verification method ID.\n      let methodId = vm.id ?? publicKey.kid ?? await computeJwkThumbprint({ jwk: publicKey });\n      methodId = `${didUri}#${extractDidFragment(methodId)}`; // Remove fragment prefix, if any.\n\n      // Initialize the `verificationMethod` array if it does not already exist.\n      document.verificationMethod ??= [];\n\n      // Add the verification method to the DID document.\n      document.verificationMethod.push({\n        id           : methodId,\n        type         : 'JsonWebKey',\n        controller   : vm.controller ?? didUri,\n        publicKeyJwk : publicKey,\n      });\n\n      // Add the verification method to the specified purpose properties of the DID document.\n      for (const purpose of vm.purposes ?? []) {\n        // Initialize the purpose property if it does not already exist.\n        if (!document[purpose]) document[purpose] = [];\n        // Add the verification method to the purpose property.\n        document[purpose]!.push(methodId);\n      }\n    }\n\n    // Add services, if any, to the DID document.\n    options.services?.forEach(service => {\n      document.service ??= [];\n      service.id = `${didUri}#${service.id.split('#').pop()}`; // Remove fragment prefix, if any.\n      document.service.push(service);\n    });\n\n    // Create the BearerDid object, including the registered DID types (if any), and specify that\n    // the DID has not yet been published.\n    const did = new BearerDid({\n      uri      : didUri,\n      document,\n      metadata : {\n        published: false,\n        ...options.types && { types: options.types }\n      },\n      keyManager\n    });\n\n    // By default, publish the DID document to a DHT Gateway unless explicitly disabled.\n    if (options.publish ?? true) {\n      const registrationResult = await DidDht.publish({ did, gatewayUri: options.gatewayUri });\n      did.metadata = registrationResult.didDocumentMetadata;\n    }\n\n    return did;\n  }\n\n  /**\n   * Instantiates a {@link BearerDid} object for the DID DHT method from a given {@link PortableDid}.\n   *\n   * This method allows for the creation of a `BearerDid` object using a previously created DID's\n   * key material, DID document, and metadata.\n   *\n   * @example\n   * ```ts\n   * // Export an existing BearerDid to PortableDid format.\n   * const portableDid = await did.export();\n   * // Reconstruct a BearerDid object from the PortableDid.\n   * const did = await DidDht.import({ portableDid });\n   * ```\n   *\n   * @param params - The parameters for the import operation.\n   * @param params.portableDid - The PortableDid object to import.\n   * @param params.keyManager - Optionally specify an external Key Management System (KMS) used to\n   *                            generate keys and sign data. If not given, a new\n   *                            {@link LocalKeyManager} instance will be created and\n   *                            used.\n   * @returns A Promise resolving to a `BearerDid` object representing the DID formed from the\n   *          provided PortableDid.\n   * @throws An error if the PortableDid document does not contain any verification methods, lacks\n   *         an Identity Key, or the keys for any verification method are missing in the key\n   *         manager.\n   */\n  public static async import({ portableDid, keyManager = new LocalKeyManager() }: {\n    keyManager?: CryptoApi & KeyImporterExporter<KmsImportKeyParams, KeyIdentifier, KmsExportKeyParams>;\n    portableDid: PortableDid;\n  }): Promise<BearerDid> {\n    // Verify the DID method is supported.\n    const parsedDid = Did.parse(portableDid.uri);\n    if (parsedDid?.method !== DidDht.methodName) {\n      throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported`);\n    }\n\n    const did = await BearerDid.import({ portableDid, keyManager });\n\n    // Validate that the given verification methods contain an Identity Key.\n    if (!did.document.verificationMethod?.some(vm => vm.id?.split('#').pop() === '0')) {\n      throw new DidError(DidErrorCode.InvalidDidDocument, `DID document must contain an Identity Key`);\n    }\n\n    return did;\n  }\n\n  /**\n   * Given the W3C DID Document of a `did:dht` DID, return the verification method that will be used\n   * for signing messages and credentials. If given, the `methodId` parameter is used to select the\n   * verification method. If not given, the Identity Key's verification method with an ID fragment\n   * of '#0' is used.\n   *\n   * @param params - The parameters for the `getSigningMethod` operation.\n   * @param params.didDocument - DID Document to get the verification method from.\n   * @param params.methodId - ID of the verification method to use for signing.\n   * @returns Verification method to use for signing.\n   */\n  public static async getSigningMethod({ didDocument, methodId = '#0' }: {\n    didDocument: DidDocument;\n    methodId?: string;\n  }): Promise<DidVerificationMethod> {\n    // Verify the DID method is supported.\n    const parsedDid = Did.parse(didDocument.id);\n    if (parsedDid && parsedDid.method !== this.methodName) {\n      throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported: ${parsedDid.method}`);\n    }\n\n    // Attempt to find a verification method that matches the given method ID, or if not given,\n    // find the first verification method intended for signing claims.\n    const verificationMethod = didDocument.verificationMethod?.find(\n      vm => extractDidFragment(vm.id) === (extractDidFragment(methodId) ?? extractDidFragment(didDocument.assertionMethod?.[0]))\n    );\n\n    if (!(verificationMethod && verificationMethod.publicKeyJwk)) {\n      throw new DidError(DidErrorCode.InternalError, 'A verification method intended for signing could not be determined from the DID Document');\n    }\n\n    return verificationMethod;\n  }\n\n  /**\n   * Publishes a DID to the DHT, making it publicly discoverable and resolvable.\n   *\n   * This method handles the publication of a DID Document associated with a `did:dht` DID to the\n   * Mainline DHT network. The publication process involves storing the DID Document in Mainline DHT\n   * via a Pkarr relay server.\n   *\n   * @remarks\n   * - This method is typically invoked automatically during the creation of a new DID unless the\n   *   `publish` option is set to `false`.\n   * - For existing, unpublished DIDs, it can be used to publish the DID Document to Mainline DHT.\n   * - The method relies on the specified Pkarr relay server to interface with the DHT network.\n   *\n   * @example\n   * ```ts\n   * // Generate a new DID and keys but explicitly disable publishing.\n   * const did = await DidDht.create({ options: { publish: false } });\n   * // Publish the DID to the DHT.\n   * const registrationResult = await DidDht.publish({ did });\n   * // `registrationResult.didDocumentMetadata.published` is true if the DID was successfully published.\n   * ```\n   *\n   * @param params - The parameters for the `publish` operation.\n   * @param params.did - The `BearerDid` object representing the DID to be published.\n   * @param params.gatewayUri - Optional. The URI of a server involved in executing DID method\n   *                            operations. In the context of publishing, the endpoint is expected\n   *                            to be a DID DHT Gateway or Pkarr Relay. If not specified, a default\n   *                            gateway node is used.\n   * @returns A promise that resolves to a {@link DidRegistrationResult} object that contains\n   *          the result of registering the DID with a DID DHT Gateway or Pkarr relay.\n   */\n  public static async publish({ did, gatewayUri = DEFAULT_GATEWAY_URI }: {\n    did: BearerDid;\n    gatewayUri?: string;\n  }): Promise<DidRegistrationResult> {\n    const registrationResult = await DidDhtDocument.put({ did, gatewayUri });\n\n    return registrationResult;\n  }\n\n  /**\n   * Resolves a `did:dht` identifier to its corresponding DID document.\n   *\n   * This method performs the resolution of a `did:dht` DID, retrieving its DID Document from the\n   * Mainline DHT network. The process involves querying the DHT network via a Pkarr relay server to\n   * retrieve the DID Document that corresponds to the given DID identifier.\n   *\n   * @remarks\n   * - If a `gatewayUri` option is not specified, a default Pkarr relay is used to access the DHT\n   *   network.\n   * - It decodes the DID identifier and retrieves the associated DID Document and metadata.\n   * - In case of resolution failure, appropriate error information is returned.\n   *\n   * @example\n   * ```ts\n   * const resolutionResult = await DidDht.resolve('did:dht:example');\n   * ```\n   *\n   * @param didUri - The DID to be resolved.\n   * @param options - Optional parameters for resolving the DID. Unused by this DID method.\n   * @returns A Promise resolving to a {@link DidResolutionResult} object representing the result of\n   *          the resolution.\n   */\n  public static async resolve(didUri: string, options: DidResolutionOptions = {}): Promise<DidResolutionResult> {\n    // To execute the read method operation, use the given gateway URI or a default.\n    const gatewayUri = options?.gatewayUri ?? DEFAULT_GATEWAY_URI;\n\n    try {\n      // Attempt to decode the z-base-32-encoded identifier.\n      await DidDhtUtils.identifierToIdentityKey({ didUri });\n\n      // Attempt to retrieve the DID document and metadata from the DHT network.\n      const { didDocument, didDocumentMetadata } = await DidDhtDocument.get({ didUri, gatewayUri });\n\n      // If the DID document was retrieved successfully, return it.\n      return {\n        ...EMPTY_DID_RESOLUTION_RESULT,\n        didDocument,\n        didDocumentMetadata\n      };\n\n    } catch (error: any) {\n      // Rethrow any unexpected errors that are not a `DidError`.\n      if (!(error instanceof DidError)) throw new Error(error);\n\n      // Return a DID Resolution Result with the appropriate error code.\n      return {\n        ...EMPTY_DID_RESOLUTION_RESULT,\n        didResolutionMetadata: {\n          error: error.code,\n          ...error.message && { errorMessage: error.message }\n        }\n      };\n    }\n  }\n}\n\n/**\n * The `DidDhtDocument` class provides functionality for interacting with the DID document stored in\n * Mainline DHT in support of DID DHT method create, resolve, update, and deactivate operations.\n *\n * This class includes methods for retrieving and publishing DID documents to and from the DHT,\n * using DNS packet encoding and DID DHT Gateway or Pkarr Relay servers.\n */\nexport class DidDhtDocument {\n  /**\n   * Retrieves a DID document and its metadata from the DHT network.\n   *\n   * @param params - The parameters for the get operation.\n   * @param params.didUri - The DID URI containing the Identity Key.\n   * @param params.gatewayUri - The DID DHT Gateway or Pkarr Relay URI.\n   * @returns A Promise resolving to a {@link DidResolutionResult} object containing the DID\n   *          document and its metadata.\n   */\n  public static async get({ didUri, gatewayUri }: {\n    didUri: string;\n    gatewayUri: string;\n  }): Promise<DidResolutionResult> {\n    // Decode the z-base-32 DID identifier to public key as a byte array.\n    const publicKeyBytes = DidDhtUtils.identifierToIdentityKeyBytes({ didUri });\n\n    // Retrieve the signed BEP44 message from a DID DHT Gateway or Pkarr relay.\n    const bep44Message = await DidDhtDocument.pkarrGet({ gatewayUri, publicKeyBytes });\n\n    // Verify the signature of the BEP44 message and parse the value to a DNS packet.\n    const dnsPacket = await DidDhtUtils.parseBep44GetMessage({ bep44Message });\n\n    // Convert the DNS packet to a DID document and metadata.\n    const resolutionResult = await DidDhtDocument.fromDnsPacket({ didUri, dnsPacket });\n\n    // Set the version ID of the DID document metadata to the sequence number of the BEP44 message.\n    resolutionResult.didDocumentMetadata.versionId = bep44Message.seq.toString();\n\n    return resolutionResult;\n  }\n\n  /**\n   * Publishes a DID document to the DHT network.\n   *\n   * @param params - The parameters to use when publishing the DID document to the DHT network.\n   * @param params.did - The DID object whose DID document will be published.\n   * @param params.gatewayUri - The DID DHT Gateway or Pkarr Relay URI.\n   * @returns A promise that resolves to a {@link DidRegistrationResult} object that contains\n   *          the result of registering the DID with a DID DHT Gateway or Pkarr relay.\n   */\n  public static async put({ did, gatewayUri }: {\n    did: BearerDid;\n    gatewayUri: string;\n  }): Promise<DidRegistrationResult> {\n    // Convert the DID document and DID metadata (such as DID types) to a DNS packet.\n    const dnsPacket = await DidDhtDocument.toDnsPacket({\n      didDocument : did.document,\n      didMetadata : did.metadata\n    });\n\n    // Create a signed BEP44 put message from the DNS packet.\n    const bep44Message = await DidDhtUtils.createBep44PutMessage({\n      dnsPacket,\n      publicKeyBytes : DidDhtUtils.identifierToIdentityKeyBytes({ didUri: did.uri }),\n      signer         : await did.getSigner({ methodId: '0' })\n    });\n\n    // Publish the DNS packet to the DHT network.\n    const putResult = await DidDhtDocument.pkarrPut({ gatewayUri, bep44Message });\n\n    // Return the result of processing the PUT operation, including the updated DID metadata with\n    // the version ID and the publishing result.\n    return {\n      didDocument         : did.document,\n      didDocumentMetadata : {\n        ...did.metadata,\n        published : putResult,\n        versionId : bep44Message.seq.toString()\n      },\n      didRegistrationMetadata: {}\n    };\n  }\n\n  /**\n   * Retrieves a signed BEP44 message from a DID DHT Gateway or Pkarr Relay server.\n   *\n   * @see {@link https://github.com/Nuhvi/pkarr/blob/main/design/relays.md | Pkarr Relay design}\n   *\n   * @param params\n   * @param params.gatewayUri - The DID DHT Gateway or Pkarr Relay URI.\n   * @param params.publicKeyBytes - The public key bytes of the Identity Key, z-base-32 encoded.\n   * @returns A promise resolving to a BEP44 message containing the signed DNS packet.\n  */\n  private static async pkarrGet({ gatewayUri, publicKeyBytes }: {\n    publicKeyBytes: Uint8Array;\n    gatewayUri: string;\n  }): Promise<Bep44Message> {\n    // The identifier (key in the DHT) is the z-base-32 encoding of the Identity Key.\n    const identifier = Convert.uint8Array(publicKeyBytes).toBase32Z();\n\n    // Concatenate the gateway URI with the identifier to form the full URL.\n    const url = new URL(identifier, gatewayUri).href;\n\n    // Transmit the Get request to the DID DHT Gateway or Pkarr Relay and get the response.\n    let response: Response;\n    try {\n      response = await fetch(url, { method: 'GET' });\n\n      if (!response.ok) {\n        throw new DidError(DidErrorCode.NotFound, `Pkarr record not found for: ${identifier}`);\n      }\n\n    } catch (error: any) {\n      if (error instanceof DidError) throw error;\n      throw new DidError(DidErrorCode.InternalError, `Failed to fetch Pkarr record: ${error.message}`);\n    }\n\n    // Read the Fetch Response stream into a byte array.\n    const messageBytes = await response.arrayBuffer();\n\n    if (messageBytes.byteLength < 72) {\n      throw new DidError(DidErrorCode.InvalidDidDocumentLength, `Pkarr response must be at least 72 bytes but got: ${messageBytes.byteLength}`);\n    }\n\n    if (messageBytes.byteLength > 1072) {\n      throw new DidError(DidErrorCode.InvalidDidDocumentLength, `Pkarr response exceeds 1000 byte limit: ${messageBytes.byteLength}`);\n    }\n\n    // Decode the BEP44 message from the byte array.\n    const bep44Message: Bep44Message = {\n      k   : publicKeyBytes,\n      seq : Number(new DataView(messageBytes).getBigUint64(64)),\n      sig : new Uint8Array(messageBytes, 0, 64),\n      v   : new Uint8Array(messageBytes, 72)\n    };\n\n    return bep44Message;\n  }\n\n  /**\n   * Publishes a signed BEP44 message to a DID DHT Gateway or Pkarr Relay server.\n   *\n   * @see {@link https://github.com/Nuhvi/pkarr/blob/main/design/relays.md | Pkarr Relay design}\n   *\n   * @param params - The parameters to use when publishing a signed BEP44 message to a Pkarr relay server.\n   * @param params.gatewayUri - The DID DHT Gateway or Pkarr Relay URI.\n   * @param params.bep44Message - The BEP44 message to be published, containing the signed DNS packet.\n   * @returns A promise resolving to `true` if the message was successfully published, otherwise `false`.\n   */\n  private static async pkarrPut({ gatewayUri, bep44Message }: {\n    bep44Message: Bep44Message;\n    gatewayUri: string;\n  }): Promise<boolean> {\n    // The identifier (key in the DHT) is the z-base-32 encoding of the Identity Key.\n    const identifier = Convert.uint8Array(bep44Message.k).toBase32Z();\n\n    // Concatenate the gateway URI with the identifier to form the full URL.\n    const url = new URL(identifier, gatewayUri).href;\n\n    // Construct the body of the request according to the Pkarr relay specification.\n    const body = new Uint8Array(bep44Message.v.length + 72);\n    body.set(bep44Message.sig, 0);\n    new DataView(body.buffer).setBigUint64(bep44Message.sig.length, BigInt(bep44Message.seq));\n    body.set(bep44Message.v, bep44Message.sig.length + 8);\n\n    // Transmit the Put request to the Pkarr relay and get the response.\n    let response: Response;\n    try {\n      response = await fetch(url, {\n        method  : 'PUT',\n        headers : { 'Content-Type': 'application/octet-stream' },\n        body\n      });\n\n    } catch (error: any) {\n      throw new DidError(DidErrorCode.InternalError, `Failed to put Pkarr record: ${error.message}`);\n    }\n\n    // Return `true` if the DHT request was successful, otherwise return `false`.\n    return response.ok;\n  }\n\n  /**\n   * Converts a DNS packet to a DID document according to the DID DHT specification.\n   *\n   * @see {@link https://did-dht.com/#dids-as-dns-records | DID DHT Specification, ยง DIDs as DNS Records}\n   *\n   * @param params - The parameters to use when converting a DNS packet to a DID document.\n   * @param params.didUri - The DID URI of the DID document.\n   * @param params.dnsPacket - The DNS packet to convert to a DID document.\n   * @returns A Promise resolving to a {@link DidResolutionResult} object containing the DID\n   *          document and its metadata.\n   */\n  private static async fromDnsPacket({ didUri, dnsPacket }: {\n    didUri: string;\n    dnsPacket: Packet;\n  }): Promise<DidResolutionResult> {\n    // Begin constructing the DID Document.\n    const didDocument: DidDocument = { id: didUri };\n\n    // Since the DID document is being retrieved from the DHT, it is considered published.\n    const didDocumentMetadata: DidMetadata = {\n      published: true\n    };\n\n    const idLookup = new Map<string, string>();\n\n    for (const answer of dnsPacket?.answers ?? []) {\n      // DID DHT properties are ONLY present in DNS TXT records.\n      if (answer.type !== 'TXT') continue;\n\n      // Get the DID DHT record identifier (e.g., k0, aka, did, etc.) from the DNS resource name.\n      const dnsRecordId = answer.name.split('.')[0].substring(1);\n\n      switch (true) {\n        // Process an also known as record.\n        case dnsRecordId.startsWith('aka'): {\n          // Decode the DNS TXT record data value to a string.\n          const data = DidDhtUtils.parseTxtDataToString(answer.data);\n\n          // Add the 'alsoKnownAs' property to the DID document.\n          didDocument.alsoKnownAs = data.split(VALUE_SEPARATOR);\n\n          break;\n        }\n\n        // Process a controller record.\n        case dnsRecordId.startsWith('cnt'): {\n          // Decode the DNS TXT record data value to a string.\n          const data = DidDhtUtils.parseTxtDataToString(answer.data);\n\n          // Add the 'controller' property to the DID document.\n          didDocument.controller = data.includes(VALUE_SEPARATOR) ? data.split(VALUE_SEPARATOR) : data;\n\n          break;\n        }\n\n        // Process verification methods.\n        case dnsRecordId.startsWith('k'): {\n          // Get the method ID fragment (id), key type (t), Base64URL-encoded public key (k), and\n          // optionally, controller (c) from the decoded TXT record data.\n          const { id, t, k, c } = DidDhtUtils.parseTxtDataToObject(answer.data);\n\n          // Convert the public key from Base64URL format to a byte array.\n          const publicKeyBytes = Convert.base64Url(k).toUint8Array();\n\n          // Use the key type integer to look up the cryptographic curve name.\n          const namedCurve = DidDhtRegisteredKeyType[Number(t)];\n\n          // Convert the public key from a byte array to JWK format.\n          let publicKey = await DidDhtUtils.keyConverter(namedCurve).bytesToPublicKey({ publicKeyBytes });\n\n          // Initialize the `verificationMethod` array if it does not already exist.\n          didDocument.verificationMethod ??= [];\n\n          // Prepend the DID URI to the ID fragment to form the full verification method ID.\n          const methodId = `${didUri}#${id}`;\n\n          // Add the verification method to the DID document.\n          didDocument.verificationMethod.push({\n            id           : methodId,\n            type         : 'JsonWebKey',\n            controller   : c ?? didUri,\n            publicKeyJwk : publicKey,\n          });\n\n          // Add a mapping from the DNS record ID (e.g., 'k0', 'k1', etc.) to the verification\n          // method ID (e.g., 'did:dht:...#0', etc.).\n          idLookup.set(dnsRecordId, methodId);\n\n          break;\n        }\n\n        // Process services.\n        case dnsRecordId.startsWith('s'): {\n          // Get the service ID fragment (id), type (t), service endpoint (se), and optionally,\n          // other properties from the decoded TXT record data.\n          const { id, t, se, ...customProperties } = DidDhtUtils.parseTxtDataToObject(answer.data);\n\n          // The service endpoint can either be a string or an array of strings.\n          const serviceEndpoint = se.includes(VALUE_SEPARATOR) ? se.split(VALUE_SEPARATOR) : se;\n\n          // Initialize the `service` array if it does not already exist.\n          didDocument.service ??= [];\n\n          didDocument.service.push({\n            ...customProperties,\n            id   : `${didUri}#${id}`,\n            type : t,\n            serviceEndpoint\n          });\n\n          break;\n        }\n\n        // Process DID DHT types.\n        case dnsRecordId.startsWith('typ'): {\n          // Decode the DNS TXT record data value to an object.\n          const { id: types } = DidDhtUtils.parseTxtDataToObject(answer.data);\n\n          // Add the DID DHT Registered DID Types represented as numbers to DID metadata.\n          didDocumentMetadata.types = types.split(VALUE_SEPARATOR).map(typeInteger => Number(typeInteger));\n\n          break;\n        }\n\n        // Process root record.\n        case dnsRecordId.startsWith('did'): {\n          // Helper function that maps verification relationship values to verification method IDs.\n          const recordIdsToMethodIds = (data: string): string[] => data\n            .split(VALUE_SEPARATOR)\n            .map(dnsRecordId => idLookup.get(dnsRecordId))\n            .filter((id): id is string => typeof id === 'string');\n\n          // Decode the DNS TXT record data and destructure verification relationship properties.\n          const { auth, asm, del, inv, agm } = DidDhtUtils.parseTxtDataToObject(answer.data);\n\n          // Add the verification relationships, if any, to the DID document.\n          if (auth) didDocument.authentication = recordIdsToMethodIds(auth);\n          if (asm) didDocument.assertionMethod = recordIdsToMethodIds(asm);\n          if (del) didDocument.capabilityDelegation = recordIdsToMethodIds(del);\n          if (inv) didDocument.capabilityInvocation = recordIdsToMethodIds(inv);\n          if (agm) didDocument.keyAgreement = recordIdsToMethodIds(agm);\n\n          break;\n        }\n      }\n    }\n\n    return { didDocument, didDocumentMetadata, didResolutionMetadata: {} };\n  }\n\n  /**\n   * Converts a DID document to a DNS packet according to the DID DHT specification.\n   *\n   * @see {@link https://did-dht.com/#dids-as-dns-records | DID DHT Specification, ยง DIDs as DNS Records}\n   *\n   * @param params - The parameters to use when converting a DID document to a DNS packet.\n   * @param params.didDocument - The DID document to convert to a DNS packet.\n   * @param params.didMetadata - The DID metadata to include in the DNS packet.\n   * @returns A promise that resolves to a DNS packet.\n   */\n  private static async toDnsPacket({ didDocument, didMetadata }: {\n    didDocument: DidDocument;\n    didMetadata: DidMetadata;\n  }): Promise<Packet> {\n    const dnsAnswerRecords: TxtAnswer[] = [];\n    const idLookup = new Map<string, string>();\n    const serviceIds: string[] = [];\n    const verificationMethodIds: string[] = [];\n\n    // Add DNS TXT records if the DID document contains an `alsoKnownAs` property.\n    if (didDocument.alsoKnownAs) {\n      dnsAnswerRecords.push({\n        type : 'TXT',\n        name : '_aka.did.',\n        ttl  : DNS_RECORD_TTL,\n        data : didDocument.alsoKnownAs.join(VALUE_SEPARATOR)\n      });\n    }\n\n    // Add DNS TXT records if the DID document contains a `controller` property.\n    if (didDocument.controller) {\n      const controller = Array.isArray(didDocument.controller)\n        ? didDocument.controller.join(VALUE_SEPARATOR)\n        : didDocument.controller;\n      dnsAnswerRecords.push({\n        type : 'TXT',\n        name : '_cnt.did.',\n        ttl  : DNS_RECORD_TTL,\n        data : controller\n      });\n    }\n\n    // Add DNS TXT records for each verification method.\n    for (const [index, vm] of didDocument.verificationMethod?.entries() ?? []) {\n      const dnsRecordId = `k${index}`;\n      verificationMethodIds.push(dnsRecordId);\n      let methodId = vm.id.split('#').pop()!; // Remove fragment prefix, if any.\n      idLookup.set(methodId, dnsRecordId);\n\n      const publicKey = vm.publicKeyJwk;\n\n      if (!(publicKey?.crv && publicKey.crv in AlgorithmToKeyTypeMap)) {\n        throw new DidError(DidErrorCode.InvalidPublicKeyType, `Verification method '${vm.id}' contains an unsupported key type: ${publicKey?.crv ?? 'undefined'}`);\n      }\n\n      // Use the public key's `crv` property to get the DID DHT key type.\n      const keyType = DidDhtRegisteredKeyType[publicKey.crv as keyof typeof DidDhtRegisteredKeyType];\n\n      // Convert the public key from JWK format to a byte array.\n      const publicKeyBytes = await DidDhtUtils.keyConverter(publicKey.crv).publicKeyToBytes({ publicKey });\n\n      // Convert the public key from a byte array to Base64URL format.\n      const publicKeyBase64Url = Convert.uint8Array(publicKeyBytes).toBase64Url();\n\n      // Define the data for the DNS TXT record.\n      const txtData = [`id=${methodId}`, `t=${keyType}`, `k=${publicKeyBase64Url}`];\n\n      // Add the controller property, if set to a value other than the Identity Key (DID Subject).\n      if (vm.controller !== didDocument.id) txtData.push(`c=${vm.controller}`);\n\n      // Add a TXT record for the verification method.\n      dnsAnswerRecords.push({\n        type : 'TXT',\n        name : `_${dnsRecordId}._did.`,\n        ttl  : DNS_RECORD_TTL,\n        data : txtData.join(PROPERTY_SEPARATOR)\n      });\n    }\n\n    // Add DNS TXT records for each service.\n    didDocument.service?.forEach((service, index) => {\n      const dnsRecordId = `s${index}`;\n      serviceIds.push(dnsRecordId);\n      const serviceId = service.id.split('#').pop()!; // Remove fragment prefix, if any.\n      const serviceEndpoint = Array.isArray(service.serviceEndpoint)\n        ? service.serviceEndpoint.join(',')\n        : service.serviceEndpoint;\n\n      // Define the data for the DNS TXT record.\n      const txtData = [`id=${serviceId}`, `t=${service.type}`, `se=${serviceEndpoint}`];\n\n      // Add a TXT record for the verification method.\n      dnsAnswerRecords.push({\n        type : 'TXT',\n        name : `_${dnsRecordId}._did.`,\n        ttl  : DNS_RECORD_TTL,\n        data : txtData.join(PROPERTY_SEPARATOR)\n      });\n    });\n\n    // Initialize the root DNS TXT record with the DID DHT specification version.\n    const rootRecord: string[] = [`v=${DID_DHT_SPECIFICATION_VERSION}`];\n\n    // Add verification methods to the root record.\n    if (verificationMethodIds.length) {\n      rootRecord.push(`vm=${verificationMethodIds.join(VALUE_SEPARATOR)}`);\n    }\n\n    // Add verification relationships to the root record.\n    Object.keys(DidVerificationRelationship).forEach(relationship => {\n      // Collect the verification method IDs for the given relationship.\n      const dnsRecordIds = (didDocument[relationship as keyof DidDocument] as any[])\n        ?.map(id => idLookup.get(id.split('#').pop()));\n\n      // If the relationship includes verification methods, add them to the root record.\n      if (dnsRecordIds) {\n        const recordName = DidDhtVerificationRelationship[relationship as keyof typeof DidDhtVerificationRelationship];\n        rootRecord.push(`${recordName}=${dnsRecordIds.join(VALUE_SEPARATOR)}`);\n      }\n    });\n\n    // Add services to the root record.\n    if (serviceIds.length) {\n      rootRecord.push(`svc=${serviceIds.join(VALUE_SEPARATOR)}`);\n    }\n\n    // If defined, add a DNS TXT record for each registered DID type.\n    if (didMetadata.types?.length) {\n      // DID types can be specified as either a string or a number, so we need to normalize the\n      // values to integers.\n      const types = didMetadata.types as (DidDhtRegisteredDidType | keyof typeof DidDhtRegisteredDidType)[];\n      const typeIntegers = types.map(type => typeof type === 'string' ? DidDhtRegisteredDidType[type] : type);\n\n      dnsAnswerRecords.push({\n        type : 'TXT',\n        name : '_typ._did.',\n        ttl  : DNS_RECORD_TTL,\n        data : `id=${typeIntegers.join(VALUE_SEPARATOR)}`\n      });\n    }\n\n    // Add a DNS TXT record for the root record.\n    dnsAnswerRecords.push({\n      type : 'TXT',\n      name : '_did.',\n      ttl  : DNS_RECORD_TTL,\n      data : rootRecord.join(PROPERTY_SEPARATOR)\n    });\n\n    // Per the DID DHT specification, the method-specific identifier must be appended as the\n    // Origin of all records.\n    const [, , identifier] = didDocument.id.split(':');\n    dnsAnswerRecords.forEach(record => record.name += identifier);\n\n    // Create a DNS response packet with the authoritative answer flag set.\n    const dnsPacket: Packet = {\n      id      : 0,\n      type    : 'response',\n      flags   : AUTHORITATIVE_ANSWER,\n      answers : dnsAnswerRecords\n    };\n\n    return dnsPacket;\n  }\n}\n\n/**\n * The `DidDhtUtils` class provides utility functions to support operations in the DID DHT method.\n * This includes functions for creating and parsing BEP44 messages, handling identity keys, and\n * converting between different formats and representations.\n */\nexport class DidDhtUtils {\n  /**\n   * Creates a BEP44 put message, which is used to publish a DID document to the DHT network.\n   *\n   * @param params - The parameters to use when creating the BEP44 put message\n   * @param params.dnsPacket - The DNS packet to encode in the BEP44 message.\n   * @param params.publicKeyBytes - The public key bytes of the Identity Key.\n   * @param params.signer - Signer that can sign and verify data using the Identity Key.\n   * @returns A promise that resolves to a BEP44 put message.\n   */\n  public static async createBep44PutMessage({ dnsPacket, publicKeyBytes, signer }: {\n      dnsPacket: Packet;\n      publicKeyBytes: Uint8Array;\n      signer: Signer;\n    }): Promise<Bep44Message> {\n    // BEP44 requires that the sequence number be a monotoically increasing integer, so we use the\n    // current time in seconds since Unix epoch as a simple solution. Higher precision is not\n    // recommended since DID DHT documents are not expected to change frequently and there are\n    // small differences in system clocks that can cause issues if multiple clients are publishing\n    // updates to the same DID document.\n    const sequenceNumber = Math.ceil(Date.now() / 1000);\n\n    // Encode the DNS packet into a byte array containing a UDP payload.\n    const encodedDnsPacket = dnsPacketEncode(dnsPacket);\n\n    // Encode the sequence and DNS byte array to bencode format.\n    const bencodedData = bencode.encode({ seq: sequenceNumber, v: encodedDnsPacket }).subarray(1, -1);\n\n    if (bencodedData.length > 1000) {\n      throw new DidError(DidErrorCode.InvalidDidDocumentLength, `DNS packet exceeds the 1000 byte maximum size: ${bencodedData.length} bytes`);\n    }\n\n    // Sign the BEP44 message.\n    const signature = await signer.sign({ data: bencodedData });\n\n    return { k: publicKeyBytes, seq: sequenceNumber, sig: signature, v: encodedDnsPacket };\n  }\n\n  /**\n   * Converts a DID URI to a JSON Web Key (JWK) representing the Identity Key.\n   *\n   * @param params - The parameters to use for the conversion.\n   * @param params.didUri - The DID URI containing the Identity Key.\n   * @returns A promise that resolves to a JWK representing the Identity Key.\n   */\n  public static async identifierToIdentityKey({ didUri }: {\n    didUri: string\n  }): Promise<Jwk> {\n    // Decode the method-specific identifier from z-base-32 to a byte array.\n    let identityKeyBytes = DidDhtUtils.identifierToIdentityKeyBytes({ didUri });\n\n    // Convert the byte array to a JWK.\n    const identityKey = await Ed25519.bytesToPublicKey({ publicKeyBytes: identityKeyBytes });\n\n    return identityKey;\n  }\n\n  /**\n   * Converts a DID URI to the byte array representation of the Identity Key.\n   *\n   * @param params - The parameters to use for the conversion.\n   * @param params.didUri - The DID URI containing the Identity Key.\n   * @returns A byte array representation of the Identity Key.\n   */\n  public static identifierToIdentityKeyBytes({ didUri }: {\n    didUri: string\n  }): Uint8Array {\n    // Parse the DID URI.\n    const parsedDid = Did.parse(didUri);\n\n    // Verify that the DID URI is valid.\n    if (!parsedDid) {\n      throw new DidError(DidErrorCode.InvalidDid, `Invalid DID URI: ${didUri}`);\n    }\n\n    // Verify the DID method is supported.\n    if (parsedDid.method !== DidDht.methodName) {\n      throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported: ${parsedDid.method}`);\n    }\n\n    // Decode the method-specific identifier from z-base-32 to a byte array.\n    let identityKeyBytes: Uint8Array | undefined;\n    try {\n      identityKeyBytes = Convert.base32Z(parsedDid.id).toUint8Array();\n    } catch {\n      throw new DidError(DidErrorCode.InvalidPublicKey, `Failed to decode method-specific identifier`);\n    }\n\n    if (identityKeyBytes.length !== 32) {\n      throw new DidError(DidErrorCode.InvalidPublicKeyLength, `Invalid public key length: ${identityKeyBytes.length}`);\n    }\n\n    return identityKeyBytes;\n  }\n\n  /**\n   * Encodes a DID DHT Identity Key into a DID identifier.\n   *\n   * This method first z-base-32 encodes the Identity Key. The resulting string is prefixed with\n   * `did:dht:` to form the DID identifier.\n   *\n   * @param params - The parameters to use for the conversion.\n   * @param params.identityKey The Identity Key from which the DID identifier is computed.\n   * @returns A promise that resolves to a string containing the DID identifier.\n   */\n  public static async identityKeyToIdentifier({ identityKey }: {\n    identityKey: Jwk\n  }): Promise<string> {\n    // Convert the key from JWK format to a byte array.\n    const publicKeyBytes = await Ed25519.publicKeyToBytes({ publicKey: identityKey });\n\n    // Encode the byte array as a z-base-32 string.\n    const identifier = Convert.uint8Array(publicKeyBytes).toBase32Z();\n\n    return `did:${DidDht.methodName}:${identifier}`;\n  }\n\n  /**\n   * Returns the appropriate key converter for the specified cryptographic curve.\n   *\n   * @param curve - The cryptographic curve to use for the key conversion.\n   * @returns An `AsymmetricKeyConverter` for the specified curve.\n   */\n  public static keyConverter(curve: string): AsymmetricKeyConverter {\n    const converters: Record<string, AsymmetricKeyConverter> = {\n      'Ed25519'   : Ed25519,\n      'P-256'     : Secp256r1,\n      'secp256k1' : Secp256k1\n    };\n\n    const converter = converters[curve];\n\n    if (!converter) throw new DidError(DidErrorCode.InvalidPublicKeyType, `Unsupported curve: ${curve}`);\n\n    return converter;\n  }\n\n  /**\n   * Parses and verifies a BEP44 Get message, converting it to a DNS packet.\n   *\n   * @param params - The parameters to use when verifying and parsing the BEP44 Get response message.\n   * @param params.bep44Message - The BEP44 message to verify and parse.\n   * @returns A promise that resolves to a DNS packet.\n   */\n  public static async parseBep44GetMessage({ bep44Message }: {\n    bep44Message: Bep44Message;\n  }): Promise<Packet> {\n    // Convert the public key byte array to JWK format.\n    const publicKey = await Ed25519.bytesToPublicKey({ publicKeyBytes: bep44Message.k });\n\n    // Encode the sequence and DNS byte array to bencode format.\n    const bencodedData = bencode.encode({ seq: bep44Message.seq, v: bep44Message.v }).subarray(1, -1);\n\n    // Verify the signature of the BEP44 message.\n    const isValid = await Ed25519.verify({\n      key       : publicKey,\n      signature : bep44Message.sig,\n      data      : bencodedData\n    });\n\n    if (!isValid) {\n      throw new DidError(DidErrorCode.InvalidSignature, `Invalid signature for DHT BEP44 message`);\n    }\n\n    return dnsPacketDecode(bep44Message.v);\n  }\n\n  /**\n   * Decodes and parses the data value of a DNS TXT record into a key-value object.\n   *\n   * @param txtData - The data value of a DNS TXT record.\n   * @returns An object containing the key/value pairs of the TXT record data.\n   */\n  public static parseTxtDataToObject(txtData: TxtData): Record<string, string> {\n    return this.parseTxtDataToString(txtData).split(PROPERTY_SEPARATOR).reduce((acc, pair) => {\n      const [key, value] = pair.split('=');\n      acc[key] = value;\n      return acc;\n    }, {} as Record<string, string>);\n  }\n\n  /**\n   * Decodes and parses the data value of a DNS TXT record into a string.\n   *\n   * @param txtData - The data value of a DNS TXT record.\n   * @returns A string representation of the TXT record data.\n   */\n  public static parseTxtDataToString(txtData: TxtData): string {\n    if (typeof txtData === 'string') {\n      return txtData;\n    } else if (txtData instanceof Uint8Array) {\n      return Convert.uint8Array(txtData).toString();\n    } else if (Array.isArray(txtData)) {\n      return txtData.map(item => this.parseTxtDataToString(item)).join('');\n    } else {\n      throw new DidError(DidErrorCode.InternalError, 'Pkarr returned DNS TXT record with invalid data type');\n    }\n  }\n}", "import type { CryptoApi, Jwk, KeyIdentifier, KeyImporterExporter, KmsExportKeyParams, KmsImportKeyParams } from '@web5/crypto';\nimport type {\n  JwkEs256k,\n  IonDocumentModel,\n  IonPublicKeyModel,\n  IonPublicKeyPurpose,\n} from '@decentralized-identity/ion-sdk';\n\nimport { IonDid, IonRequest } from '@decentralized-identity/ion-sdk';\nimport { LocalKeyManager, computeJwkThumbprint } from '@web5/crypto';\n\nimport type { PortableDid } from '../types/portable-did.js';\nimport type { DidCreateOptions, DidCreateVerificationMethod, DidRegistrationResult } from '../methods/did-method.js';\nimport type {\n  DidService,\n  DidDocument,\n  DidResolutionResult,\n  DidResolutionOptions,\n  DidVerificationMethod,\n  DidVerificationRelationship,\n} from '../types/did-core.js';\n\nimport { Did } from '../did.js';\nimport { BearerDid } from '../bearer-did.js';\nimport { DidMethod } from '../methods/did-method.js';\nimport { DidError, DidErrorCode } from '../did-error.js';\nimport { getVerificationRelationshipsById } from '../utils.js';\nimport { EMPTY_DID_RESOLUTION_RESULT } from '../resolver/did-resolver.js';\n\n/**\n * Options for creating a Decentralized Identifier (DID) using the DID ION method.\n */\nexport interface DidIonCreateOptions<TKms> extends DidCreateOptions<TKms> {\n  /**\n   * Optional. The URI of a server involved in executing DID method operations. In the context of\n   * DID creation, the endpoint is expected to be a Sidetree node. If not specified, a default\n   * gateway node is used.\n   */\n  gatewayUri?: string;\n\n  /**\n   * Optional. Determines whether the created DID should be published to a Sidetree node.\n   *\n   * If set to `true` or omitted, the DID is publicly discoverable. If `false`, the DID is not\n   * published and cannot be resolved by others. By default, newly created DIDs are published.\n   *\n   * @see {@link https://identity.foundation/sidetree/spec/#create | Sidetree Protocol Specification, ยง Create}\n   *\n   * @example\n   * ```ts\n   * const did = await DidIon.create({\n   *  options: {\n   *   publish: false\n   * };\n   * ```\n   */\n  publish?: boolean;\n\n  /**\n   * Optional. An array of service endpoints associated with the DID.\n   *\n   * Services are used in DID documents to express ways of communicating with the DID subject or\n   * associated entities. A service can be any type of service the DID subject wants to advertise,\n   * including decentralized identity management services for further discovery, authentication,\n   * authorization, or interaction.\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#services | DID Core Specification, ยง Services}\n   *\n   * @example\n   * ```ts\n   * const did = await DidIon.create({\n   *  options: {\n   *   services: [\n   *     {\n   *       id: 'dwn',\n   *       type: 'DecentralizedWebNode',\n   *       serviceEndpoint: ['https://example.com/dwn1', 'https://example/dwn2']\n   *     }\n   *   ]\n   * };\n   * ```\n   */\n  services?: DidService[];\n\n  /**\n   * Optional. An array of verification methods to be included in the DID document.\n   *\n   * By default, a newly created DID ION document will contain a single Ed25519 verification method.\n   * Additional verification methods can be added to the DID document using the\n   * `verificationMethods` property.\n   *\n   * @see {@link https://www.w3.org/TR/did-core/#verification-methods | DID Core Specification, ยง Verification Methods}\n   *\n   * @example\n   * ```ts\n   * const did = await DidIon.create({\n   *  options: {\n   *   verificationMethods: [\n   *     {\n   *       algorithm: 'Ed25519',\n   *       purposes: ['authentication', 'assertionMethod']\n   *     },\n   *     {\n   *       algorithm: 'Ed25519',\n   *       id: 'dwn-sig',\n   *       purposes: ['authentication', 'assertionMethod']\n   *     }\n   *   ]\n   * };\n   * ```\n   */\n  verificationMethods?: DidCreateVerificationMethod<TKms>[];\n}\n\n/**\n * Represents the request model for managing DID documents within the ION network, according to the\n * Sidetree protocol specification.\n */\nexport interface DidIonCreateRequest {\n  /** The type of operation to perform, which is always 'create' for a Create Operation. */\n  type: 'create';\n\n  /** Contains properties related to the initial state of the DID document. */\n  suffixData: {\n    /** A hash of the `delta` object, representing the initial changes to the DID document. */\n    deltaHash: string;\n    /** A commitment value used for future recovery operations, hashed for security. */\n    recoveryCommitment: string;\n  };\n\n  /** Details the changes to be applied to the DID document in this operation. */\n  delta: {\n    /** A commitment value used for the next update operation, hashed for security. */\n    updateCommitment: string;\n    /** An array of patch objects specifying the modifications to apply to the DID document. */\n    patches: {\n      /** The type of modification to perform (e.g., adding or removing public keys or service\n       * endpoints). */\n      action: string;\n      /** The document state or partial state to apply with this patch. */\n      document: IonDocumentModel;\n    }[];\n  }\n}\n\n/**\n * Represents a {@link DidVerificationMethod | DID verification method} in the context of DID ION\n * create, update, deactivate, and resolve operations.\n *\n * Unlike the DID Core standard {@link DidVerificationMethod} interface, this type is specific to\n * the ION method operations and only includes the `id`, `publicKeyJwk`, and `purposes` properties:\n * - The `id` property is optional and specifies the identifier fragment of the verification method.\n * - The `publicKeyJwk` property is required and represents the public key in JWK format.\n * - The `purposes` property is required and specifies the purposes for which the verification\n *  method can be used.\n *\n * @example\n * ```ts\n * const verificationMethod: DidIonVerificationMethod = {\n *   id           : 'sig',\n *   publicKeyJwk : {\n *     kty : 'OKP',\n *     crv : 'Ed25519',\n *     x   : 'o40shZrsco-CfEqk6mFsXfcP94ly3Az3gm84PzAUsXo',\n *     kid : 'BDp0xim82GswlxnPV8TPtBdUw80wkGIF8gjFbw1x5iQ',\n *   },\n *   purposes: ['authentication', 'assertionMethod']\n * };\n * ```\n */\nexport interface DidIonVerificationMethod {\n  /**\n   * Optionally specify the identifier fragment of the verification method.\n   *\n   * If not specified, the method's ID will be generated from the key's ID or thumbprint.\n   *\n   * @example\n   * ```ts\n   * const verificationMethod: DidIonVerificationMethod = {\n   *   id: 'sig',\n   *   ...\n   * };\n   * ```\n   */\n  id?: string;\n\n  /**\n   * A public key in JWK format.\n   *\n   * A JSON Web Key (JWK) that conforms to {@link https://datatracker.ietf.org/doc/html/rfc7517 | RFC 7517}.\n   *\n   * @example\n   * ```ts\n   * const verificationMethod: DidIonVerificationMethod = {\n   *   publicKeyJwk: {\n   *     kty : \"OKP\",\n   *     crv : \"X25519\",\n   *     x   : \"7XdJtNmJ9pV_O_3mxWdn6YjiHJ-HhNkdYQARzVU_mwY\",\n   *     kid : \"xtsuKULPh6VN9fuJMRwj66cDfQyLaxuXHkMlmAe_v6I\"\n   *   },\n   *   ...\n   * };\n   * ```\n   */\n  publicKeyJwk: Jwk;\n\n  /**\n   * Specify the purposes for which a verification method is intended to be used in a DID document.\n   *\n   * The `purposes` property defines the specific\n   * {@link DidVerificationRelationship | verification relationships} between the DID subject and\n   * the verification method. This enables the verification method to be utilized for distinct\n   * actions such as authentication, assertion, key agreement, capability delegation, and others. It\n   * is important for verifiers to recognize that a verification method must be associated with the\n   * relevant purpose in the DID document to be valid for that specific use case.\n   *\n   * @example\n   * ```ts\n   * const verificationMethod: DidIonVerificationMethod = {\n   *   purposes: ['authentication', 'assertionMethod'],\n   *   ...\n   * };\n   * ```\n   */\n  purposes: (DidVerificationRelationship | keyof typeof DidVerificationRelationship)[];\n}\n\n/**\n * `IonPortableDid` interface extends the {@link PortableDid} interface.\n *\n * It represents a Decentralized Identifier (DID) that is portable and can be used across different\n * domains, including the ION specific recovery and update keys.\n */\nexport interface IonPortableDid extends PortableDid {\n  /** The JSON Web Key (JWK) used for recovery purposes. */\n  recoveryKey: Jwk;\n\n  /** The JSON Web Key (JWK) used for updating the DID. */\n  updateKey: Jwk;\n}\n\n/**\n * Enumerates the types of keys that can be used in a DID ION document.\n *\n * The DID ION method supports various cryptographic key types. These key types are essential for\n * the creation and management of DIDs and their associated cryptographic operations like signing\n * and encryption.\n */\nexport enum DidIonRegisteredKeyType {\n  /**\n   * Ed25519: A public-key signature system using the EdDSA (Edwards-curve Digital Signature\n   * Algorithm) and Curve25519.\n   */\n  Ed25519 = 'Ed25519',\n\n  /**\n   * secp256k1: A cryptographic curve used for digital signatures in a range of decentralized\n   * systems.\n   */\n  secp256k1 = 'secp256k1',\n\n  /**\n   * secp256r1: Also known as P-256 or prime256v1, this curve is used for cryptographic operations\n   * and is widely supported in various cryptographic libraries and standards.\n   */\n  secp256r1 = 'secp256r1',\n\n  /**\n   * X25519: A Diffie-Hellman key exchange algorithm using Curve25519.\n   */\n  X25519 = 'X25519'\n}\n\n/**\n * Private helper that maps algorithm identifiers to their corresponding DID ION\n * {@link DidIonRegisteredKeyType | registered key type}.\n */\nconst AlgorithmToKeyTypeMap = {\n  Ed25519   : DidIonRegisteredKeyType.Ed25519,\n  ES256K    : DidIonRegisteredKeyType.secp256k1,\n  ES256     : DidIonRegisteredKeyType.secp256r1,\n  'P-256'   : DidIonRegisteredKeyType.secp256r1,\n  secp256k1 : DidIonRegisteredKeyType.secp256k1,\n  secp256r1 : DidIonRegisteredKeyType.secp256r1\n} as const;\n\n/**\n * The default node to use as a gateway to the Sidetree newtork when anchoring, updating, and\n * resolving DID documents.\n */\nconst DEFAULT_GATEWAY_URI = 'https://ion.tbd.engineering';\n\n/**\n * The `DidIon` class provides an implementation of the `did:ion` DID method.\n *\n * Features:\n * - DID Creation: Create new `did:ion` DIDs.\n * - DID Key Management: Instantiate a DID object from an existing key in a Key Management System\n *                       (KMS). If supported by the KMS, a DID's key can be exported to a portable\n *                       DID format.\n * - DID Resolution: Resolve a `did:ion` to its corresponding DID Document stored in the Sidetree\n *                   network.\n * - Signature Operations: Sign and verify messages using keys associated with a DID.\n *\n * @see {@link https://identity.foundation/sidetree/spec/ | Sidetree Protocol Specification}\n * @see {@link https://github.com/decentralized-identity/ion/blob/master/docs/design.md | ION Design Document}\n *\n * @example\n * ```ts\n * // DID Creation\n * const did = await DidIon.create();\n *\n * // DID Creation with a KMS\n * const keyManager = new LocalKeyManager();\n * const did = await DidIon.create({ keyManager });\n *\n * // DID Resolution\n * const resolutionResult = await DidIon.resolve({ did: did.uri });\n *\n * // Signature Operations\n * const signer = await did.getSigner();\n * const signature = await signer.sign({ data: new TextEncoder().encode('Message') });\n * const isValid = await signer.verify({ data: new TextEncoder().encode('Message'), signature });\n *\n * // Key Management\n *\n * // Instantiate a DID object for a published DID with existing keys in a KMS\n * const did = await DidIon.fromKeyManager({\n *  didUri: 'did:ion:EiAzB7K-xDIKc1csXo5HX2eNBoemK9feNhL3cKwfukYOug',\n *  keyManager\n * });\n *\n * // Convert a DID object to a portable format\n * const portableDid = await DidIon.toKeys({ did });\n * ```\n */\n\nexport class DidIon extends DidMethod {\n\n  /**\n   * Name of the DID method, as defined in the DID ION specification.\n   */\n  public static methodName = 'ion';\n\n  /**\n   * Creates a new DID using the `did:ion` method formed from a newly generated key.\n   *\n   * Notes:\n   * - If no `options` are given, by default a new Ed25519 key will be generated.\n   *\n   * @example\n   * ```ts\n   * // DID Creation\n   * const did = await DidIon.create();\n   *\n   * // DID Creation with a KMS\n   * const keyManager = new LocalKeyManager();\n   * const did = await DidIon.create({ keyManager });\n   * ```\n   *\n   * @param params - The parameters for the create operation.\n   * @param params.keyManager - Optionally specify a Key Management System (KMS) used to generate\n   *                            keys and sign data.\n   * @param params.options - Optional parameters that can be specified when creating a new DID.\n   * @returns A Promise resolving to a {@link BearerDid} object representing the new DID.\n   */\n  public static async create<TKms extends CryptoApi | undefined = undefined>({\n    keyManager = new LocalKeyManager(),\n    options = {}\n  }: {\n    keyManager?: TKms;\n    options?: DidIonCreateOptions<TKms>;\n  } = {}): Promise<BearerDid> {\n    // Before processing the create operation, validate DID-method-specific requirements to prevent\n    // keys from being generated unnecessarily.\n\n    // Check 1: Validate that the algorithm for any given verification method is supported by the\n    // DID ION specification.\n    if (options.verificationMethods?.some(vm => !(vm.algorithm in AlgorithmToKeyTypeMap))) {\n      throw new Error('One or more verification method algorithms are not supported');\n    }\n\n    // Check 2: Validate that the ID for any given verification method is unique.\n    const methodIds = options.verificationMethods?.filter(vm => 'id' in vm).map(vm => vm.id);\n    if (methodIds && methodIds.length !== new Set(methodIds).size) {\n      throw new Error('One or more verification method IDs are not unique');\n    }\n\n    // Check 3: Validate that the required properties for any given services are present.\n    if (options.services?.some(s => !s.id || !s.type || !s.serviceEndpoint)) {\n      throw new Error('One or more services are missing required properties');\n    }\n\n    // If no verification methods were specified, generate a default Ed25519 verification method.\n    const defaultVerificationMethod: DidCreateVerificationMethod<TKms> = {\n      algorithm : 'Ed25519' as any,\n      purposes  : ['authentication', 'assertionMethod', 'capabilityDelegation', 'capabilityInvocation']\n    };\n\n    const verificationMethodsToAdd: DidIonVerificationMethod[] = [];\n\n    // Generate random key material for additional verification methods, if any.\n    for (const vm of options.verificationMethods ?? [defaultVerificationMethod]) {\n      // Generate a random key for the verification method.\n      const keyUri = await keyManager.generateKey({ algorithm: vm.algorithm });\n      const publicKey = await keyManager.getPublicKey({ keyUri });\n\n      // Add the verification method to the DID document.\n      verificationMethodsToAdd.push({\n        id           : vm.id,\n        publicKeyJwk : publicKey,\n        purposes     : vm.purposes ?? ['authentication', 'assertionMethod', 'capabilityDelegation', 'capabilityInvocation']\n      });\n    }\n\n    // Generate a random key for the ION Recovery Key. Sidetree requires secp256k1 recovery keys.\n    const recoveryKeyUri = await keyManager.generateKey({ algorithm: DidIonRegisteredKeyType.secp256k1 });\n    const recoveryKey = await keyManager.getPublicKey({ keyUri: recoveryKeyUri });\n\n    // Generate a random key for the ION Update Key. Sidetree requires secp256k1 update keys.\n    const updateKeyUri = await keyManager.generateKey({ algorithm: DidIonRegisteredKeyType.secp256k1 });\n    const updateKey = await keyManager.getPublicKey({ keyUri: updateKeyUri });\n\n    // Compute the Long Form DID URI from the keys and services, if any.\n    const longFormDidUri = await DidIonUtils.computeLongFormDidUri({\n      recoveryKey,\n      updateKey,\n      services            : options.services ?? [],\n      verificationMethods : verificationMethodsToAdd\n    });\n\n    // Expand the DID URI string to a DID document.\n    const { didDocument, didResolutionMetadata } = await DidIon.resolve(longFormDidUri, { gatewayUri: options.gatewayUri });\n    if (didDocument === null) {\n      throw new Error(`Unable to resolve DID during creation: ${didResolutionMetadata?.error}`);\n    }\n\n    // Create the BearerDid object, including the \"Short Form\" of the DID URI, the ION update and\n    // recovery keys, and specifying that the DID has not yet been published.\n    const did = new BearerDid({\n      uri      : longFormDidUri,\n      document : didDocument,\n      metadata : {\n        published   : false,\n        canonicalId : longFormDidUri.split(':', 3).join(':'),\n        recoveryKey,\n        updateKey\n      },\n      keyManager\n    });\n\n    // By default, publish the DID document to a Sidetree node unless explicitly disabled.\n    if (options.publish ?? true) {\n      const registrationResult = await DidIon.publish({ did, gatewayUri: options.gatewayUri });\n      did.metadata = registrationResult.didDocumentMetadata;\n    }\n\n    return did;\n  }\n\n  /**\n   * Given the W3C DID Document of a `did:ion` DID, return the verification method that will be used\n   * for signing messages and credentials. If given, the `methodId` parameter is used to select the\n   * verification method. If not given, the first verification method in the authentication property\n   * in the DID Document is used.\n   *\n   * @param params - The parameters for the `getSigningMethod` operation.\n   * @param params.didDocument - DID Document to get the verification method from.\n   * @param params.methodId - ID of the verification method to use for signing.\n   * @returns Verification method to use for signing.\n   */\n  public static async getSigningMethod({ didDocument, methodId }: {\n    didDocument: DidDocument;\n    methodId?: string;\n  }): Promise<DidVerificationMethod> {\n    // Verify the DID method is supported.\n    const parsedDid = Did.parse(didDocument.id);\n    if (parsedDid && parsedDid.method !== this.methodName) {\n      throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported: ${parsedDid.method}`);\n    }\n\n    // Get the verification method with either the specified ID or the first assertion method.\n    const verificationMethod = didDocument.verificationMethod?.find(\n      vm => vm.id === (methodId ?? didDocument.assertionMethod?.[0])\n    );\n\n    if (!(verificationMethod && verificationMethod.publicKeyJwk)) {\n      throw new DidError(DidErrorCode.InternalError, 'A verification method intended for signing could not be determined from the DID Document');\n    }\n\n    return verificationMethod;\n  }\n\n  /**\n   * Instantiates a {@link BearerDid} object for the DID ION method from a given {@link PortableDid}.\n   *\n   * This method allows for the creation of a `BearerDid` object using a previously created DID's\n   * key material, DID document, and metadata.\n   *\n   * @example\n   * ```ts\n   * // Export an existing BearerDid to PortableDid format.\n   * const portableDid = await did.export();\n   * // Reconstruct a BearerDid object from the PortableDid.\n   * const did = await DidIon.import({ portableDid });\n   * ```\n   *\n   * @param params - The parameters for the import operation.\n   * @param params.portableDid - The PortableDid object to import.\n   * @param params.keyManager - Optionally specify an external Key Management System (KMS) used to\n   *                            generate keys and sign data. If not given, a new\n   *                            {@link LocalKeyManager} instance will be created and\n   *                            used.\n   * @returns A Promise resolving to a `BearerDid` object representing the DID formed from the\n   *          provided PortableDid.\n   * @throws An error if the DID document does not contain any verification methods or the keys for\n   *         any verification method are missing in the key manager.\n   */\n  public static async import({ portableDid, keyManager = new LocalKeyManager() }: {\n    keyManager?: CryptoApi & KeyImporterExporter<KmsImportKeyParams, KeyIdentifier, KmsExportKeyParams>;\n    portableDid: PortableDid;\n  }): Promise<BearerDid> {\n    // Verify the DID method is supported.\n    const parsedDid = Did.parse(portableDid.uri);\n    if (parsedDid?.method !== DidIon.methodName) {\n      throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported`);\n    }\n\n    const did = await BearerDid.import({ portableDid, keyManager });\n\n    return did;\n  }\n\n  /**\n   * Publishes a DID to a Sidetree node, making it publicly discoverable and resolvable.\n   *\n   * This method handles the publication of a DID Document associated with a `did:ion` DID to a\n   * Sidetree node.\n   *\n   * @remarks\n   * - This method is typically invoked automatically during the creation of a new DID unless the\n   *   `publish` option is set to `false`.\n   * - For existing, unpublished DIDs, it can be used to publish the DID Document to a Sidetree node.\n   * - The method relies on the specified Sidetree node to interface with the network.\n   *\n   * @param params - The parameters for the `publish` operation.\n   * @param params.did - The `BearerDid` object representing the DID to be published.\n   * @param params.gatewayUri - Optional. The URI of a server involved in executing DID\n   *                                    method operations. In the context of publishing, the\n   *                                    endpoint is expected to be a Sidetree node. If not\n   *                                    specified, a default node is used.\n   * @returns A Promise resolving to a boolean indicating whether the publication was successful.\n   *\n   * @example\n   * ```ts\n   * // Generate a new DID and keys but explicitly disable publishing.\n   * const did = await DidIon.create({ options: { publish: false } });\n   * // Publish the DID to the Sidetree network.\n   * const isPublished = await DidIon.publish({ did });\n   * // `isPublished` is true if the DID was successfully published.\n   * ```\n   */\n  public static async publish({ did, gatewayUri = DEFAULT_GATEWAY_URI }: {\n    did: BearerDid;\n    gatewayUri?: string;\n  }): Promise<DidRegistrationResult> {\n    // Construct an ION verification method made up of the id, public key, and purposes from each\n    // verification method in the DID document.\n    const verificationMethods: DidIonVerificationMethod[] = did.document.verificationMethod?.map(\n      vm => ({\n        id           : vm.id,\n        publicKeyJwk : vm.publicKeyJwk!,\n        purposes     : getVerificationRelationshipsById({ didDocument: did.document, methodId: vm.id })\n      })\n    ) ?? [];\n\n    // Create the ION document.\n    const ionDocument = await DidIonUtils.createIonDocument({\n      services: did.document.service ?? [],\n      verificationMethods\n    });\n\n    // Construct the ION Create Operation request.\n    const createOperation = await DidIonUtils.constructCreateRequest({\n      ionDocument,\n      recoveryKey : did.metadata.recoveryKey,\n      updateKey   : did.metadata.updateKey\n    });\n\n    try {\n      // Construct the URL of the SideTree node's operations endpoint.\n      const operationsUrl = DidIonUtils.appendPathToUrl({\n        baseUrl : gatewayUri,\n        path    : `/operations`\n      });\n\n      // Submit the Create Operation to the operations endpoint.\n      const response = await fetch(operationsUrl, {\n        method  : 'POST',\n        mode    : 'cors',\n        headers : { 'Content-Type': 'application/json' },\n        body    : JSON.stringify(createOperation)\n      });\n\n      // Return the result of processing the Create operation, including the updated DID metadata\n      // with the publishing result.\n      return {\n        didDocument         : did.document,\n        didDocumentMetadata : {\n          ...did.metadata,\n          published: response.ok,\n        },\n        didRegistrationMetadata: {}\n      };\n\n    } catch (error: any) {\n      return {\n        didDocument         : null,\n        didDocumentMetadata : {\n          published: false,\n        },\n        didRegistrationMetadata: {\n          error        : DidErrorCode.InternalError,\n          errorMessage : `Failed to publish DID document for: ${did.uri}`\n        }\n      };\n    }\n  }\n\n  /**\n   * Resolves a `did:ion` identifier to its corresponding DID document.\n   *\n   * This method performs the resolution of a `did:ion` DID, retrieving its DID Document from the\n   * Sidetree-based DID overlay network. The process involves querying a Sidetree node to retrieve\n   * the DID Document that corresponds to the given DID identifier.\n   *\n   * @remarks\n   * - If a `gatewayUri` option is not specified, a default node is used to access the Sidetree\n   *   network.\n   * - It decodes the DID identifier and retrieves the associated DID Document and metadata.\n   * - In case of resolution failure, appropriate error information is returned.\n   *\n   * @example\n   * ```ts\n   * const resolutionResult = await DidIon.resolve('did:ion:example');\n   * ```\n   *\n   * @param didUri - The DID to be resolved.\n   * @param options - Optional parameters for resolving the DID. Unused by this DID method.\n   * @returns A Promise resolving to a {@link DidResolutionResult} object representing the result of the resolution.\n   */\n  public static async resolve(didUri: string, options: DidResolutionOptions = {}): Promise<DidResolutionResult> {\n    // Attempt to parse the DID URI.\n    const parsedDid = Did.parse(didUri);\n\n    // If parsing failed, the DID is invalid.\n    if (!parsedDid) {\n      return {\n        ...EMPTY_DID_RESOLUTION_RESULT,\n        didResolutionMetadata: { error: 'invalidDid' }\n      };\n    }\n\n    // If the DID method is not \"ion\", return an error.\n    if (parsedDid.method !== DidIon.methodName) {\n      return {\n        ...EMPTY_DID_RESOLUTION_RESULT,\n        didResolutionMetadata: { error: 'methodNotSupported' }\n      };\n    }\n\n    // To execute the read method operation, use the given gateway URI or a default Sidetree node.\n    const gatewayUri = options?.gatewayUri ?? DEFAULT_GATEWAY_URI;\n\n    try {\n      // Construct the URL to be used in the resolution request.\n      const resolutionUrl = DidIonUtils.appendPathToUrl({\n        baseUrl : gatewayUri,\n        path    : `/identifiers/${didUri}`\n      });\n\n      // Attempt to retrieve the DID document and metadata from the Sidetree node.\n      const response = await fetch(resolutionUrl);\n\n      // If the DID document was not found, return an error.\n      if (!response.ok) {\n        throw new DidError(DidErrorCode.NotFound, `Unable to find DID document for: ${didUri}`);\n      }\n\n      // If the DID document was retrieved successfully, return it.\n      const { didDocument, didDocumentMetadata } = await response.json() as DidResolutionResult;\n      return {\n        ...EMPTY_DID_RESOLUTION_RESULT,\n        ...didDocument && { didDocument },\n        didDocumentMetadata: {\n          published: didDocumentMetadata?.method?.published,\n          ...didDocumentMetadata\n        }\n      };\n\n    } catch (error: any) {\n      // Rethrow any unexpected errors that are not a `DidError`.\n      if (!(error instanceof DidError)) throw new Error(error);\n\n      // Return a DID Resolution Result with the appropriate error code.\n      return {\n        ...EMPTY_DID_RESOLUTION_RESULT,\n        didResolutionMetadata: {\n          error: error.code,\n          ...error.message && { errorMessage: error.message }\n        }\n      };\n    }\n  }\n}\n\n/**\n * The `DidIonUtils` class provides utility functions to support operations in the DID ION method.\n */\nexport class DidIonUtils {\n  /**\n   * Appends a specified path to a base URL, ensuring proper formatting of the resulting URL.\n   *\n   * This method is useful for constructing URLs for accessing various endpoints, such as Sidetree\n   * nodes in the ION network. It handles the nuances of URL path concatenation, including the\n   * addition or removal of leading/trailing slashes, to create a well-formed URL.\n   *\n   * @param params - The parameters for URL construction.\n   * @param params.baseUrl - The base URL to which the path will be appended.\n   * @param params.path - The path to append to the base URL.\n   * @returns The fully constructed URL string with the path appended to the base URL.\n   */\n  public static appendPathToUrl({ baseUrl, path }: {\n    baseUrl: string;\n    path: string;\n  }): string {\n    const url = new URL(baseUrl);\n    url.pathname = url.pathname.endsWith('/') ? url.pathname : url.pathname + '/';\n    url.pathname += path.startsWith('/') ? path.substring(1) : path;\n\n    return url.toString();\n  }\n\n  /**\n   * Computes the Long Form DID URI given an ION DID's recovery key, update key, services, and\n   * verification methods.\n   *\n   * @param params - The parameters for computing the Long Form DID URI.\n   * @param params.recoveryKey - The ION Recovery Key.\n   * @param params.updateKey - The ION Update Key.\n   * @param params.services - An array of services associated with the DID.\n   * @param params.verificationMethods - An array of verification methods associated with the DID.\n   * @returns A Promise resolving to the Long Form DID URI.\n   */\n  public static async computeLongFormDidUri({ recoveryKey, updateKey, services, verificationMethods }: {\n    recoveryKey: Jwk;\n    updateKey: Jwk;\n    services: DidService[];\n    verificationMethods: DidIonVerificationMethod[];\n  }): Promise<string> {\n    // Create the ION document.\n    const ionDocument = await DidIonUtils.createIonDocument({ services, verificationMethods });\n\n    // Normalize JWK to onnly include specific members and in lexicographic order.\n    const normalizedRecoveryKey = DidIonUtils.normalizeJwk(recoveryKey);\n    const normalizedUpdateKey = DidIonUtils.normalizeJwk(updateKey);\n\n    // Compute the Long Form DID URI.\n    const longFormDidUri = await IonDid.createLongFormDid({\n      document    : ionDocument,\n      recoveryKey : normalizedRecoveryKey as JwkEs256k,\n      updateKey   : normalizedUpdateKey as JwkEs256k\n    });\n\n    return longFormDidUri;\n  }\n\n  /**\n   * Constructs a Sidetree Create Operation request for a DID document within the ION network.\n   *\n   * This method prepares the necessary payload for submitting a Create Operation to a Sidetree\n   * node, encapsulating the details of the DID document, recovery key, and update key.\n   *\n   * @param params - Parameters required to construct the Create Operation request.\n   * @param params.ionDocument - The DID document model containing public keys and service endpoints.\n   * @param params.recoveryKey - The recovery public key in JWK format.\n   * @param params.updateKey - The update public key in JWK format.\n   * @returns A promise resolving to the ION Create Operation request model, ready for submission to a Sidetree node.\n   */\n  public static async constructCreateRequest({ ionDocument, recoveryKey, updateKey }: {\n    ionDocument: IonDocumentModel,\n    recoveryKey: Jwk,\n    updateKey: Jwk\n  }): Promise<DidIonCreateRequest> {\n    // Create an ION DID create request operation.\n    const createRequest = await IonRequest.createCreateRequest({\n      document    : ionDocument,\n      recoveryKey : DidIonUtils.normalizeJwk(recoveryKey) as JwkEs256k,\n      updateKey   : DidIonUtils.normalizeJwk(updateKey) as JwkEs256k\n    }) as DidIonCreateRequest;\n\n    return createRequest;\n  }\n\n  /**\n   * Assembles an ION document model from provided services and verification methods\n   *\n   * This model serves as the foundation for a DID document in the ION network, facilitating the\n   * creation and management of decentralized identities. It translates service endpoints and\n   * public keys into a format compatible with the Sidetree protocol, ensuring the resulting DID\n   * document adheres to the required specifications for ION DIDs. This method is essential for\n   * constructing the payload needed to register or update DIDs within the ION network.\n   *\n   * @param params - The parameters containing the services and verification methods to include in the ION document.\n   * @param params.services - A list of service endpoints to be included in the DID document, specifying ways to interact with the DID subject.\n   * @param params.verificationMethods - A list of verification methods to be included, detailing the cryptographic keys and their intended uses within the DID document.\n   * @returns A Promise resolving to an `IonDocumentModel`, ready for use in Sidetree operations like DID creation and updates.\n   */\n  public static async createIonDocument({ services, verificationMethods }: {\n    services: DidService[];\n    verificationMethods: DidIonVerificationMethod[]\n  }): Promise<IonDocumentModel> {\n    /**\n     * STEP 1: Convert verification methods to ION SDK format.\n     */\n    const ionPublicKeys: IonPublicKeyModel[] = [];\n\n    for (const vm of verificationMethods) {\n      // Use the given ID, the key's ID, or the key's thumbprint as the verification method ID.\n      let methodId = vm.id ?? vm.publicKeyJwk.kid ?? await computeJwkThumbprint({ jwk: vm.publicKeyJwk });\n      methodId = `${methodId.split('#').pop()}`; // Remove fragment prefix, if any.\n\n      // Convert public key JWK to ION format.\n      const publicKey: IonPublicKeyModel = {\n        id           : methodId,\n        publicKeyJwk : DidIonUtils.normalizeJwk(vm.publicKeyJwk),\n        purposes     : vm.purposes as IonPublicKeyPurpose[],\n        type         : 'JsonWebKey2020'\n      };\n\n      ionPublicKeys.push(publicKey);\n    }\n\n    /**\n     * STEP 2: Convert service entries, if any, to ION SDK format.\n     */\n    const ionServices = services.map(service => ({\n      ...service,\n      id: `${service.id.split('#').pop()}` // Remove fragment prefix, if any.\n    }));\n\n    /**\n     * STEP 3: Format as ION document.\n     */\n    const ionDocumentModel: IonDocumentModel = {\n      publicKeys : ionPublicKeys,\n      services   : ionServices\n    };\n\n    return ionDocumentModel;\n  }\n\n  /**\n   * Normalize the given JWK to include only specific members and in lexicographic order.\n   *\n   * @param jwk - The JWK to normalize.\n   * @returns The normalized JWK.\n   */\n  private static normalizeJwk(jwk: Jwk): Jwk {\n    const keyType = jwk.kty;\n    let normalizedJwk: Jwk;\n\n    if (keyType === 'EC') {\n      normalizedJwk = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };\n    } else if (keyType === 'oct') {\n      normalizedJwk = { k: jwk.k, kty: jwk.kty };\n    } else if (keyType === 'OKP') {\n      normalizedJwk = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };\n    } else if (keyType === 'RSA') {\n      normalizedJwk = { e: jwk.e, kty: jwk.kty, n: jwk.n };\n    } else {\n      throw new Error(`Unsupported key type: ${keyType}`);\n    }\n\n    return normalizedJwk;\n  }\n}", "import type {\n  Jwk,\n  CryptoApi,\n  KeyIdentifier,\n  KmsExportKeyParams,\n  KmsImportKeyParams,\n  KeyImporterExporter,\n  InferKeyGeneratorAlgorithm,\n} from '@web5/crypto';\n\nimport { Convert } from '@web5/common';\nimport { LocalKeyManager } from '@web5/crypto';\n\nimport type { PortableDid } from '../types/portable-did.js';\nimport type { DidCreateOptions, DidCreateVerificationMethod } from './did-method.js';\nimport type { DidDocument, DidResolutionOptions, DidResolutionResult, DidVerificationMethod } from '../types/did-core.js';\n\nimport { Did } from '../did.js';\nimport { DidMethod } from './did-method.js';\nimport { BearerDid } from '../bearer-did.js';\nimport { DidError, DidErrorCode } from '../did-error.js';\nimport { EMPTY_DID_RESOLUTION_RESULT } from '../resolver/did-resolver.js';\n\n/**\n * Defines the set of options available when creating a new Decentralized Identifier (DID) with the\n * 'did:jwk' method.\n *\n * Either the `algorithm` or `verificationMethods` option can be specified, but not both.\n * - A new key will be generated using the algorithm identifier specified in either the `algorithm`\n *   property or the `verificationMethods` object's `algorithm` property.\n * - If `verificationMethods` is given, it must contain exactly one entry since DID JWK only\n *   supports a single verification method.\n * - If neither is given, the default is to generate a new Ed25519 key.\n *\n * @example\n * ```ts\n * // DID Creation\n *\n * // By default, when no options are given, a new Ed25519 key will be generated.\n * const did = await DidJwk.create();\n *\n * // The algorithm to use for key generation can be specified as a top-level option.\n * const did = await DidJwk.create({\n *   options: { algorithm = 'ES256K' }\n * });\n *\n * // Or, alternatively as a property of the verification method.\n * const did = await DidJwk.create({\n *   options: {\n *     verificationMethods: [{ algorithm = 'ES256K' }]\n *   }\n * });\n *\n * // DID Creation with a KMS\n * const keyManager = new LocalKeyManager();\n * const did = await DidJwk.create({ keyManager });\n *\n * // DID Resolution\n * const resolutionResult = await DidJwk.resolve({ did: did.uri });\n *\n * // Signature Operations\n * const signer = await did.getSigner();\n * const signature = await signer.sign({ data: new TextEncoder().encode('Message') });\n * const isValid = await signer.verify({ data: new TextEncoder().encode('Message'), signature });\n *\n * // Import / Export\n *\n * // Export a BearerDid object to the PortableDid format.\n * const portableDid = await did.export();\n *\n * // Reconstruct a BearerDid object from a PortableDid\n * const did = await DidJwk.import(portableDid);\n * ```\n */\nexport interface DidJwkCreateOptions<TKms> extends DidCreateOptions<TKms> {\n  /**\n   * Optionally specify the algorithm to be used for key generation.\n   */\n  algorithm?: TKms extends CryptoApi\n    ? InferKeyGeneratorAlgorithm<TKms>\n    : InferKeyGeneratorAlgorithm<LocalKeyManager>;\n\n  /**\n   * Alternatively, specify the algorithm to be used for key generation of the single verification\n   * method in the DID Document.\n   */\n  verificationMethods?: [DidCreateVerificationMethod<TKms>];\n}\n\n/**\n * The `DidJwk` class provides an implementation of the `did:jwk` DID method.\n *\n * Features:\n * - DID Creation: Create new `did:jwk` DIDs.\n * - DID Key Management: Instantiate a DID object from an existing verification method key set or\n *                       or a key in a Key Management System (KMS). If supported by the KMS, a DID's\n *                       key can be exported to a portable DID format.\n * - DID Resolution: Resolve a `did:jwk` to its corresponding DID Document.\n * - Signature Operations: Sign and verify messages using keys associated with a DID.\n *\n * @remarks\n * The `did:jwk` DID method uses a single JSON Web Key (JWK) to generate a DID and does not rely\n * on any external system such as a blockchain or centralized database. This characteristic makes\n * it suitable for use cases where a assertions about a DID Subject can be self-verifiable by\n * third parties.\n *\n * The DID URI is formed by Base64URL-encoding the JWK and prefixing with `did:jwk:`. The DID\n * Document of a `did:jwk` DID contains a single verification method, which is the JWK used\n * to generate the DID. The verification method is identified by the key ID `#0`.\n *\n * @see {@link https://github.com/quartzjer/did-jwk/blob/main/spec.md | DID JWK Specification}\n *\n * @example\n * ```ts\n * // DID Creation\n * const did = await DidJwk.create();\n *\n * // DID Creation with a KMS\n * const keyManager = new LocalKeyManager();\n * const did = await DidJwk.create({ keyManager });\n *\n * // DID Resolution\n * const resolutionResult = await DidJwk.resolve({ did: did.uri });\n *\n * // Signature Operations\n * const signer = await did.getSigner();\n * const signature = await signer.sign({ data: new TextEncoder().encode('Message') });\n * const isValid = await signer.verify({ data: new TextEncoder().encode('Message'), signature });\n *\n * // Key Management\n *\n * // Instantiate a DID object from an existing key in a KMS\n * const did = await DidJwk.fromKeyManager({\n *  didUri: 'did:jwk:eyJrIjoiT0tQIiwidCI6IkV1c2UyNTYifQ',\n *  keyManager\n * });\n *\n * // Instantiate a DID object from an existing verification method key\n * const did = await DidJwk.fromKeys({\n *   verificationMethods: [{\n *     publicKeyJwk: {\n *       kty: 'OKP',\n *       crv: 'Ed25519',\n *       x: 'cHs7YMLQ3gCWjkacMURBsnEJBcEsvlsE5DfnsfTNDP4'\n *     },\n *     privateKeyJwk: {\n *       kty: 'OKP',\n *       crv: 'Ed25519',\n *       x: 'cHs7YMLQ3gCWjkacMURBsnEJBcEsvlsE5DfnsfTNDP4',\n *       d: 'bdcGE4KzEaekOwoa-ee3gAm1a991WvNj_Eq3WKyqTnE'\n *     }\n *   }]\n * });\n *\n * // Convert a DID object to a portable format\n * const portableDid = await DidJwk.toKeys({ did });\n *\n * // Reconstruct a DID object from a portable format\n * const did = await DidJwk.fromKeys(portableDid);\n * ```\n */\nexport class DidJwk extends DidMethod {\n\n  /**\n   * Name of the DID method, as defined in the DID JWK specification.\n   */\n  public static methodName = 'jwk';\n\n  /**\n   * Creates a new DID using the `did:jwk` method formed from a newly generated key.\n   *\n   * @remarks\n   * The DID URI is formed by Base64URL-encoding the JWK and prefixing with `did:jwk:`.\n   *\n   * Notes:\n   * - If no `options` are given, by default a new Ed25519 key will be generated.\n   * - The `algorithm` and `verificationMethods` options are mutually exclusive. If both are given,\n   *   an error will be thrown.\n   *\n   * @example\n   * ```ts\n   * // DID Creation\n   * const did = await DidJwk.create();\n   *\n   * // DID Creation with a KMS\n   * const keyManager = new LocalKeyManager();\n   * const did = await DidJwk.create({ keyManager });\n   * ```\n   *\n   * @param params - The parameters for the create operation.\n   * @param params.keyManager - Optionally specify a Key Management System (KMS) used to generate\n   *                            keys and sign data.\n   * @param params.options - Optional parameters that can be specified when creating a new DID.\n   * @returns A Promise resolving to a {@link BearerDid} object representing the new DID.\n   */\n  public static async create<TKms extends CryptoApi | undefined = undefined>({\n    keyManager = new LocalKeyManager(),\n    options = {}\n  }: {\n    keyManager?: TKms;\n    options?: DidJwkCreateOptions<TKms>;\n  } = {}): Promise<BearerDid> {\n    // Before processing the create operation, validate DID-method-specific requirements to prevent\n    // keys from being generated unnecessarily.\n\n    // Check 1: Validate that `algorithm` or `verificationMethods` options are not both given.\n    if (options.algorithm && options.verificationMethods) {\n      throw new Error(`The 'algorithm' and 'verificationMethods' options are mutually exclusive`);\n    }\n\n    // Check 2: If `verificationMethods` is given, it must contain exactly one entry since DID JWK\n    // only supports a single verification method.\n    if (options.verificationMethods && options.verificationMethods.length !== 1) {\n      throw new Error(`The 'verificationMethods' option must contain exactly one entry`);\n    }\n\n    // Default to Ed25519 key generation if an algorithm is not given.\n    const algorithm = options.algorithm ?? options.verificationMethods?.[0]?.algorithm ?? 'Ed25519';\n\n    // Generate a new key using the specified `algorithm`.\n    const keyUri = await keyManager.generateKey({ algorithm });\n    const publicKey = await keyManager.getPublicKey({ keyUri });\n\n    // Compute the DID identifier from the public key by serializing the JWK to a UTF-8 string and\n    // encoding in Base64URL format.\n    const identifier = Convert.object(publicKey).toBase64Url();\n\n    // Attach the prefix `did:jwk` to form the complete DID URI.\n    const didUri = `did:${DidJwk.methodName}:${identifier}`;\n\n    // Expand the DID URI string to a DID document.\n    const didResolutionResult = await DidJwk.resolve(didUri);\n    const document = didResolutionResult.didDocument as DidDocument;\n\n    // Create the BearerDid object from the generated key material.\n    const did = new BearerDid({\n      uri      : didUri,\n      document,\n      metadata : {},\n      keyManager\n    });\n\n    return did;\n  }\n\n  /**\n   * Given the W3C DID Document of a `did:jwk` DID, return the verification method that will be used\n   * for signing messages and credentials. If given, the `methodId` parameter is used to select the\n   * verification method. If not given, the first verification method in the DID Document is used.\n   *\n   * Note that for DID JWK, only one verification method can exist so specifying `methodId` could be\n   * considered redundant or unnecessary. The option is provided for consistency with other DID\n   * method implementations.\n   *\n   * @param params - The parameters for the `getSigningMethod` operation.\n   * @param params.didDocument - DID Document to get the verification method from.\n   * @param params.methodId - ID of the verification method to use for signing.\n   * @returns Verification method to use for signing.\n   */\n  public static async getSigningMethod({ didDocument }: {\n    didDocument: DidDocument;\n    methodId?: string;\n  }): Promise<DidVerificationMethod> {\n    // Verify the DID method is supported.\n    const parsedDid = Did.parse(didDocument.id);\n    if (parsedDid && parsedDid.method !== this.methodName) {\n      throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported: ${parsedDid.method}`);\n    }\n\n    // Attempt to find the verification method in the DID Document.\n    const [ verificationMethod ] = didDocument.verificationMethod ?? [];\n\n    if (!(verificationMethod && verificationMethod.publicKeyJwk)) {\n      throw new DidError(DidErrorCode.InternalError, 'A verification method intended for signing could not be determined from the DID Document');\n    }\n\n    return verificationMethod;\n  }\n\n  /**\n   * Instantiates a {@link BearerDid} object for the DID JWK method from a given {@link PortableDid}.\n   *\n   * This method allows for the creation of a `BearerDid` object using a previously created DID's\n   * key material, DID document, and metadata.\n   *\n   * @remarks\n   * The `verificationMethod` array of the DID document must contain exactly one key since the\n   * `did:jwk` method only supports a single verification method.\n   *\n   * @example\n   * ```ts\n   * // Export an existing BearerDid to PortableDid format.\n   * const portableDid = await did.export();\n   * // Reconstruct a BearerDid object from the PortableDid.\n   * const did = await DidJwk.import({ portableDid });\n   * ```\n   *\n   * @param params - The parameters for the import operation.\n   * @param params.portableDid - The PortableDid object to import.\n   * @param params.keyManager - Optionally specify an external Key Management System (KMS) used to\n   *                            generate keys and sign data. If not given, a new\n   *                            {@link LocalKeyManager} instance will be created and\n   *                            used.\n   * @returns A Promise resolving to a `BearerDid` object representing the DID formed from the provided keys.\n   * @throws An error if the DID document does not contain exactly one verification method.\n   */\n  public static async import({ portableDid, keyManager = new LocalKeyManager() }: {\n    keyManager?: CryptoApi & KeyImporterExporter<KmsImportKeyParams, KeyIdentifier, KmsExportKeyParams>;\n    portableDid: PortableDid;\n  }): Promise<BearerDid> {\n    // Verify the DID method is supported.\n    const parsedDid = Did.parse(portableDid.uri);\n    if (parsedDid?.method !== DidJwk.methodName) {\n      throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported`);\n    }\n\n    // Use the given PortableDid to construct the BearerDid object.\n    const did = await BearerDid.import({ portableDid, keyManager });\n\n    // Validate that the given DID document contains exactly one verification method.\n    // Note: The non-undefined assertion is necessary because the type system cannot infer that\n    // the `verificationMethod` property is defined -- which is checked by `BearerDid.import()`.\n    if (did.document.verificationMethod!.length !== 1) {\n      throw new DidError(DidErrorCode.InvalidDidDocument, `DID document must contain exactly one verification method`);\n    }\n\n    return did;\n  }\n\n  /**\n   * Resolves a `did:jwk` identifier to a DID Document.\n   *\n   * @param didUri - The DID to be resolved.\n   * @param _options - Optional parameters for resolving the DID. Unused by this DID method.\n   * @returns A Promise resolving to a {@link DidResolutionResult} object representing the result of the resolution.\n   */\n  public static async resolve(didUri: string, _options?: DidResolutionOptions): Promise<DidResolutionResult> {\n    // Attempt to parse the DID URI.\n    const parsedDid = Did.parse(didUri);\n\n    // Attempt to decode the Base64URL-encoded JWK.\n    let publicKey: Jwk | undefined;\n    try {\n      publicKey = Convert.base64Url(parsedDid!.id).toObject() as Jwk;\n    } catch { /* Consume the error so that a DID resolution error can be returned later. */ }\n\n    // If parsing or decoding failed, the DID is invalid.\n    if (!parsedDid || !publicKey) {\n      return {\n        ...EMPTY_DID_RESOLUTION_RESULT,\n        didResolutionMetadata: { error: 'invalidDid' }\n      };\n    }\n\n    // If the DID method is not \"jwk\", return an error.\n    if (parsedDid.method !== DidJwk.methodName) {\n      return {\n        ...EMPTY_DID_RESOLUTION_RESULT,\n        didResolutionMetadata: { error: 'methodNotSupported' }\n      };\n    }\n\n    const didDocument: DidDocument = {\n      '@context': [\n        'https://www.w3.org/ns/did/v1',\n        'https://w3id.org/security/suites/jws-2020/v1'\n      ],\n      id: parsedDid.uri\n    };\n\n    const keyUri = `${didDocument.id}#0`;\n\n    // Set the Verification Method property.\n    didDocument.verificationMethod = [{\n      id           : keyUri,\n      type         : 'JsonWebKey2020',\n      controller   : didDocument.id,\n      publicKeyJwk : publicKey\n    }];\n\n    // Set the Verification Relationship properties.\n    didDocument.authentication = [keyUri];\n    didDocument.assertionMethod = [keyUri];\n    didDocument.capabilityInvocation = [keyUri];\n    didDocument.capabilityDelegation = [keyUri];\n    didDocument.keyAgreement = [keyUri];\n\n    // If the JWK contains a `use` property with the value \"sig\" then the `keyAgreement` property\n    // is not included in the DID Document. If the `use` value is \"enc\" then only the `keyAgreement`\n    // property is included in the DID Document.\n    switch (publicKey.use) {\n      case 'sig': {\n        delete didDocument.keyAgreement;\n        break;\n      }\n\n      case 'enc': {\n        delete didDocument.authentication;\n        delete didDocument.assertionMethod;\n        delete didDocument.capabilityInvocation;\n        delete didDocument.capabilityDelegation;\n        break;\n      }\n    }\n\n    return {\n      ...EMPTY_DID_RESOLUTION_RESULT,\n      didDocument,\n    };\n  }\n}", "import type { MulticodecCode, MulticodecDefinition, RequireOnly } from '@web5/common';\nimport type {\n  Jwk,\n  CryptoApi,\n  KeyCompressor,\n  KeyIdentifier,\n  KmsExportKeyParams,\n  KmsImportKeyParams,\n  KeyImporterExporter,\n  AsymmetricKeyConverter,\n  InferKeyGeneratorAlgorithm,\n} from '@web5/crypto';\n\nimport { Multicodec, universalTypeOf } from '@web5/common';\nimport {\n  X25519,\n  Ed25519,\n  Secp256k1,\n  Secp256r1,\n  LocalKeyManager,\n} from '@web5/crypto';\n\nimport type { PortableDid } from '../types/portable-did.js';\nimport type { DidCreateOptions, DidCreateVerificationMethod } from './did-method.js';\nimport type {\n  DidDocument,\n  DidResolutionOptions,\n  DidResolutionResult,\n  DidVerificationMethod,\n} from '../types/did-core.js';\n\nimport { Did } from '../did.js';\nimport { DidMethod } from './did-method.js';\nimport { BearerDid } from '../bearer-did.js';\nimport { DidError, DidErrorCode } from '../did-error.js';\nimport { KeyWithMulticodec } from '../types/multibase.js';\nimport { EMPTY_DID_RESOLUTION_RESULT } from '../resolver/did-resolver.js';\nimport { getVerificationMethodTypes, keyBytesToMultibaseId, multibaseIdToKeyBytes } from '../utils.js';\n\n/**\n * Defines the set of options available when creating a new Decentralized Identifier (DID) with the\n * 'did:key' method.\n *\n * Either the `algorithm` or `verificationMethods` option can be specified, but not both.\n * - A new key will be generated using the algorithm identifier specified in either the `algorithm`\n *   property or the `verificationMethods` object's `algorithm` property.\n * - If `verificationMethods` is given, it must contain exactly one entry since DID Key only\n *   supports a single verification method.\n * - If neither is given, the default is to generate a new Ed25519 key.\n *\n * @example\n * ```ts\n  * // By default, when no options are given, a new Ed25519 key will be generated.\n * const did = await DidKey.create();\n *\n * // The algorithm to use for key generation can be specified as a top-level option.\n * const did = await DidKey.create({\n *   options: { algorithm = 'secp256k1' }\n * });\n *\n * // Or, alternatively as a property of the verification method.\n * const did = await DidKey.create({\n *   options: {\n *     verificationMethods: [{ algorithm = 'secp256k1' }]\n *   }\n * });\n *\n * // DID Creation with a KMS\n * const keyManager = new LocalKeyManager();\n * const did = await DidKey.create({ keyManager });\n *\n * // DID Resolution\n * const resolutionResult = await DidKey.resolve({ did: did.uri });\n *\n * // Signature Operations\n * const signer = await did.getSigner();\n * const signature = await signer.sign({ data: new TextEncoder().encode('Message') });\n * const isValid = await signer.verify({ data: new TextEncoder().encode('Message'), signature });\n *\n * // Import / Export\n *\n * // Export a BearerDid object to the PortableDid format.\n * const portableDid = await did.export();\n *\n * // Reconstruct a BearerDid object from a PortableDid\n * const did = await DidKey.import(portableDid);\n * ```\n */\nexport interface DidKeyCreateOptions<TKms> extends DidCreateOptions<TKms> {\n  /**\n   * Optionally specify the algorithm to be used for key generation.\n   */\n  algorithm?: TKms extends CryptoApi\n    ? InferKeyGeneratorAlgorithm<TKms>\n    : InferKeyGeneratorAlgorithm<LocalKeyManager>;\n\n  /**\n   * Optionally specify an array of JSON-LD context links for the @context property of the DID\n   * document.\n   *\n   * The @context property provides a JSON-LD processor with the information necessary to interpret\n   * the DID document JSON. The default context URL is 'https://www.w3.org/ns/did/v1'.\n   */\n  defaultContext?: string;\n\n  /**\n   * Optionally enable encryption key derivation during DID creation.\n   *\n   * By default, this option is set to `false`, which means encryption key derivation is not\n   * performed unless explicitly enabled.\n   *\n   * When set to `true`, an `X25519` key will be derived from the `Ed25519` public key used to\n   * create the DID. This feature enables the same DID to be used for encrypted communication, in\n   * addition to signature verification.\n   *\n   * Notes:\n   * - This option is ONLY applicable when the `algorithm` of the DID's public key is `Ed25519`.\n   * - Enabling this introduces specific cryptographic considerations that should be understood\n   *   before using the same key pair for digital signatures and encrypted communication. See the following for more information:\n   */\n  enableEncryptionKeyDerivation?: boolean;\n\n  /**\n   * Optionally enable experimental public key types during DID creation.\n   * By default, this option is set to `false`, which means experimental public key types are not\n   * supported.\n   *\n   * Note: This implementation of the DID Key method does not support any experimental public key\n   * types.\n   */\n  enableExperimentalPublicKeyTypes?: boolean;\n\n  /**\n   * Optionally specify the format of the public key to be used for DID creation.\n   */\n  publicKeyFormat?: keyof typeof DidKeyVerificationMethodType;\n\n  /**\n   * Alternatively, specify the algorithm to be used for key generation of the single verification\n   * method in the DID Document.\n   */\n  verificationMethods?: [DidCreateVerificationMethod<TKms>];\n}\n\n/**\n * Enumerates the types of keys that can be used in a DID Key document.\n *\n * The DID Key method supports various cryptographic key types. These key types are essential for\n * the creation and management of DIDs and their associated cryptographic operations like signing\n * and encryption.\n */\nexport enum DidKeyRegisteredKeyType {\n  /**\n   * Ed25519: A public-key signature system using the EdDSA (Edwards-curve Digital Signature\n   * Algorithm) and Curve25519.\n   */\n  Ed25519 = 'Ed25519',\n\n  /**\n   * secp256k1: A cryptographic curve used for digital signatures in a range of decentralized\n   * systems.\n   */\n  secp256k1 = 'secp256k1',\n\n  /**\n   * secp256r1: Also known as P-256 or prime256v1, this curve is used for cryptographic operations\n   * and is widely supported in various cryptographic libraries and standards.\n   */\n  secp256r1 = 'secp256r1',\n\n  /**\n   * X25519: A Diffie-Hellman key exchange algorithm using Curve25519.\n   */\n  X25519 = 'X25519'\n}\n\n/**\n * Enumerates the verification method types supported by the DID Key method.\n *\n * This enum defines the URIs associated with common verification methods used in DID Documents.\n * These URIs represent cryptographic suites or key types standardized for use across decentralized\n * identifiers (DIDs).\n */\nexport const DidKeyVerificationMethodType = {\n  /** Represents an Ed25519 public key used for digital signatures. */\n  Ed25519VerificationKey2020: 'https://w3id.org/security/suites/ed25519-2020/v1',\n\n  /** Represents a JSON Web Key (JWK) used for digital signatures and key agreement protocols. */\n  JsonWebKey2020: 'https://w3id.org/security/suites/jws-2020/v1',\n\n  /** Represents an X25519 public key used for key agreement protocols. */\n  X25519KeyAgreementKey2020: 'https://w3id.org/security/suites/x25519-2020/v1',\n} as const;\n\n/**\n * Private helper that maps algorithm identifiers to their corresponding DID Key\n * {@link DidKeyRegisteredKeyType | registered key type}.\n */\nconst AlgorithmToKeyTypeMap = {\n  Ed25519   : DidKeyRegisteredKeyType.Ed25519,\n  ES256K    : DidKeyRegisteredKeyType.secp256k1,\n  ES256     : DidKeyRegisteredKeyType.secp256r1,\n  'P-256'   : DidKeyRegisteredKeyType.secp256r1,\n  secp256k1 : DidKeyRegisteredKeyType.secp256k1,\n  secp256r1 : DidKeyRegisteredKeyType.secp256r1,\n  X25519    : DidKeyRegisteredKeyType.X25519\n} as const;\n\n/**\n * The `DidKey` class provides an implementation of the 'did:key' DID method.\n *\n * Features:\n * - DID Creation: Create new `did:key` DIDs.\n * - DID Key Management: Instantiate a DID object from an existing verification method key set or\n *                       or a key in a Key Management System (KMS). If supported by the KMS, a DID's\n *                       key can be exported to a portable DID format.\n * - DID Resolution: Resolve a `did:key` to its corresponding DID Document.\n * - Signature Operations: Sign and verify messages using keys associated with a DID.\n *\n * @remarks\n * The `did:key` DID method uses a single public key to generate a DID and does not rely\n * on any external system such as a blockchain or centralized database. This characteristic makes\n * it suitable for use cases where a assertions about a DID Subject can be self-verifiable by\n * third parties.\n *\n * The method-specific identifier is formed by\n * {@link https://datatracker.ietf.org/doc/html/draft-multiformats-multibase#name-base-58-bitcoin-encoding | Multibase base58-btc}\n * encoding the concatenation of the\n * {@link https://github.com/multiformats/multicodec/blob/master/README.md | Multicodec} identifier\n * for the public key type and the raw public key bytes. To form the DID URI, the method-specific\n * identifier is prefixed with the string 'did:key:'.\n *\n * This method can optionally derive an encryption key from the public key used to create the DID\n * if and only if the public key algorithm is `Ed25519`. This feature enables the same DID to be\n * used for encrypted communication, in addition to signature verification. To enable this\n * feature when calling {@link DidKey.create | `DidKey.create()`}, first specify an `algorithm` of\n * `Ed25519` or provide a `keySet` referencing an `Ed25519` key and then set the\n * `enableEncryptionKeyDerivation` option to `true`.\n *\n * Note:\n * - The authors of the DID Key specification have indicated that use of this method for long-lived\n *   use cases is only recommended when accompanied with high confidence that private keys are\n *   securely protected by software or hardware isolation.\n *\n * @see {@link https://w3c-ccg.github.io/did-method-key/ | DID Key Specification}\n *\n* @example\n * ```ts\n * // DID Creation\n * const did = await DidKey.create();\n *\n * // DID Creation with a KMS\n * const keyManager = new LocalKeyManager();\n * const did = await DidKey.create({ keyManager });\n *\n * // DID Resolution\n * const resolutionResult = await DidKey.resolve({ did: did.uri });\n *\n * // Signature Operations\n * const signer = await did.getSigner();\n * const signature = await signer.sign({ data: new TextEncoder().encode('Message') });\n * const isValid = await signer.verify({ data: new TextEncoder().encode('Message'), signature });\n *\n * // Key Management\n *\n * // Instantiate a DID object from an existing key in a KMS\n * const did = await DidKey.fromKeyManager({\n *  didUri: 'did:key:z6MkpUzNmYVTGpqhStxK8yRKXWCRNm1bGYz8geAg2zmjYHKX',\n *  keyManager\n * });\n *\n * // Instantiate a DID object from an existing verification method key\n * const did = await DidKey.fromKeys({\n *   verificationMethods: [{\n *     publicKeyJwk: {\n *       kty: 'OKP',\n *       crv: 'Ed25519',\n *       x: 'cHs7YMLQ3gCWjkacMURBsnEJBcEsvlsE5DfnsfTNDP4'\n *     },\n *     privateKeyJwk: {\n *       kty: 'OKP',\n *       crv: 'Ed25519',\n *       x: 'cHs7YMLQ3gCWjkacMURBsnEJBcEsvlsE5DfnsfTNDP4',\n *       d: 'bdcGE4KzEaekOwoa-ee3gAm1a991WvNj_Eq3WKyqTnE'\n *     }\n *   }]\n * });\n *\n * // Convert a DID object to a portable format\n * const portableDid = await DidKey.toKeys({ did });\n *\n * // Reconstruct a DID object from a portable format\n * const did = await DidKey.fromKeys(portableDid);\n * ```\n */\nexport class DidKey extends DidMethod {\n\n  /**\n   * Name of the DID method, as defined in the DID Key specification.\n   */\n  public static methodName = 'key';\n\n  /**\n   * Creates a new DID using the `did:key` method formed from a newly generated key.\n   *\n   * @remarks\n   * The DID URI is formed by\n   * {@link https://datatracker.ietf.org/doc/html/draft-multiformats-multibase#name-base-58-bitcoin-encoding | Multibase base58-btc}\n   * encoding the\n   * {@link https://github.com/multiformats/multicodec/blob/master/README.md | Multicodec}-encoded\n   * public key and prefixing with `did:key:`.\n   *\n   * This method can optionally derive an encryption key from the public key used to create the DID\n   * if and only if the public key algorithm is `Ed25519`. This feature enables the same DID to be\n   * used for encrypted communication, in addition to signature verification. To enable this\n   * feature, specify an `algorithm` of `Ed25519` as either a top-level option or in a\n   * `verificationMethod` and set the `enableEncryptionKeyDerivation` option to `true`.\n   *\n   * Notes:\n   * - If no `options` are given, by default a new Ed25519 key will be generated.\n   * - The `algorithm` and `verificationMethods` options are mutually exclusive. If both are given,\n   *   an error will be thrown.\n   *\n   * @example\n   * ```ts\n   * // DID Creation\n   * const did = await DidKey.create();\n   *\n   * // DID Creation with a KMS\n   * const keyManager = new LocalKeyManager();\n   * const did = await DidKey.create({ keyManager });\n   * ```\n   *\n   * @param params - The parameters for the create operation.\n   * @param params.keyManager - Key Management System (KMS) used to generate keys and sign data.\n   * @param params.options - Optional parameters that can be specified when creating a new DID.\n   * @returns A Promise resolving to a {@link BearerDid} object representing the new DID.\n   */\n  public static async create<TKms extends CryptoApi | undefined = undefined>({\n    keyManager = new LocalKeyManager(),\n    options = {}\n  }: {\n    keyManager?: TKms;\n    options?: DidKeyCreateOptions<TKms>;\n  } = {}): Promise<BearerDid> {\n    // Before processing the create operation, validate DID-method-specific requirements to prevent\n    // keys from being generated unnecessarily.\n\n    // Check 1: Validate that `algorithm` or `verificationMethods` options are not both given.\n    if (options.algorithm && options.verificationMethods) {\n      throw new Error(`The 'algorithm' and 'verificationMethods' options are mutually exclusive`);\n    }\n\n    // Check 2: If `verificationMethods` is given, it must contain exactly one entry since DID Key\n    // only supports a single verification method.\n    if (options.verificationMethods && options.verificationMethods.length !== 1) {\n      throw new Error(`The 'verificationMethods' option must contain exactly one entry`);\n    }\n\n    // Default to Ed25519 key generation if an algorithm is not given.\n    const algorithm = options.algorithm ?? options.verificationMethods?.[0]?.algorithm ?? 'Ed25519';\n\n    // Generate a new key using the specified `algorithm`.\n    const keyUri = await keyManager.generateKey({ algorithm });\n    const publicKey = await keyManager.getPublicKey({ keyUri });\n\n    // Compute the DID identifier from the public key by converting the JWK to a multibase-encoded\n    // multicodec value.\n    const identifier = await DidKeyUtils.publicKeyToMultibaseId({ publicKey });\n\n    // Attach the prefix `did:key` to form the complete DID URI.\n    const didUri = `did:${DidKey.methodName}:${identifier}`;\n\n    // Expand the DID URI string to a DID document.\n    const didResolutionResult = await DidKey.resolve(didUri, options);\n    const document = didResolutionResult.didDocument as DidDocument;\n\n    // Create the BearerDid object from the generated key material.\n    const did = new BearerDid({\n      uri      : didUri,\n      document,\n      metadata : {},\n      keyManager\n    });\n\n    return did;\n  }\n\n  /**\n   * Given the W3C DID Document of a `did:key` DID, return the verification method that will be used\n   * for signing messages and credentials. With DID Key, the first verification method in the\n   * authentication property in the DID Document is used.\n   *\n   * Note that for DID Key, only one verification method intended for signing can exist so\n   * specifying `methodId` could be considered redundant or unnecessary. The option is provided for\n   * consistency with other DID method implementations.\n   *\n   * @param params - The parameters for the `getSigningMethod` operation.\n   * @param params.didDocument - DID Document to get the verification method from.\n   * @param params.methodId - ID of the verification method to use for signing.\n   * @returns Verification method to use for signing.\n   */\n  public static async getSigningMethod({ didDocument }: {\n    didDocument: DidDocument;\n    methodId?: string;\n  }): Promise<DidVerificationMethod> {\n    // Verify the DID method is supported.\n    const parsedDid = Did.parse(didDocument.id);\n    if (parsedDid && parsedDid.method !== this.methodName) {\n      throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported: ${parsedDid.method}`);\n    }\n\n    // Attempt to ge the first verification method intended for signing claims.\n    const [ methodId ] = didDocument.assertionMethod || [];\n    const verificationMethod = didDocument.verificationMethod?.find(vm => vm.id === methodId);\n\n    if (!(verificationMethod && verificationMethod.publicKeyJwk)) {\n      throw new DidError(DidErrorCode.InternalError, 'A verification method intended for signing could not be determined from the DID Document');\n    }\n\n    return verificationMethod;\n  }\n\n  /**\n   * Instantiates a {@link BearerDid} object for the DID Key method from a given {@link PortableDid}.\n   *\n   * This method allows for the creation of a `BearerDid` object using a previously created DID's\n   * key material, DID document, and metadata.\n   *\n   * @remarks\n   * The `verificationMethod` array of the DID document must contain exactly one key since the\n   * `did:key` method only supports a single verification method.\n   *\n   * @example\n   * ```ts\n   * // Export an existing BearerDid to PortableDid format.\n   * const portableDid = await did.export();\n   * // Reconstruct a BearerDid object from the PortableDid.\n   * const did = await DidKey.import({ portableDid });\n   * ```\n   *\n   * @param params - The parameters for the import operation.\n   * @param params.portableDid - The PortableDid object to import.\n   * @param params.keyManager - Optionally specify an external Key Management System (KMS) used to\n   *                            generate keys and sign data. If not given, a new\n   *                            {@link LocalKeyManager} instance will be created and\n   *                            used.\n   * @returns A Promise resolving to a `BearerDid` object representing the DID formed from the provided keys.\n   * @throws An error if the DID document does not contain exactly one verification method.\n   */\n  public static async import({ portableDid, keyManager = new LocalKeyManager() }: {\n    keyManager?: CryptoApi & KeyImporterExporter<KmsImportKeyParams, KeyIdentifier, KmsExportKeyParams>;\n    portableDid: PortableDid;\n  }): Promise<BearerDid> {\n    // Verify the DID method is supported.\n    const parsedDid = Did.parse(portableDid.uri);\n    if (parsedDid?.method !== DidKey.methodName) {\n      throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported`);\n    }\n\n    // Use the given PortableDid to construct the BearerDid object.\n    const did = await BearerDid.import({ portableDid, keyManager });\n\n    // Validate that the given DID document contains exactly one verification method.\n    // Note: The non-undefined assertion is necessary because the type system cannot infer that\n    // the `verificationMethod` property is defined -- which is checked by `BearerDid.import()`.\n    if (did.document.verificationMethod!.length !== 1) {\n      throw new DidError(DidErrorCode.InvalidDidDocument, `DID document must contain exactly one verification method`);\n    }\n\n    return did;\n  }\n\n  /**\n   * Resolves a `did:key` identifier to a DID Document.\n   *\n   * @param didUri - The DID to be resolved.\n   * @param options - Optional parameters for resolving the DID.\n   * @returns A Promise resolving to a {@link DidResolutionResult} object representing the result of the resolution.\n   */\n  public static async resolve(didUri: string, options?: DidResolutionOptions): Promise<DidResolutionResult> {\n    try {\n      // Attempt to expand the DID URI string to a DID document.\n      const didDocument = await DidKey.createDocument({ didUri, options });\n\n      // If the DID document was created successfully, return it.\n      return {\n        ...EMPTY_DID_RESOLUTION_RESULT,\n        didDocument,\n      };\n\n    } catch (error: any) {\n      // Rethrow any unexpected errors that are not a `DidError`.\n      if (!(error instanceof DidError)) throw new Error(error);\n\n      // Return a DID Resolution Result with the appropriate error code.\n      return {\n        ...EMPTY_DID_RESOLUTION_RESULT,\n        didResolutionMetadata: {\n          error: error.code,\n          ...error.message && { errorMessage: error.message }\n        }\n      };\n    }\n  }\n\n  /**\n   * Expands a did:key identifier to a DID Document.\n   *\n   * Reference: https://w3c-ccg.github.io/did-method-key/#document-creation-algorithm\n   *\n   * @param options\n   * @returns - A DID dodcument.\n   */\n  private static async createDocument({ didUri, options = {}}: {\n    didUri: string;\n    options?: Exclude<DidKeyCreateOptions<CryptoApi>, 'algorithm' | 'verificationMethods'> | DidResolutionOptions;\n  }): Promise<DidDocument> {\n    const {\n      defaultContext = 'https://www.w3.org/ns/did/v1',\n      enableEncryptionKeyDerivation = false,\n      enableExperimentalPublicKeyTypes = false,\n      publicKeyFormat = 'JsonWebKey2020'\n    } = options;\n\n    /**\n     * 1. Initialize document to an empty object.\n     */\n    const didDocument: DidDocument = { id: '' };\n\n    /**\n     * 2. Using a colon (:) as the delimiter, split the identifier into its\n     * components: a scheme, a method, a version, and a multibaseValue.\n     * If there are only three components set the version to the string\n     * value 1 and use the last value as the multibaseValue.\n     */\n    const parsedDid = Did.parse(didUri);\n    if (!parsedDid) {\n      throw new DidError(DidErrorCode.InvalidDid, `Invalid DID URI: ${didUri}`);\n    }\n    const multibaseValue = parsedDid.id;\n\n    /**\n     * 3. Check the validity of the input identifier.\n     * The scheme MUST be the value did. The method MUST be the value key.\n     * The version MUST be convertible to a positive integer value. The\n     * multibaseValue MUST be a string and begin with the letter z. If any\n     * of these requirements fail, an invalidDid error MUST be raised.\n     */\n    if (parsedDid.method !== DidKey.methodName) {\n      throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported: ${parsedDid.method}`);\n    }\n    if (!DidKey.validateIdentifier(parsedDid)) {\n      throw new DidError(DidErrorCode.InvalidDid, `Invalid DID URI: ${didUri}`);\n    }\n\n    /**\n     * 4. Initialize the signatureVerificationMethod to the result of passing\n     * identifier, multibaseValue, and options to a\n     *  {@link https://w3c-ccg.github.io/did-method-key/#signature-method-creation-algorithm | Signature Method Creation Algorithm}.\n     */\n    const signatureVerificationMethod = await DidKey.createSignatureMethod({\n      didUri,\n      multibaseValue,\n      options: { enableExperimentalPublicKeyTypes, publicKeyFormat }\n    });\n\n    /**\n     * 5. Set document.id to identifier. If document.id is not a valid DID,\n     * an invalidDid error MUST be raised.\n     *\n     * Note: Identifier was already confirmed to be valid in Step 3, so\n     *       skipping the redundant validation.\n     */\n    didDocument.id = parsedDid.uri;\n\n    /**\n     * 6. Initialize the verificationMethod property in document to an array\n     * where the first value is the signatureVerificationMethod.\n     */\n    didDocument.verificationMethod = [signatureVerificationMethod];\n\n    /**\n     * 7. Initialize the authentication, assertionMethod, capabilityInvocation,\n     * and the capabilityDelegation properties in document to an array where\n     * the first item is the value of the id property in\n     * signatureVerificationMethod.\n     */\n    didDocument.authentication = [signatureVerificationMethod.id];\n    didDocument.assertionMethod = [signatureVerificationMethod.id];\n    didDocument.capabilityInvocation = [signatureVerificationMethod.id];\n    didDocument.capabilityDelegation = [signatureVerificationMethod.id];\n\n    /**\n     * 8. If options.enableEncryptionKeyDerivation is set to true:\n     * Add the encryptionVerificationMethod value to the verificationMethod\n     * array. Initialize the keyAgreement property in document to an array\n     * where the first item is the value of the id property in\n     * encryptionVerificationMethod.\n     */\n    if (enableEncryptionKeyDerivation === true) {\n      /**\n       * Although not covered by the did:key method specification, a sensible\n       * default will be taken to use the 'X25519KeyAgreementKey2020'\n       * verification method type if the given publicKeyFormat is\n       * 'Ed25519VerificationKey2020' and 'JsonWebKey2020' otherwise.\n       */\n      const encryptionPublicKeyFormat =\n        (publicKeyFormat === 'Ed25519VerificationKey2020')\n          ? 'X25519KeyAgreementKey2020'\n          : 'JsonWebKey2020';\n\n      /**\n       * 8.1 Initialize the encryptionVerificationMethod to the result of\n       * passing identifier, multibaseValue, and options to an\n     * {@link https://w3c-ccg.github.io/did-method-key/#encryption-method-creation-algorithm | Encryption Method Creation Algorithm}.\n       */\n      const encryptionVerificationMethod = await this.createEncryptionMethod({\n        didUri,\n        multibaseValue,\n        options: { enableExperimentalPublicKeyTypes, publicKeyFormat: encryptionPublicKeyFormat }\n      });\n\n      /**\n       * 8.2 Add the encryptionVerificationMethod value to the\n       * verificationMethod array.\n       */\n      didDocument.verificationMethod.push(encryptionVerificationMethod);\n\n      /**\n       * 8.3. Initialize the keyAgreement property in document to an array\n       * where the first item is the value of the id property in\n       * encryptionVerificationMethod.\n       */\n      didDocument.keyAgreement = [encryptionVerificationMethod.id];\n    }\n\n    /**\n     * 9. Initialize the @context property in document to the result of passing document and options to the Context\n     * Creation algorithm.\n     */\n    // Set contextArray to an array that is initialized to options.defaultContext.\n    const contextArray = [ defaultContext ];\n\n    // For every object in every verification relationship listed in document,\n    // add a string value to the contextArray based on the object type value,\n    // if it doesn't already exist, according to the following table:\n    // {@link https://w3c-ccg.github.io/did-method-key/#context-creation-algorithm | Context Type URL}\n    const verificationMethodTypes = getVerificationMethodTypes({ didDocument });\n    verificationMethodTypes.forEach((typeName: string) => {\n      const typeUrl = DidKeyVerificationMethodType[typeName as keyof typeof DidKeyVerificationMethodType];\n      contextArray.push(typeUrl);\n    });\n    didDocument['@context'] = contextArray;\n\n    /**\n     * 10. Return document.\n     */\n    return didDocument;\n  }\n\n  /**\n   * Decoding a multibase-encoded multicodec value into a verification method\n   * that is suitable for verifying that encrypted information will be\n   * received by the intended recipient.\n   */\n  private static async createEncryptionMethod({ didUri, multibaseValue, options }: {\n    didUri: string;\n    multibaseValue: string;\n    options: Required<Pick<DidKeyCreateOptions<CryptoApi>, 'enableExperimentalPublicKeyTypes' | 'publicKeyFormat'>>;\n  }): Promise<DidVerificationMethod> {\n    const { enableExperimentalPublicKeyTypes, publicKeyFormat } = options;\n\n    /**\n     * 1. Initialize verificationMethod to an empty object.\n     */\n    const verificationMethod: DidVerificationMethod = { id: '', type: '', controller: '' };\n\n    /**\n     * 2. Set multicodecValue and raw publicKeyBytes to the result of passing multibaseValue and\n     * options to a Derive Encryption Key algorithm.\n     */\n    const {\n      keyBytes: publicKeyBytes,\n      multicodecCode: multicodecValue,\n    } = await DidKey.deriveEncryptionKey({ multibaseValue });\n\n    /**\n     * 3. Ensure the proper key length of raw publicKeyBytes based on the multicodecValue table\n     * provided below:\n     *\n     * Multicodec hexadecimal value: 0xec\n     *\n     * If the byte length of raw publicKeyBytes does not match the expected public key length for\n     * the associated multicodecValue, an invalidPublicKeyLength error MUST be raised.\n     */\n    const actualLength = publicKeyBytes.byteLength;\n    const expectedLength = DidKeyUtils.MULTICODEC_PUBLIC_KEY_LENGTH[multicodecValue];\n    if (actualLength !== expectedLength) {\n      throw new DidError(DidErrorCode.InvalidPublicKeyLength, `Expected ${actualLength} bytes. Actual: ${expectedLength}`);\n    }\n\n    /**\n     * 4. Create the multibaseValue by concatenating the letter 'z' and the\n     * base58-btc encoding of the concatenation of the multicodecValue and\n     * the raw publicKeyBytes.\n     */\n    const kemMultibaseValue = keyBytesToMultibaseId({\n      keyBytes       : publicKeyBytes,\n      multicodecCode : multicodecValue\n    });\n\n    /**\n     * 5. Set the verificationMethod.id value by concatenating identifier,\n     * a hash character (#), and the multibaseValue. If verificationMethod.id\n     * is not a valid DID URL, an invalidDidUrl error MUST be raised.\n     */\n    verificationMethod.id = `${didUri}#${kemMultibaseValue}`;\n    try {\n      new URL(verificationMethod.id);\n    } catch (error: any) {\n      throw new DidError(DidErrorCode.InvalidDidUrl, 'Verification Method ID is not a valid DID URL.');\n    }\n\n    /**\n     * 6. Set the publicKeyFormat value to the options.publicKeyFormat value.\n     * 7. If publicKeyFormat is not known to the implementation, an\n     * unsupportedPublicKeyType error MUST be raised.\n     */\n    if (!(publicKeyFormat in DidKeyVerificationMethodType)) {\n      throw new DidError(DidErrorCode.UnsupportedPublicKeyType, `Unsupported format: ${publicKeyFormat}`);\n    }\n\n    /**\n     * 8. If options.enableExperimentalPublicKeyTypes is set to false and publicKeyFormat is not\n     * Multikey, JsonWebKey2020, or X25519KeyAgreementKey2020, an invalidPublicKeyType error MUST be\n     * raised.\n     */\n    const StandardPublicKeyTypes = ['Multikey', 'JsonWebKey2020', 'X25519KeyAgreementKey2020'];\n    if (enableExperimentalPublicKeyTypes === false\n      && !(StandardPublicKeyTypes.includes(publicKeyFormat))) {\n      throw new DidError(DidErrorCode.InvalidPublicKeyType, `Specified '${publicKeyFormat}' without setting enableExperimentalPublicKeyTypes to true.`);\n    }\n\n    /**\n     * 9. Set verificationMethod.type to the publicKeyFormat value.\n     */\n    verificationMethod.type = publicKeyFormat;\n\n    /**\n     * 10. Set verificationMethod.controller to the identifier value.\n     */\n    verificationMethod.controller = didUri;\n\n    /**\n     * 11. If publicKeyFormat is Multikey or X25519KeyAgreementKey2020, set the verificationMethod.publicKeyMultibase\n     * value to multibaseValue.\n     *\n     * Note: This implementation does not currently support the Multikey\n     *       format.\n     */\n    if (publicKeyFormat === 'X25519KeyAgreementKey2020') {\n      verificationMethod.publicKeyMultibase = kemMultibaseValue;\n    }\n\n    /**\n     * 12. If publicKeyFormat is JsonWebKey2020, set the verificationMethod.publicKeyJwk value to\n     * the result of passing multicodecValue and rawPublicKeyBytes to a JWK encoding algorithm.\n     */\n    if (publicKeyFormat === 'JsonWebKey2020') {\n      const { crv } = await DidKeyUtils.multicodecToJwk({ code: multicodecValue });\n      verificationMethod.publicKeyJwk = await DidKeyUtils.keyConverter(crv!).bytesToPublicKey({ publicKeyBytes });\n    }\n\n    /**\n     * 13. Return verificationMethod.\n     */\n    return verificationMethod;\n  }\n\n  /**\n   * Decodes a multibase-encoded multicodec value into a verification method\n   * that is suitable for verifying digital signatures.\n   * @param options - Signature method creation algorithm inputs.\n   * @returns - A verification method.\n   */\n  private static async createSignatureMethod({ didUri, multibaseValue, options }: {\n    didUri: string;\n    multibaseValue: string;\n    options: Required<Pick<DidKeyCreateOptions<CryptoApi>, 'enableExperimentalPublicKeyTypes' | 'publicKeyFormat'>>\n  }): Promise<DidVerificationMethod> {\n    const { enableExperimentalPublicKeyTypes, publicKeyFormat } = options;\n\n    /**\n     * 1. Initialize verificationMethod to an empty object.\n     */\n    const verificationMethod: DidVerificationMethod = { id: '', type: '', controller: '' };\n\n    /**\n     * 2. Set multicodecValue and publicKeyBytes to the result of passing\n     * multibaseValue and options to a Decode Public Key algorithm.\n     */\n    const {\n      keyBytes: publicKeyBytes,\n      multicodecCode: multicodecValue,\n      multicodecName\n    } = multibaseIdToKeyBytes({ multibaseKeyId: multibaseValue });\n\n    /**\n     * 3. Ensure the proper key length of publicKeyBytes based on the multicodecValue\n     * {@link https://w3c-ccg.github.io/did-method-key/#signature-method-creation-algorithm | table provided}.\n     * If the byte length of rawPublicKeyBytes does not match the expected public key length for the\n     * associated multicodecValue, an invalidPublicKeyLength error MUST be raised.\n     */\n    const actualLength = publicKeyBytes.byteLength;\n    const expectedLength = DidKeyUtils.MULTICODEC_PUBLIC_KEY_LENGTH[multicodecValue];\n    if (actualLength !== expectedLength) {\n      throw new DidError(DidErrorCode.InvalidPublicKeyLength, `Expected ${actualLength} bytes. Actual: ${expectedLength}`);\n    }\n\n    /**\n     * 4. Ensure the publicKeyBytes are a proper encoding of the public key type as specified by\n     * the multicodecValue. If an invalid public key value is detected, an invalidPublicKey error\n     * MUST be raised.\n     */\n    let isValid = false;\n    switch (multicodecName) {\n      case 'secp256k1-pub':\n        isValid = await Secp256k1.validatePublicKey({ publicKeyBytes });\n        break;\n      case 'ed25519-pub':\n        isValid = await Ed25519.validatePublicKey({ publicKeyBytes });\n        break;\n      case 'x25519-pub':\n        // TODO: Validate key once/if X25519.validatePublicKey() is implemented.\n        // isValid = X25519.validatePublicKey({ key: rawPublicKeyBytes})\n        isValid = true;\n        break;\n    }\n    if (!isValid) {\n      throw new DidError(DidErrorCode.InvalidPublicKey, 'Invalid public key detected.');\n    }\n\n    /**\n     * 5. Set the verificationMethod.id value by concatenating identifier, a hash character (#), and\n     * the multibaseValue. If verificationMethod.id is not a valid DID URL, an invalidDidUrl error\n     * MUST be raised.\n     */\n    verificationMethod.id = `${didUri}#${multibaseValue}`;\n    try {\n      new URL(verificationMethod.id);\n    } catch (error: any) {\n      throw new DidError(DidErrorCode.InvalidDidUrl, 'Verification Method ID is not a valid DID URL.');\n    }\n\n    /**\n     * 6. Set the publicKeyFormat value to the options.publicKeyFormat value.\n     * 7. If publicKeyFormat is not known to the implementation, an unsupportedPublicKeyType error\n     * MUST be raised.\n     */\n    if (!(publicKeyFormat in DidKeyVerificationMethodType)) {\n      throw new DidError(DidErrorCode.UnsupportedPublicKeyType, `Unsupported format: ${publicKeyFormat}`);\n    }\n\n    /**\n     * 8. If options.enableExperimentalPublicKeyTypes is set to false and publicKeyFormat is not\n     * Multikey, JsonWebKey2020, or Ed25519VerificationKey2020, an invalidPublicKeyType error MUST\n     * be raised.\n     */\n    const StandardPublicKeyTypes = ['Multikey', 'JsonWebKey2020', 'Ed25519VerificationKey2020'];\n    if (enableExperimentalPublicKeyTypes === false\n      && !(StandardPublicKeyTypes.includes(publicKeyFormat))) {\n      throw new DidError(DidErrorCode.InvalidPublicKeyType, `Specified '${publicKeyFormat}' without setting enableExperimentalPublicKeyTypes to true.`);\n    }\n\n    /**\n     * 9. Set verificationMethod.type to the publicKeyFormat value.\n     */\n    verificationMethod.type = publicKeyFormat;\n\n    /**\n     * 10. Set verificationMethod.controller to the identifier value.\n     */\n    verificationMethod.controller = didUri;\n\n    /**\n     * 11. If publicKeyFormat is Multikey or Ed25519VerificationKey2020,\n     * set the verificationMethod.publicKeyMultibase value to multibaseValue.\n     *\n     * Note: This implementation does not currently support the Multikey\n     *       format.\n     */\n    if (publicKeyFormat === 'Ed25519VerificationKey2020') {\n      verificationMethod.publicKeyMultibase = multibaseValue;\n    }\n\n    /**\n     * 12. If publicKeyFormat is JsonWebKey2020, set the verificationMethod.publicKeyJwk value to\n     * the result of passing multicodecValue and rawPublicKeyBytes to a JWK encoding algorithm.\n     */\n    if (publicKeyFormat === 'JsonWebKey2020') {\n      const { crv } = await DidKeyUtils.multicodecToJwk({ code: multicodecValue });\n      verificationMethod.publicKeyJwk = await DidKeyUtils.keyConverter(crv!).bytesToPublicKey({ publicKeyBytes});\n    }\n\n    /**\n     * 13. Return verificationMethod.\n     */\n    return verificationMethod;\n  }\n\n\n  /**\n   * Transform a multibase-encoded multicodec value to public encryption key\n   * components that are suitable for encrypting messages to a receiver. A\n   * mathematical proof elaborating on the safety of performing this operation\n   * is available in:\n   * {@link https://eprint.iacr.org/2021/509.pdf | On using the same key pair for Ed25519 and an X25519 based KEM}\n   */\n  private static async deriveEncryptionKey({ multibaseValue }: {\n    multibaseValue: string\n  }): Promise<RequireOnly<KeyWithMulticodec, 'keyBytes' | 'multicodecCode'>> {\n    /**\n     * 1. Set publicEncryptionKey to an empty object.\n     */\n    let publicEncryptionKey: RequireOnly<KeyWithMulticodec, 'keyBytes' | 'multicodecCode'> = {\n      keyBytes       : new Uint8Array(),\n      multicodecCode : 0\n    };\n\n    /**\n     * 2. Decode multibaseValue using the base58-btc multibase alphabet and\n     * set multicodecValue to the multicodec header for the decoded value.\n     * Implementers are cautioned to ensure that the multicodecValue is set\n     * to the result after performing varint decoding.\n     *\n     * 3. Set the rawPublicKeyBytes to the bytes remaining after the multicodec\n     * header.\n     */\n    const {\n      keyBytes: publicKeyBytes,\n      multicodecCode: multicodecValue\n    } = multibaseIdToKeyBytes({ multibaseKeyId: multibaseValue });\n\n    /**\n     * 4. If the multicodecValue is 0xed (Ed25519 public key), derive a public X25519 encryption key\n     * by using the raw publicKeyBytes and the algorithm defined in\n     * {@link https://datatracker.ietf.org/doc/html/draft-ietf-core-oscore-groupcomm | Group OSCORE - Secure Group Communication for CoAP}\n     * for Curve25519 in Section 2.4.2: ECDH with Montgomery Coordinates and set\n     * generatedPublicEncryptionKeyBytes to the result.\n     */\n    if (multicodecValue === 0xed) {\n      const ed25519PublicKey = await DidKeyUtils.keyConverter('Ed25519').bytesToPublicKey({\n        publicKeyBytes\n      });\n      const generatedPublicEncryptionKey = await Ed25519.convertPublicKeyToX25519({\n        publicKey: ed25519PublicKey\n      });\n      const generatedPublicEncryptionKeyBytes = await DidKeyUtils.keyConverter('Ed25519').publicKeyToBytes({\n        publicKey: generatedPublicEncryptionKey\n      });\n\n      /**\n       * 5. Set multicodecValue to 0xec.\n       * 6. Set raw public keyBytes to generatedPublicEncryptionKeyBytes.\n       */\n      publicEncryptionKey = {\n        keyBytes       : generatedPublicEncryptionKeyBytes,\n        multicodecCode : 0xec\n      };\n    }\n\n    /**\n     * 7. Return publicEncryptionKey.\n     */\n    return publicEncryptionKey;\n  }\n\n  /**\n   * Validates the structure and components of a DID URI against the `did:key` method specification.\n   *\n   * @param parsedDid - An object representing the parsed components of a DID URI, including the\n   *                    scheme, method, and method-specific identifier.\n   * @returns `true` if the DID URI meets the `did:key` method's structural requirements, `false` otherwise.\n   *\n   */\n  private static validateIdentifier(parsedDid: Did): boolean {\n    const { method, id: multibaseValue } = parsedDid;\n    const [ scheme ] = parsedDid.uri.split(':', 1);\n\n    /**\n     * Note: The W3C DID specification makes no mention of a version value being part of the DID\n     *       syntax.  Additionally, there does not appear to be any real-world usage of the version\n     *       number. Consequently, this implementation will ignore the version related guidance in\n     *       the did:key specification.\n     */\n    const version = '1';\n\n    return (\n      scheme === 'did' &&\n      method === 'key' &&\n      Number(version) > 0 &&\n      universalTypeOf(multibaseValue) === 'String' &&\n      multibaseValue.startsWith('z')\n    );\n  }\n}\n\n/**\n * The `DidKeyUtils` class provides utility functions to support operations in the DID Key method.\n */\nexport class DidKeyUtils {\n  /**\n   * A mapping from JSON Web Key (JWK) property descriptors to multicodec names.\n   *\n   * This mapping is used to convert keys in JWK (JSON Web Key) format to multicodec format.\n   *\n   * @remarks\n   * The keys of this object are strings that describe the JOSE key type and usage,\n   * such as 'Ed25519:public', 'Ed25519:private', etc. The values are the corresponding multicodec\n   * names used to represent these key types.\n   *\n   * @example\n   * ```ts\n   * const multicodecName = JWK_TO_MULTICODEC['Ed25519:public'];\n   * // Returns 'ed25519-pub', the multicodec name for an Ed25519 public key\n   * ```\n   */\n  private static JWK_TO_MULTICODEC: { [key: string]: string } = {\n    'Ed25519:public'    : 'ed25519-pub',\n    'Ed25519:private'   : 'ed25519-priv',\n    'secp256k1:public'  : 'secp256k1-pub',\n    'secp256k1:private' : 'secp256k1-priv',\n    'X25519:public'     : 'x25519-pub',\n    'X25519:private'    : 'x25519-priv',\n  };\n\n  /**\n   * Defines the expected byte lengths for public keys associated with different cryptographic\n   * algorithms, indexed by their multicodec code values.\n   */\n  public static MULTICODEC_PUBLIC_KEY_LENGTH: Record<number, number> = {\n    // secp256k1-pub - Secp256k1 public key (compressed) - 33 bytes\n    0xe7: 33,\n\n    // x25519-pub - Curve25519 public key - 32 bytes\n    0xec: 32,\n\n    // ed25519-pub - Ed25519 public key - 32 bytes\n    0xed: 32\n  };\n\n  /**\n   * A mapping from multicodec names to their corresponding JOSE (JSON Object Signing and Encryption)\n   * representations. This mapping facilitates the conversion of multicodec key formats to\n   * JWK (JSON Web Key) formats.\n   *\n   * @remarks\n   * The keys of this object are multicodec names, such as 'ed25519-pub', 'ed25519-priv', etc.\n   * The values are objects representing the corresponding JWK properties for that key type.\n   *\n   * @example\n   * ```ts\n   * const joseKey = MULTICODEC_TO_JWK['ed25519-pub'];\n   * // Returns a partial JWK for an Ed25519 public key\n   * ```\n   */\n  private static MULTICODEC_TO_JWK: { [key: string]: Jwk } = {\n    'ed25519-pub'    : { crv: 'Ed25519',   kty: 'OKP', x: '' },\n    'ed25519-priv'   : { crv: 'Ed25519',   kty: 'OKP', x: '',        d: '' },\n    'secp256k1-pub'  : { crv: 'secp256k1', kty: 'EC',  x: '', y: ''},\n    'secp256k1-priv' : { crv: 'secp256k1', kty: 'EC',  x: '', y: '', d: '' },\n    'x25519-pub'     : { crv: 'X25519',    kty: 'OKP', x: '' },\n    'x25519-priv'    : { crv: 'X25519',    kty: 'OKP', x: '',        d: '' },\n  };\n\n  /**\n   * Converts a JWK (JSON Web Key) to a Multicodec code and name.\n   *\n   * @example\n   * ```ts\n   * const jwk: Jwk = { crv: 'Ed25519', kty: 'OKP', x: '...' };\n   * const { code, name } = await DidKeyUtils.jwkToMulticodec({ jwk });\n   * ```\n   *\n   * @param params - The parameters for the conversion.\n   * @param params.jwk - The JSON Web Key to be converted.\n   * @returns A promise that resolves to a Multicodec definition.\n   */\n  public static async jwkToMulticodec({ jwk }: {\n    jwk: Jwk\n  }): Promise<MulticodecDefinition<MulticodecCode>> {\n    const params: string[] = [];\n\n    if (jwk.crv) {\n      params.push(jwk.crv);\n      if (jwk.d) {\n        params.push('private');\n      } else {\n        params.push('public');\n      }\n    }\n\n    const lookupKey = params.join(':');\n    const name = DidKeyUtils.JWK_TO_MULTICODEC[lookupKey];\n\n    if (name === undefined) {\n      throw new Error(`Unsupported JWK to Multicodec conversion: '${lookupKey}'`);\n    }\n\n    const code = Multicodec.getCodeFromName({ name });\n\n    return { code, name };\n  }\n\n  /**\n   * Returns the appropriate public key compressor for the specified cryptographic curve.\n   *\n   * @param curve - The cryptographic curve to use for the key conversion.\n   * @returns A public key compressor for the specified curve.\n   */\n  public static keyCompressor(\n    curve: string\n  ): KeyCompressor['compressPublicKey'] {\n  // ): ({ publicKeyBytes }: { publicKeyBytes: Uint8Array }) => Promise<Uint8Array> {\n    const compressors = {\n      'P-256'     : Secp256r1.compressPublicKey,\n      'secp256k1' : Secp256k1.compressPublicKey\n    } as Record<string, KeyCompressor['compressPublicKey']>;\n\n    const compressor = compressors[curve];\n\n    if (!compressor) throw new DidError(DidErrorCode.InvalidPublicKeyType, `Unsupported curve: ${curve}`);\n\n    return compressor;\n  }\n\n  /**\n   * Returns the appropriate key converter for the specified cryptographic curve.\n   *\n   * @param curve - The cryptographic curve to use for the key conversion.\n   * @returns An `AsymmetricKeyConverter` for the specified curve.\n   */\n  public static keyConverter(curve: string): AsymmetricKeyConverter {\n    const converters: Record<string, AsymmetricKeyConverter> = {\n      'Ed25519'   : Ed25519,\n      'P-256'     : Secp256r1,\n      'secp256k1' : Secp256k1,\n      'X25519'    : X25519\n    };\n\n    const converter = converters[curve];\n\n    if (!converter) throw new DidError(DidErrorCode.InvalidPublicKeyType, `Unsupported curve: ${curve}`);\n\n    return converter;\n  }\n\n  /**\n   * Converts a Multicodec code or name to parial JWK (JSON Web Key).\n   *\n   * @example\n   * ```ts\n   * const partialJwk = await DidKeyUtils.multicodecToJwk({ name: 'ed25519-pub' });\n   * ```\n   *\n   * @param params - The parameters for the conversion.\n   * @param params.code - Optional Multicodec code to convert.\n   * @param params.name - Optional Multicodec name to convert.\n   * @returns A promise that resolves to a JOSE format key.\n   */\n  public static async multicodecToJwk({ code, name }: {\n    code?: MulticodecCode,\n    name?: string\n  }): Promise<Jwk> {\n    // Either code or name must be specified, but not both.\n    if (!(name ? !code : code)) {\n      throw new Error(`Either 'name' or 'code' must be defined, but not both.`);\n    }\n\n    // If name is undefined, lookup by code.\n    name = (name === undefined ) ? Multicodec.getNameFromCode({ code: code! }) : name;\n\n    const lookupKey = name;\n    const jose = DidKeyUtils.MULTICODEC_TO_JWK[lookupKey];\n\n    if (jose === undefined) {\n      throw new Error(`Unsupported Multicodec to JWK conversion`);\n    }\n\n    return { ...jose };\n  }\n\n  /**\n   * Converts a public key in JWK (JSON Web Key) format to a multibase identifier.\n   *\n   * @remarks\n   * Note: All secp public keys are converted to compressed point encoding\n   *       before the multibase identifier is computed.\n   *\n   * Per {@link https://github.com/multiformats/multicodec/blob/master/table.csv | Multicodec table}:\n   *    Public keys for Elliptic Curve cryptography algorithms (e.g., secp256k1,\n   *    secp256k1r1, secp384r1, etc.) are always represented with compressed point\n   *    encoding (e.g., secp256k1-pub, p256-pub, p384-pub, etc.).\n   *\n   * Per {@link https://datatracker.ietf.org/doc/html/rfc8812#name-jose-and-cose-secp256k1-cur | RFC 8812}:\n   *    \"As a compressed point encoding representation is not defined for JWK\n   *    elliptic curve points, the uncompressed point encoding defined there\n   *    MUST be used. The x and y values represented MUST both be exactly\n   *    256 bits, with any leading zeros preserved.\"\n   *\n   * @example\n   * ```ts\n   * const publicKey = { crv: 'Ed25519', kty: 'OKP', x: '...' };\n   * const multibaseId = await DidKeyUtils.publicKeyToMultibaseId({ publicKey });\n   * ```\n   *\n   * @param params - The parameters for the conversion.\n   * @param params.publicKey - The public key in JWK format.\n   * @returns A promise that resolves to the multibase identifier.\n   */\n  public static async publicKeyToMultibaseId({ publicKey }: {\n    publicKey: Jwk\n  }): Promise<string> {\n    if (!(publicKey?.crv && publicKey.crv in AlgorithmToKeyTypeMap)) {\n      throw new DidError(DidErrorCode.InvalidPublicKeyType, `Public key contains an unsupported key type: ${publicKey?.crv ?? 'undefined'}`);\n    }\n\n    // Convert the public key from JWK format to a byte array.\n    let publicKeyBytes = await DidKeyUtils.keyConverter(publicKey.crv).publicKeyToBytes({ publicKey });\n\n    // Compress the public key if it is an elliptic curve key.\n    if (/^(secp256k1|P-256|P-384|P-521)$/.test(publicKey.crv)) {\n      publicKeyBytes = await DidKeyUtils.keyCompressor(publicKey.crv)({ publicKeyBytes });\n    }\n\n    // Convert the JSON Web Key (JWK) parameters to a Multicodec name.\n    const { name: multicodecName } = await DidKeyUtils.jwkToMulticodec({ jwk: publicKey });\n\n    // Compute the multibase identifier based on the provided key.\n    const multibaseId = keyBytesToMultibaseId({\n      keyBytes: publicKeyBytes,\n      multicodecName\n    });\n\n    return multibaseId;\n  }\n}", "import type { DidDocument, DidResolutionOptions, DidResolutionResult } from '../types/did-core.js';\n\nimport { Did } from '../did.js';\nimport { DidMethod } from './did-method.js';\nimport { EMPTY_DID_RESOLUTION_RESULT } from '../resolver/did-resolver.js';\n\n/**\n * The `DidWeb` class provides an implementation of the `did:web` DID method.\n *\n * Features:\n * - DID Resolution: Resolve a `did:web` to its corresponding DID Document.\n *\n * @remarks\n * The `did:web` method uses a web domain's existing reputation and aims to integrate decentralized\n * identities with the existing web infrastructure to drive adoption. It leverages familiar web\n * security models and domain ownership to provide accessible, interoperable digital identity\n * management.\n *\n * @see {@link https://w3c-ccg.github.io/did-method-web/ | DID Web Specification}\n *\n * @example\n * ```ts\n * // DID Resolution\n * const resolutionResult = await DidWeb.resolve({ did: did.uri });\n * ```\n */\nexport class DidWeb extends DidMethod {\n\n  /**\n   * Name of the DID method, as defined in the DID Web specification.\n   */\n  public static methodName = 'web';\n\n  /**\n   * Resolves a `did:web` identifier to a DID Document.\n   *\n   * @param didUri - The DID to be resolved.\n   * @param _options - Optional parameters for resolving the DID. Unused by this DID method.\n   * @returns A Promise resolving to a {@link DidResolutionResult} object representing the result of the resolution.\n   */\n  public static async resolve(didUri: string, _options?: DidResolutionOptions): Promise<DidResolutionResult> {\n    // Attempt to parse the DID URI.\n    const parsedDid = Did.parse(didUri);\n\n    // If parsing failed, the DID is invalid.\n    if (!parsedDid) {\n      return {\n        ...EMPTY_DID_RESOLUTION_RESULT,\n        didResolutionMetadata: { error: 'invalidDid' }\n      };\n    }\n\n    // If the DID method is not \"web\", return an error.\n    if (parsedDid.method !== DidWeb.methodName) {\n      return {\n        ...EMPTY_DID_RESOLUTION_RESULT,\n        didResolutionMetadata: { error: 'methodNotSupported' }\n      };\n    }\n\n    // Replace \":\" with \"/\" in the identifier and prepend \"https://\" to obtain the fully qualified\n    // domain name and optional path.\n    let baseUrl = `https://${parsedDid.id.replace(/:/g, '/')}`;\n\n    // If the domain contains a percent encoded port value, decode the colon.\n    baseUrl = decodeURIComponent(baseUrl);\n\n    // Append the expected location of the DID document depending on whether a path was specified.\n    const didDocumentUrl = parsedDid.id.includes(':') ?\n      `${baseUrl}/did.json` :\n      `${baseUrl}/.well-known/did.json`;\n\n    try {\n      // Perform an HTTP GET request to obtain the DID document.\n      const response = await fetch(didDocumentUrl);\n\n      // If the response status code is not 200, return an error.\n      if (!response.ok) throw new Error('HTTP error status code returned');\n\n      // Parse the DID document.\n      const didDocument = await response.json() as DidDocument;\n\n      return {\n        ...EMPTY_DID_RESOLUTION_RESULT,\n        didDocument,\n      };\n\n    } catch (error: any) {\n      // If the DID document could not be retrieved, return an error.\n      return {\n        ...EMPTY_DID_RESOLUTION_RESULT,\n        didResolutionMetadata: { error: 'notFound' }\n      };\n    }\n  }\n}", "import type { AbstractLevel } from 'abstract-level';\n\nimport ms from 'ms';\nimport { Level } from 'level';\n\nimport type { DidResolverCache } from './did-resolver.js';\nimport type { DidResolutionResult } from '../types/did-core.js';\n\n/**\n * Configuration parameters for creating a LevelDB-based cache for DID resolution results.\n *\n * Allows customization of the underlying database instance, storage location, and cache\n * time-to-live (TTL) settings.\n */\nexport type DidResolverCacheLevelParams = {\n  /**\n   * Optional. An instance of `AbstractLevel` to use as the database. If not provided, a new\n   * LevelDB instance will be created at the specified `location`.\n   */\n  db?: AbstractLevel<string | Buffer | Uint8Array, string, string>;\n\n  /**\n   * Optional. The file system path or IndexedDB name where the LevelDB store will be created.\n   * Defaults to 'DATA/DID_RESOLVERCACHE' if not specified.\n   */\n  location?: string;\n\n  /**\n   * Optional. The time-to-live for cache entries, expressed as a string (e.g., '1h', '15m').\n   * Determines how long a cache entry should remain valid before being considered expired. Defaults\n   * to '15m' if not specified.\n   */\n  ttl?: string;\n}\n\n/**\n * Encapsulates a DID resolution result along with its expiration information for caching purposes.\n *\n * This type is used internally by the `DidResolverCacheLevel` to store DID resolution results\n * with an associated time-to-live (TTL) value. The TTL is represented in milliseconds and\n * determines when the cached entry is considered expired and eligible for removal.\n */\ntype CacheWrapper = {\n  /**\n   * The expiration time of the cache entry in milliseconds since the Unix epoch.\n   *\n   * This value is used to calculate whether the cached entry is still valid or has expired.\n   */\n  ttlMillis: number;\n\n  /**\n   * The DID resolution result being cached.\n   *\n   * This object contains the resolved DID document and associated metadata.\n   */\n  value: DidResolutionResult;\n}\n\n/**\n * A Level-based cache implementation for storing and retrieving DID resolution results.\n *\n * This cache uses LevelDB for storage, allowing data persistence across process restarts or\n * browser refreshes. It's suitable for both Node.js and browser environments.\n *\n * @remarks\n * The LevelDB cache keeps data in memory for fast access and also writes to the filesystem in\n * Node.js or indexedDB in browsers. Time-to-live (TTL) for cache entries is configurable.\n *\n * @example\n * ```\n * const cache = new DidResolverCacheLevel({ ttl: '15m' });\n * ```\n */\nexport class DidResolverCacheLevel implements DidResolverCache {\n  /** The underlying LevelDB store used for caching. */\n  private cache: AbstractLevel<string | Buffer | Uint8Array, string, string>;\n\n  /** The time-to-live for cache entries in milliseconds. */\n  private ttl: number;\n\n  constructor({\n    db,\n    location = 'DATA/DID_RESOLVERCACHE',\n    ttl = '15m'\n  }: DidResolverCacheLevelParams = {}) {\n    this.cache = db ?? new Level<string, string>(location);\n    this.ttl = ms(ttl);\n  }\n\n  /**\n   * Retrieves a DID resolution result from the cache.\n   *\n   * If the cached item has exceeded its TTL, it's scheduled for deletion and undefined is returned.\n   *\n   * @param did - The DID string used as the key for retrieving the cached result.\n   * @returns The cached DID resolution result or undefined if not found or expired.\n   */\n  async get(did: string): Promise<DidResolutionResult | void> {\n    try {\n      const str = await this.cache.get(did);\n      const cacheWrapper: CacheWrapper = JSON.parse(str);\n\n      if (Date.now() >= cacheWrapper.ttlMillis) {\n        // defer deletion to be called in the next tick of the js event loop\n        this.cache.nextTick(() => this.cache.del(did));\n\n        return;\n      } else {\n        return cacheWrapper.value;\n      }\n\n    } catch(error: any) {\n      // Don't throw when a key wasn't found.\n      if (error.notFound) {\n        return;\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Stores a DID resolution result in the cache with a TTL.\n   *\n   * @param did - The DID string used as the key for storing the result.\n   * @param value - The DID resolution result to be cached.\n   * @returns A promise that resolves when the operation is complete.\n   */\n  set(did: string, value: DidResolutionResult): Promise<void> {\n    const cacheWrapper: CacheWrapper = { ttlMillis: Date.now() + this.ttl, value };\n    const str = JSON.stringify(cacheWrapper);\n\n    return this.cache.put(did, str);\n  }\n\n  /**\n   * Deletes a DID resolution result from the cache.\n   *\n   * @param did - The DID string used as the key for deletion.\n   * @returns A promise that resolves when the operation is complete.\n   */\n  delete(did: string): Promise<void> {\n    return this.cache.del(did);\n  }\n\n  /**\n   * Clears all entries from the cache.\n   *\n   * @returns A promise that resolves when the operation is complete.\n   */\n  clear(): Promise<void> {\n    return this.cache.clear();\n  }\n\n  /**\n   * Closes the underlying LevelDB store.\n   *\n   * @returns A promise that resolves when the store is closed.\n   */\n  close(): Promise<void> {\n    return this.cache.close();\n  }\n}", "import { BearerDid } from '@web5/dids';\nimport type {\n  JwtPayload,\n  JwtHeaderParams,\n  JwkParamsEcPublic,\n  JwkParamsOkpPublic,\n} from '@web5/crypto';\n\nimport { Convert } from '@web5/common';\nimport { LocalKeyManager as CryptoApi  } from '@web5/crypto';\nimport { DidDht, DidIon, DidKey, DidJwk, DidWeb, DidResolver, utils as didUtils } from '@web5/dids';\n\nconst crypto = new CryptoApi();\n\n/**\n * Result of parsing a JWT.\n */\nexport type JwtParseResult = {\n  decoded: JwtVerifyResult\n  encoded: {\n    header: string\n    payload: string\n    signature: string\n  }\n}\n\n/**\n * Result of verifying a JWT.\n */\nexport interface JwtVerifyResult {\n  /** JWT Protected Header */\n  header: JwtHeaderParams;\n\n  /** JWT Claims Set */\n  payload: JwtPayload;\n}\n\n/**\n * Parameters for parsing a JWT.\n * used in {@link Jwt.parse}\n */\nexport type ParseJwtOptions = {\n  jwt: string\n}\n\n/**\n * Parameters for signing a JWT.\n */\nexport type SignJwtOptions = {\n  signerDid: BearerDid\n  payload: JwtPayload\n}\n\n/**\n * Parameters for verifying a JWT.\n */\nexport type VerifyJwtOptions = {\n  jwt: string\n}\n\n/**\n * Class for handling Compact JSON Web Tokens (JWTs).\n * This class provides methods to create, verify, and decode JWTs using various cryptographic algorithms.\n * More information on JWTs can be found [here](https://datatracker.ietf.org/doc/html/rfc7519)\n */\nexport class Jwt {\n  /**\n   * DID Resolver instance for resolving decentralized identifiers.\n   */\n  static didResolver: DidResolver = new DidResolver({ didResolvers: [DidDht, DidIon, DidKey, DidJwk, DidWeb] });\n\n  /**\n   * Creates a signed JWT.\n   *\n   * @example\n   * ```ts\n   * const jwt = await Jwt.sign({ signerDid: myDid, payload: myPayload });\n   * ```\n   *\n   * @param options - Parameters for JWT creation including signer DID and payload.\n   * @returns The compact JWT as a string.\n   */\n  static async sign(options: SignJwtOptions): Promise<string> {\n    const { signerDid, payload } = options;\n    const signer = await signerDid.getSigner();\n\n    let vmId = signer.keyId;\n    if (vmId.charAt(0) === '#') {\n      vmId = `${signerDid.uri}${vmId}`;\n    }\n\n    const header: JwtHeaderParams = {\n      typ : 'JWT',\n      alg : signer.algorithm,\n      kid : vmId,\n    };\n\n    const base64UrlEncodedHeader = Convert.object(header).toBase64Url();\n    const base64UrlEncodedPayload = Convert.object(payload).toBase64Url();\n\n    const toSign = `${base64UrlEncodedHeader}.${base64UrlEncodedPayload}`;\n    const toSignBytes = Convert.string(toSign).toUint8Array();\n\n    const signatureBytes = await signer.sign({ data: toSignBytes });\n\n    const base64UrlEncodedSignature = Convert.uint8Array(signatureBytes).toBase64Url();\n\n    return `${toSign}.${base64UrlEncodedSignature}`;\n  }\n\n  /**\n   * Verifies a JWT.\n   *\n   * @example\n   * ```ts\n   * const verifiedJwt = await Jwt.verify({ jwt: myJwt });\n   * ```\n   *\n   * @param options - Parameters for JWT verification\n   * @returns Verified JWT information including signer DID, header, and payload.\n   */\n  static async verify(options: VerifyJwtOptions): Promise<JwtVerifyResult> {\n    const { decoded: decodedJwt, encoded: encodedJwt } = Jwt.parse({ jwt: options.jwt });\n\n    if (decodedJwt.payload.exp && Math.floor(Date.now() / 1000) > decodedJwt.payload.exp) {\n      throw new Error(`Verification failed: JWT is expired`);\n    }\n\n    // TODO: should really be looking for verificationMethod with authentication verification relationship\n    const dereferenceResult = await Jwt.didResolver.dereference(decodedJwt.header.kid!);\n    if (dereferenceResult.dereferencingMetadata.error) {\n      throw new Error(`Failed to resolve ${decodedJwt.header.kid}`);\n    }\n\n    const verificationMethod = dereferenceResult.contentStream;\n    if (!verificationMethod || !didUtils.isDidVerificationMethod(verificationMethod)) { // ensure that appropriate verification method was found\n      throw new Error('Verification failed: Expected kid in JWT header to dereference a DID Document Verification Method');\n    }\n\n    // will be used to verify signature\n    const publicKeyJwk = verificationMethod.publicKeyJwk as JwkParamsEcPublic | JwkParamsOkpPublic;\n    if (!publicKeyJwk) { // ensure that Verification Method includes public key as a JWK.\n      throw new Error('Verification failed: Expected kid in JWT header to dereference to a DID Document Verification Method with publicKeyJwk');\n    }\n\n    if(publicKeyJwk.alg && (publicKeyJwk.alg !== decodedJwt.header.alg)) {\n      throw new Error('Verification failed: Expected alg in JWT header to match DID Document Verification Method alg');\n    }\n\n    const signedData = `${encodedJwt.header}.${encodedJwt.payload}`;\n    const signedDataBytes = Convert.string(signedData).toUint8Array();\n\n    const signatureBytes = Convert.base64Url(encodedJwt.signature).toUint8Array();\n\n    const isSignatureValid = await crypto.verify({\n      key       : publicKeyJwk,\n      signature : signatureBytes,\n      data      : signedDataBytes,\n    });\n\n    if (!isSignatureValid) {\n      throw new Error('Signature verification failed: Integrity mismatch');\n    }\n\n    return decodedJwt;\n  }\n\n  /**\n   * Parses a JWT without verifying its signature.\n   *\n   * @example\n   * ```ts\n   * const { encoded: encodedJwt, decoded: decodedJwt } = Jwt.parse({ jwt: myJwt });\n   * ```\n   *\n   * @param options - Parameters for JWT decoding, including the JWT string.\n   * @returns both encoded and decoded JWT parts\n   */\n  static parse(options: ParseJwtOptions): JwtParseResult {\n    const splitJwt = options.jwt.split('.');\n    if (splitJwt.length !== 3) {\n      throw new Error(`Verification failed: Malformed JWT. expected 3 parts. got ${splitJwt.length}`);\n    }\n\n    const [base64urlEncodedJwtHeader, base64urlEncodedJwtPayload, base64urlEncodedSignature] = splitJwt;\n    let jwtHeader: JwtHeaderParams;\n    let jwtPayload: JwtPayload;\n\n    try {\n      jwtHeader = Convert.base64Url(base64urlEncodedJwtHeader).toObject() as JwtHeaderParams;\n    } catch(e) {\n      throw new Error('Verification failed: Malformed JWT. Invalid base64url encoding for JWT header');\n    }\n\n    if (!jwtHeader.typ || jwtHeader.typ !== 'JWT') {\n      throw new Error('Verification failed: Expected JWT header to contain typ property set to JWT');\n    }\n\n    if (!jwtHeader.alg || !jwtHeader.kid) { // ensure that JWT header has required properties\n      throw new Error('Verification failed: Expected JWT header to contain alg and kid');\n    }\n\n    // TODO: validate optional payload fields: https://datatracker.ietf.org/doc/html/rfc7519#section-4.1\n    try {\n      jwtPayload = Convert.base64Url(base64urlEncodedJwtPayload).toObject() as JwtPayload;\n    } catch(e) {\n      throw new Error('Verification failed: Malformed JWT. Invalid base64url encoding for JWT payload');\n    }\n\n    return {\n      decoded: {\n        header  : jwtHeader,\n        payload : jwtPayload,\n      },\n      encoded: {\n        header    : base64urlEncodedJwtHeader,\n        payload   : base64urlEncodedJwtPayload,\n        signature : base64urlEncodedSignature\n      }\n    };\n  }\n}", "import type { IPresentation, PresentationSubmission } from '@sphereon/ssi-types';\nimport type { PresentationDefinitionV2 as PexPresDefV2 } from '@sphereon/pex-models';\nimport type {\n  SelectResults,\n  EvaluationResults,\n  PresentationResult,\n  Validated as PexValidated,\n} from '@sphereon/pex';\n\nimport { PEX } from '@sphereon/pex';\n\nexport interface PresentationDefinitionV2 extends PexPresDefV2 { }\n\nexport type Validated = PexValidated;\n\nexport class PresentationExchange {\n  /**\n   * The Presentation Exchange (PEX) Library implements the functionality described in the DIF Presentation Exchange specification\n   */\n  private static pex: PEX = new PEX();\n\n  /**\n   * Selects credentials that satisfy a given presentation definition.\n   *\n   * @param {string[]} vcJwts The list of Verifiable Credentials to select from.\n   * @param {PresentationDefinitionV2} presentationDefinition The Presentation Definition to match against.\n   * @returns {string[]} selectedVcJwts A list of Verifiable Credentials that satisfy the Presentation Definition.\n   */\n  public static selectCredentials({ vcJwts, presentationDefinition }: {\n    vcJwts: string[],\n    presentationDefinition: PresentationDefinitionV2\n  }): string[] {\n    this.resetPex();\n    const selectResults: SelectResults = this.pex.selectFrom(presentationDefinition, vcJwts);\n    return Array.from(new Set(selectResults.verifiableCredential as string[] ?? []));\n  }\n\n  /**\n   * Validates if a list of VC JWTs satisfies the given presentation definition.\n   *\n   * @param vcJwts - An array of VC JWTs as strings.\n   * @param presentationDefinition - The criteria to validate against.\n   * @throws Error if the evaluation results in warnings or errors.\n   */\n  public static satisfiesPresentationDefinition({ vcJwts, presentationDefinition }: {\n    vcJwts: string[],\n    presentationDefinition: PresentationDefinitionV2\n  }): void {\n    this.resetPex();\n    const evaluationResults: EvaluationResults = this.pex.evaluateCredentials(presentationDefinition, vcJwts);\n    if (evaluationResults.warnings?.length) {\n      console.warn('Warnings were generated during the evaluation process: ' + JSON.stringify(evaluationResults.warnings));\n    }\n\n    if (evaluationResults.areRequiredCredentialsPresent.toString() !== 'info' || evaluationResults.errors?.length) {\n      let errorMessage = 'Failed to create Verifiable Presentation JWT due to: ';\n      if(evaluationResults.areRequiredCredentialsPresent) {\n        errorMessage += 'Required Credentials Not Present: ' + JSON.stringify(evaluationResults.areRequiredCredentialsPresent);\n      }\n\n      if (evaluationResults.errors?.length) {\n        errorMessage += 'Errors: ' + JSON.stringify(evaluationResults.errors);\n      }\n\n      throw new Error(errorMessage);\n    }\n  }\n\n  /**\n   * Creates a presentation from a list of Verifiable Credentials that satisfy a given presentation definition.\n   * This function initializes the Presentation Exchange (PEX) process, validates the presentation definition,\n   * evaluates the credentials against the definition, and finally constructs the presentation result if the\n   * evaluation is successful.\n   *\n   * @param {string[]} vcJwts The list of Verifiable Credentials (VCs) in JWT format to be evaluated.\n   * @param {PresentationDefinitionV2} presentationDefinition The Presentation Definition V2 to match the VCs against.\n   * @returns {PresentationResult} The result of the presentation creation process, containing a presentation submission\n   *                               that satisfies the presentation definition criteria.\n   * @throws {Error} If the evaluation results in warnings or errors, or if the required credentials are not present,\n   *                 an error is thrown with a descriptive message.\n   */\n  public static createPresentationFromCredentials({ vcJwts, presentationDefinition }: {\n    vcJwts: string[],\n    presentationDefinition: PresentationDefinitionV2\n  }): PresentationResult {\n    this.resetPex();\n\n    const pdValidated: Validated = PEX.validateDefinition(presentationDefinition);\n    isValid(pdValidated);\n\n    const evaluationResults: EvaluationResults = this.pex.evaluateCredentials(presentationDefinition, vcJwts);\n\n    if (evaluationResults.warnings?.length) {\n      console.warn('Warnings were generated during the evaluation process: ' + JSON.stringify(evaluationResults.warnings));\n    }\n\n    if (evaluationResults.areRequiredCredentialsPresent.toString() !== 'info' || evaluationResults.errors?.length) {\n      let errorMessage = 'Failed to create Verifiable Presentation JWT due to: ';\n      if(evaluationResults.areRequiredCredentialsPresent) {\n        errorMessage += 'Required Credentials Not Present: ' + JSON.stringify(evaluationResults.areRequiredCredentialsPresent);\n      }\n\n      if (evaluationResults.errors?.length) {\n        errorMessage += 'Errors: ' + JSON.stringify(evaluationResults.errors);\n      }\n\n      throw new Error(errorMessage);\n    }\n\n    const presentationResult: PresentationResult = this.pex.presentationFrom(presentationDefinition, vcJwts);\n\n    const submissionValidated: Validated = PEX.validateSubmission(presentationResult.presentationSubmission);\n    isValid(submissionValidated);\n\n    return presentationResult;\n  }\n\n  /**\n   * This method validates whether an object is usable as a presentation definition or not.\n   *\n   * @param {PresentationDefinitionV2} presentationDefinition: presentationDefinition to be validated.\n   * @returns {Validated} the validation results to reveal what is acceptable/unacceptable about the passed object to be considered a valid presentation definition\n   */\n  public static validateDefinition({ presentationDefinition }: {\n    presentationDefinition: PresentationDefinitionV2\n  }): Validated {\n    return PEX.validateDefinition(presentationDefinition);\n  }\n\n  /**\n   * This method validates whether an object is usable as a presentation submission or not.\n   *\n   * @param {PresentationSubmission} presentationSubmission the object to be validated.\n   * @returns {Validated} the validation results to reveal what is acceptable/unacceptable about the passed object to be considered a valid presentation submission\n   */\n  public static validateSubmission({ presentationSubmission }: {\n    presentationSubmission: PresentationSubmission\n  }): Validated {\n    return PEX.validateSubmission(presentationSubmission);\n  }\n\n  /**\n   * Evaluates a presentation against a presentation definition.\n   *\n   * @returns {EvaluationResults} The result of the evaluation process.\n   */\n  public static evaluatePresentation({ presentationDefinition, presentation }: {\n    presentationDefinition: PresentationDefinitionV2,\n    presentation: IPresentation\n  }): EvaluationResults {\n    this.resetPex();\n    return this.pex.evaluatePresentation(presentationDefinition, presentation);\n  }\n\n  private static resetPex() {\n    this.pex = new PEX();\n  }\n}\n\nfunction isValid(validated: Validated) {\n  let errorMessage = 'Failed to pass validation check due to: ';\n  if (Array.isArray(validated)) {\n    if (!validated.every(item => item.status === 'info')) {\n      errorMessage += 'Validation Errors: ' + JSON.stringify(validated);\n      throw new Error(errorMessage);\n    }\n  } else {\n    if (validated.status !== 'info') {\n      errorMessage += 'Validation Errors: ' + JSON.stringify(validated);\n      throw new Error(errorMessage);\n    }\n  }\n}", "import type {\n  ICredentialContextType,\n  ICredentialSubject\n} from '@sphereon/ssi-types';\n\nimport {\n  DEFAULT_CONTEXT,\n  DEFAULT_VC_TYPE,\n  VerifiableCredential\n} from './verifiable-credential.js';\n\nimport { isValidXmlSchema112Timestamp } from './utils.js';\nimport { DEFAULT_VP_TYPE } from './verifiable-presentation.js';\n\nexport class SsiValidator {\n  static validateCredentialPayload(vc: VerifiableCredential): void {\n    this.validateContext(vc.vcDataModel['@context']);\n    this.validateVcType(vc.type);\n    this.validateCredentialSubject(vc.vcDataModel.credentialSubject);\n    if (vc.vcDataModel.issuanceDate) this.validateTimestamp(vc.vcDataModel.issuanceDate);\n    if (vc.vcDataModel.expirationDate) this.validateTimestamp(vc.vcDataModel.expirationDate);\n  }\n\n  static validateContext(value: ICredentialContextType | ICredentialContextType[]): void {\n    const input = this.asArray(value);\n    if (input.length < 1 || input.indexOf(DEFAULT_CONTEXT) === -1) {\n      throw new Error(`@context is missing default context \"${DEFAULT_CONTEXT}\"`);\n    }\n  }\n\n  static validateVcType(value: string | string[]): void {\n    const input = this.asArray(value);\n    if (input.length < 1 || input.indexOf(DEFAULT_VC_TYPE) === -1) {\n      throw new Error(`type is missing default \"${DEFAULT_VC_TYPE}\"`);\n    }\n  }\n\n  static validateVpType(value: string | string[]): void {\n    const input = this.asArray(value);\n    if (input.length < 1 || input.indexOf(DEFAULT_VP_TYPE) === -1) {\n      throw new Error(`type is missing default \"${DEFAULT_VP_TYPE}\"`);\n    }\n  }\n\n  static validateCredentialSubject(value: ICredentialSubject | ICredentialSubject[]): void {\n    if (Object.keys(value).length === 0) {\n      throw new Error(`credentialSubject must not be empty`);\n    }\n  }\n\n  static validateTimestamp(timestamp: string) {\n    if(!isValidXmlSchema112Timestamp(timestamp)){\n      throw new Error(`timestamp is not valid xml schema 112 timestamp`);\n    }\n  }\n\n  static asArray(arg: any | any[]): any[] {\n    return Array.isArray(arg) ? arg : [arg];\n  }\n}", "/**\n * Retrieves the current timestamp in XML Schema 1.1.2 date-time format.\n *\n * This function omits the milliseconds part from the ISO 8601 timestamp, returning a date-time\n * string in the format \"yyyy-MM-ddTHH:mm:ssZ\".\n *\n * @example\n * ```ts\n * const currentTimestamp = getCurrentXmlSchema112Timestamp(); // \"2023-08-23T12:34:56Z\"\n * ```\n *\n * @returns The current timestamp in XML Schema 1.1.2 format.\n */\nexport function getCurrentXmlSchema112Timestamp(): string {\n  // Omit the milliseconds part from toISOString() output\n  return new Date().toISOString().replace(/\\.\\d+Z$/, 'Z');\n}\n\n/**\n * Calculates a future timestamp in XML Schema 1.1.2 date-time format based on a given number of\n * seconds.\n *\n * This function takes a number of seconds and adds it to the current timestamp, returning a\n * date-time string in the format \"yyyy-MM-ddTHH:mm:ssZ\" without milliseconds.\n *\n * @example\n * ```ts\n * const futureTimestamp = getFutureXmlSchema112Timestamp(60); // \"2023-08-23T12:35:56Z\"\n * ```\n *\n * @param secondsInFuture - The number of seconds to project into the future.\n * @returns The future timestamp in XML Schema 1.1.2 format.\n */\nexport function getFutureXmlSchema112Timestamp(secondsInFuture: number): string {\n  const futureDate = new Date(Date.now() + secondsInFuture * 1000);\n  return futureDate.toISOString().replace(/\\.\\d+Z$/, 'Z');\n}\n\n/**\n * Validates a timestamp string against the XML Schema 1.1.2 date-time format.\n *\n * This function checks whether the provided timestamp string conforms to the\n * format \"yyyy-MM-ddTHH:mm:ssZ\", without milliseconds, as defined in XML Schema 1.1.2.\n *\n * @example\n * ```ts\n * const isValid = isValidXmlSchema112Timestamp('2023-08-23T12:34:56Z'); // true\n * ```\n *\n * @param timestamp - The timestamp string to validate.\n * @returns `true` if the timestamp is valid, `false` otherwise.\n */\nexport function isValidXmlSchema112Timestamp(timestamp: string): boolean {\n  // Format: yyyy-MM-ddTHH:mm:ssZ\n  const regex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$/;\n  if (!regex.test(timestamp)) {\n    return false;\n  }\n\n  const date = new Date(timestamp);\n\n  return !isNaN(date.getTime());\n}", "import type { BearerDid } from '@web5/dids';\nimport type { IPresentation} from '@sphereon/ssi-types';\n\nimport { utils as cryptoUtils } from '@web5/crypto';\n\nimport { Jwt } from './jwt.js';\nimport { SsiValidator } from './validators.js';\n\nexport const DEFAULT_CONTEXT = 'https://www.w3.org/2018/credentials/v1';\nexport const DEFAULT_VP_TYPE = 'VerifiablePresentation';\n\n/**\n * A Verifiable Presentation\n *\n * @see {@link https://www.w3.org/TR/vc-data-model/#credentials | VC Data Model}\n */\nexport type VpDataModel = IPresentation;\n\n/**\n * Options for creating a verifiable presentation.\n * @param holder The holder URI of the presentation, as a string.\n * @param vcJwts The JWTs of the credentials to be included in the presentation.\n * @param type Optional. The type of the presentation, can be a string or an array of strings.\n * @param additionalData Optional additional data to be included in the presentation.\n */\nexport type VerifiablePresentationCreateOptions = {\n  holder: string,\n  vcJwts: string[],\n  type?: string | string[];\n  additionalData?: Record<string, any>\n};\n\n/**\n * Options for signing a verifiable presentation.\n * @param did - The holder DID of the presentation, represented as a PortableDid.\n */\nexport type VerifiablePresentationSignOptions = {\n  did: BearerDid;\n};\n\n/**\n * `VerifiablePresentation` is a tamper-evident presentation encoded in such a way that authorship of the data\n * can be trusted after a process of cryptographic verification.\n * [W3C Verifiable Presentation Data Model](https://www.w3.org/TR/vc-data-model/#presentations).\n *\n * It provides functionalities to sign, verify, and create presentations, offering a concise API to\n * work with JWT representations of verifiable presentations and ensuring that the signatures\n * and claims within those JWTs can be validated.\n *\n * @property vpDataModel The [vpDataModel] instance representing the core data model of a verifiable presentation.\n */\nexport class VerifiablePresentation {\n  constructor(public vpDataModel: VpDataModel) {}\n\n  get type(): string {\n    return this.vpDataModel.type![this.vpDataModel.type!.length - 1];\n  }\n\n  get holder(): string {\n    return this.vpDataModel.holder!.toString();\n  }\n\n  get verifiableCredential(): string[] {\n    return this.vpDataModel.verifiableCredential! as string[];\n  }\n\n  /**\n   * Signs the verifiable presentation and returns it as a signed JWT.\n   *\n   * @example\n   * ```ts\n   * const vpJwt = verifiablePresentation.sign({ did: myDid });\n   * ```\n   *\n   * @param options - The sign options used to sign the presentation.\n   * @returns The JWT representing the signed verifiable presentation.\n   */\n  public async sign(options: VerifiablePresentationSignOptions): Promise<string> {\n    const vpJwt: string = await Jwt.sign({\n      signerDid : options.did,\n      payload   : {\n        vp  : this.vpDataModel,\n        iss : options.did.uri,\n        sub : options.did.uri,\n      }\n    });\n\n    return vpJwt;\n  }\n\n  /**\n   * Converts the current object to its JSON representation.\n   *\n   * @returns The JSON representation of the object.\n   */\n  public toString(): string {\n    return JSON.stringify(this.vpDataModel);\n  }\n\n  /**\n   * Create a [VerifiablePresentation] based on the provided parameters.\n   *\n   * @example\n   * ```ts\n   * const vp = await VerifiablePresentation.create({\n   *     type: 'PresentationSubmission',\n   *     holder: 'did:ex:holder',\n   *     vcJwts: vcJwts,\n   *     additionalData: { 'arbitrary': 'data' }\n   *   })\n   * ```\n   *\n   * @param options - The options to use when creating the Verifiable Presentation.\n   * @returns A [VerifiablePresentation] instance.\n   */\n  public static async create(options: VerifiablePresentationCreateOptions): Promise<VerifiablePresentation> {\n    const { type, holder, vcJwts, additionalData } = options;\n\n    if (additionalData) {\n      const jsonData = JSON.parse(JSON.stringify(additionalData));\n\n      if (typeof jsonData !== 'object') {\n        throw new Error('Expected data to be parseable into a JSON object');\n      }\n    }\n\n    if(!holder) {\n      throw new Error('Holder must be defined');\n    }\n\n    if(typeof holder !== 'string') {\n      throw new Error('Holder must be of type string');\n    }\n\n    const vpDataModel: VpDataModel = {\n      '@context' : [DEFAULT_CONTEXT],\n      type       : Array.isArray(type)\n        ? [DEFAULT_VP_TYPE, ...type]\n        : (type ? [DEFAULT_VP_TYPE, type] : [DEFAULT_VP_TYPE]),\n      id                   : `urn:uuid:${cryptoUtils.randomUuid()}`,\n      holder               : holder,\n      verifiableCredential : vcJwts,\n      ...additionalData,\n    };\n\n    validatePayload(vpDataModel);\n\n    return new VerifiablePresentation(vpDataModel);\n  }\n\n  /**\n   * Verifies the integrity and authenticity of a Verifiable Presentation (VP) encoded as a JSON Web Token (JWT).\n   *\n   * This function performs several crucial validation steps to ensure the trustworthiness of the provided VP:\n   * - Parses and validates the structure of the JWT.\n   * - Ensures the presence of critical header elements `alg` and `kid` in the JWT header.\n   * - Resolves the Decentralized Identifier (DID) and retrieves the associated DID Document.\n   * - Validates the DID and establishes a set of valid verification method IDs.\n   * - Identifies the correct Verification Method from the DID Document based on the `kid` parameter.\n   * - Verifies the JWT's signature using the public key associated with the Verification Method.\n   *\n   * If any of these steps fail, the function will throw a [Error] with a message indicating the nature of the failure.\n   *\n   * @example\n   * ```ts\n   * try {\n   *     VerifiablePresentation.verify({ vpJwt: signedVpJwt })\n   *     console.log(\"VC Verification successful!\")\n   * } catch (e: Error) {\n   *     console.log(\"VC Verification failed: ${e.message}\")\n   * }\n   * ```\n   *\n   * @param vpJwt The Verifiable Presentation in JWT format as a [string].\n   * @throws Error if the verification fails at any step, providing a message with failure details.\n   * @throws Error if critical JWT header elements are absent.\n   */\n  public static async verify({ vpJwt }: {\n    vpJwt: string\n  }) {\n    const { payload } = await Jwt.verify({ jwt: vpJwt });\n    const vp = payload['vp'] as VpDataModel;\n    if (!vp) {\n      throw new Error('vp property missing.');\n    }\n\n    validatePayload(vp);\n\n    for (const vcJwt of vp.verifiableCredential!) {\n      await Jwt.verify({ jwt: vcJwt as string });\n    }\n\n    return {\n      issuer  : payload.iss!,\n      subject : payload.sub!,\n      vc      : payload['vp'] as VpDataModel\n    };\n  }\n\n  /**\n   * Parses a JWT into a [VerifiablePresentation] instance.\n   *\n   * @example\n   * ```ts\n   * const vp = VerifiablePresentation.parseJwt({ vpJwt: signedVpJwt })\n   * ```\n   *\n   * @param vpJwt The verifiable presentation JWT as a [String].\n   * @returns A [VerifiablePresentation] instance derived from the JWT.\n   */\n  public static parseJwt({ vpJwt }: { vpJwt: string }): VerifiablePresentation {\n    const parsedJwt = Jwt.parse({ jwt: vpJwt });\n    const vpDataModel: VpDataModel = parsedJwt.decoded.payload['vp'] as VpDataModel;\n\n    if(!vpDataModel) {\n      throw Error('Jwt payload missing vp property');\n    }\n\n    return new VerifiablePresentation(vpDataModel);\n  }\n}\n\n/**\n * Validates the structure and integrity of a Verifiable Presentation payload.\n *\n * @param vp - The Verifiable Presentaation object to validate.\n * @throws Error if any validation check fails.\n */\nfunction validatePayload(vp: VpDataModel): void {\n  SsiValidator.validateContext(vp['@context']);\n  SsiValidator.validateVpType(vp.type!);\n}", "import type { BearerDid } from '@web5/dids';\nimport type { ICredential, ICredentialSubject} from '@sphereon/ssi-types';\n\nimport { utils as cryptoUtils } from '@web5/crypto';\n\nimport { Jwt } from './jwt.js';\nimport { SsiValidator } from './validators.js';\nimport { getCurrentXmlSchema112Timestamp } from './utils.js';\n\nexport const DEFAULT_CONTEXT = 'https://www.w3.org/2018/credentials/v1';\nexport const DEFAULT_VC_TYPE = 'VerifiableCredential';\n\n/**\n * A Verifiable Credential is a set of one or more claims made by the same entity.\n *\n * @see {@link https://www.w3.org/TR/vc-data-model/#credentials | VC Data Model}\n */\nexport type VcDataModel = ICredential;\n\n/**\n * Options for creating a verifiable credential.\n * @param type Optional. The type of the credential, can be a string or an array of strings.\n * @param issuer The issuer URI of the credential, as a string.\n * @param subject The subject URI of the credential, as a string.\n * @param data The credential data, as a generic type any.\n * @param issuanceDate Optional. The issuance date of the credential, as a string.\n *               Defaults to the current date if not specified.\n * @param expirationDate Optional. The expiration date of the credential, as a string.\n */\nexport type VerifiableCredentialCreateOptions = {\n  type?: string | string[];\n  issuer: string;\n  subject: string;\n  data: any;\n  issuanceDate?: string;\n  expirationDate?: string;\n};\n\n/**\n * Options for signing a verifiable credential.\n * @param did - The issuer DID of the credential, represented as a PortableDid.\n */\nexport type VerifiableCredentialSignOptions = {\n  did: BearerDid;\n};\n\ntype CredentialSubject = ICredentialSubject;\n\n/**\n * `VerifiableCredential` represents a digitally verifiable credential according to the\n * [W3C Verifiable Credentials Data Model](https://www.w3.org/TR/vc-data-model/).\n *\n * It provides functionalities to sign, verify, and create credentials, offering a concise API to\n * work with JWT representations of verifiable credentials and ensuring that the signatures\n * and claims within those JWTs can be validated.\n *\n * @property vcDataModel The [VcDataModel] instance representing the core data model of a verifiable credential.\n */\nexport class VerifiableCredential {\n  constructor(public vcDataModel: VcDataModel) {}\n\n  get type(): string {\n    return this.vcDataModel.type[this.vcDataModel.type.length - 1];\n  }\n\n  get issuer(): string {\n    return this.vcDataModel.issuer.toString();\n  }\n\n  get subject(): string {\n    if (Array.isArray(this.vcDataModel.credentialSubject)) {\n      return this.vcDataModel.credentialSubject[0].id!;\n    } else {\n      return this.vcDataModel.credentialSubject.id!;\n    }\n  }\n\n  /**\n   * Signs the verifiable credential and returns it as a signed JWT.\n   *\n   * @example\n   * ```ts\n   * const vcJwt = verifiableCredential.sign({ did: myDid });\n   * ```\n   *\n   * @param options - The sign options used to sign the credential.\n   * @returns The JWT representing the signed verifiable credential.\n   */\n  public async sign(options: VerifiableCredentialSignOptions): Promise<string> {\n    const vcJwt: string = await Jwt.sign({\n      signerDid : options.did,\n      payload   : {\n        vc  : this.vcDataModel,\n        iss : this.issuer,\n        sub : this.subject,\n      }\n    });\n\n    return vcJwt;\n  }\n\n  /**\n   * Converts the current object to its JSON representation.\n   *\n   * @returns The JSON representation of the object.\n   */\n  public toString(): string {\n    return JSON.stringify(this.vcDataModel);\n  }\n\n  /**\n   * Create a [VerifiableCredential] based on the provided parameters.\n   *\n   * @example\n   * ```ts\n   * const vc = await VerifiableCredential.create({\n   *     type: 'StreetCredibility',\n   *     issuer: 'did:ex:issuer',\n   *     subject: 'did:ex:subject',\n   *     data: { 'arbitrary': 'data' }\n   *   })\n   * ```\n   *\n   * @param options - The options to use when creating the Verifiable Credential.\n   * @returns A [VerifiableCredential] instance.\n   */\n  public static async create(options: VerifiableCredentialCreateOptions): Promise<VerifiableCredential> {\n    const { type, issuer, subject, data, issuanceDate, expirationDate } = options;\n\n    const jsonData = JSON.parse(JSON.stringify(data));\n\n    if (typeof jsonData !== 'object') {\n      throw new Error('Expected data to be parseable into a JSON object');\n    }\n\n    if(!issuer || !subject) {\n      throw new Error('Issuer and subject must be defined');\n    }\n\n    if(typeof issuer !== 'string' || typeof subject !== 'string') {\n      throw new Error('Issuer and subject must be of type string');\n    }\n\n    const credentialSubject: CredentialSubject = {\n      id: subject,\n      ...jsonData\n    };\n\n    const vcDataModel: VcDataModel = {\n      '@context' : [DEFAULT_CONTEXT],\n      type       : Array.isArray(type)\n        ? [DEFAULT_VC_TYPE, ...type]\n        : (type ? [DEFAULT_VC_TYPE, type] : [DEFAULT_VC_TYPE]),\n      id                : `urn:uuid:${cryptoUtils.randomUuid()}`,\n      issuer            : issuer,\n      issuanceDate      : issuanceDate || getCurrentXmlSchema112Timestamp(), // use default if undefined\n      credentialSubject : credentialSubject,\n      ...(expirationDate && { expirationDate }), // optional property\n    };\n\n    validatePayload(vcDataModel);\n\n    return new VerifiableCredential(vcDataModel);\n  }\n\n  /**\n   * Verifies the integrity and authenticity of a Verifiable Credential (VC) encoded as a JSON Web Token (JWT).\n   *\n   * This function performs several crucial validation steps to ensure the trustworthiness of the provided VC:\n   * - Parses and validates the structure of the JWT.\n   * - Ensures the presence of critical header elements `alg` and `kid` in the JWT header.\n   * - Resolves the Decentralized Identifier (DID) and retrieves the associated DID Document.\n   * - Validates the DID and establishes a set of valid verification method IDs.\n   * - Identifies the correct Verification Method from the DID Document based on the `kid` parameter.\n   * - Verifies the JWT's signature using the public key associated with the Verification Method.\n   *\n   * If any of these steps fail, the function will throw a [Error] with a message indicating the nature of the failure.\n   *\n   * @example\n   * ```ts\n   * try {\n   *     VerifiableCredential.verify({ vcJwt: signedVcJwt })\n   *     console.log(\"VC Verification successful!\")\n   * } catch (e: Error) {\n   *     console.log(\"VC Verification failed: ${e.message}\")\n   * }\n   * ```\n   *\n   * @param vcJwt The Verifiable Credential in JWT format as a [string].\n   * @throws Error if the verification fails at any step, providing a message with failure details.\n   * @throws Error if critical JWT header elements are absent.\n   */\n  public static async verify({ vcJwt }: {\n    vcJwt: string\n  }) {\n    const { payload } = await Jwt.verify({ jwt: vcJwt });\n    const vc = payload['vc'] as VcDataModel;\n    if (!vc) {\n      throw new Error('vc property missing.');\n    }\n\n    validatePayload(vc);\n\n    return {\n      issuer  : payload.iss!,\n      subject : payload.sub!,\n      vc      : payload['vc'] as VcDataModel\n    };\n  }\n\n  /**\n   * Parses a JWT into a [VerifiableCredential] instance.\n   *\n   * @example\n   * ```ts\n   * const vc = VerifiableCredential.parseJwt({ vcJwt: signedVcJwt })\n   * ```\n   *\n   * @param vcJwt The verifiable credential JWT as a [String].\n   * @returns A [VerifiableCredential] instance derived from the JWT.\n   */\n  public static parseJwt({ vcJwt }: { vcJwt: string }): VerifiableCredential {\n    const parsedJwt = Jwt.parse({ jwt: vcJwt });\n    const vcDataModel: VcDataModel = parsedJwt.decoded.payload['vc'] as VcDataModel;\n\n    if(!vcDataModel) {\n      throw Error('Jwt payload missing vc property');\n    }\n\n    return new VerifiableCredential(vcDataModel);\n  }\n}\n\n/**\n * Validates the structure and integrity of a Verifiable Credential payload.\n *\n * @param vc - The Verifiable Credential object to validate.\n * @throws Error if any validation check fails.\n */\nfunction validatePayload(vc: VcDataModel): void {\n  SsiValidator.validateContext(vc['@context']);\n  SsiValidator.validateVcType(vc.type);\n  SsiValidator.validateCredentialSubject(vc.credentialSubject);\n  if (vc.issuanceDate) SsiValidator.validateTimestamp(vc.issuanceDate);\n  if (vc.expirationDate) SsiValidator.validateTimestamp(vc.expirationDate);\n}"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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",
  "names": ["import_dist", "ms", "import_dist", "import_dist", "DidVerificationRelationship", "import_dist", "import_dist", "DidErrorCode", "_b", "_a", "_a", "isValid", "import_dist", "DidDhtRegisteredDidType", "DidDhtRegisteredKeyType", "DidDhtVerificationRelationship", "_a", "dnsRecordId", "isValid", "DidIonRegisteredKeyType", "AlgorithmToKeyTypeMap", "DEFAULT_GATEWAY_URI", "_a", "DidKeyRegisteredKeyType", "AlgorithmToKeyTypeMap", "isValid", "utils_exports", "import_dist", "import_dist", "utils_exports", "import_dist"]
}
