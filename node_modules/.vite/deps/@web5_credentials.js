"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports) {
      "use strict";
      init_dist();
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js"(exports) {
      init_dist();
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s2 = buffer[offset + i];
        i += d;
        e = s2 & (1 << -nBits) - 1;
        s2 >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s2 ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s2 * 128;
      };
    }
  });

  // node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js"(exports) {
      "use strict";
      init_dist();
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer2;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      var { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new GlobalUint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new GlobalUint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer2.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (GlobalArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b)
          return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);
      Object.setPrototypeOf(Buffer2, GlobalUint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, GlobalUint8Array)) {
          const copy = new GlobalUint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new GlobalUint8Array(array);
        } else if (length === void 0) {
          buf = new GlobalUint8Array(array, byteOffset);
        } else {
          buf = new GlobalUint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer2.alloc(+length);
      }
      Buffer2.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer2.prototype;
      };
      Buffer2.compare = function compare(a, b) {
        if (isInstance(a, GlobalUint8Array))
          a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b, GlobalUint8Array))
          b = Buffer2.from(b, b.offset, b.byteLength);
        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b)
          return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer = Buffer2.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, GlobalUint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer2.isBuffer(buf))
                buf = Buffer2.from(buf);
              buf.copy(buffer, pos);
            } else {
              GlobalUint8Array.prototype.set.call(
                buffer,
                buf,
                pos
              );
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }
        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer2.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
      Buffer2.prototype.equals = function equals(b) {
        if (!Buffer2.isBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }
      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, GlobalUint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }
        if (!Buffer2.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof GlobalUint8Array.prototype.indexOf === "function") {
            if (dir) {
              return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer2.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val = this[offset + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let i = byteLength2;
        let mul = 1;
        let val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          GlobalUint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length)
            break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js
  var require_browser = __commonJS({
    "node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js"(exports, module) {
      init_dist();
      var process = module.exports = {};
      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          if (typeof setTimeout === "function") {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === "function") {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e2) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e2) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      process.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      process.title = "browser";
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = "";
      process.versions = {};
      function noop() {
      }
      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;
      process.listeners = function(name) {
        return [];
      };
      process.binding = function(name) {
        throw new Error("process.binding is not supported");
      };
      process.cwd = function() {
        return "/";
      };
      process.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
      };
      process.umask = function() {
        return 0;
      };
    }
  });

  // shims/dist/index.js
  var import_buffer_polyfill, import_process, o;
  var init_dist = __esm({
    "shims/dist/index.js"() {
      "use strict";
      import_buffer_polyfill = __toESM(require_buffer(), 1);
      import_process = __toESM(require_browser(), 1);
      o = globalThis || void 0 || self;
    }
  });

  // shims/banner/index.cjs
  var require_banner = __commonJS({
    "shims/banner/index.cjs"() {
      init_dist();
      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;
      globalThis.global = globalThis.global || o;
      globalThis.process = globalThis.process || import_process.default;
    }
  });
  require_banner();
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/

import {
  PEX
} from "./chunk-IDIKVVDV.js";
import {
  Convert,
  Ed25519,
  LocalKeyManager,
  Multicodec,
  Secp256k1,
  Secp256r1,
  X25519,
  computeJwkThumbprint,
  universalTypeOf,
  utils_exports
} from "./chunk-W2H5HRLX.js";
import {
  AUTHORITATIVE_ANSWER,
  IonDid,
  IonRequest,
  bencode_default,
  decode,
  encode,
  require_browser
} from "./chunk-UPUZYSSL.js";
import {
  __commonJS,
  __export,
  __toESM,
  require_dist
} from "./chunk-C4XPKKSS.js";

// node_modules/@web5/credentials/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/@web5/credentials/node_modules/ms/index.js"(exports, module) {
    var import_dist23 = __toESM(require_dist());
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d) {
        return Math.round(ms2 / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms2 / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms2 / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms2 / s) + "s";
      }
      return ms2 + "ms";
    }
    function fmtLong(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d) {
        return plural(ms2, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms2, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms2, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms2, msAbs, s, "second");
      }
      return ms2 + " ms";
    }
    function plural(ms2, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/@web5/credentials/dist/esm/index.js
var import_dist22 = __toESM(require_dist());

// node_modules/@web5/credentials/dist/esm/jwt.js
var import_dist16 = __toESM(require_dist(), 1);

// node_modules/@web5/credentials/node_modules/@web5/dids/dist/esm/index.js
var import_dist15 = __toESM(require_dist());

// node_modules/@web5/credentials/node_modules/@web5/dids/dist/esm/types/did-core.js
var import_dist = __toESM(require_dist(), 1);
var DidVerificationRelationship;
(function(DidVerificationRelationship2) {
  DidVerificationRelationship2["authentication"] = "authentication";
  DidVerificationRelationship2["assertionMethod"] = "assertionMethod";
  DidVerificationRelationship2["keyAgreement"] = "keyAgreement";
  DidVerificationRelationship2["capabilityDelegation"] = "capabilityDelegation";
  DidVerificationRelationship2["capabilityInvocation"] = "capabilityInvocation";
})(DidVerificationRelationship || (DidVerificationRelationship = {}));

// node_modules/@web5/credentials/node_modules/@web5/dids/dist/esm/did.js
var import_dist2 = __toESM(require_dist(), 1);
var Did = class _Did {
  /**
   * Constructs a new `Did` instance from individual components.
   *
   * @param params - An object containing the parameters to be included in the DID URI.
   * @param params.method - The name of the DID method.
   * @param params.id - The DID method identifier.
   * @param params.path - Optional. The path component of the DID URI.
   * @param params.query - Optional. The query component of the DID URI.
   * @param params.fragment - Optional. The fragment component of the DID URI.
   * @param params.params - Optional. The query parameters in the DID URI.
   */
  constructor({ method, id, path, query, fragment, params }) {
    this.uri = `did:${method}:${id}`;
    this.method = method;
    this.id = id;
    this.path = path;
    this.query = query;
    this.fragment = fragment;
    this.params = params;
  }
  /**
   * Parses a DID URI string into its individual components.
   *
   * @example
   * ```ts
   * const did = Did.parse('did:example:123?service=agent&relativeRef=/credentials#degree');
   *
   * console.log(did.uri)      // Output: 'did:example:123'
   * console.log(did.method)   // Output: 'example'
   * console.log(did.id)       // Output: '123'
   * console.log(did.query)    // Output: 'service=agent&relativeRef=/credentials'
   * console.log(did.fragment) // Output: 'degree'
   * console.log(did.params)   // Output: { service: 'agent', relativeRef: '/credentials' }
   * ```
   *
   * @params didUri - The DID URI string to be parsed.
   * @returns A `Did` object representing the parsed DID URI, or `null` if the input string is not a valid DID URI.
   */
  static parse(didUri) {
    if (!didUri)
      return null;
    const match = _Did.DID_URI_PATTERN.exec(didUri);
    if (!match || !match.groups)
      return null;
    const { method, id, path, query, fragment } = match.groups;
    const did = {
      uri: `did:${method}:${id}`,
      method,
      id
    };
    if (path)
      did.path = path;
    if (query)
      did.query = query.slice(1);
    if (fragment)
      did.fragment = fragment.slice(1);
    if (query) {
      const parsedParams = {};
      const paramPairs = query.slice(1).split("&");
      for (const pair of paramPairs) {
        const [key, value] = pair.split("=");
        parsedParams[key] = value;
      }
      did.params = parsedParams;
    }
    return did;
  }
};
Did.METHOD_PATTERN = "([a-z0-9]+)";
Did.PCT_ENCODED_PATTERN = "(?:%[0-9a-fA-F]{2})";
Did.ID_CHAR_PATTERN = `(?:[a-zA-Z0-9._-]|${Did.PCT_ENCODED_PATTERN})`;
Did.METHOD_ID_PATTERN = `((?:${Did.ID_CHAR_PATTERN}*:)*(${Did.ID_CHAR_PATTERN}+))`;
Did.PATH_PATTERN = `(/[^#?]*)?`;
Did.QUERY_PATTERN = `([?][^#]*)?`;
Did.FRAGMENT_PATTERN = `(#.*)?`;
Did.DID_URI_PATTERN = new RegExp(`^did:(?<method>${Did.METHOD_PATTERN}):(?<id>${Did.METHOD_ID_PATTERN})(?<path>${Did.PATH_PATTERN})(?<query>${Did.QUERY_PATTERN})(?<fragment>${Did.FRAGMENT_PATTERN})$`);

// node_modules/@web5/credentials/node_modules/@web5/dids/dist/esm/did-error.js
var import_dist3 = __toESM(require_dist(), 1);
var DidError = class _DidError extends Error {
  /**
   * Constructs an instance of DidError, a custom error class for handling DID-related errors.
   *
   * @param code - A {@link DidErrorCode} representing the specific type of error encountered.
   * @param message - A human-readable description of the error.
   */
  constructor(code, message) {
    super(message);
    this.code = code;
    this.name = "DidError";
    Object.setPrototypeOf(this, new.target.prototype);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _DidError);
    }
  }
};
var DidErrorCode;
(function(DidErrorCode2) {
  DidErrorCode2["InvalidDid"] = "invalidDid";
  DidErrorCode2["MethodNotSupported"] = "methodNotSupported";
  DidErrorCode2["InternalError"] = "internalError";
  DidErrorCode2["InvalidDidDocument"] = "invalidDidDocument";
  DidErrorCode2["InvalidDidDocumentLength"] = "invalidDidDocumentLength";
  DidErrorCode2["InvalidDidUrl"] = "invalidDidUrl";
  DidErrorCode2["InvalidPublicKey"] = "invalidPublicKey";
  DidErrorCode2["InvalidPublicKeyLength"] = "invalidPublicKeyLength";
  DidErrorCode2["InvalidPublicKeyType"] = "invalidPublicKeyType";
  DidErrorCode2["InvalidSignature"] = "invalidSignature";
  DidErrorCode2["NotFound"] = "notFound";
  DidErrorCode2["RepresentationNotSupported"] = "representationNotSupported";
  DidErrorCode2["UnsupportedPublicKeyType"] = "unsupportedPublicKeyType";
})(DidErrorCode || (DidErrorCode = {}));

// node_modules/@web5/credentials/node_modules/@web5/dids/dist/esm/bearer-did.js
var import_dist5 = __toESM(require_dist(), 1);

// node_modules/@web5/credentials/node_modules/@web5/dids/dist/esm/utils.js
var utils_exports2 = {};
__export(utils_exports2, {
  extractDidFragment: () => extractDidFragment,
  getServices: () => getServices,
  getVerificationMethodByKey: () => getVerificationMethodByKey,
  getVerificationMethodTypes: () => getVerificationMethodTypes,
  getVerificationMethods: () => getVerificationMethods,
  getVerificationRelationshipsById: () => getVerificationRelationshipsById,
  isDidService: () => isDidService,
  isDidVerificationMethod: () => isDidVerificationMethod,
  isDwnDidService: () => isDwnDidService,
  keyBytesToMultibaseId: () => keyBytesToMultibaseId,
  multibaseIdToKeyBytes: () => multibaseIdToKeyBytes
});
var import_dist4 = __toESM(require_dist(), 1);
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function extractDidFragment(input) {
  if (typeof input !== "string")
    return void 0;
  if (input.length === 0)
    return void 0;
  return input.split("#").pop();
}
function getServices({ didDocument, id, type }) {
  var _a, _b;
  return (_b = (_a = didDocument === null || didDocument === void 0 ? void 0 : didDocument.service) === null || _a === void 0 ? void 0 : _a.filter((service) => {
    if (id && service.id !== id)
      return false;
    if (type && service.type !== type)
      return false;
    return true;
  })) !== null && _b !== void 0 ? _b : [];
}
function getVerificationMethodByKey({ didDocument, publicKeyJwk, publicKeyMultibase }) {
  return __awaiter(this, void 0, void 0, function* () {
    const verificationMethods = getVerificationMethods({ didDocument });
    for (let method of verificationMethods) {
      if (publicKeyJwk && method.publicKeyJwk) {
        const publicKeyThumbprint = yield computeJwkThumbprint({ jwk: publicKeyJwk });
        if (publicKeyThumbprint === (yield computeJwkThumbprint({ jwk: method.publicKeyJwk }))) {
          return method;
        }
      } else if (publicKeyMultibase && method.publicKeyMultibase) {
        if (publicKeyMultibase === method.publicKeyMultibase) {
          return method;
        }
      }
    }
    return null;
  });
}
function getVerificationMethods({ didDocument }) {
  var _a, _b;
  if (!didDocument)
    throw new TypeError(`Required parameter missing: 'didDocument'`);
  const verificationMethods = [];
  verificationMethods.push(...(_b = (_a = didDocument.verificationMethod) === null || _a === void 0 ? void 0 : _a.filter(isDidVerificationMethod)) !== null && _b !== void 0 ? _b : []);
  Object.keys(DidVerificationRelationship).forEach((relationship) => {
    var _a2, _b2;
    verificationMethods.push(...(_b2 = (_a2 = didDocument[relationship]) === null || _a2 === void 0 ? void 0 : _a2.filter(isDidVerificationMethod)) !== null && _b2 !== void 0 ? _b2 : []);
  });
  return verificationMethods;
}
function getVerificationMethodTypes({ didDocument }) {
  const verificationMethods = getVerificationMethods({ didDocument });
  const types = verificationMethods.map((method) => method.type);
  return [...new Set(types)];
}
function getVerificationRelationshipsById({ didDocument, methodId }) {
  const relationships = [];
  Object.keys(DidVerificationRelationship).forEach((relationship) => {
    if (Array.isArray(didDocument[relationship])) {
      const relationshipMethods = didDocument[relationship];
      const methodIdFragment = extractDidFragment(methodId);
      const containsMethodId = relationshipMethods.some((method) => {
        const isByReferenceMatch = extractDidFragment(method) === methodIdFragment;
        const isEmbeddedMethodMatch = isDidVerificationMethod(method) && extractDidFragment(method.id) === methodIdFragment;
        return isByReferenceMatch || isEmbeddedMethodMatch;
      });
      if (containsMethodId) {
        relationships.push(relationship);
      }
    }
  });
  return relationships;
}
function isDidService(obj) {
  if (!obj || typeof obj !== "object" || obj === null)
    return false;
  return "id" in obj && "type" in obj && "serviceEndpoint" in obj;
}
function isDwnDidService(obj) {
  if (!isDidService(obj))
    return false;
  if (obj.type !== "DecentralizedWebNode")
    return false;
  if (!("enc" in obj && "sig" in obj))
    return false;
  const isStringOrStringArray = (prop) => typeof prop === "string" || Array.isArray(prop) && prop.every((item) => typeof item === "string");
  return isStringOrStringArray(obj.enc) && isStringOrStringArray(obj.sig);
}
function isDidVerificationMethod(obj) {
  if (!obj || typeof obj !== "object" || obj === null)
    return false;
  if (!("id" in obj && "type" in obj && "controller" in obj))
    return false;
  if (typeof obj.id !== "string")
    return false;
  if (typeof obj.type !== "string")
    return false;
  if (typeof obj.controller !== "string")
    return false;
  return true;
}
function keyBytesToMultibaseId({ keyBytes, multicodecCode, multicodecName }) {
  const prefixedKey = Multicodec.addPrefix({
    code: multicodecCode,
    data: keyBytes,
    name: multicodecName
  });
  const prefixedKeyB58 = Convert.uint8Array(prefixedKey).toBase58Btc();
  const multibaseKeyId = Convert.base58Btc(prefixedKeyB58).toMultibase();
  return multibaseKeyId;
}
function multibaseIdToKeyBytes({ multibaseKeyId }) {
  try {
    const prefixedKeyB58 = Convert.multibase(multibaseKeyId).toBase58Btc();
    const prefixedKey = Convert.base58Btc(prefixedKeyB58).toUint8Array();
    const { code, data, name } = Multicodec.removePrefix({ prefixedData: prefixedKey });
    return { keyBytes: data, multicodecCode: code, multicodecName: name };
  } catch (error) {
    throw new DidError(DidErrorCode.InvalidDid, `Invalid multibase identifier: ${multibaseKeyId}`);
  }
}

// node_modules/@web5/credentials/node_modules/@web5/dids/dist/esm/bearer-did.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var BearerDid = class _BearerDid {
  constructor({ uri, document, metadata, keyManager }) {
    this.uri = uri;
    this.document = document;
    this.metadata = metadata;
    this.keyManager = keyManager;
  }
  /**
   * Converts a `BearerDid` object to a portable format containing the URI and verification methods
   * associated with the DID.
   *
   * This method is useful when you need to represent the key material and metadata associated with
   * a DID in format that can be used independently of the specific DID method implementation. It
   * extracts both public and private keys from the DID's key manager and organizes them into a
   * `PortableDid` structure.
   *
   * @remarks
   * This method requires that the DID's key manager supports the `exportKey` operation. If the DID
   * document does not contain any verification methods, or if the key manager does not support key
   * export, an error is thrown.
   *
   * The resulting `PortableDid` will contain the same number of verification methods as the DID
   * document, each with its associated public and private keys and the purposes for which the key
   * can be used.
   *
   * @example
   * ```ts
   * // Assuming `did` is an instance of BearerDid
   * const portableDid = await did.export();
   * // portableDid now contains the DID URI, document, metadata, and optionally, private keys.
   * ```
   *
   * @returns A `PortableDid` containing the URI, DID document, metadata, and optionally private
   *          keys associated with the `BearerDid`.
   * @throws An error if the DID document does not contain any verification methods or the keys for
   *         any verification method are missing in the key manager.
   */
  export() {
    return __awaiter2(this, void 0, void 0, function* () {
      if (!(Array.isArray(this.document.verificationMethod) && this.document.verificationMethod.length > 0)) {
        throw new Error(`DID document for '${this.uri}' is missing verification methods`);
      }
      let portableDid = {
        uri: this.uri,
        document: this.document,
        metadata: this.metadata
      };
      if ("exportKey" in this.keyManager && typeof this.keyManager.exportKey === "function") {
        const privateKeys = [];
        for (let vm of this.document.verificationMethod) {
          if (!vm.publicKeyJwk) {
            throw new Error(`Verification method '${vm.id}' does not contain a public key in JWK format`);
          }
          const keyUri = yield this.keyManager.getKeyUri({ key: vm.publicKeyJwk });
          const privateKey = yield this.keyManager.exportKey({ keyUri });
          privateKeys.push(Object.assign({}, privateKey));
        }
        portableDid.privateKeys = privateKeys;
      }
      return portableDid;
    });
  }
  /**
   * Return a {@link Signer} that can be used to sign messages, credentials, or arbitrary data.
   *
   * If given, the `methodId` parameter is used to select a key from the verification methods
   * present in the DID Document.
   *
   * If `methodID` is not given, the first verification method intended for signing claims is used.
   *
   * @param params - The parameters for the `getSigner` operation.
   * @param params.methodId - ID of the verification method key that will be used for sign and
   *                          verify operations. Optional.
   * @returns An instantiated {@link Signer} that can be used to sign and verify data.
   */
  getSigner(params) {
    var _a;
    return __awaiter2(this, void 0, void 0, function* () {
      const verificationMethod = (_a = this.document.verificationMethod) === null || _a === void 0 ? void 0 : _a.find((vm) => {
        var _a2, _b;
        return extractDidFragment(vm.id) === ((_a2 = extractDidFragment(params === null || params === void 0 ? void 0 : params.methodId)) !== null && _a2 !== void 0 ? _a2 : extractDidFragment((_b = this.document.assertionMethod) === null || _b === void 0 ? void 0 : _b[0]));
      });
      if (!(verificationMethod && verificationMethod.publicKeyJwk)) {
        throw new DidError(DidErrorCode.InternalError, "A verification method intended for signing could not be determined from the DID Document");
      }
      const keyUri = yield this.keyManager.getKeyUri({ key: verificationMethod.publicKeyJwk });
      const publicKey = yield this.keyManager.getPublicKey({ keyUri });
      const keyManager = this.keyManager;
      const algorithm = _BearerDid.getAlgorithmFromPublicKey(publicKey);
      return {
        algorithm,
        keyId: verificationMethod.id,
        sign({ data }) {
          return __awaiter2(this, void 0, void 0, function* () {
            const signature = yield keyManager.sign({ data, keyUri });
            return signature;
          });
        },
        verify({ data, signature }) {
          return __awaiter2(this, void 0, void 0, function* () {
            const isValid2 = yield keyManager.verify({ data, key: publicKey, signature });
            return isValid2;
          });
        }
      };
    });
  }
  /**
   * Instantiates a {@link BearerDid} object for the DID DHT method from a given {@link PortableDid}.
   *
   * This method allows for the creation of a `BearerDid` object using a previously created DID's
   * key material, DID document, and metadata.
   *
   * @example
   * ```ts
   * // Export an existing BearerDid to PortableDid format.
   * const portableDid = await did.export();
   * // Reconstruct a BearerDid object from the PortableDid.
   * const did = await DidDht.import({ portableDid });
   * ```
   *
   * @param params - The parameters for the import operation.
   * @param params.portableDid - The PortableDid object to import.
   * @param params.keyManager - Optionally specify an external Key Management System (KMS) used to
   *                            generate keys and sign data. If not given, a new
   *                            {@link LocalKeyManager} instance will be created and
   *                            used.
   * @returns A Promise resolving to a `BearerDid` object representing the DID formed from the
   *          provided PortableDid.
   * @throws An error if the PortableDid document does not contain any verification methods or the
   *         keys for any verification method are missing in the key manager.
   */
  static import({ portableDid, keyManager = new LocalKeyManager() }) {
    var _a;
    return __awaiter2(this, void 0, void 0, function* () {
      const verificationMethods = getVerificationMethods({ didDocument: portableDid.document });
      if (verificationMethods.length === 0) {
        throw new DidError(DidErrorCode.InvalidDidDocument, `At least one verification method is required but 0 were given`);
      }
      for (let key of (_a = portableDid.privateKeys) !== null && _a !== void 0 ? _a : []) {
        yield keyManager.importKey({ key });
      }
      for (let vm of verificationMethods) {
        if (!vm.publicKeyJwk) {
          throw new Error(`Verification method '${vm.id}' does not contain a public key in JWK format`);
        }
        const keyUri = yield keyManager.getKeyUri({ key: vm.publicKeyJwk });
        yield keyManager.getPublicKey({ keyUri });
      }
      const did = new _BearerDid({
        uri: portableDid.uri,
        document: portableDid.document,
        metadata: portableDid.metadata,
        keyManager
      });
      return did;
    });
  }
  /**
   * Determines the name of the algorithm based on the key's curve property.
   *
   * @remarks
   * This method facilitates the identification of the correct algorithm for cryptographic
   * operations based on the `alg` or `crv` properties of a {@link Jwk | JWK}.
   *
   * @example
   * ```ts
   * const publicKey = { ... }; // Public key in JWK format
   * const algorithm = BearerDid.getAlgorithmFromPublicKey({ key: publicKey });
   * ```
   *
   * @param publicKey - A JWK containing the `alg` and/or `crv` properties.
   *
   * @returns The name of the algorithm associated with the key.
   *
   * @throws Error if the algorithm cannot be determined from the provided input.
   */
  static getAlgorithmFromPublicKey(publicKey) {
    const registeredSigningAlgorithms = {
      "Ed25519": "EdDSA",
      "P-256": "ES256",
      "P-384": "ES384",
      "P-521": "ES512",
      "secp256k1": "ES256K"
    };
    if (publicKey.alg) {
      return publicKey.alg;
    }
    if (publicKey.crv && Object.keys(registeredSigningAlgorithms).includes(publicKey.crv)) {
      return registeredSigningAlgorithms[publicKey.crv];
    }
    throw new Error(`Unable to determine algorithm based on provided input: alg=${publicKey.alg}, crv=${publicKey.crv}`);
  }
};

// node_modules/@web5/credentials/node_modules/@web5/dids/dist/esm/methods/did-dht.js
var import_dist9 = __toESM(require_dist(), 1);

// node_modules/@web5/credentials/node_modules/@web5/dids/dist/esm/methods/did-method.js
var import_dist6 = __toESM(require_dist(), 1);
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DidMethod = class {
  /**
   * MUST be implemented by all DID method implementations that extend {@link DidMethod}.
   *
   * Given the W3C DID Document of a DID, return the verification method that will be used for
   * signing messages and credentials. If given, the `methodId` parameter is used to select the
   * verification method. If not given, each DID method implementation will select a default
   * verification method from the DID Document.
   *
   * @param _params - The parameters for the `getSigningMethod` operation.
   * @param _params.didDocument - DID Document to get the verification method from.
   * @param _params.methodId - ID of the verification method to use for signing.
   * @returns Verification method to use for signing.
   */
  static getSigningMethod(_params) {
    return __awaiter3(this, void 0, void 0, function* () {
      throw new Error(`Not implemented: Classes extending DidMethod must implement getSigningMethod()`);
    });
  }
  /**
   * MUST be implemented by all DID method implementations that extend {@link DidMethod}.
   *
   * Resolves a DID URI to a DID Document.
   *
   * @param _didUri - The DID to be resolved.
   * @param _options - Optional parameters for resolving the DID.
   * @returns A Promise resolving to a {@link DidResolutionResult} object representing the result of the resolution.
   */
  static resolve(_didUri, _options) {
    return __awaiter3(this, void 0, void 0, function* () {
      throw new Error(`Not implemented: Classes extending DidMethod must implement resolve()`);
    });
  }
};

// node_modules/@web5/credentials/node_modules/@web5/dids/dist/esm/resolver/did-resolver.js
var import_dist8 = __toESM(require_dist(), 1);

// node_modules/@web5/credentials/node_modules/@web5/dids/dist/esm/resolver/resolver-cache-noop.js
var import_dist7 = __toESM(require_dist(), 1);
var DidResolverCacheNoop = {
  get: function(_key) {
    return null;
  },
  set: function(_key, _value) {
    return null;
  },
  delete: function(_key) {
    return null;
  },
  clear: function() {
    return null;
  },
  close: function() {
    return null;
  }
};

// node_modules/@web5/credentials/node_modules/@web5/dids/dist/esm/resolver/did-resolver.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var EMPTY_DID_RESOLUTION_RESULT = {
  "@context": "https://w3id.org/did-resolution/v1",
  didResolutionMetadata: {},
  didDocument: null,
  didDocumentMetadata: {}
};
var DidResolver = class {
  /**
   * Constructs a new `DidResolver`.
   *
   * @param params - The parameters for constructing the `DidResolver`.
   */
  constructor({ cache, didResolvers }) {
    this.didResolvers = /* @__PURE__ */ new Map();
    this.cache = cache || DidResolverCacheNoop;
    for (const resolver of didResolvers) {
      this.didResolvers.set(resolver.methodName, resolver);
    }
  }
  /**
   * Resolves a DID to a DID Resolution Result.
   *
   * If the DID Resolution Result is present in the cache, it returns the cached result. Otherwise,
   * it uses the appropriate method resolver to resolve the DID, stores the resolution result in the
   * cache, and returns the resolultion result.
   *
   * @param didUri - The DID or DID URL to resolve.
   * @returns A promise that resolves to the DID Resolution Result.
   */
  resolve(didUri, options) {
    return __awaiter4(this, void 0, void 0, function* () {
      const parsedDid = Did.parse(didUri);
      if (!parsedDid) {
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didResolutionMetadata: {
          error: DidErrorCode.InvalidDid,
          errorMessage: `Invalid DID URI: ${didUri}`
        } });
      }
      const resolver = this.didResolvers.get(parsedDid.method);
      if (!resolver) {
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didResolutionMetadata: {
          error: DidErrorCode.MethodNotSupported,
          errorMessage: `Method not supported: ${parsedDid.method}`
        } });
      }
      const cachedResolutionResult = yield this.cache.get(parsedDid.uri);
      if (cachedResolutionResult) {
        return cachedResolutionResult;
      } else {
        const resolutionResult = yield resolver.resolve(parsedDid.uri, options);
        yield this.cache.set(parsedDid.uri, resolutionResult);
        return resolutionResult;
      }
    });
  }
  /**
   * Dereferences a DID (Decentralized Identifier) URL to a corresponding DID resource.
   *
   *
   * This method interprets the DID URL's components, which include the DID method, method-specific
   * identifier, path, query, and fragment, and retrieves the related resource as per the DID Core
   * specifications.
   *
   * The dereferencing process involves resolving the DID contained in the DID URL to a DID document,
   * and then extracting the specific part of the document identified by the fragment in the DID URL.
   * If no fragment is specified, the entire DID document is returned.
   *
   * This method supports resolution of different components within a DID document such as service
   * endpoints and verification methods, based on their IDs. It accommodates both full and
   * DID URLs as specified in the DID Core specification.
   *
   * More information on DID URL dereferencing can be found in the
   * {@link https://www.w3.org/TR/did-core/#did-url-dereferencing | DID Core specification}.
   *
   * TODO: This is a partial implementation and does not fully implement DID URL dereferencing. (https://github.com/TBD54566975/web5-js/issues/387)
   *
   * @param didUrl - The DID URL string to dereference.
   * @param [_options] - Input options to the dereference function. Optional.
   * @returns a {@link DidDereferencingResult}
   */
  dereference(didUrl, _options) {
    return __awaiter4(this, void 0, void 0, function* () {
      const parsedDidUrl = Did.parse(didUrl);
      if (!parsedDidUrl) {
        return {
          dereferencingMetadata: { error: DidErrorCode.InvalidDidUrl },
          contentStream: null,
          contentMetadata: {}
        };
      }
      const { didDocument, didResolutionMetadata, didDocumentMetadata } = yield this.resolve(parsedDidUrl.uri);
      if (!didDocument) {
        return {
          dereferencingMetadata: { error: didResolutionMetadata.error },
          contentStream: null,
          contentMetadata: {}
        };
      }
      if (!parsedDidUrl.fragment || parsedDidUrl.query) {
        return {
          dereferencingMetadata: { contentType: "application/did+json" },
          contentStream: didDocument,
          contentMetadata: didDocumentMetadata
        };
      }
      const { service = [], verificationMethod = [] } = didDocument;
      const idSet = /* @__PURE__ */ new Set([didUrl, parsedDidUrl.fragment, `#${parsedDidUrl.fragment}`]);
      let didResource;
      for (let vm of verificationMethod) {
        if (idSet.has(vm.id)) {
          didResource = vm;
          break;
        }
      }
      for (let svc of service) {
        if (idSet.has(svc.id)) {
          didResource = svc;
          break;
        }
      }
      if (didResource) {
        return {
          dereferencingMetadata: { contentType: "application/did+json" },
          contentStream: didResource,
          contentMetadata: didResolutionMetadata
        };
      } else {
        return {
          dereferencingMetadata: { error: DidErrorCode.NotFound },
          contentStream: null,
          contentMetadata: {}
        };
      }
    });
  }
};

// node_modules/@web5/credentials/node_modules/@web5/dids/dist/esm/methods/did-dht.js
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var DEFAULT_GATEWAY_URI = "https://diddht.tbddev.org";
var DID_DHT_SPECIFICATION_VERSION = 0;
var DNS_RECORD_TTL = 7200;
var PROPERTY_SEPARATOR = ";";
var VALUE_SEPARATOR = ",";
var DidDhtRegisteredDidType;
(function(DidDhtRegisteredDidType2) {
  DidDhtRegisteredDidType2[DidDhtRegisteredDidType2["Discoverable"] = 0] = "Discoverable";
  DidDhtRegisteredDidType2[DidDhtRegisteredDidType2["Organization"] = 1] = "Organization";
  DidDhtRegisteredDidType2[DidDhtRegisteredDidType2["Government"] = 2] = "Government";
  DidDhtRegisteredDidType2[DidDhtRegisteredDidType2["Corporation"] = 3] = "Corporation";
  DidDhtRegisteredDidType2[DidDhtRegisteredDidType2["LocalBusiness"] = 4] = "LocalBusiness";
  DidDhtRegisteredDidType2[DidDhtRegisteredDidType2["SoftwarePackage"] = 5] = "SoftwarePackage";
  DidDhtRegisteredDidType2[DidDhtRegisteredDidType2["WebApp"] = 6] = "WebApp";
  DidDhtRegisteredDidType2[DidDhtRegisteredDidType2["FinancialInstitution"] = 7] = "FinancialInstitution";
})(DidDhtRegisteredDidType || (DidDhtRegisteredDidType = {}));
var DidDhtRegisteredKeyType;
(function(DidDhtRegisteredKeyType2) {
  DidDhtRegisteredKeyType2[DidDhtRegisteredKeyType2["Ed25519"] = 0] = "Ed25519";
  DidDhtRegisteredKeyType2[DidDhtRegisteredKeyType2["secp256k1"] = 1] = "secp256k1";
  DidDhtRegisteredKeyType2[DidDhtRegisteredKeyType2["secp256r1"] = 2] = "secp256r1";
})(DidDhtRegisteredKeyType || (DidDhtRegisteredKeyType = {}));
var DidDhtVerificationRelationship;
(function(DidDhtVerificationRelationship2) {
  DidDhtVerificationRelationship2["authentication"] = "auth";
  DidDhtVerificationRelationship2["assertionMethod"] = "asm";
  DidDhtVerificationRelationship2["capabilityDelegation"] = "del";
  DidDhtVerificationRelationship2["capabilityInvocation"] = "inv";
  DidDhtVerificationRelationship2["keyAgreement"] = "agm";
})(DidDhtVerificationRelationship || (DidDhtVerificationRelationship = {}));
var AlgorithmToKeyTypeMap = {
  Ed25519: DidDhtRegisteredKeyType.Ed25519,
  ES256K: DidDhtRegisteredKeyType.secp256k1,
  ES256: DidDhtRegisteredKeyType.secp256r1,
  "P-256": DidDhtRegisteredKeyType.secp256r1,
  secp256k1: DidDhtRegisteredKeyType.secp256k1,
  secp256r1: DidDhtRegisteredKeyType.secp256r1
};
var DidDht = class _DidDht extends DidMethod {
  /**
   * Creates a new DID using the `did:dht` method formed from a newly generated key.
   *
   * @remarks
   * The DID URI is formed by z-base-32 encoding the Identity Key public key and prefixing with
   * `did:dht:`.
   *
   * Notes:
   * - If no `options` are given, by default a new Ed25519 key will be generated which serves as the
   *   Identity Key.
   *
   * @example
   * ```ts
   * // DID Creation
   * const did = await DidDht.create();
   *
   * // DID Creation with a KMS
   * const keyManager = new LocalKeyManager();
   * const did = await DidDht.create({ keyManager });
   * ```
   *
   * @param params - The parameters for the create operation.
   * @param params.keyManager - Optionally specify a Key Management System (KMS) used to generate
   *                            keys and sign data.
   * @param params.options - Optional parameters that can be specified when creating a new DID.
   * @returns A Promise resolving to a {@link BearerDid} object representing the new DID.
   */
  static create({ keyManager = new LocalKeyManager(), options = {} } = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    return __awaiter5(this, void 0, void 0, function* () {
      if ((_a = options.verificationMethods) === null || _a === void 0 ? void 0 : _a.some((vm) => !(vm.algorithm in AlgorithmToKeyTypeMap))) {
        throw new Error("One or more verification method algorithms are not supported");
      }
      const methodIds = (_b = options.verificationMethods) === null || _b === void 0 ? void 0 : _b.filter((vm) => "id" in vm).map((vm) => vm.id);
      if (methodIds && methodIds.length !== new Set(methodIds).size) {
        throw new Error("One or more verification method IDs are not unique");
      }
      if ((_c = options.services) === null || _c === void 0 ? void 0 : _c.some((s) => !s.id || !s.type || !s.serviceEndpoint)) {
        throw new Error("One or more services are missing required properties");
      }
      const identityKeyUri = yield keyManager.generateKey({ algorithm: "Ed25519" });
      const identityKey = yield keyManager.getPublicKey({ keyUri: identityKeyUri });
      const didUri = yield DidDhtUtils.identityKeyToIdentifier({ identityKey });
      const document = Object.assign(Object.assign({ id: didUri }, options.alsoKnownAs && { alsoKnownAs: options.alsoKnownAs }), options.controllers && { controller: options.controllers });
      const verificationMethodsToAdd = [...(_d = options.verificationMethods) !== null && _d !== void 0 ? _d : []];
      if (!(verificationMethodsToAdd === null || verificationMethodsToAdd === void 0 ? void 0 : verificationMethodsToAdd.some((vm) => {
        var _a2;
        return ((_a2 = vm.id) === null || _a2 === void 0 ? void 0 : _a2.split("#").pop()) === "0";
      }))) {
        verificationMethodsToAdd.unshift({
          algorithm: "Ed25519",
          id: "0",
          purposes: ["authentication", "assertionMethod", "capabilityDelegation", "capabilityInvocation"]
        });
      }
      for (const vm of verificationMethodsToAdd) {
        const keyUri = vm.id && vm.id.split("#").pop() === "0" ? identityKeyUri : yield keyManager.generateKey({ algorithm: vm.algorithm });
        const publicKey = yield keyManager.getPublicKey({ keyUri });
        let methodId = (_f = (_e = vm.id) !== null && _e !== void 0 ? _e : publicKey.kid) !== null && _f !== void 0 ? _f : yield computeJwkThumbprint({ jwk: publicKey });
        methodId = `${didUri}#${extractDidFragment(methodId)}`;
        (_g = document.verificationMethod) !== null && _g !== void 0 ? _g : document.verificationMethod = [];
        document.verificationMethod.push({
          id: methodId,
          type: "JsonWebKey",
          controller: (_h = vm.controller) !== null && _h !== void 0 ? _h : didUri,
          publicKeyJwk: publicKey
        });
        for (const purpose of (_j = vm.purposes) !== null && _j !== void 0 ? _j : []) {
          if (!document[purpose])
            document[purpose] = [];
          document[purpose].push(methodId);
        }
      }
      (_k = options.services) === null || _k === void 0 ? void 0 : _k.forEach((service) => {
        var _a2;
        (_a2 = document.service) !== null && _a2 !== void 0 ? _a2 : document.service = [];
        service.id = `${didUri}#${service.id.split("#").pop()}`;
        document.service.push(service);
      });
      const did = new BearerDid({
        uri: didUri,
        document,
        metadata: Object.assign({ published: false }, options.types && { types: options.types }),
        keyManager
      });
      if ((_l = options.publish) !== null && _l !== void 0 ? _l : true) {
        const registrationResult = yield _DidDht.publish({ did, gatewayUri: options.gatewayUri });
        did.metadata = registrationResult.didDocumentMetadata;
      }
      return did;
    });
  }
  /**
   * Instantiates a {@link BearerDid} object for the DID DHT method from a given {@link PortableDid}.
   *
   * This method allows for the creation of a `BearerDid` object using a previously created DID's
   * key material, DID document, and metadata.
   *
   * @example
   * ```ts
   * // Export an existing BearerDid to PortableDid format.
   * const portableDid = await did.export();
   * // Reconstruct a BearerDid object from the PortableDid.
   * const did = await DidDht.import({ portableDid });
   * ```
   *
   * @param params - The parameters for the import operation.
   * @param params.portableDid - The PortableDid object to import.
   * @param params.keyManager - Optionally specify an external Key Management System (KMS) used to
   *                            generate keys and sign data. If not given, a new
   *                            {@link LocalKeyManager} instance will be created and
   *                            used.
   * @returns A Promise resolving to a `BearerDid` object representing the DID formed from the
   *          provided PortableDid.
   * @throws An error if the PortableDid document does not contain any verification methods, lacks
   *         an Identity Key, or the keys for any verification method are missing in the key
   *         manager.
   */
  static import({ portableDid, keyManager = new LocalKeyManager() }) {
    var _a;
    return __awaiter5(this, void 0, void 0, function* () {
      const parsedDid = Did.parse(portableDid.uri);
      if ((parsedDid === null || parsedDid === void 0 ? void 0 : parsedDid.method) !== _DidDht.methodName) {
        throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported`);
      }
      const did = yield BearerDid.import({ portableDid, keyManager });
      if (!((_a = did.document.verificationMethod) === null || _a === void 0 ? void 0 : _a.some((vm) => {
        var _a2;
        return ((_a2 = vm.id) === null || _a2 === void 0 ? void 0 : _a2.split("#").pop()) === "0";
      }))) {
        throw new DidError(DidErrorCode.InvalidDidDocument, `DID document must contain an Identity Key`);
      }
      return did;
    });
  }
  /**
   * Given the W3C DID Document of a `did:dht` DID, return the verification method that will be used
   * for signing messages and credentials. If given, the `methodId` parameter is used to select the
   * verification method. If not given, the Identity Key's verification method with an ID fragment
   * of '#0' is used.
   *
   * @param params - The parameters for the `getSigningMethod` operation.
   * @param params.didDocument - DID Document to get the verification method from.
   * @param params.methodId - ID of the verification method to use for signing.
   * @returns Verification method to use for signing.
   */
  static getSigningMethod({ didDocument, methodId = "#0" }) {
    var _a;
    return __awaiter5(this, void 0, void 0, function* () {
      const parsedDid = Did.parse(didDocument.id);
      if (parsedDid && parsedDid.method !== this.methodName) {
        throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported: ${parsedDid.method}`);
      }
      const verificationMethod = (_a = didDocument.verificationMethod) === null || _a === void 0 ? void 0 : _a.find((vm) => {
        var _a2, _b;
        return extractDidFragment(vm.id) === ((_a2 = extractDidFragment(methodId)) !== null && _a2 !== void 0 ? _a2 : extractDidFragment((_b = didDocument.assertionMethod) === null || _b === void 0 ? void 0 : _b[0]));
      });
      if (!(verificationMethod && verificationMethod.publicKeyJwk)) {
        throw new DidError(DidErrorCode.InternalError, "A verification method intended for signing could not be determined from the DID Document");
      }
      return verificationMethod;
    });
  }
  /**
   * Publishes a DID to the DHT, making it publicly discoverable and resolvable.
   *
   * This method handles the publication of a DID Document associated with a `did:dht` DID to the
   * Mainline DHT network. The publication process involves storing the DID Document in Mainline DHT
   * via a Pkarr relay server.
   *
   * @remarks
   * - This method is typically invoked automatically during the creation of a new DID unless the
   *   `publish` option is set to `false`.
   * - For existing, unpublished DIDs, it can be used to publish the DID Document to Mainline DHT.
   * - The method relies on the specified Pkarr relay server to interface with the DHT network.
   *
   * @example
   * ```ts
   * // Generate a new DID and keys but explicitly disable publishing.
   * const did = await DidDht.create({ options: { publish: false } });
   * // Publish the DID to the DHT.
   * const registrationResult = await DidDht.publish({ did });
   * // `registrationResult.didDocumentMetadata.published` is true if the DID was successfully published.
   * ```
   *
   * @param params - The parameters for the `publish` operation.
   * @param params.did - The `BearerDid` object representing the DID to be published.
   * @param params.gatewayUri - Optional. The URI of a server involved in executing DID method
   *                            operations. In the context of publishing, the endpoint is expected
   *                            to be a DID DHT Gateway or Pkarr Relay. If not specified, a default
   *                            gateway node is used.
   * @returns A promise that resolves to a {@link DidRegistrationResult} object that contains
   *          the result of registering the DID with a DID DHT Gateway or Pkarr relay.
   */
  static publish({ did, gatewayUri = DEFAULT_GATEWAY_URI }) {
    return __awaiter5(this, void 0, void 0, function* () {
      const registrationResult = yield DidDhtDocument.put({ did, gatewayUri });
      return registrationResult;
    });
  }
  /**
   * Resolves a `did:dht` identifier to its corresponding DID document.
   *
   * This method performs the resolution of a `did:dht` DID, retrieving its DID Document from the
   * Mainline DHT network. The process involves querying the DHT network via a Pkarr relay server to
   * retrieve the DID Document that corresponds to the given DID identifier.
   *
   * @remarks
   * - If a `gatewayUri` option is not specified, a default Pkarr relay is used to access the DHT
   *   network.
   * - It decodes the DID identifier and retrieves the associated DID Document and metadata.
   * - In case of resolution failure, appropriate error information is returned.
   *
   * @example
   * ```ts
   * const resolutionResult = await DidDht.resolve('did:dht:example');
   * ```
   *
   * @param didUri - The DID to be resolved.
   * @param options - Optional parameters for resolving the DID. Unused by this DID method.
   * @returns A Promise resolving to a {@link DidResolutionResult} object representing the result of
   *          the resolution.
   */
  static resolve(didUri, options = {}) {
    var _a;
    return __awaiter5(this, void 0, void 0, function* () {
      const gatewayUri = (_a = options === null || options === void 0 ? void 0 : options.gatewayUri) !== null && _a !== void 0 ? _a : DEFAULT_GATEWAY_URI;
      try {
        yield DidDhtUtils.identifierToIdentityKey({ didUri });
        const { didDocument, didDocumentMetadata } = yield DidDhtDocument.get({ didUri, gatewayUri });
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), {
          didDocument,
          didDocumentMetadata
        });
      } catch (error) {
        if (!(error instanceof DidError))
          throw new Error(error);
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didResolutionMetadata: Object.assign({ error: error.code }, error.message && { errorMessage: error.message }) });
      }
    });
  }
};
DidDht.methodName = "dht";
var DidDhtDocument = class _DidDhtDocument {
  /**
   * Retrieves a DID document and its metadata from the DHT network.
   *
   * @param params - The parameters for the get operation.
   * @param params.didUri - The DID URI containing the Identity Key.
   * @param params.gatewayUri - The DID DHT Gateway or Pkarr Relay URI.
   * @returns A Promise resolving to a {@link DidResolutionResult} object containing the DID
   *          document and its metadata.
   */
  static get({ didUri, gatewayUri }) {
    return __awaiter5(this, void 0, void 0, function* () {
      const publicKeyBytes = DidDhtUtils.identifierToIdentityKeyBytes({ didUri });
      const bep44Message = yield _DidDhtDocument.pkarrGet({ gatewayUri, publicKeyBytes });
      const dnsPacket = yield DidDhtUtils.parseBep44GetMessage({ bep44Message });
      const resolutionResult = yield _DidDhtDocument.fromDnsPacket({ didUri, dnsPacket });
      resolutionResult.didDocumentMetadata.versionId = bep44Message.seq.toString();
      return resolutionResult;
    });
  }
  /**
   * Publishes a DID document to the DHT network.
   *
   * @param params - The parameters to use when publishing the DID document to the DHT network.
   * @param params.did - The DID object whose DID document will be published.
   * @param params.gatewayUri - The DID DHT Gateway or Pkarr Relay URI.
   * @returns A promise that resolves to a {@link DidRegistrationResult} object that contains
   *          the result of registering the DID with a DID DHT Gateway or Pkarr relay.
   */
  static put({ did, gatewayUri }) {
    return __awaiter5(this, void 0, void 0, function* () {
      const dnsPacket = yield _DidDhtDocument.toDnsPacket({
        didDocument: did.document,
        didMetadata: did.metadata
      });
      const bep44Message = yield DidDhtUtils.createBep44PutMessage({
        dnsPacket,
        publicKeyBytes: DidDhtUtils.identifierToIdentityKeyBytes({ didUri: did.uri }),
        signer: yield did.getSigner({ methodId: "0" })
      });
      const putResult = yield _DidDhtDocument.pkarrPut({ gatewayUri, bep44Message });
      return {
        didDocument: did.document,
        didDocumentMetadata: Object.assign(Object.assign({}, did.metadata), { published: putResult, versionId: bep44Message.seq.toString() }),
        didRegistrationMetadata: {}
      };
    });
  }
  /**
   * Retrieves a signed BEP44 message from a DID DHT Gateway or Pkarr Relay server.
   *
   * @see {@link https://github.com/Nuhvi/pkarr/blob/main/design/relays.md | Pkarr Relay design}
   *
   * @param params
   * @param params.gatewayUri - The DID DHT Gateway or Pkarr Relay URI.
   * @param params.publicKeyBytes - The public key bytes of the Identity Key, z-base-32 encoded.
   * @returns A promise resolving to a BEP44 message containing the signed DNS packet.
  */
  static pkarrGet({ gatewayUri, publicKeyBytes }) {
    return __awaiter5(this, void 0, void 0, function* () {
      const identifier = Convert.uint8Array(publicKeyBytes).toBase32Z();
      const url = new URL(identifier, gatewayUri).href;
      let response;
      try {
        response = yield fetch(url, { method: "GET" });
        if (!response.ok) {
          throw new DidError(DidErrorCode.NotFound, `Pkarr record not found for: ${identifier}`);
        }
      } catch (error) {
        if (error instanceof DidError)
          throw error;
        throw new DidError(DidErrorCode.InternalError, `Failed to fetch Pkarr record: ${error.message}`);
      }
      const messageBytes = yield response.arrayBuffer();
      if (messageBytes.byteLength < 72) {
        throw new DidError(DidErrorCode.InvalidDidDocumentLength, `Pkarr response must be at least 72 bytes but got: ${messageBytes.byteLength}`);
      }
      if (messageBytes.byteLength > 1072) {
        throw new DidError(DidErrorCode.InvalidDidDocumentLength, `Pkarr response exceeds 1000 byte limit: ${messageBytes.byteLength}`);
      }
      const bep44Message = {
        k: publicKeyBytes,
        seq: Number(new DataView(messageBytes).getBigUint64(64)),
        sig: new Uint8Array(messageBytes, 0, 64),
        v: new Uint8Array(messageBytes, 72)
      };
      return bep44Message;
    });
  }
  /**
   * Publishes a signed BEP44 message to a DID DHT Gateway or Pkarr Relay server.
   *
   * @see {@link https://github.com/Nuhvi/pkarr/blob/main/design/relays.md | Pkarr Relay design}
   *
   * @param params - The parameters to use when publishing a signed BEP44 message to a Pkarr relay server.
   * @param params.gatewayUri - The DID DHT Gateway or Pkarr Relay URI.
   * @param params.bep44Message - The BEP44 message to be published, containing the signed DNS packet.
   * @returns A promise resolving to `true` if the message was successfully published, otherwise `false`.
   */
  static pkarrPut({ gatewayUri, bep44Message }) {
    return __awaiter5(this, void 0, void 0, function* () {
      const identifier = Convert.uint8Array(bep44Message.k).toBase32Z();
      const url = new URL(identifier, gatewayUri).href;
      const body = new Uint8Array(bep44Message.v.length + 72);
      body.set(bep44Message.sig, 0);
      new DataView(body.buffer).setBigUint64(bep44Message.sig.length, BigInt(bep44Message.seq));
      body.set(bep44Message.v, bep44Message.sig.length + 8);
      let response;
      try {
        response = yield fetch(url, {
          method: "PUT",
          headers: { "Content-Type": "application/octet-stream" },
          body
        });
      } catch (error) {
        throw new DidError(DidErrorCode.InternalError, `Failed to put Pkarr record: ${error.message}`);
      }
      return response.ok;
    });
  }
  /**
   * Converts a DNS packet to a DID document according to the DID DHT specification.
   *
   * @see {@link https://did-dht.com/#dids-as-dns-records | DID DHT Specification,  DIDs as DNS Records}
   *
   * @param params - The parameters to use when converting a DNS packet to a DID document.
   * @param params.didUri - The DID URI of the DID document.
   * @param params.dnsPacket - The DNS packet to convert to a DID document.
   * @returns A Promise resolving to a {@link DidResolutionResult} object containing the DID
   *          document and its metadata.
   */
  static fromDnsPacket({ didUri, dnsPacket }) {
    var _a, _b, _c;
    return __awaiter5(this, void 0, void 0, function* () {
      const didDocument = { id: didUri };
      const didDocumentMetadata = {
        published: true
      };
      const idLookup = /* @__PURE__ */ new Map();
      for (const answer of (_a = dnsPacket === null || dnsPacket === void 0 ? void 0 : dnsPacket.answers) !== null && _a !== void 0 ? _a : []) {
        if (answer.type !== "TXT")
          continue;
        const dnsRecordId = answer.name.split(".")[0].substring(1);
        switch (true) {
          case dnsRecordId.startsWith("aka"): {
            const data = DidDhtUtils.parseTxtDataToString(answer.data);
            didDocument.alsoKnownAs = data.split(VALUE_SEPARATOR);
            break;
          }
          case dnsRecordId.startsWith("cnt"): {
            const data = DidDhtUtils.parseTxtDataToString(answer.data);
            didDocument.controller = data.includes(VALUE_SEPARATOR) ? data.split(VALUE_SEPARATOR) : data;
            break;
          }
          case dnsRecordId.startsWith("k"): {
            const { id, t, k, c } = DidDhtUtils.parseTxtDataToObject(answer.data);
            const publicKeyBytes = Convert.base64Url(k).toUint8Array();
            const namedCurve = DidDhtRegisteredKeyType[Number(t)];
            let publicKey = yield DidDhtUtils.keyConverter(namedCurve).bytesToPublicKey({ publicKeyBytes });
            (_b = didDocument.verificationMethod) !== null && _b !== void 0 ? _b : didDocument.verificationMethod = [];
            const methodId = `${didUri}#${id}`;
            didDocument.verificationMethod.push({
              id: methodId,
              type: "JsonWebKey",
              controller: c !== null && c !== void 0 ? c : didUri,
              publicKeyJwk: publicKey
            });
            idLookup.set(dnsRecordId, methodId);
            break;
          }
          case dnsRecordId.startsWith("s"): {
            const _d = DidDhtUtils.parseTxtDataToObject(answer.data), { id, t, se } = _d, customProperties = __rest(_d, ["id", "t", "se"]);
            const serviceEndpoint = se.includes(VALUE_SEPARATOR) ? se.split(VALUE_SEPARATOR) : se;
            (_c = didDocument.service) !== null && _c !== void 0 ? _c : didDocument.service = [];
            didDocument.service.push(Object.assign(Object.assign({}, customProperties), { id: `${didUri}#${id}`, type: t, serviceEndpoint }));
            break;
          }
          case dnsRecordId.startsWith("typ"): {
            const { id: types } = DidDhtUtils.parseTxtDataToObject(answer.data);
            didDocumentMetadata.types = types.split(VALUE_SEPARATOR).map((typeInteger) => Number(typeInteger));
            break;
          }
          case dnsRecordId.startsWith("did"): {
            const recordIdsToMethodIds = (data) => data.split(VALUE_SEPARATOR).map((dnsRecordId2) => idLookup.get(dnsRecordId2)).filter((id) => typeof id === "string");
            const { auth, asm, del, inv, agm } = DidDhtUtils.parseTxtDataToObject(answer.data);
            if (auth)
              didDocument.authentication = recordIdsToMethodIds(auth);
            if (asm)
              didDocument.assertionMethod = recordIdsToMethodIds(asm);
            if (del)
              didDocument.capabilityDelegation = recordIdsToMethodIds(del);
            if (inv)
              didDocument.capabilityInvocation = recordIdsToMethodIds(inv);
            if (agm)
              didDocument.keyAgreement = recordIdsToMethodIds(agm);
            break;
          }
        }
      }
      return { didDocument, didDocumentMetadata, didResolutionMetadata: {} };
    });
  }
  /**
   * Converts a DID document to a DNS packet according to the DID DHT specification.
   *
   * @see {@link https://did-dht.com/#dids-as-dns-records | DID DHT Specification,  DIDs as DNS Records}
   *
   * @param params - The parameters to use when converting a DID document to a DNS packet.
   * @param params.didDocument - The DID document to convert to a DNS packet.
   * @param params.didMetadata - The DID metadata to include in the DNS packet.
   * @returns A promise that resolves to a DNS packet.
   */
  static toDnsPacket({ didDocument, didMetadata }) {
    var _a, _b, _c, _d, _e;
    return __awaiter5(this, void 0, void 0, function* () {
      const dnsAnswerRecords = [];
      const idLookup = /* @__PURE__ */ new Map();
      const serviceIds = [];
      const verificationMethodIds = [];
      if (didDocument.alsoKnownAs) {
        dnsAnswerRecords.push({
          type: "TXT",
          name: "_aka.did.",
          ttl: DNS_RECORD_TTL,
          data: didDocument.alsoKnownAs.join(VALUE_SEPARATOR)
        });
      }
      if (didDocument.controller) {
        const controller = Array.isArray(didDocument.controller) ? didDocument.controller.join(VALUE_SEPARATOR) : didDocument.controller;
        dnsAnswerRecords.push({
          type: "TXT",
          name: "_cnt.did.",
          ttl: DNS_RECORD_TTL,
          data: controller
        });
      }
      for (const [index, vm] of (_b = (_a = didDocument.verificationMethod) === null || _a === void 0 ? void 0 : _a.entries()) !== null && _b !== void 0 ? _b : []) {
        const dnsRecordId = `k${index}`;
        verificationMethodIds.push(dnsRecordId);
        let methodId = vm.id.split("#").pop();
        idLookup.set(methodId, dnsRecordId);
        const publicKey = vm.publicKeyJwk;
        if (!((publicKey === null || publicKey === void 0 ? void 0 : publicKey.crv) && publicKey.crv in AlgorithmToKeyTypeMap)) {
          throw new DidError(DidErrorCode.InvalidPublicKeyType, `Verification method '${vm.id}' contains an unsupported key type: ${(_c = publicKey === null || publicKey === void 0 ? void 0 : publicKey.crv) !== null && _c !== void 0 ? _c : "undefined"}`);
        }
        const keyType = DidDhtRegisteredKeyType[publicKey.crv];
        const publicKeyBytes = yield DidDhtUtils.keyConverter(publicKey.crv).publicKeyToBytes({ publicKey });
        const publicKeyBase64Url = Convert.uint8Array(publicKeyBytes).toBase64Url();
        const txtData = [`id=${methodId}`, `t=${keyType}`, `k=${publicKeyBase64Url}`];
        if (vm.controller !== didDocument.id)
          txtData.push(`c=${vm.controller}`);
        dnsAnswerRecords.push({
          type: "TXT",
          name: `_${dnsRecordId}._did.`,
          ttl: DNS_RECORD_TTL,
          data: txtData.join(PROPERTY_SEPARATOR)
        });
      }
      (_d = didDocument.service) === null || _d === void 0 ? void 0 : _d.forEach((service, index) => {
        const dnsRecordId = `s${index}`;
        serviceIds.push(dnsRecordId);
        const serviceId = service.id.split("#").pop();
        const serviceEndpoint = Array.isArray(service.serviceEndpoint) ? service.serviceEndpoint.join(",") : service.serviceEndpoint;
        const txtData = [`id=${serviceId}`, `t=${service.type}`, `se=${serviceEndpoint}`];
        dnsAnswerRecords.push({
          type: "TXT",
          name: `_${dnsRecordId}._did.`,
          ttl: DNS_RECORD_TTL,
          data: txtData.join(PROPERTY_SEPARATOR)
        });
      });
      const rootRecord = [`v=${DID_DHT_SPECIFICATION_VERSION}`];
      if (verificationMethodIds.length) {
        rootRecord.push(`vm=${verificationMethodIds.join(VALUE_SEPARATOR)}`);
      }
      Object.keys(DidVerificationRelationship).forEach((relationship) => {
        var _a2;
        const dnsRecordIds = (_a2 = didDocument[relationship]) === null || _a2 === void 0 ? void 0 : _a2.map((id) => idLookup.get(id.split("#").pop()));
        if (dnsRecordIds) {
          const recordName = DidDhtVerificationRelationship[relationship];
          rootRecord.push(`${recordName}=${dnsRecordIds.join(VALUE_SEPARATOR)}`);
        }
      });
      if (serviceIds.length) {
        rootRecord.push(`svc=${serviceIds.join(VALUE_SEPARATOR)}`);
      }
      if ((_e = didMetadata.types) === null || _e === void 0 ? void 0 : _e.length) {
        const types = didMetadata.types;
        const typeIntegers = types.map((type) => typeof type === "string" ? DidDhtRegisteredDidType[type] : type);
        dnsAnswerRecords.push({
          type: "TXT",
          name: "_typ._did.",
          ttl: DNS_RECORD_TTL,
          data: `id=${typeIntegers.join(VALUE_SEPARATOR)}`
        });
      }
      dnsAnswerRecords.push({
        type: "TXT",
        name: "_did.",
        ttl: DNS_RECORD_TTL,
        data: rootRecord.join(PROPERTY_SEPARATOR)
      });
      const [, , identifier] = didDocument.id.split(":");
      dnsAnswerRecords.forEach((record) => record.name += identifier);
      const dnsPacket = {
        id: 0,
        type: "response",
        flags: AUTHORITATIVE_ANSWER,
        answers: dnsAnswerRecords
      };
      return dnsPacket;
    });
  }
};
var DidDhtUtils = class _DidDhtUtils {
  /**
   * Creates a BEP44 put message, which is used to publish a DID document to the DHT network.
   *
   * @param params - The parameters to use when creating the BEP44 put message
   * @param params.dnsPacket - The DNS packet to encode in the BEP44 message.
   * @param params.publicKeyBytes - The public key bytes of the Identity Key.
   * @param params.signer - Signer that can sign and verify data using the Identity Key.
   * @returns A promise that resolves to a BEP44 put message.
   */
  static createBep44PutMessage({ dnsPacket, publicKeyBytes, signer }) {
    return __awaiter5(this, void 0, void 0, function* () {
      const sequenceNumber = Math.ceil(Date.now() / 1e3);
      const encodedDnsPacket = encode(dnsPacket);
      const bencodedData = bencode_default.encode({ seq: sequenceNumber, v: encodedDnsPacket }).subarray(1, -1);
      if (bencodedData.length > 1e3) {
        throw new DidError(DidErrorCode.InvalidDidDocumentLength, `DNS packet exceeds the 1000 byte maximum size: ${bencodedData.length} bytes`);
      }
      const signature = yield signer.sign({ data: bencodedData });
      return { k: publicKeyBytes, seq: sequenceNumber, sig: signature, v: encodedDnsPacket };
    });
  }
  /**
   * Converts a DID URI to a JSON Web Key (JWK) representing the Identity Key.
   *
   * @param params - The parameters to use for the conversion.
   * @param params.didUri - The DID URI containing the Identity Key.
   * @returns A promise that resolves to a JWK representing the Identity Key.
   */
  static identifierToIdentityKey({ didUri }) {
    return __awaiter5(this, void 0, void 0, function* () {
      let identityKeyBytes = _DidDhtUtils.identifierToIdentityKeyBytes({ didUri });
      const identityKey = yield Ed25519.bytesToPublicKey({ publicKeyBytes: identityKeyBytes });
      return identityKey;
    });
  }
  /**
   * Converts a DID URI to the byte array representation of the Identity Key.
   *
   * @param params - The parameters to use for the conversion.
   * @param params.didUri - The DID URI containing the Identity Key.
   * @returns A byte array representation of the Identity Key.
   */
  static identifierToIdentityKeyBytes({ didUri }) {
    const parsedDid = Did.parse(didUri);
    if (!parsedDid) {
      throw new DidError(DidErrorCode.InvalidDid, `Invalid DID URI: ${didUri}`);
    }
    if (parsedDid.method !== DidDht.methodName) {
      throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported: ${parsedDid.method}`);
    }
    let identityKeyBytes;
    try {
      identityKeyBytes = Convert.base32Z(parsedDid.id).toUint8Array();
    } catch (_a) {
      throw new DidError(DidErrorCode.InvalidPublicKey, `Failed to decode method-specific identifier`);
    }
    if (identityKeyBytes.length !== 32) {
      throw new DidError(DidErrorCode.InvalidPublicKeyLength, `Invalid public key length: ${identityKeyBytes.length}`);
    }
    return identityKeyBytes;
  }
  /**
   * Encodes a DID DHT Identity Key into a DID identifier.
   *
   * This method first z-base-32 encodes the Identity Key. The resulting string is prefixed with
   * `did:dht:` to form the DID identifier.
   *
   * @param params - The parameters to use for the conversion.
   * @param params.identityKey The Identity Key from which the DID identifier is computed.
   * @returns A promise that resolves to a string containing the DID identifier.
   */
  static identityKeyToIdentifier({ identityKey }) {
    return __awaiter5(this, void 0, void 0, function* () {
      const publicKeyBytes = yield Ed25519.publicKeyToBytes({ publicKey: identityKey });
      const identifier = Convert.uint8Array(publicKeyBytes).toBase32Z();
      return `did:${DidDht.methodName}:${identifier}`;
    });
  }
  /**
   * Returns the appropriate key converter for the specified cryptographic curve.
   *
   * @param curve - The cryptographic curve to use for the key conversion.
   * @returns An `AsymmetricKeyConverter` for the specified curve.
   */
  static keyConverter(curve) {
    const converters = {
      "Ed25519": Ed25519,
      "P-256": Secp256r1,
      "secp256k1": Secp256k1
    };
    const converter = converters[curve];
    if (!converter)
      throw new DidError(DidErrorCode.InvalidPublicKeyType, `Unsupported curve: ${curve}`);
    return converter;
  }
  /**
   * Parses and verifies a BEP44 Get message, converting it to a DNS packet.
   *
   * @param params - The parameters to use when verifying and parsing the BEP44 Get response message.
   * @param params.bep44Message - The BEP44 message to verify and parse.
   * @returns A promise that resolves to a DNS packet.
   */
  static parseBep44GetMessage({ bep44Message }) {
    return __awaiter5(this, void 0, void 0, function* () {
      const publicKey = yield Ed25519.bytesToPublicKey({ publicKeyBytes: bep44Message.k });
      const bencodedData = bencode_default.encode({ seq: bep44Message.seq, v: bep44Message.v }).subarray(1, -1);
      const isValid2 = yield Ed25519.verify({
        key: publicKey,
        signature: bep44Message.sig,
        data: bencodedData
      });
      if (!isValid2) {
        throw new DidError(DidErrorCode.InvalidSignature, `Invalid signature for DHT BEP44 message`);
      }
      return decode(bep44Message.v);
    });
  }
  /**
   * Decodes and parses the data value of a DNS TXT record into a key-value object.
   *
   * @param txtData - The data value of a DNS TXT record.
   * @returns An object containing the key/value pairs of the TXT record data.
   */
  static parseTxtDataToObject(txtData) {
    return this.parseTxtDataToString(txtData).split(PROPERTY_SEPARATOR).reduce((acc, pair) => {
      const [key, value] = pair.split("=");
      acc[key] = value;
      return acc;
    }, {});
  }
  /**
   * Decodes and parses the data value of a DNS TXT record into a string.
   *
   * @param txtData - The data value of a DNS TXT record.
   * @returns A string representation of the TXT record data.
   */
  static parseTxtDataToString(txtData) {
    if (typeof txtData === "string") {
      return txtData;
    } else if (txtData instanceof Uint8Array) {
      return Convert.uint8Array(txtData).toString();
    } else if (Array.isArray(txtData)) {
      return txtData.map((item) => this.parseTxtDataToString(item)).join("");
    } else {
      throw new DidError(DidErrorCode.InternalError, "Pkarr returned DNS TXT record with invalid data type");
    }
  }
};

// node_modules/@web5/credentials/node_modules/@web5/dids/dist/esm/methods/did-ion.js
var import_dist10 = __toESM(require_dist(), 1);
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DidIonRegisteredKeyType;
(function(DidIonRegisteredKeyType2) {
  DidIonRegisteredKeyType2["Ed25519"] = "Ed25519";
  DidIonRegisteredKeyType2["secp256k1"] = "secp256k1";
  DidIonRegisteredKeyType2["secp256r1"] = "secp256r1";
  DidIonRegisteredKeyType2["X25519"] = "X25519";
})(DidIonRegisteredKeyType || (DidIonRegisteredKeyType = {}));
var AlgorithmToKeyTypeMap2 = {
  Ed25519: DidIonRegisteredKeyType.Ed25519,
  ES256K: DidIonRegisteredKeyType.secp256k1,
  ES256: DidIonRegisteredKeyType.secp256r1,
  "P-256": DidIonRegisteredKeyType.secp256r1,
  secp256k1: DidIonRegisteredKeyType.secp256k1,
  secp256r1: DidIonRegisteredKeyType.secp256r1
};
var DEFAULT_GATEWAY_URI2 = "https://ion.tbd.engineering";
var DidIon = class _DidIon extends DidMethod {
  /**
   * Creates a new DID using the `did:ion` method formed from a newly generated key.
   *
   * Notes:
   * - If no `options` are given, by default a new Ed25519 key will be generated.
   *
   * @example
   * ```ts
   * // DID Creation
   * const did = await DidIon.create();
   *
   * // DID Creation with a KMS
   * const keyManager = new LocalKeyManager();
   * const did = await DidIon.create({ keyManager });
   * ```
   *
   * @param params - The parameters for the create operation.
   * @param params.keyManager - Optionally specify a Key Management System (KMS) used to generate
   *                            keys and sign data.
   * @param params.options - Optional parameters that can be specified when creating a new DID.
   * @returns A Promise resolving to a {@link BearerDid} object representing the new DID.
   */
  static create({ keyManager = new LocalKeyManager(), options = {} } = {}) {
    var _a, _b, _c, _d, _e, _f, _g;
    return __awaiter6(this, void 0, void 0, function* () {
      if ((_a = options.verificationMethods) === null || _a === void 0 ? void 0 : _a.some((vm) => !(vm.algorithm in AlgorithmToKeyTypeMap2))) {
        throw new Error("One or more verification method algorithms are not supported");
      }
      const methodIds = (_b = options.verificationMethods) === null || _b === void 0 ? void 0 : _b.filter((vm) => "id" in vm).map((vm) => vm.id);
      if (methodIds && methodIds.length !== new Set(methodIds).size) {
        throw new Error("One or more verification method IDs are not unique");
      }
      if ((_c = options.services) === null || _c === void 0 ? void 0 : _c.some((s) => !s.id || !s.type || !s.serviceEndpoint)) {
        throw new Error("One or more services are missing required properties");
      }
      const defaultVerificationMethod = {
        algorithm: "Ed25519",
        purposes: ["authentication", "assertionMethod", "capabilityDelegation", "capabilityInvocation"]
      };
      const verificationMethodsToAdd = [];
      for (const vm of (_d = options.verificationMethods) !== null && _d !== void 0 ? _d : [defaultVerificationMethod]) {
        const keyUri = yield keyManager.generateKey({ algorithm: vm.algorithm });
        const publicKey = yield keyManager.getPublicKey({ keyUri });
        verificationMethodsToAdd.push({
          id: vm.id,
          publicKeyJwk: publicKey,
          purposes: (_e = vm.purposes) !== null && _e !== void 0 ? _e : ["authentication", "assertionMethod", "capabilityDelegation", "capabilityInvocation"]
        });
      }
      const recoveryKeyUri = yield keyManager.generateKey({ algorithm: DidIonRegisteredKeyType.secp256k1 });
      const recoveryKey = yield keyManager.getPublicKey({ keyUri: recoveryKeyUri });
      const updateKeyUri = yield keyManager.generateKey({ algorithm: DidIonRegisteredKeyType.secp256k1 });
      const updateKey = yield keyManager.getPublicKey({ keyUri: updateKeyUri });
      const longFormDidUri = yield DidIonUtils.computeLongFormDidUri({
        recoveryKey,
        updateKey,
        services: (_f = options.services) !== null && _f !== void 0 ? _f : [],
        verificationMethods: verificationMethodsToAdd
      });
      const { didDocument, didResolutionMetadata } = yield _DidIon.resolve(longFormDidUri, { gatewayUri: options.gatewayUri });
      if (didDocument === null) {
        throw new Error(`Unable to resolve DID during creation: ${didResolutionMetadata === null || didResolutionMetadata === void 0 ? void 0 : didResolutionMetadata.error}`);
      }
      const did = new BearerDid({
        uri: longFormDidUri,
        document: didDocument,
        metadata: {
          published: false,
          canonicalId: longFormDidUri.split(":", 3).join(":"),
          recoveryKey,
          updateKey
        },
        keyManager
      });
      if ((_g = options.publish) !== null && _g !== void 0 ? _g : true) {
        const registrationResult = yield _DidIon.publish({ did, gatewayUri: options.gatewayUri });
        did.metadata = registrationResult.didDocumentMetadata;
      }
      return did;
    });
  }
  /**
   * Given the W3C DID Document of a `did:ion` DID, return the verification method that will be used
   * for signing messages and credentials. If given, the `methodId` parameter is used to select the
   * verification method. If not given, the first verification method in the authentication property
   * in the DID Document is used.
   *
   * @param params - The parameters for the `getSigningMethod` operation.
   * @param params.didDocument - DID Document to get the verification method from.
   * @param params.methodId - ID of the verification method to use for signing.
   * @returns Verification method to use for signing.
   */
  static getSigningMethod({ didDocument, methodId }) {
    var _a;
    return __awaiter6(this, void 0, void 0, function* () {
      const parsedDid = Did.parse(didDocument.id);
      if (parsedDid && parsedDid.method !== this.methodName) {
        throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported: ${parsedDid.method}`);
      }
      const verificationMethod = (_a = didDocument.verificationMethod) === null || _a === void 0 ? void 0 : _a.find((vm) => {
        var _a2;
        return vm.id === (methodId !== null && methodId !== void 0 ? methodId : (_a2 = didDocument.assertionMethod) === null || _a2 === void 0 ? void 0 : _a2[0]);
      });
      if (!(verificationMethod && verificationMethod.publicKeyJwk)) {
        throw new DidError(DidErrorCode.InternalError, "A verification method intended for signing could not be determined from the DID Document");
      }
      return verificationMethod;
    });
  }
  /**
   * Instantiates a {@link BearerDid} object for the DID ION method from a given {@link PortableDid}.
   *
   * This method allows for the creation of a `BearerDid` object using a previously created DID's
   * key material, DID document, and metadata.
   *
   * @example
   * ```ts
   * // Export an existing BearerDid to PortableDid format.
   * const portableDid = await did.export();
   * // Reconstruct a BearerDid object from the PortableDid.
   * const did = await DidIon.import({ portableDid });
   * ```
   *
   * @param params - The parameters for the import operation.
   * @param params.portableDid - The PortableDid object to import.
   * @param params.keyManager - Optionally specify an external Key Management System (KMS) used to
   *                            generate keys and sign data. If not given, a new
   *                            {@link LocalKeyManager} instance will be created and
   *                            used.
   * @returns A Promise resolving to a `BearerDid` object representing the DID formed from the
   *          provided PortableDid.
   * @throws An error if the DID document does not contain any verification methods or the keys for
   *         any verification method are missing in the key manager.
   */
  static import({ portableDid, keyManager = new LocalKeyManager() }) {
    return __awaiter6(this, void 0, void 0, function* () {
      const parsedDid = Did.parse(portableDid.uri);
      if ((parsedDid === null || parsedDid === void 0 ? void 0 : parsedDid.method) !== _DidIon.methodName) {
        throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported`);
      }
      const did = yield BearerDid.import({ portableDid, keyManager });
      return did;
    });
  }
  /**
   * Publishes a DID to a Sidetree node, making it publicly discoverable and resolvable.
   *
   * This method handles the publication of a DID Document associated with a `did:ion` DID to a
   * Sidetree node.
   *
   * @remarks
   * - This method is typically invoked automatically during the creation of a new DID unless the
   *   `publish` option is set to `false`.
   * - For existing, unpublished DIDs, it can be used to publish the DID Document to a Sidetree node.
   * - The method relies on the specified Sidetree node to interface with the network.
   *
   * @param params - The parameters for the `publish` operation.
   * @param params.did - The `BearerDid` object representing the DID to be published.
   * @param params.gatewayUri - Optional. The URI of a server involved in executing DID
   *                                    method operations. In the context of publishing, the
   *                                    endpoint is expected to be a Sidetree node. If not
   *                                    specified, a default node is used.
   * @returns A Promise resolving to a boolean indicating whether the publication was successful.
   *
   * @example
   * ```ts
   * // Generate a new DID and keys but explicitly disable publishing.
   * const did = await DidIon.create({ options: { publish: false } });
   * // Publish the DID to the Sidetree network.
   * const isPublished = await DidIon.publish({ did });
   * // `isPublished` is true if the DID was successfully published.
   * ```
   */
  static publish({ did, gatewayUri = DEFAULT_GATEWAY_URI2 }) {
    var _a, _b, _c;
    return __awaiter6(this, void 0, void 0, function* () {
      const verificationMethods = (_b = (_a = did.document.verificationMethod) === null || _a === void 0 ? void 0 : _a.map((vm) => ({
        id: vm.id,
        publicKeyJwk: vm.publicKeyJwk,
        purposes: getVerificationRelationshipsById({ didDocument: did.document, methodId: vm.id })
      }))) !== null && _b !== void 0 ? _b : [];
      const ionDocument = yield DidIonUtils.createIonDocument({
        services: (_c = did.document.service) !== null && _c !== void 0 ? _c : [],
        verificationMethods
      });
      const createOperation = yield DidIonUtils.constructCreateRequest({
        ionDocument,
        recoveryKey: did.metadata.recoveryKey,
        updateKey: did.metadata.updateKey
      });
      try {
        const operationsUrl = DidIonUtils.appendPathToUrl({
          baseUrl: gatewayUri,
          path: `/operations`
        });
        const response = yield fetch(operationsUrl, {
          method: "POST",
          mode: "cors",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(createOperation)
        });
        return {
          didDocument: did.document,
          didDocumentMetadata: Object.assign(Object.assign({}, did.metadata), { published: response.ok }),
          didRegistrationMetadata: {}
        };
      } catch (error) {
        return {
          didDocument: null,
          didDocumentMetadata: {
            published: false
          },
          didRegistrationMetadata: {
            error: DidErrorCode.InternalError,
            errorMessage: `Failed to publish DID document for: ${did.uri}`
          }
        };
      }
    });
  }
  /**
   * Resolves a `did:ion` identifier to its corresponding DID document.
   *
   * This method performs the resolution of a `did:ion` DID, retrieving its DID Document from the
   * Sidetree-based DID overlay network. The process involves querying a Sidetree node to retrieve
   * the DID Document that corresponds to the given DID identifier.
   *
   * @remarks
   * - If a `gatewayUri` option is not specified, a default node is used to access the Sidetree
   *   network.
   * - It decodes the DID identifier and retrieves the associated DID Document and metadata.
   * - In case of resolution failure, appropriate error information is returned.
   *
   * @example
   * ```ts
   * const resolutionResult = await DidIon.resolve('did:ion:example');
   * ```
   *
   * @param didUri - The DID to be resolved.
   * @param options - Optional parameters for resolving the DID. Unused by this DID method.
   * @returns A Promise resolving to a {@link DidResolutionResult} object representing the result of the resolution.
   */
  static resolve(didUri, options = {}) {
    var _a, _b;
    return __awaiter6(this, void 0, void 0, function* () {
      const parsedDid = Did.parse(didUri);
      if (!parsedDid) {
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didResolutionMetadata: { error: "invalidDid" } });
      }
      if (parsedDid.method !== _DidIon.methodName) {
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didResolutionMetadata: { error: "methodNotSupported" } });
      }
      const gatewayUri = (_a = options === null || options === void 0 ? void 0 : options.gatewayUri) !== null && _a !== void 0 ? _a : DEFAULT_GATEWAY_URI2;
      try {
        const resolutionUrl = DidIonUtils.appendPathToUrl({
          baseUrl: gatewayUri,
          path: `/identifiers/${didUri}`
        });
        const response = yield fetch(resolutionUrl);
        if (!response.ok) {
          throw new DidError(DidErrorCode.NotFound, `Unable to find DID document for: ${didUri}`);
        }
        const { didDocument, didDocumentMetadata } = yield response.json();
        return Object.assign(Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), didDocument && { didDocument }), { didDocumentMetadata: Object.assign({ published: (_b = didDocumentMetadata === null || didDocumentMetadata === void 0 ? void 0 : didDocumentMetadata.method) === null || _b === void 0 ? void 0 : _b.published }, didDocumentMetadata) });
      } catch (error) {
        if (!(error instanceof DidError))
          throw new Error(error);
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didResolutionMetadata: Object.assign({ error: error.code }, error.message && { errorMessage: error.message }) });
      }
    });
  }
};
DidIon.methodName = "ion";
var DidIonUtils = class _DidIonUtils {
  /**
   * Appends a specified path to a base URL, ensuring proper formatting of the resulting URL.
   *
   * This method is useful for constructing URLs for accessing various endpoints, such as Sidetree
   * nodes in the ION network. It handles the nuances of URL path concatenation, including the
   * addition or removal of leading/trailing slashes, to create a well-formed URL.
   *
   * @param params - The parameters for URL construction.
   * @param params.baseUrl - The base URL to which the path will be appended.
   * @param params.path - The path to append to the base URL.
   * @returns The fully constructed URL string with the path appended to the base URL.
   */
  static appendPathToUrl({ baseUrl, path }) {
    const url = new URL(baseUrl);
    url.pathname = url.pathname.endsWith("/") ? url.pathname : url.pathname + "/";
    url.pathname += path.startsWith("/") ? path.substring(1) : path;
    return url.toString();
  }
  /**
   * Computes the Long Form DID URI given an ION DID's recovery key, update key, services, and
   * verification methods.
   *
   * @param params - The parameters for computing the Long Form DID URI.
   * @param params.recoveryKey - The ION Recovery Key.
   * @param params.updateKey - The ION Update Key.
   * @param params.services - An array of services associated with the DID.
   * @param params.verificationMethods - An array of verification methods associated with the DID.
   * @returns A Promise resolving to the Long Form DID URI.
   */
  static computeLongFormDidUri({ recoveryKey, updateKey, services, verificationMethods }) {
    return __awaiter6(this, void 0, void 0, function* () {
      const ionDocument = yield _DidIonUtils.createIonDocument({ services, verificationMethods });
      const normalizedRecoveryKey = _DidIonUtils.normalizeJwk(recoveryKey);
      const normalizedUpdateKey = _DidIonUtils.normalizeJwk(updateKey);
      const longFormDidUri = yield IonDid.createLongFormDid({
        document: ionDocument,
        recoveryKey: normalizedRecoveryKey,
        updateKey: normalizedUpdateKey
      });
      return longFormDidUri;
    });
  }
  /**
   * Constructs a Sidetree Create Operation request for a DID document within the ION network.
   *
   * This method prepares the necessary payload for submitting a Create Operation to a Sidetree
   * node, encapsulating the details of the DID document, recovery key, and update key.
   *
   * @param params - Parameters required to construct the Create Operation request.
   * @param params.ionDocument - The DID document model containing public keys and service endpoints.
   * @param params.recoveryKey - The recovery public key in JWK format.
   * @param params.updateKey - The update public key in JWK format.
   * @returns A promise resolving to the ION Create Operation request model, ready for submission to a Sidetree node.
   */
  static constructCreateRequest({ ionDocument, recoveryKey, updateKey }) {
    return __awaiter6(this, void 0, void 0, function* () {
      const createRequest = yield IonRequest.createCreateRequest({
        document: ionDocument,
        recoveryKey: _DidIonUtils.normalizeJwk(recoveryKey),
        updateKey: _DidIonUtils.normalizeJwk(updateKey)
      });
      return createRequest;
    });
  }
  /**
   * Assembles an ION document model from provided services and verification methods
   *
   * This model serves as the foundation for a DID document in the ION network, facilitating the
   * creation and management of decentralized identities. It translates service endpoints and
   * public keys into a format compatible with the Sidetree protocol, ensuring the resulting DID
   * document adheres to the required specifications for ION DIDs. This method is essential for
   * constructing the payload needed to register or update DIDs within the ION network.
   *
   * @param params - The parameters containing the services and verification methods to include in the ION document.
   * @param params.services - A list of service endpoints to be included in the DID document, specifying ways to interact with the DID subject.
   * @param params.verificationMethods - A list of verification methods to be included, detailing the cryptographic keys and their intended uses within the DID document.
   * @returns A Promise resolving to an `IonDocumentModel`, ready for use in Sidetree operations like DID creation and updates.
   */
  static createIonDocument({ services, verificationMethods }) {
    var _a, _b;
    return __awaiter6(this, void 0, void 0, function* () {
      const ionPublicKeys = [];
      for (const vm of verificationMethods) {
        let methodId = (_b = (_a = vm.id) !== null && _a !== void 0 ? _a : vm.publicKeyJwk.kid) !== null && _b !== void 0 ? _b : yield computeJwkThumbprint({ jwk: vm.publicKeyJwk });
        methodId = `${methodId.split("#").pop()}`;
        const publicKey = {
          id: methodId,
          publicKeyJwk: _DidIonUtils.normalizeJwk(vm.publicKeyJwk),
          purposes: vm.purposes,
          type: "JsonWebKey2020"
        };
        ionPublicKeys.push(publicKey);
      }
      const ionServices = services.map((service) => Object.assign(Object.assign({}, service), {
        id: `${service.id.split("#").pop()}`
        // Remove fragment prefix, if any.
      }));
      const ionDocumentModel = {
        publicKeys: ionPublicKeys,
        services: ionServices
      };
      return ionDocumentModel;
    });
  }
  /**
   * Normalize the given JWK to include only specific members and in lexicographic order.
   *
   * @param jwk - The JWK to normalize.
   * @returns The normalized JWK.
   */
  static normalizeJwk(jwk) {
    const keyType = jwk.kty;
    let normalizedJwk;
    if (keyType === "EC") {
      normalizedJwk = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };
    } else if (keyType === "oct") {
      normalizedJwk = { k: jwk.k, kty: jwk.kty };
    } else if (keyType === "OKP") {
      normalizedJwk = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };
    } else if (keyType === "RSA") {
      normalizedJwk = { e: jwk.e, kty: jwk.kty, n: jwk.n };
    } else {
      throw new Error(`Unsupported key type: ${keyType}`);
    }
    return normalizedJwk;
  }
};

// node_modules/@web5/credentials/node_modules/@web5/dids/dist/esm/methods/did-jwk.js
var import_dist11 = __toESM(require_dist(), 1);
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DidJwk = class _DidJwk extends DidMethod {
  /**
   * Creates a new DID using the `did:jwk` method formed from a newly generated key.
   *
   * @remarks
   * The DID URI is formed by Base64URL-encoding the JWK and prefixing with `did:jwk:`.
   *
   * Notes:
   * - If no `options` are given, by default a new Ed25519 key will be generated.
   * - The `algorithm` and `verificationMethods` options are mutually exclusive. If both are given,
   *   an error will be thrown.
   *
   * @example
   * ```ts
   * // DID Creation
   * const did = await DidJwk.create();
   *
   * // DID Creation with a KMS
   * const keyManager = new LocalKeyManager();
   * const did = await DidJwk.create({ keyManager });
   * ```
   *
   * @param params - The parameters for the create operation.
   * @param params.keyManager - Optionally specify a Key Management System (KMS) used to generate
   *                            keys and sign data.
   * @param params.options - Optional parameters that can be specified when creating a new DID.
   * @returns A Promise resolving to a {@link BearerDid} object representing the new DID.
   */
  static create({ keyManager = new LocalKeyManager(), options = {} } = {}) {
    var _a, _b, _c, _d;
    return __awaiter7(this, void 0, void 0, function* () {
      if (options.algorithm && options.verificationMethods) {
        throw new Error(`The 'algorithm' and 'verificationMethods' options are mutually exclusive`);
      }
      if (options.verificationMethods && options.verificationMethods.length !== 1) {
        throw new Error(`The 'verificationMethods' option must contain exactly one entry`);
      }
      const algorithm = (_d = (_a = options.algorithm) !== null && _a !== void 0 ? _a : (_c = (_b = options.verificationMethods) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.algorithm) !== null && _d !== void 0 ? _d : "Ed25519";
      const keyUri = yield keyManager.generateKey({ algorithm });
      const publicKey = yield keyManager.getPublicKey({ keyUri });
      const identifier = Convert.object(publicKey).toBase64Url();
      const didUri = `did:${_DidJwk.methodName}:${identifier}`;
      const didResolutionResult = yield _DidJwk.resolve(didUri);
      const document = didResolutionResult.didDocument;
      const did = new BearerDid({
        uri: didUri,
        document,
        metadata: {},
        keyManager
      });
      return did;
    });
  }
  /**
   * Given the W3C DID Document of a `did:jwk` DID, return the verification method that will be used
   * for signing messages and credentials. If given, the `methodId` parameter is used to select the
   * verification method. If not given, the first verification method in the DID Document is used.
   *
   * Note that for DID JWK, only one verification method can exist so specifying `methodId` could be
   * considered redundant or unnecessary. The option is provided for consistency with other DID
   * method implementations.
   *
   * @param params - The parameters for the `getSigningMethod` operation.
   * @param params.didDocument - DID Document to get the verification method from.
   * @param params.methodId - ID of the verification method to use for signing.
   * @returns Verification method to use for signing.
   */
  static getSigningMethod({ didDocument }) {
    var _a;
    return __awaiter7(this, void 0, void 0, function* () {
      const parsedDid = Did.parse(didDocument.id);
      if (parsedDid && parsedDid.method !== this.methodName) {
        throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported: ${parsedDid.method}`);
      }
      const [verificationMethod] = (_a = didDocument.verificationMethod) !== null && _a !== void 0 ? _a : [];
      if (!(verificationMethod && verificationMethod.publicKeyJwk)) {
        throw new DidError(DidErrorCode.InternalError, "A verification method intended for signing could not be determined from the DID Document");
      }
      return verificationMethod;
    });
  }
  /**
   * Instantiates a {@link BearerDid} object for the DID JWK method from a given {@link PortableDid}.
   *
   * This method allows for the creation of a `BearerDid` object using a previously created DID's
   * key material, DID document, and metadata.
   *
   * @remarks
   * The `verificationMethod` array of the DID document must contain exactly one key since the
   * `did:jwk` method only supports a single verification method.
   *
   * @example
   * ```ts
   * // Export an existing BearerDid to PortableDid format.
   * const portableDid = await did.export();
   * // Reconstruct a BearerDid object from the PortableDid.
   * const did = await DidJwk.import({ portableDid });
   * ```
   *
   * @param params - The parameters for the import operation.
   * @param params.portableDid - The PortableDid object to import.
   * @param params.keyManager - Optionally specify an external Key Management System (KMS) used to
   *                            generate keys and sign data. If not given, a new
   *                            {@link LocalKeyManager} instance will be created and
   *                            used.
   * @returns A Promise resolving to a `BearerDid` object representing the DID formed from the provided keys.
   * @throws An error if the DID document does not contain exactly one verification method.
   */
  static import({ portableDid, keyManager = new LocalKeyManager() }) {
    return __awaiter7(this, void 0, void 0, function* () {
      const parsedDid = Did.parse(portableDid.uri);
      if ((parsedDid === null || parsedDid === void 0 ? void 0 : parsedDid.method) !== _DidJwk.methodName) {
        throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported`);
      }
      const did = yield BearerDid.import({ portableDid, keyManager });
      if (did.document.verificationMethod.length !== 1) {
        throw new DidError(DidErrorCode.InvalidDidDocument, `DID document must contain exactly one verification method`);
      }
      return did;
    });
  }
  /**
   * Resolves a `did:jwk` identifier to a DID Document.
   *
   * @param didUri - The DID to be resolved.
   * @param _options - Optional parameters for resolving the DID. Unused by this DID method.
   * @returns A Promise resolving to a {@link DidResolutionResult} object representing the result of the resolution.
   */
  static resolve(didUri, _options) {
    return __awaiter7(this, void 0, void 0, function* () {
      const parsedDid = Did.parse(didUri);
      let publicKey;
      try {
        publicKey = Convert.base64Url(parsedDid.id).toObject();
      } catch (_a) {
      }
      if (!parsedDid || !publicKey) {
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didResolutionMetadata: { error: "invalidDid" } });
      }
      if (parsedDid.method !== _DidJwk.methodName) {
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didResolutionMetadata: { error: "methodNotSupported" } });
      }
      const didDocument = {
        "@context": [
          "https://www.w3.org/ns/did/v1",
          "https://w3id.org/security/suites/jws-2020/v1"
        ],
        id: parsedDid.uri
      };
      const keyUri = `${didDocument.id}#0`;
      didDocument.verificationMethod = [{
        id: keyUri,
        type: "JsonWebKey2020",
        controller: didDocument.id,
        publicKeyJwk: publicKey
      }];
      didDocument.authentication = [keyUri];
      didDocument.assertionMethod = [keyUri];
      didDocument.capabilityInvocation = [keyUri];
      didDocument.capabilityDelegation = [keyUri];
      didDocument.keyAgreement = [keyUri];
      switch (publicKey.use) {
        case "sig": {
          delete didDocument.keyAgreement;
          break;
        }
        case "enc": {
          delete didDocument.authentication;
          delete didDocument.assertionMethod;
          delete didDocument.capabilityInvocation;
          delete didDocument.capabilityDelegation;
          break;
        }
      }
      return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didDocument });
    });
  }
};
DidJwk.methodName = "jwk";

// node_modules/@web5/credentials/node_modules/@web5/dids/dist/esm/methods/did-key.js
var import_dist12 = __toESM(require_dist(), 1);
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DidKeyRegisteredKeyType;
(function(DidKeyRegisteredKeyType2) {
  DidKeyRegisteredKeyType2["Ed25519"] = "Ed25519";
  DidKeyRegisteredKeyType2["secp256k1"] = "secp256k1";
  DidKeyRegisteredKeyType2["secp256r1"] = "secp256r1";
  DidKeyRegisteredKeyType2["X25519"] = "X25519";
})(DidKeyRegisteredKeyType || (DidKeyRegisteredKeyType = {}));
var DidKeyVerificationMethodType = {
  /** Represents an Ed25519 public key used for digital signatures. */
  Ed25519VerificationKey2020: "https://w3id.org/security/suites/ed25519-2020/v1",
  /** Represents a JSON Web Key (JWK) used for digital signatures and key agreement protocols. */
  JsonWebKey2020: "https://w3id.org/security/suites/jws-2020/v1",
  /** Represents an X25519 public key used for key agreement protocols. */
  X25519KeyAgreementKey2020: "https://w3id.org/security/suites/x25519-2020/v1"
};
var AlgorithmToKeyTypeMap3 = {
  Ed25519: DidKeyRegisteredKeyType.Ed25519,
  ES256K: DidKeyRegisteredKeyType.secp256k1,
  ES256: DidKeyRegisteredKeyType.secp256r1,
  "P-256": DidKeyRegisteredKeyType.secp256r1,
  secp256k1: DidKeyRegisteredKeyType.secp256k1,
  secp256r1: DidKeyRegisteredKeyType.secp256r1,
  X25519: DidKeyRegisteredKeyType.X25519
};
var DidKey = class _DidKey extends DidMethod {
  /**
   * Creates a new DID using the `did:key` method formed from a newly generated key.
   *
   * @remarks
   * The DID URI is formed by
   * {@link https://datatracker.ietf.org/doc/html/draft-multiformats-multibase#name-base-58-bitcoin-encoding | Multibase base58-btc}
   * encoding the
   * {@link https://github.com/multiformats/multicodec/blob/master/README.md | Multicodec}-encoded
   * public key and prefixing with `did:key:`.
   *
   * This method can optionally derive an encryption key from the public key used to create the DID
   * if and only if the public key algorithm is `Ed25519`. This feature enables the same DID to be
   * used for encrypted communication, in addition to signature verification. To enable this
   * feature, specify an `algorithm` of `Ed25519` as either a top-level option or in a
   * `verificationMethod` and set the `enableEncryptionKeyDerivation` option to `true`.
   *
   * Notes:
   * - If no `options` are given, by default a new Ed25519 key will be generated.
   * - The `algorithm` and `verificationMethods` options are mutually exclusive. If both are given,
   *   an error will be thrown.
   *
   * @example
   * ```ts
   * // DID Creation
   * const did = await DidKey.create();
   *
   * // DID Creation with a KMS
   * const keyManager = new LocalKeyManager();
   * const did = await DidKey.create({ keyManager });
   * ```
   *
   * @param params - The parameters for the create operation.
   * @param params.keyManager - Key Management System (KMS) used to generate keys and sign data.
   * @param params.options - Optional parameters that can be specified when creating a new DID.
   * @returns A Promise resolving to a {@link BearerDid} object representing the new DID.
   */
  static create({ keyManager = new LocalKeyManager(), options = {} } = {}) {
    var _a, _b, _c, _d;
    return __awaiter8(this, void 0, void 0, function* () {
      if (options.algorithm && options.verificationMethods) {
        throw new Error(`The 'algorithm' and 'verificationMethods' options are mutually exclusive`);
      }
      if (options.verificationMethods && options.verificationMethods.length !== 1) {
        throw new Error(`The 'verificationMethods' option must contain exactly one entry`);
      }
      const algorithm = (_d = (_a = options.algorithm) !== null && _a !== void 0 ? _a : (_c = (_b = options.verificationMethods) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.algorithm) !== null && _d !== void 0 ? _d : "Ed25519";
      const keyUri = yield keyManager.generateKey({ algorithm });
      const publicKey = yield keyManager.getPublicKey({ keyUri });
      const identifier = yield DidKeyUtils.publicKeyToMultibaseId({ publicKey });
      const didUri = `did:${_DidKey.methodName}:${identifier}`;
      const didResolutionResult = yield _DidKey.resolve(didUri, options);
      const document = didResolutionResult.didDocument;
      const did = new BearerDid({
        uri: didUri,
        document,
        metadata: {},
        keyManager
      });
      return did;
    });
  }
  /**
   * Given the W3C DID Document of a `did:key` DID, return the verification method that will be used
   * for signing messages and credentials. With DID Key, the first verification method in the
   * authentication property in the DID Document is used.
   *
   * Note that for DID Key, only one verification method intended for signing can exist so
   * specifying `methodId` could be considered redundant or unnecessary. The option is provided for
   * consistency with other DID method implementations.
   *
   * @param params - The parameters for the `getSigningMethod` operation.
   * @param params.didDocument - DID Document to get the verification method from.
   * @param params.methodId - ID of the verification method to use for signing.
   * @returns Verification method to use for signing.
   */
  static getSigningMethod({ didDocument }) {
    var _a;
    return __awaiter8(this, void 0, void 0, function* () {
      const parsedDid = Did.parse(didDocument.id);
      if (parsedDid && parsedDid.method !== this.methodName) {
        throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported: ${parsedDid.method}`);
      }
      const [methodId] = didDocument.assertionMethod || [];
      const verificationMethod = (_a = didDocument.verificationMethod) === null || _a === void 0 ? void 0 : _a.find((vm) => vm.id === methodId);
      if (!(verificationMethod && verificationMethod.publicKeyJwk)) {
        throw new DidError(DidErrorCode.InternalError, "A verification method intended for signing could not be determined from the DID Document");
      }
      return verificationMethod;
    });
  }
  /**
   * Instantiates a {@link BearerDid} object for the DID Key method from a given {@link PortableDid}.
   *
   * This method allows for the creation of a `BearerDid` object using a previously created DID's
   * key material, DID document, and metadata.
   *
   * @remarks
   * The `verificationMethod` array of the DID document must contain exactly one key since the
   * `did:key` method only supports a single verification method.
   *
   * @example
   * ```ts
   * // Export an existing BearerDid to PortableDid format.
   * const portableDid = await did.export();
   * // Reconstruct a BearerDid object from the PortableDid.
   * const did = await DidKey.import({ portableDid });
   * ```
   *
   * @param params - The parameters for the import operation.
   * @param params.portableDid - The PortableDid object to import.
   * @param params.keyManager - Optionally specify an external Key Management System (KMS) used to
   *                            generate keys and sign data. If not given, a new
   *                            {@link LocalKeyManager} instance will be created and
   *                            used.
   * @returns A Promise resolving to a `BearerDid` object representing the DID formed from the provided keys.
   * @throws An error if the DID document does not contain exactly one verification method.
   */
  static import({ portableDid, keyManager = new LocalKeyManager() }) {
    return __awaiter8(this, void 0, void 0, function* () {
      const parsedDid = Did.parse(portableDid.uri);
      if ((parsedDid === null || parsedDid === void 0 ? void 0 : parsedDid.method) !== _DidKey.methodName) {
        throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported`);
      }
      const did = yield BearerDid.import({ portableDid, keyManager });
      if (did.document.verificationMethod.length !== 1) {
        throw new DidError(DidErrorCode.InvalidDidDocument, `DID document must contain exactly one verification method`);
      }
      return did;
    });
  }
  /**
   * Resolves a `did:key` identifier to a DID Document.
   *
   * @param didUri - The DID to be resolved.
   * @param options - Optional parameters for resolving the DID.
   * @returns A Promise resolving to a {@link DidResolutionResult} object representing the result of the resolution.
   */
  static resolve(didUri, options) {
    return __awaiter8(this, void 0, void 0, function* () {
      try {
        const didDocument = yield _DidKey.createDocument({ didUri, options });
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didDocument });
      } catch (error) {
        if (!(error instanceof DidError))
          throw new Error(error);
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didResolutionMetadata: Object.assign({ error: error.code }, error.message && { errorMessage: error.message }) });
      }
    });
  }
  /**
   * Expands a did:key identifier to a DID Document.
   *
   * Reference: https://w3c-ccg.github.io/did-method-key/#document-creation-algorithm
   *
   * @param options
   * @returns - A DID dodcument.
   */
  static createDocument({ didUri, options = {} }) {
    return __awaiter8(this, void 0, void 0, function* () {
      const { defaultContext = "https://www.w3.org/ns/did/v1", enableEncryptionKeyDerivation = false, enableExperimentalPublicKeyTypes = false, publicKeyFormat = "JsonWebKey2020" } = options;
      const didDocument = { id: "" };
      const parsedDid = Did.parse(didUri);
      if (!parsedDid) {
        throw new DidError(DidErrorCode.InvalidDid, `Invalid DID URI: ${didUri}`);
      }
      const multibaseValue = parsedDid.id;
      if (parsedDid.method !== _DidKey.methodName) {
        throw new DidError(DidErrorCode.MethodNotSupported, `Method not supported: ${parsedDid.method}`);
      }
      if (!_DidKey.validateIdentifier(parsedDid)) {
        throw new DidError(DidErrorCode.InvalidDid, `Invalid DID URI: ${didUri}`);
      }
      const signatureVerificationMethod = yield _DidKey.createSignatureMethod({
        didUri,
        multibaseValue,
        options: { enableExperimentalPublicKeyTypes, publicKeyFormat }
      });
      didDocument.id = parsedDid.uri;
      didDocument.verificationMethod = [signatureVerificationMethod];
      didDocument.authentication = [signatureVerificationMethod.id];
      didDocument.assertionMethod = [signatureVerificationMethod.id];
      didDocument.capabilityInvocation = [signatureVerificationMethod.id];
      didDocument.capabilityDelegation = [signatureVerificationMethod.id];
      if (enableEncryptionKeyDerivation === true) {
        const encryptionPublicKeyFormat = publicKeyFormat === "Ed25519VerificationKey2020" ? "X25519KeyAgreementKey2020" : "JsonWebKey2020";
        const encryptionVerificationMethod = yield this.createEncryptionMethod({
          didUri,
          multibaseValue,
          options: { enableExperimentalPublicKeyTypes, publicKeyFormat: encryptionPublicKeyFormat }
        });
        didDocument.verificationMethod.push(encryptionVerificationMethod);
        didDocument.keyAgreement = [encryptionVerificationMethod.id];
      }
      const contextArray = [defaultContext];
      const verificationMethodTypes = getVerificationMethodTypes({ didDocument });
      verificationMethodTypes.forEach((typeName) => {
        const typeUrl = DidKeyVerificationMethodType[typeName];
        contextArray.push(typeUrl);
      });
      didDocument["@context"] = contextArray;
      return didDocument;
    });
  }
  /**
   * Decoding a multibase-encoded multicodec value into a verification method
   * that is suitable for verifying that encrypted information will be
   * received by the intended recipient.
   */
  static createEncryptionMethod({ didUri, multibaseValue, options }) {
    return __awaiter8(this, void 0, void 0, function* () {
      const { enableExperimentalPublicKeyTypes, publicKeyFormat } = options;
      const verificationMethod = { id: "", type: "", controller: "" };
      const { keyBytes: publicKeyBytes, multicodecCode: multicodecValue } = yield _DidKey.deriveEncryptionKey({ multibaseValue });
      const actualLength = publicKeyBytes.byteLength;
      const expectedLength = DidKeyUtils.MULTICODEC_PUBLIC_KEY_LENGTH[multicodecValue];
      if (actualLength !== expectedLength) {
        throw new DidError(DidErrorCode.InvalidPublicKeyLength, `Expected ${actualLength} bytes. Actual: ${expectedLength}`);
      }
      const kemMultibaseValue = keyBytesToMultibaseId({
        keyBytes: publicKeyBytes,
        multicodecCode: multicodecValue
      });
      verificationMethod.id = `${didUri}#${kemMultibaseValue}`;
      try {
        new URL(verificationMethod.id);
      } catch (error) {
        throw new DidError(DidErrorCode.InvalidDidUrl, "Verification Method ID is not a valid DID URL.");
      }
      if (!(publicKeyFormat in DidKeyVerificationMethodType)) {
        throw new DidError(DidErrorCode.UnsupportedPublicKeyType, `Unsupported format: ${publicKeyFormat}`);
      }
      const StandardPublicKeyTypes = ["Multikey", "JsonWebKey2020", "X25519KeyAgreementKey2020"];
      if (enableExperimentalPublicKeyTypes === false && !StandardPublicKeyTypes.includes(publicKeyFormat)) {
        throw new DidError(DidErrorCode.InvalidPublicKeyType, `Specified '${publicKeyFormat}' without setting enableExperimentalPublicKeyTypes to true.`);
      }
      verificationMethod.type = publicKeyFormat;
      verificationMethod.controller = didUri;
      if (publicKeyFormat === "X25519KeyAgreementKey2020") {
        verificationMethod.publicKeyMultibase = kemMultibaseValue;
      }
      if (publicKeyFormat === "JsonWebKey2020") {
        const { crv } = yield DidKeyUtils.multicodecToJwk({ code: multicodecValue });
        verificationMethod.publicKeyJwk = yield DidKeyUtils.keyConverter(crv).bytesToPublicKey({ publicKeyBytes });
      }
      return verificationMethod;
    });
  }
  /**
   * Decodes a multibase-encoded multicodec value into a verification method
   * that is suitable for verifying digital signatures.
   * @param options - Signature method creation algorithm inputs.
   * @returns - A verification method.
   */
  static createSignatureMethod({ didUri, multibaseValue, options }) {
    return __awaiter8(this, void 0, void 0, function* () {
      const { enableExperimentalPublicKeyTypes, publicKeyFormat } = options;
      const verificationMethod = { id: "", type: "", controller: "" };
      const { keyBytes: publicKeyBytes, multicodecCode: multicodecValue, multicodecName } = multibaseIdToKeyBytes({ multibaseKeyId: multibaseValue });
      const actualLength = publicKeyBytes.byteLength;
      const expectedLength = DidKeyUtils.MULTICODEC_PUBLIC_KEY_LENGTH[multicodecValue];
      if (actualLength !== expectedLength) {
        throw new DidError(DidErrorCode.InvalidPublicKeyLength, `Expected ${actualLength} bytes. Actual: ${expectedLength}`);
      }
      let isValid2 = false;
      switch (multicodecName) {
        case "secp256k1-pub":
          isValid2 = yield Secp256k1.validatePublicKey({ publicKeyBytes });
          break;
        case "ed25519-pub":
          isValid2 = yield Ed25519.validatePublicKey({ publicKeyBytes });
          break;
        case "x25519-pub":
          isValid2 = true;
          break;
      }
      if (!isValid2) {
        throw new DidError(DidErrorCode.InvalidPublicKey, "Invalid public key detected.");
      }
      verificationMethod.id = `${didUri}#${multibaseValue}`;
      try {
        new URL(verificationMethod.id);
      } catch (error) {
        throw new DidError(DidErrorCode.InvalidDidUrl, "Verification Method ID is not a valid DID URL.");
      }
      if (!(publicKeyFormat in DidKeyVerificationMethodType)) {
        throw new DidError(DidErrorCode.UnsupportedPublicKeyType, `Unsupported format: ${publicKeyFormat}`);
      }
      const StandardPublicKeyTypes = ["Multikey", "JsonWebKey2020", "Ed25519VerificationKey2020"];
      if (enableExperimentalPublicKeyTypes === false && !StandardPublicKeyTypes.includes(publicKeyFormat)) {
        throw new DidError(DidErrorCode.InvalidPublicKeyType, `Specified '${publicKeyFormat}' without setting enableExperimentalPublicKeyTypes to true.`);
      }
      verificationMethod.type = publicKeyFormat;
      verificationMethod.controller = didUri;
      if (publicKeyFormat === "Ed25519VerificationKey2020") {
        verificationMethod.publicKeyMultibase = multibaseValue;
      }
      if (publicKeyFormat === "JsonWebKey2020") {
        const { crv } = yield DidKeyUtils.multicodecToJwk({ code: multicodecValue });
        verificationMethod.publicKeyJwk = yield DidKeyUtils.keyConverter(crv).bytesToPublicKey({ publicKeyBytes });
      }
      return verificationMethod;
    });
  }
  /**
   * Transform a multibase-encoded multicodec value to public encryption key
   * components that are suitable for encrypting messages to a receiver. A
   * mathematical proof elaborating on the safety of performing this operation
   * is available in:
   * {@link https://eprint.iacr.org/2021/509.pdf | On using the same key pair for Ed25519 and an X25519 based KEM}
   */
  static deriveEncryptionKey({ multibaseValue }) {
    return __awaiter8(this, void 0, void 0, function* () {
      let publicEncryptionKey = {
        keyBytes: new Uint8Array(),
        multicodecCode: 0
      };
      const { keyBytes: publicKeyBytes, multicodecCode: multicodecValue } = multibaseIdToKeyBytes({ multibaseKeyId: multibaseValue });
      if (multicodecValue === 237) {
        const ed25519PublicKey = yield DidKeyUtils.keyConverter("Ed25519").bytesToPublicKey({
          publicKeyBytes
        });
        const generatedPublicEncryptionKey = yield Ed25519.convertPublicKeyToX25519({
          publicKey: ed25519PublicKey
        });
        const generatedPublicEncryptionKeyBytes = yield DidKeyUtils.keyConverter("Ed25519").publicKeyToBytes({
          publicKey: generatedPublicEncryptionKey
        });
        publicEncryptionKey = {
          keyBytes: generatedPublicEncryptionKeyBytes,
          multicodecCode: 236
        };
      }
      return publicEncryptionKey;
    });
  }
  /**
   * Validates the structure and components of a DID URI against the `did:key` method specification.
   *
   * @param parsedDid - An object representing the parsed components of a DID URI, including the
   *                    scheme, method, and method-specific identifier.
   * @returns `true` if the DID URI meets the `did:key` method's structural requirements, `false` otherwise.
   *
   */
  static validateIdentifier(parsedDid) {
    const { method, id: multibaseValue } = parsedDid;
    const [scheme] = parsedDid.uri.split(":", 1);
    const version = "1";
    return scheme === "did" && method === "key" && Number(version) > 0 && universalTypeOf(multibaseValue) === "String" && multibaseValue.startsWith("z");
  }
};
DidKey.methodName = "key";
var DidKeyUtils = class _DidKeyUtils {
  /**
   * Converts a JWK (JSON Web Key) to a Multicodec code and name.
   *
   * @example
   * ```ts
   * const jwk: Jwk = { crv: 'Ed25519', kty: 'OKP', x: '...' };
   * const { code, name } = await DidKeyUtils.jwkToMulticodec({ jwk });
   * ```
   *
   * @param params - The parameters for the conversion.
   * @param params.jwk - The JSON Web Key to be converted.
   * @returns A promise that resolves to a Multicodec definition.
   */
  static jwkToMulticodec({ jwk }) {
    return __awaiter8(this, void 0, void 0, function* () {
      const params = [];
      if (jwk.crv) {
        params.push(jwk.crv);
        if (jwk.d) {
          params.push("private");
        } else {
          params.push("public");
        }
      }
      const lookupKey = params.join(":");
      const name = _DidKeyUtils.JWK_TO_MULTICODEC[lookupKey];
      if (name === void 0) {
        throw new Error(`Unsupported JWK to Multicodec conversion: '${lookupKey}'`);
      }
      const code = Multicodec.getCodeFromName({ name });
      return { code, name };
    });
  }
  /**
   * Returns the appropriate public key compressor for the specified cryptographic curve.
   *
   * @param curve - The cryptographic curve to use for the key conversion.
   * @returns A public key compressor for the specified curve.
   */
  static keyCompressor(curve) {
    const compressors = {
      "P-256": Secp256r1.compressPublicKey,
      "secp256k1": Secp256k1.compressPublicKey
    };
    const compressor = compressors[curve];
    if (!compressor)
      throw new DidError(DidErrorCode.InvalidPublicKeyType, `Unsupported curve: ${curve}`);
    return compressor;
  }
  /**
   * Returns the appropriate key converter for the specified cryptographic curve.
   *
   * @param curve - The cryptographic curve to use for the key conversion.
   * @returns An `AsymmetricKeyConverter` for the specified curve.
   */
  static keyConverter(curve) {
    const converters = {
      "Ed25519": Ed25519,
      "P-256": Secp256r1,
      "secp256k1": Secp256k1,
      "X25519": X25519
    };
    const converter = converters[curve];
    if (!converter)
      throw new DidError(DidErrorCode.InvalidPublicKeyType, `Unsupported curve: ${curve}`);
    return converter;
  }
  /**
   * Converts a Multicodec code or name to parial JWK (JSON Web Key).
   *
   * @example
   * ```ts
   * const partialJwk = await DidKeyUtils.multicodecToJwk({ name: 'ed25519-pub' });
   * ```
   *
   * @param params - The parameters for the conversion.
   * @param params.code - Optional Multicodec code to convert.
   * @param params.name - Optional Multicodec name to convert.
   * @returns A promise that resolves to a JOSE format key.
   */
  static multicodecToJwk({ code, name }) {
    return __awaiter8(this, void 0, void 0, function* () {
      if (!(name ? !code : code)) {
        throw new Error(`Either 'name' or 'code' must be defined, but not both.`);
      }
      name = name === void 0 ? Multicodec.getNameFromCode({ code }) : name;
      const lookupKey = name;
      const jose = _DidKeyUtils.MULTICODEC_TO_JWK[lookupKey];
      if (jose === void 0) {
        throw new Error(`Unsupported Multicodec to JWK conversion`);
      }
      return Object.assign({}, jose);
    });
  }
  /**
   * Converts a public key in JWK (JSON Web Key) format to a multibase identifier.
   *
   * @remarks
   * Note: All secp public keys are converted to compressed point encoding
   *       before the multibase identifier is computed.
   *
   * Per {@link https://github.com/multiformats/multicodec/blob/master/table.csv | Multicodec table}:
   *    Public keys for Elliptic Curve cryptography algorithms (e.g., secp256k1,
   *    secp256k1r1, secp384r1, etc.) are always represented with compressed point
   *    encoding (e.g., secp256k1-pub, p256-pub, p384-pub, etc.).
   *
   * Per {@link https://datatracker.ietf.org/doc/html/rfc8812#name-jose-and-cose-secp256k1-cur | RFC 8812}:
   *    "As a compressed point encoding representation is not defined for JWK
   *    elliptic curve points, the uncompressed point encoding defined there
   *    MUST be used. The x and y values represented MUST both be exactly
   *    256 bits, with any leading zeros preserved."
   *
   * @example
   * ```ts
   * const publicKey = { crv: 'Ed25519', kty: 'OKP', x: '...' };
   * const multibaseId = await DidKeyUtils.publicKeyToMultibaseId({ publicKey });
   * ```
   *
   * @param params - The parameters for the conversion.
   * @param params.publicKey - The public key in JWK format.
   * @returns A promise that resolves to the multibase identifier.
   */
  static publicKeyToMultibaseId({ publicKey }) {
    var _a;
    return __awaiter8(this, void 0, void 0, function* () {
      if (!((publicKey === null || publicKey === void 0 ? void 0 : publicKey.crv) && publicKey.crv in AlgorithmToKeyTypeMap3)) {
        throw new DidError(DidErrorCode.InvalidPublicKeyType, `Public key contains an unsupported key type: ${(_a = publicKey === null || publicKey === void 0 ? void 0 : publicKey.crv) !== null && _a !== void 0 ? _a : "undefined"}`);
      }
      let publicKeyBytes = yield _DidKeyUtils.keyConverter(publicKey.crv).publicKeyToBytes({ publicKey });
      if (/^(secp256k1|P-256|P-384|P-521)$/.test(publicKey.crv)) {
        publicKeyBytes = yield _DidKeyUtils.keyCompressor(publicKey.crv)({ publicKeyBytes });
      }
      const { name: multicodecName } = yield _DidKeyUtils.jwkToMulticodec({ jwk: publicKey });
      const multibaseId = keyBytesToMultibaseId({
        keyBytes: publicKeyBytes,
        multicodecName
      });
      return multibaseId;
    });
  }
};
DidKeyUtils.JWK_TO_MULTICODEC = {
  "Ed25519:public": "ed25519-pub",
  "Ed25519:private": "ed25519-priv",
  "secp256k1:public": "secp256k1-pub",
  "secp256k1:private": "secp256k1-priv",
  "X25519:public": "x25519-pub",
  "X25519:private": "x25519-priv"
};
DidKeyUtils.MULTICODEC_PUBLIC_KEY_LENGTH = {
  // secp256k1-pub - Secp256k1 public key (compressed) - 33 bytes
  231: 33,
  // x25519-pub - Curve25519 public key - 32 bytes
  236: 32,
  // ed25519-pub - Ed25519 public key - 32 bytes
  237: 32
};
DidKeyUtils.MULTICODEC_TO_JWK = {
  "ed25519-pub": { crv: "Ed25519", kty: "OKP", x: "" },
  "ed25519-priv": { crv: "Ed25519", kty: "OKP", x: "", d: "" },
  "secp256k1-pub": { crv: "secp256k1", kty: "EC", x: "", y: "" },
  "secp256k1-priv": { crv: "secp256k1", kty: "EC", x: "", y: "", d: "" },
  "x25519-pub": { crv: "X25519", kty: "OKP", x: "" },
  "x25519-priv": { crv: "X25519", kty: "OKP", x: "", d: "" }
};

// node_modules/@web5/credentials/node_modules/@web5/dids/dist/esm/methods/did-web.js
var import_dist13 = __toESM(require_dist(), 1);
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DidWeb = class _DidWeb extends DidMethod {
  /**
   * Resolves a `did:web` identifier to a DID Document.
   *
   * @param didUri - The DID to be resolved.
   * @param _options - Optional parameters for resolving the DID. Unused by this DID method.
   * @returns A Promise resolving to a {@link DidResolutionResult} object representing the result of the resolution.
   */
  static resolve(didUri, _options) {
    return __awaiter9(this, void 0, void 0, function* () {
      const parsedDid = Did.parse(didUri);
      if (!parsedDid) {
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didResolutionMetadata: { error: "invalidDid" } });
      }
      if (parsedDid.method !== _DidWeb.methodName) {
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didResolutionMetadata: { error: "methodNotSupported" } });
      }
      let baseUrl = `https://${parsedDid.id.replace(/:/g, "/")}`;
      baseUrl = decodeURIComponent(baseUrl);
      const didDocumentUrl = parsedDid.id.includes(":") ? `${baseUrl}/did.json` : `${baseUrl}/.well-known/did.json`;
      try {
        const response = yield fetch(didDocumentUrl);
        if (!response.ok)
          throw new Error("HTTP error status code returned");
        const didDocument = yield response.json();
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didDocument });
      } catch (error) {
        return Object.assign(Object.assign({}, EMPTY_DID_RESOLUTION_RESULT), { didResolutionMetadata: { error: "notFound" } });
      }
    });
  }
};
DidWeb.methodName = "web";

// node_modules/@web5/credentials/node_modules/@web5/dids/dist/esm/resolver/resolver-cache-level.js
var import_dist14 = __toESM(require_dist(), 1);
var import_ms = __toESM(require_ms(), 1);
var import_level = __toESM(require_browser(), 1);

// node_modules/@web5/credentials/dist/esm/jwt.js
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var crypto = new LocalKeyManager();
var Jwt = class _Jwt {
  /**
   * Creates a signed JWT.
   *
   * @example
   * ```ts
   * const jwt = await Jwt.sign({ signerDid: myDid, payload: myPayload });
   * ```
   *
   * @param options - Parameters for JWT creation including signer DID and payload.
   * @returns The compact JWT as a string.
   */
  static sign(options) {
    return __awaiter10(this, void 0, void 0, function* () {
      const { signerDid, payload } = options;
      const signer = yield signerDid.getSigner();
      let vmId = signer.keyId;
      if (vmId.charAt(0) === "#") {
        vmId = `${signerDid.uri}${vmId}`;
      }
      const header = {
        typ: "JWT",
        alg: signer.algorithm,
        kid: vmId
      };
      const base64UrlEncodedHeader = Convert.object(header).toBase64Url();
      const base64UrlEncodedPayload = Convert.object(payload).toBase64Url();
      const toSign = `${base64UrlEncodedHeader}.${base64UrlEncodedPayload}`;
      const toSignBytes = Convert.string(toSign).toUint8Array();
      const signatureBytes = yield signer.sign({ data: toSignBytes });
      const base64UrlEncodedSignature = Convert.uint8Array(signatureBytes).toBase64Url();
      return `${toSign}.${base64UrlEncodedSignature}`;
    });
  }
  /**
   * Verifies a JWT.
   *
   * @example
   * ```ts
   * const verifiedJwt = await Jwt.verify({ jwt: myJwt });
   * ```
   *
   * @param options - Parameters for JWT verification
   * @returns Verified JWT information including signer DID, header, and payload.
   */
  static verify(options) {
    return __awaiter10(this, void 0, void 0, function* () {
      const { decoded: decodedJwt, encoded: encodedJwt } = _Jwt.parse({ jwt: options.jwt });
      if (decodedJwt.payload.exp && Math.floor(Date.now() / 1e3) > decodedJwt.payload.exp) {
        throw new Error(`Verification failed: JWT is expired`);
      }
      const dereferenceResult = yield _Jwt.didResolver.dereference(decodedJwt.header.kid);
      if (dereferenceResult.dereferencingMetadata.error) {
        throw new Error(`Failed to resolve ${decodedJwt.header.kid}`);
      }
      const verificationMethod = dereferenceResult.contentStream;
      if (!verificationMethod || !utils_exports2.isDidVerificationMethod(verificationMethod)) {
        throw new Error("Verification failed: Expected kid in JWT header to dereference a DID Document Verification Method");
      }
      const publicKeyJwk = verificationMethod.publicKeyJwk;
      if (!publicKeyJwk) {
        throw new Error("Verification failed: Expected kid in JWT header to dereference to a DID Document Verification Method with publicKeyJwk");
      }
      if (publicKeyJwk.alg && publicKeyJwk.alg !== decodedJwt.header.alg) {
        throw new Error("Verification failed: Expected alg in JWT header to match DID Document Verification Method alg");
      }
      const signedData = `${encodedJwt.header}.${encodedJwt.payload}`;
      const signedDataBytes = Convert.string(signedData).toUint8Array();
      const signatureBytes = Convert.base64Url(encodedJwt.signature).toUint8Array();
      const isSignatureValid = yield crypto.verify({
        key: publicKeyJwk,
        signature: signatureBytes,
        data: signedDataBytes
      });
      if (!isSignatureValid) {
        throw new Error("Signature verification failed: Integrity mismatch");
      }
      return decodedJwt;
    });
  }
  /**
   * Parses a JWT without verifying its signature.
   *
   * @example
   * ```ts
   * const { encoded: encodedJwt, decoded: decodedJwt } = Jwt.parse({ jwt: myJwt });
   * ```
   *
   * @param options - Parameters for JWT decoding, including the JWT string.
   * @returns both encoded and decoded JWT parts
   */
  static parse(options) {
    const splitJwt = options.jwt.split(".");
    if (splitJwt.length !== 3) {
      throw new Error(`Verification failed: Malformed JWT. expected 3 parts. got ${splitJwt.length}`);
    }
    const [base64urlEncodedJwtHeader, base64urlEncodedJwtPayload, base64urlEncodedSignature] = splitJwt;
    let jwtHeader;
    let jwtPayload;
    try {
      jwtHeader = Convert.base64Url(base64urlEncodedJwtHeader).toObject();
    } catch (e) {
      throw new Error("Verification failed: Malformed JWT. Invalid base64url encoding for JWT header");
    }
    if (!jwtHeader.typ || jwtHeader.typ !== "JWT") {
      throw new Error("Verification failed: Expected JWT header to contain typ property set to JWT");
    }
    if (!jwtHeader.alg || !jwtHeader.kid) {
      throw new Error("Verification failed: Expected JWT header to contain alg and kid");
    }
    try {
      jwtPayload = Convert.base64Url(base64urlEncodedJwtPayload).toObject();
    } catch (e) {
      throw new Error("Verification failed: Malformed JWT. Invalid base64url encoding for JWT payload");
    }
    return {
      decoded: {
        header: jwtHeader,
        payload: jwtPayload
      },
      encoded: {
        header: base64urlEncodedJwtHeader,
        payload: base64urlEncodedJwtPayload,
        signature: base64urlEncodedSignature
      }
    };
  }
};
Jwt.didResolver = new DidResolver({ didResolvers: [DidDht, DidIon, DidKey, DidJwk, DidWeb] });

// node_modules/@web5/credentials/dist/esm/presentation-exchange.js
var import_dist17 = __toESM(require_dist(), 1);
var PresentationExchange = class {
  /**
   * Selects credentials that satisfy a given presentation definition.
   *
   * @param {string[]} vcJwts The list of Verifiable Credentials to select from.
   * @param {PresentationDefinitionV2} presentationDefinition The Presentation Definition to match against.
   * @returns {string[]} selectedVcJwts A list of Verifiable Credentials that satisfy the Presentation Definition.
   */
  static selectCredentials({ vcJwts, presentationDefinition }) {
    var _a;
    this.resetPex();
    const selectResults = this.pex.selectFrom(presentationDefinition, vcJwts);
    return Array.from(new Set((_a = selectResults.verifiableCredential) !== null && _a !== void 0 ? _a : []));
  }
  /**
   * Validates if a list of VC JWTs satisfies the given presentation definition.
   *
   * @param vcJwts - An array of VC JWTs as strings.
   * @param presentationDefinition - The criteria to validate against.
   * @throws Error if the evaluation results in warnings or errors.
   */
  static satisfiesPresentationDefinition({ vcJwts, presentationDefinition }) {
    var _a, _b, _c;
    this.resetPex();
    const evaluationResults = this.pex.evaluateCredentials(presentationDefinition, vcJwts);
    if ((_a = evaluationResults.warnings) === null || _a === void 0 ? void 0 : _a.length) {
      console.warn("Warnings were generated during the evaluation process: " + JSON.stringify(evaluationResults.warnings));
    }
    if (evaluationResults.areRequiredCredentialsPresent.toString() !== "info" || ((_b = evaluationResults.errors) === null || _b === void 0 ? void 0 : _b.length)) {
      let errorMessage = "Failed to create Verifiable Presentation JWT due to: ";
      if (evaluationResults.areRequiredCredentialsPresent) {
        errorMessage += "Required Credentials Not Present: " + JSON.stringify(evaluationResults.areRequiredCredentialsPresent);
      }
      if ((_c = evaluationResults.errors) === null || _c === void 0 ? void 0 : _c.length) {
        errorMessage += "Errors: " + JSON.stringify(evaluationResults.errors);
      }
      throw new Error(errorMessage);
    }
  }
  /**
   * Creates a presentation from a list of Verifiable Credentials that satisfy a given presentation definition.
   * This function initializes the Presentation Exchange (PEX) process, validates the presentation definition,
   * evaluates the credentials against the definition, and finally constructs the presentation result if the
   * evaluation is successful.
   *
   * @param {string[]} vcJwts The list of Verifiable Credentials (VCs) in JWT format to be evaluated.
   * @param {PresentationDefinitionV2} presentationDefinition The Presentation Definition V2 to match the VCs against.
   * @returns {PresentationResult} The result of the presentation creation process, containing a presentation submission
   *                               that satisfies the presentation definition criteria.
   * @throws {Error} If the evaluation results in warnings or errors, or if the required credentials are not present,
   *                 an error is thrown with a descriptive message.
   */
  static createPresentationFromCredentials({ vcJwts, presentationDefinition }) {
    var _a, _b, _c;
    this.resetPex();
    const pdValidated = PEX.validateDefinition(presentationDefinition);
    isValid(pdValidated);
    const evaluationResults = this.pex.evaluateCredentials(presentationDefinition, vcJwts);
    if ((_a = evaluationResults.warnings) === null || _a === void 0 ? void 0 : _a.length) {
      console.warn("Warnings were generated during the evaluation process: " + JSON.stringify(evaluationResults.warnings));
    }
    if (evaluationResults.areRequiredCredentialsPresent.toString() !== "info" || ((_b = evaluationResults.errors) === null || _b === void 0 ? void 0 : _b.length)) {
      let errorMessage = "Failed to create Verifiable Presentation JWT due to: ";
      if (evaluationResults.areRequiredCredentialsPresent) {
        errorMessage += "Required Credentials Not Present: " + JSON.stringify(evaluationResults.areRequiredCredentialsPresent);
      }
      if ((_c = evaluationResults.errors) === null || _c === void 0 ? void 0 : _c.length) {
        errorMessage += "Errors: " + JSON.stringify(evaluationResults.errors);
      }
      throw new Error(errorMessage);
    }
    const presentationResult = this.pex.presentationFrom(presentationDefinition, vcJwts);
    const submissionValidated = PEX.validateSubmission(presentationResult.presentationSubmission);
    isValid(submissionValidated);
    return presentationResult;
  }
  /**
   * This method validates whether an object is usable as a presentation definition or not.
   *
   * @param {PresentationDefinitionV2} presentationDefinition: presentationDefinition to be validated.
   * @returns {Validated} the validation results to reveal what is acceptable/unacceptable about the passed object to be considered a valid presentation definition
   */
  static validateDefinition({ presentationDefinition }) {
    return PEX.validateDefinition(presentationDefinition);
  }
  /**
   * This method validates whether an object is usable as a presentation submission or not.
   *
   * @param {PresentationSubmission} presentationSubmission the object to be validated.
   * @returns {Validated} the validation results to reveal what is acceptable/unacceptable about the passed object to be considered a valid presentation submission
   */
  static validateSubmission({ presentationSubmission }) {
    return PEX.validateSubmission(presentationSubmission);
  }
  /**
   * Evaluates a presentation against a presentation definition.
   *
   * @returns {EvaluationResults} The result of the evaluation process.
   */
  static evaluatePresentation({ presentationDefinition, presentation }) {
    this.resetPex();
    return this.pex.evaluatePresentation(presentationDefinition, presentation);
  }
  static resetPex() {
    this.pex = new PEX();
  }
};
PresentationExchange.pex = new PEX();
function isValid(validated) {
  let errorMessage = "Failed to pass validation check due to: ";
  if (Array.isArray(validated)) {
    if (!validated.every((item) => item.status === "info")) {
      errorMessage += "Validation Errors: " + JSON.stringify(validated);
      throw new Error(errorMessage);
    }
  } else {
    if (validated.status !== "info") {
      errorMessage += "Validation Errors: " + JSON.stringify(validated);
      throw new Error(errorMessage);
    }
  }
}

// node_modules/@web5/credentials/dist/esm/verifiable-credential.js
var import_dist21 = __toESM(require_dist(), 1);

// node_modules/@web5/credentials/dist/esm/validators.js
var import_dist20 = __toESM(require_dist(), 1);

// node_modules/@web5/credentials/dist/esm/utils.js
var utils_exports3 = {};
__export(utils_exports3, {
  getCurrentXmlSchema112Timestamp: () => getCurrentXmlSchema112Timestamp,
  getFutureXmlSchema112Timestamp: () => getFutureXmlSchema112Timestamp,
  isValidXmlSchema112Timestamp: () => isValidXmlSchema112Timestamp
});
var import_dist18 = __toESM(require_dist(), 1);
function getCurrentXmlSchema112Timestamp() {
  return (/* @__PURE__ */ new Date()).toISOString().replace(/\.\d+Z$/, "Z");
}
function getFutureXmlSchema112Timestamp(secondsInFuture) {
  const futureDate = new Date(Date.now() + secondsInFuture * 1e3);
  return futureDate.toISOString().replace(/\.\d+Z$/, "Z");
}
function isValidXmlSchema112Timestamp(timestamp) {
  const regex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z$/;
  if (!regex.test(timestamp)) {
    return false;
  }
  const date = new Date(timestamp);
  return !isNaN(date.getTime());
}

// node_modules/@web5/credentials/dist/esm/verifiable-presentation.js
var import_dist19 = __toESM(require_dist(), 1);
var DEFAULT_VP_TYPE = "VerifiablePresentation";

// node_modules/@web5/credentials/dist/esm/validators.js
var SsiValidator = class {
  static validateCredentialPayload(vc) {
    this.validateContext(vc.vcDataModel["@context"]);
    this.validateVcType(vc.type);
    this.validateCredentialSubject(vc.vcDataModel.credentialSubject);
    if (vc.vcDataModel.issuanceDate)
      this.validateTimestamp(vc.vcDataModel.issuanceDate);
    if (vc.vcDataModel.expirationDate)
      this.validateTimestamp(vc.vcDataModel.expirationDate);
  }
  static validateContext(value) {
    const input = this.asArray(value);
    if (input.length < 1 || input.indexOf(DEFAULT_CONTEXT) === -1) {
      throw new Error(`@context is missing default context "${DEFAULT_CONTEXT}"`);
    }
  }
  static validateVcType(value) {
    const input = this.asArray(value);
    if (input.length < 1 || input.indexOf(DEFAULT_VC_TYPE) === -1) {
      throw new Error(`type is missing default "${DEFAULT_VC_TYPE}"`);
    }
  }
  static validateVpType(value) {
    const input = this.asArray(value);
    if (input.length < 1 || input.indexOf(DEFAULT_VP_TYPE) === -1) {
      throw new Error(`type is missing default "${DEFAULT_VP_TYPE}"`);
    }
  }
  static validateCredentialSubject(value) {
    if (Object.keys(value).length === 0) {
      throw new Error(`credentialSubject must not be empty`);
    }
  }
  static validateTimestamp(timestamp) {
    if (!isValidXmlSchema112Timestamp(timestamp)) {
      throw new Error(`timestamp is not valid xml schema 112 timestamp`);
    }
  }
  static asArray(arg) {
    return Array.isArray(arg) ? arg : [arg];
  }
};

// node_modules/@web5/credentials/dist/esm/verifiable-credential.js
var __awaiter11 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DEFAULT_CONTEXT = "https://www.w3.org/2018/credentials/v1";
var DEFAULT_VC_TYPE = "VerifiableCredential";
var VerifiableCredential = class _VerifiableCredential {
  constructor(vcDataModel) {
    this.vcDataModel = vcDataModel;
  }
  get type() {
    return this.vcDataModel.type[this.vcDataModel.type.length - 1];
  }
  get issuer() {
    return this.vcDataModel.issuer.toString();
  }
  get subject() {
    if (Array.isArray(this.vcDataModel.credentialSubject)) {
      return this.vcDataModel.credentialSubject[0].id;
    } else {
      return this.vcDataModel.credentialSubject.id;
    }
  }
  /**
   * Signs the verifiable credential and returns it as a signed JWT.
   *
   * @example
   * ```ts
   * const vcJwt = verifiableCredential.sign({ did: myDid });
   * ```
   *
   * @param options - The sign options used to sign the credential.
   * @returns The JWT representing the signed verifiable credential.
   */
  sign(options) {
    return __awaiter11(this, void 0, void 0, function* () {
      const vcJwt = yield Jwt.sign({
        signerDid: options.did,
        payload: {
          vc: this.vcDataModel,
          iss: this.issuer,
          sub: this.subject
        }
      });
      return vcJwt;
    });
  }
  /**
   * Converts the current object to its JSON representation.
   *
   * @returns The JSON representation of the object.
   */
  toString() {
    return JSON.stringify(this.vcDataModel);
  }
  /**
   * Create a [VerifiableCredential] based on the provided parameters.
   *
   * @example
   * ```ts
   * const vc = await VerifiableCredential.create({
   *     type: 'StreetCredibility',
   *     issuer: 'did:ex:issuer',
   *     subject: 'did:ex:subject',
   *     data: { 'arbitrary': 'data' }
   *   })
   * ```
   *
   * @param options - The options to use when creating the Verifiable Credential.
   * @returns A [VerifiableCredential] instance.
   */
  static create(options) {
    return __awaiter11(this, void 0, void 0, function* () {
      const { type, issuer, subject, data, issuanceDate, expirationDate } = options;
      const jsonData = JSON.parse(JSON.stringify(data));
      if (typeof jsonData !== "object") {
        throw new Error("Expected data to be parseable into a JSON object");
      }
      if (!issuer || !subject) {
        throw new Error("Issuer and subject must be defined");
      }
      if (typeof issuer !== "string" || typeof subject !== "string") {
        throw new Error("Issuer and subject must be of type string");
      }
      const credentialSubject = Object.assign({ id: subject }, jsonData);
      const vcDataModel = Object.assign({ "@context": [DEFAULT_CONTEXT], type: Array.isArray(type) ? [DEFAULT_VC_TYPE, ...type] : type ? [DEFAULT_VC_TYPE, type] : [DEFAULT_VC_TYPE], id: `urn:uuid:${utils_exports.randomUuid()}`, issuer, issuanceDate: issuanceDate || getCurrentXmlSchema112Timestamp(), credentialSubject }, expirationDate && { expirationDate });
      validatePayload(vcDataModel);
      return new _VerifiableCredential(vcDataModel);
    });
  }
  /**
   * Verifies the integrity and authenticity of a Verifiable Credential (VC) encoded as a JSON Web Token (JWT).
   *
   * This function performs several crucial validation steps to ensure the trustworthiness of the provided VC:
   * - Parses and validates the structure of the JWT.
   * - Ensures the presence of critical header elements `alg` and `kid` in the JWT header.
   * - Resolves the Decentralized Identifier (DID) and retrieves the associated DID Document.
   * - Validates the DID and establishes a set of valid verification method IDs.
   * - Identifies the correct Verification Method from the DID Document based on the `kid` parameter.
   * - Verifies the JWT's signature using the public key associated with the Verification Method.
   *
   * If any of these steps fail, the function will throw a [Error] with a message indicating the nature of the failure.
   *
   * @example
   * ```ts
   * try {
   *     VerifiableCredential.verify({ vcJwt: signedVcJwt })
   *     console.log("VC Verification successful!")
   * } catch (e: Error) {
   *     console.log("VC Verification failed: ${e.message}")
   * }
   * ```
   *
   * @param vcJwt The Verifiable Credential in JWT format as a [string].
   * @throws Error if the verification fails at any step, providing a message with failure details.
   * @throws Error if critical JWT header elements are absent.
   */
  static verify({ vcJwt }) {
    return __awaiter11(this, void 0, void 0, function* () {
      const { payload } = yield Jwt.verify({ jwt: vcJwt });
      const vc = payload["vc"];
      if (!vc) {
        throw new Error("vc property missing.");
      }
      validatePayload(vc);
      return {
        issuer: payload.iss,
        subject: payload.sub,
        vc: payload["vc"]
      };
    });
  }
  /**
   * Parses a JWT into a [VerifiableCredential] instance.
   *
   * @example
   * ```ts
   * const vc = VerifiableCredential.parseJwt({ vcJwt: signedVcJwt })
   * ```
   *
   * @param vcJwt The verifiable credential JWT as a [String].
   * @returns A [VerifiableCredential] instance derived from the JWT.
   */
  static parseJwt({ vcJwt }) {
    const parsedJwt = Jwt.parse({ jwt: vcJwt });
    const vcDataModel = parsedJwt.decoded.payload["vc"];
    if (!vcDataModel) {
      throw Error("Jwt payload missing vc property");
    }
    return new _VerifiableCredential(vcDataModel);
  }
};
function validatePayload(vc) {
  SsiValidator.validateContext(vc["@context"]);
  SsiValidator.validateVcType(vc.type);
  SsiValidator.validateCredentialSubject(vc.credentialSubject);
  if (vc.issuanceDate)
    SsiValidator.validateTimestamp(vc.issuanceDate);
  if (vc.expirationDate)
    SsiValidator.validateTimestamp(vc.expirationDate);
}
export {
  DEFAULT_CONTEXT,
  DEFAULT_VC_TYPE,
  Jwt,
  PresentationExchange,
  VerifiableCredential,
  utils_exports3 as utils
};
//# sourceMappingURL=@web5_credentials.js.map
