"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports) {
      "use strict";
      init_dist();
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js"(exports) {
      init_dist();
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s2 = buffer[offset + i];
        i += d;
        e = s2 & (1 << -nBits) - 1;
        s2 >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s2 ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s2 * 128;
      };
    }
  });

  // node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js"(exports) {
      "use strict";
      init_dist();
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer2;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      var { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new GlobalUint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new GlobalUint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer2.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (GlobalArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b)
          return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);
      Object.setPrototypeOf(Buffer2, GlobalUint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, GlobalUint8Array)) {
          const copy = new GlobalUint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new GlobalUint8Array(array);
        } else if (length === void 0) {
          buf = new GlobalUint8Array(array, byteOffset);
        } else {
          buf = new GlobalUint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer2.alloc(+length);
      }
      Buffer2.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer2.prototype;
      };
      Buffer2.compare = function compare(a, b) {
        if (isInstance(a, GlobalUint8Array))
          a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b, GlobalUint8Array))
          b = Buffer2.from(b, b.offset, b.byteLength);
        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b)
          return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer = Buffer2.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, GlobalUint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer2.isBuffer(buf))
                buf = Buffer2.from(buf);
              buf.copy(buffer, pos);
            } else {
              GlobalUint8Array.prototype.set.call(
                buffer,
                buf,
                pos
              );
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }
        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer2.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
      Buffer2.prototype.equals = function equals(b) {
        if (!Buffer2.isBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }
      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, GlobalUint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }
        if (!Buffer2.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof GlobalUint8Array.prototype.indexOf === "function") {
            if (dir) {
              return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer2.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val = this[offset + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let i = byteLength2;
        let mul = 1;
        let val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          GlobalUint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length)
            break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js
  var require_browser = __commonJS({
    "node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js"(exports, module) {
      init_dist();
      var process = module.exports = {};
      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          if (typeof setTimeout === "function") {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === "function") {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e2) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e2) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      process.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      process.title = "browser";
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = "";
      process.versions = {};
      function noop() {
      }
      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;
      process.listeners = function(name) {
        return [];
      };
      process.binding = function(name) {
        throw new Error("process.binding is not supported");
      };
      process.cwd = function() {
        return "/";
      };
      process.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
      };
      process.umask = function() {
        return 0;
      };
    }
  });

  // shims/dist/index.js
  var import_buffer_polyfill, import_process, o;
  var init_dist = __esm({
    "shims/dist/index.js"() {
      "use strict";
      import_buffer_polyfill = __toESM(require_buffer(), 1);
      import_process = __toESM(require_browser(), 1);
      o = globalThis || void 0 || self;
    }
  });

  // shims/banner/index.cjs
  var require_banner = __commonJS({
    "shims/banner/index.cjs"() {
      init_dist();
      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;
      globalThis.global = globalThis.global || o;
      globalThis.process = globalThis.process || import_process.default;
    }
  });
  require_banner();
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/

import {
  require_uri_all
} from "./chunk-UPUZYSSL.js";
import {
  __commonJS,
  __esm,
  __export,
  __publicField,
  __require,
  __toCommonJS,
  __toESM,
  require_dist
} from "./chunk-C4XPKKSS.js";

// node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "node_modules/ajv/dist/compile/codegen/code.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports._CodeOrName = _CodeOrName;
    exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        super();
        if (!exports.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a;
        return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a;
        return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names, c) => {
          if (c instanceof Name)
            names[c.str] = (names[c.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports._Code = _Code;
    exports.nil = new _Code("");
    function _(strs, ...args) {
      const code = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    exports._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name)
        code.push(arg);
      else
        code.push(interpolate(arg));
    }
    exports.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
          return;
        if (typeof b != "string")
          return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
          return a.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports.regexpCode = regexpCode;
  }
});

// node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "node_modules/ajv/dist/compile/codegen/scope.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));
    exports.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a, _b;
        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports.ValueScope = ValueScope;
  }
});

// node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/ajv/dist/compile/codegen/index.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n2) => code + n2.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n2 = nodes[i].optimizeNodes();
          if (Array.isArray(n2))
            nodes.splice(i, 1, ...n2);
          else if (n2)
            nodes[i] = n2;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n2 = nodes[i];
          if (n2.optimizeNames(names, constants))
            continue;
          subtractNames(names, n2.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n2) => addNames(names, n2.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e2 = this.else;
        if (e2) {
          const ns = e2.optimizeNodes();
          e2 = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e2) {
          if (cond === false)
            return e2 instanceof _If ? e2 : e2.nodes;
          if (this.nodes.length)
            return this;
          return new _If(not(cond), e2 instanceof _If ? [e2] : e2.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a;
        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
          addNames(names, this.else.names);
        return names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a, _b;
        super.optimizeNodes();
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a, _b;
        super.optimizeNames(names, constants);
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch)
          addNames(names, this.catch.names);
        if (this.finally)
          addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function")
          c();
        else if (c !== code_1.nil)
          this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n2 = 1) {
        while (n2-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n2 = this._currNode;
        if (n2 instanceof N1 || N2 && n2 instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n2 = this._currNode;
        if (!(n2 instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n2.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports.CodeGen = CodeGen;
    function addNames(names, from) {
      for (const n2 in from)
        names[n2] = (names[n2] || 0) + (from[n2] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name)
          c = replaceName(c);
        if (c instanceof code_1._Code)
          items.push(...c._items);
        else
          items.push(c);
        return items;
      }, []));
      function replaceName(n2) {
        const c = constants[n2.str];
        if (c === void 0 || names[n2.str] !== 1)
          return n2;
        delete names[n2.str];
        return c;
      }
      function canOptimize(e2) {
        return e2 instanceof code_1._Code && e2._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (const n2 in from)
        names[n2] = (names[n2] || 0) - (from[n2] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports.not = not;
    var andCode = mappend(exports.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports.and = and;
    var orCode = mappend(exports.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// node_modules/ajv/dist/compile/util.js
var require_util = __commonJS({
  "node_modules/ajv/dist/compile/util.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    exports.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it, schema);
      return !schemaHasRules(schema, it.self.RULES.all);
    }
    exports.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      const { opts, self } = it;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules = self.RULES.keywords;
      for (const key in schema) {
        if (!rules[key])
          checkStrictMode(it, `unknown keyword: "${key}"`);
      }
    }
    exports.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules[key])
          return true;
      return false;
    }
    exports.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    exports.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs)
          f(x);
      } else {
        f(xs);
      }
    }
    exports.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    exports.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
    }
    exports.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type = exports.Type || (exports.Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it.self.logger.warn(msg);
    }
    exports.checkStrictMode = checkStrictMode;
  }
});

// node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "node_modules/ajv/dist/compile/names.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      errors: new codegen_1.Name("errors"),
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports.default = names;
  }
});

// node_modules/ajv/dist/compile/errors.js
var require_errors = __commonJS({
  "node_modules/ajv/dist/compile/errors.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    exports.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports.reportError = reportError;
    function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    exports.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
        if (it.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      const { gen, validateName, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword, data, schemaValue, it } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
    }
  }
});

// node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "node_modules/ajv/dist/compile/validate/boolSchema.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      const { gen, schema, validateName } = it;
      if (schema === false) {
        falseSchemaError(it, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen, schema } = it;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it);
      } else {
        gen.var(valid, true);
      }
    }
    exports.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen, data } = it;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "node_modules/ajv/dist/compile/rules.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRules = exports.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports.getRules = getRules;
  }
});

// node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "node_modules/ajv/dist/compile/validate/applicability.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self }, type) {
      const group = self.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a;
      return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
    }
    exports.shouldUseRule = shouldUseRule;
  }
});

// node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "node_modules/ajv/dist/compile/validate/dataType.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
    var rules_1 = require_rules();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType = exports.DataType || (exports.DataType = {}));
    function getSchemaTypes(schema) {
      const types = getJSONTypes(schema.type);
      const hasNull = types.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types.push("null");
      }
      return types;
    }
    exports.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
      const { gen, data, opts } = it;
      const coerceTo = coerceToTypes(types, opts.coerceTypes);
      const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it, types, coerceTo);
          else
            reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t2) => COERCIBLE.has(t2) || coerceTypes === "array" && t2 === "array") : [];
    }
    function coerceData(it, types, coerceTo) {
      const { gen, data, opts } = it;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t2 of coerceTo) {
        if (COERCIBLE.has(t2) || t2 === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t2);
        }
      }
      gen.else();
      reportTypeError(it);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t2) {
        switch (t2) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types.number)
        delete types.integer;
      for (const t2 in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t2, data, strictNums, correct));
      return cond;
    }
    exports.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen, data, schema } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
  }
});

// node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "node_modules/ajv/dist/compile/validate/defaults.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function assignDefaults(it, ty) {
      const { properties, items } = it.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    exports.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/code.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    var util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    exports.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
      if (alwaysValid && !it.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports.validateUnion = validateUnion;
  }
});

// node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "node_modules/ajv/dist/compile/validate/keyword.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword, schema, parentSchema, it } = cxt;
      const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
      const schemaRef = useKeyword(gen, keyword, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a;
      const { gen, keyword, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      const validate2 = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
      const validateRef = useKeyword(gen, keyword, validate2);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e2) => gen.assign(valid, false).if((0, codegen_1._)`${e2} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e2}.errors`), () => gen.throw(e2)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a2;
        gen.if((0, codegen_1.not)((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors);
      }
    }
    exports.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    exports.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
          const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    exports.validateKeywordUsage = validateKeywordUsage;
  }
});

// node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "node_modules/ajv/dist/compile/validate/subschema.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema.propertyName = propertyName;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports.extendSubschemaMode = extendSubschemaMode;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    module.exports = function equal(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length2, i, keys;
        if (Array.isArray(a)) {
          length2 = a.length;
          if (length2 != b.length)
            return false;
          for (i = length2; i-- !== 0; )
            if (!equal(a[i], b[i]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length2 = keys.length;
        if (length2 !== Object.keys(b).length)
          return false;
        for (i = length2; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        for (i = length2; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/json-schema-traverse/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var traverse = module.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse2(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse2(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse2(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse2(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse2(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "node_modules/ajv/dist/compile/resolve.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
    var util_1 = require_util();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema);
      if (!limit)
        return false;
      return countKeys(schema) <= limit;
    }
    exports.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      const p = resolver.parse(id);
      return _getFullPath(resolver, p);
    }
    exports.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      const serialized = resolver.serialize(p);
      return serialized.split("#")[0] + "#";
    }
    exports._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      id = normalizeId(id);
      return resolver.resolve(baseId, id);
    }
    exports.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let baseId2 = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          baseId2 = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = baseId2;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(baseId2 ? _resolve(baseId2, ref) : ref);
          if (schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports.getSchemaRefs = getSchemaRefs;
  }
});

// node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "node_modules/ajv/dist/compile/validate/index.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var errors_1 = require_errors();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      const { schema, opts, gen } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema, gen, opts } = it;
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
      const types = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
      schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema, errSchemaPath, opts, self } = it;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it) {
      const { schema, opts } = it;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self } = it;
      const { RULES } = self;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it, types);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it, group);
          if (types.length === 1 && types[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it, group) {
      const { gen, schema, opts: { useDefaults } } = it;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it, types) {
      if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
      checkContextTypes(it, types);
      if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types) {
      if (!types.length)
        return;
      if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
      }
      types.forEach((t2) => {
        if (!includesType(it.dataTypes, t2)) {
          strictTypesError(it, `type "${t2}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it, types);
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules = it.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          const { type } = rule.definition;
          if (type.length && !type.some((t2) => hasApplicableType(ts, t2))) {
            strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t2) {
      return ts.includes(t2) || t2 === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      const ts = [];
      for (const t2 of it.dataTypes) {
        if (includesType(withTypes, t2))
          ts.push(t2);
        else if (withTypes.includes("integer") && t2 === "number")
          ts.push("integer");
      }
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
          return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports.getData = getData;
  }
});

// node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "node_modules/ajv/dist/runtime/validation_error.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports.default = ValidationError;
  }
});

// node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "node_modules/ajv/dist/compile/ref_error.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var resolve_1 = require_resolve();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports.default = MissingRefError;
  }
});

// node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "node_modules/ajv/dist/compile/index.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
          schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate2 = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate2 });
        validate2.errors = null;
        validate2.schema = sch.schema;
        validate2.schemaEnv = sch;
        if (sch.$async)
          validate2.$async = true;
        if (this.opts.code.source === true) {
          validate2.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate2.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate2.source)
            validate2.source.evaluated = (0, codegen_1.stringify)(validate2.evaluated);
        }
        sch.validate = validate2;
        return sch;
      } catch (e2) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e2;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    exports.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      const p = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
      }
      const id = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p, schOrRef);
    }
    exports.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a;
      if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
  }
});

// node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "node_modules/ajv/dist/refs/data.json"(exports, module) {
    module.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "node_modules/ajv/dist/runtime/uri.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var uri = require_uri_all();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports.default = uri;
  }
});

// node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "node_modules/ajv/dist/core.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules();
    var compile_1 = require_compile();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve();
    var dataType_1 = require_dataType();
    var util_1 = require_util();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o2) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      const s = o2.strict;
      const _optz = (_a = o2.code) === null || _a === void 0 ? void 0 : _a.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o2.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o2.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o2.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o2.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o2.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o2.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o2.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
        code: o2.code ? { ...o2.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o2.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o2.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o2.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o2.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o2.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o2.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o2.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o2.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o2.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o2.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o2.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv2 = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e2) {
            if (!(e2 instanceof ref_error_1.default))
              throw e2;
            checkLoaded.call(this, e2);
            await loadMissingSchema.call(this, e2.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref) {
          const _schema = await _loadSchema.call(this, ref);
          if (!this.refs[ref])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref])
            this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
          const p = this._loading[ref];
          if (p)
            return p;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id = schema[schemaId];
          if (id !== void 0 && typeof id != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t2) => addRule.call(this, k, definition, t2)));
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format) {
        if (typeof format == "string")
          format = new RegExp(format);
        this.formats[name] = format;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e2) => `${dataVar}${e2.instancePath} ${e2.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
          throw new Error(`schema with key or id "${id}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    exports.default = Ajv2;
    Ajv2.ValidationError = validation_error_1.default;
    Ajv2.MissingRefError = ref_error_1.default;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format = this.opts.formats[name];
        if (format)
          this.addFormat(name, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
          def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === false)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword, definition, dataType) {
      var _a;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t2 }) => t2 === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition)
        return;
      const rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/id.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/ref.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.callRef = exports.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it } = cxt;
      const { allErrors, schemaEnv: env, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e2) => {
          gen.if((0, codegen_1._)`!(${e2} instanceof ${it.ValidationError})`, () => gen.throw(e2));
          addErrorsFrom(e2);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source2) {
        const errs = (0, codegen_1._)`${source2}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source2) {
        var _a;
        if (!it.opts.unevaluated)
          return;
        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source2}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source2}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
          }
        }
      }
    }
    exports.callRef = callRef;
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/index.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var id_1 = require_id();
    var ref_1 = require_ref();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports.default = core;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/ajv/dist/runtime/ucs2length.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length2 = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length2++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length2;
    }
    exports.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var ucs2length_1 = require_ucs2length();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/required.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "node_modules/ajv/dist/runtime/equal.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports.default = equal;
  }
});

// node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t2) => t2 === "object" || t2 === "array");
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/const.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/enum.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/index.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports.default = validation;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema, data, keyword, it } = cxt;
      it.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports.validateAdditionalItems = validateAdditionalItems;
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports.validateTuple = validateTuple;
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var items_1 = require_items();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    exports.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports.validateSchemaDeps = validateSchemaDeps;
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var util_2 = require_util();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/not.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/if.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else
              cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it, keyword) {
      const schema = it.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/index.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports.default = getApplicator;
  }
});

// node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/format.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self } = it;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/index.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var format_1 = require_format();
    var format = [format_1.default];
    exports.default = format;
  }
});

// node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "node_modules/ajv/dist/vocabularies/metadata.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.contentVocabulary = exports.metadataVocabulary = void 0;
    exports.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "node_modules/ajv/dist/vocabularies/draft7.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var core_1 = require_core2();
    var validation_1 = require_validation();
    var applicator_1 = require_applicator();
    var format_1 = require_format2();
    var metadata_1 = require_metadata();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports.default = draft7Vocabularies;
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError = exports.DiscrError || (exports.DiscrError = {}));
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
            }
            const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required }) {
            return Array.isArray(required) && required.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "node_modules/ajv/dist/ajv.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    var core_1 = require_core();
    var draft7_1 = require_draft7();
    var discriminator_1 = require_discriminator();
    var draft7MetaSchema = require_json_schema_draft_07();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv2 = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    module.exports = exports = Ajv2;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Ajv2;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// node_modules/@sphereon/ssi-types/dist/types/did.js
var require_did = __commonJS({
  "node_modules/@sphereon/ssi-types/dist/types/did.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseDid = exports.IProofType = exports.IProofPurpose = void 0;
    var IProofPurpose;
    (function(IProofPurpose2) {
      IProofPurpose2["verificationMethod"] = "verificationMethod";
      IProofPurpose2["assertionMethod"] = "assertionMethod";
      IProofPurpose2["authentication"] = "authentication";
      IProofPurpose2["keyAgreement"] = "keyAgreement";
      IProofPurpose2["contractAgreement"] = "contactAgreement";
      IProofPurpose2["capabilityInvocation"] = "capabilityInvocation";
      IProofPurpose2["capabilityDelegation"] = "capabilityDelegation";
    })(IProofPurpose = exports.IProofPurpose || (exports.IProofPurpose = {}));
    var IProofType2;
    (function(IProofType3) {
      IProofType3["Ed25519Signature2018"] = "Ed25519Signature2018";
      IProofType3["Ed25519Signature2020"] = "Ed25519Signature2020";
      IProofType3["EcdsaSecp256k1Signature2019"] = "EcdsaSecp256k1Signature2019";
      IProofType3["EcdsaSecp256k1RecoverySignature2020"] = "EcdsaSecp256k1RecoverySignature2020";
      IProofType3["JsonWebSignature2020"] = "JsonWebSignature2020";
      IProofType3["RsaSignature2018"] = "RsaSignature2018";
      IProofType3["GpgSignature2020"] = "GpgSignature2020";
      IProofType3["JcsEd25519Signature2020"] = "JcsEd25519Signature2020";
      IProofType3["BbsBlsSignatureProof2020"] = "BbsBlsSignatureProof2020";
      IProofType3["BbsBlsBoundSignatureProof2020"] = "BbsBlsBoundSignatureProof2020";
      IProofType3["JwtProof2020"] = "JwtProof2020";
    })(IProofType2 = exports.IProofType || (exports.IProofType = {}));
    var parseDid = (did) => {
      const parsedDid = parse2(did);
      if (parsedDid === null) {
        throw new Error("invalid did");
      }
      return parsedDid;
    };
    exports.parseDid = parseDid;
    var parse2 = (didUrl) => {
      const PCT_ENCODED = "(?:%[0-9a-fA-F]{2})";
      const ID_CHAR = `(?:[a-zA-Z0-9._-]|${PCT_ENCODED})`;
      const METHOD = "([a-z0-9]+)";
      const METHOD_ID = `((?:${ID_CHAR}*:)*(${ID_CHAR}+))`;
      const PARAM_CHAR = "[a-zA-Z0-9_.:%-]";
      const PARAM = `;${PARAM_CHAR}+=${PARAM_CHAR}*`;
      const PARAMS = `((${PARAM})*)`;
      const PATH = `(/[^#?]*)?`;
      const QUERY = `([?][^#]*)?`;
      const FRAGMENT = `(#.*)?`;
      const DID_MATCHER = new RegExp(`^did:${METHOD}:${METHOD_ID}${PARAMS}${PATH}${QUERY}${FRAGMENT}$`);
      if (didUrl === "" || !didUrl)
        return null;
      const sections = didUrl.match(DID_MATCHER);
      if (sections) {
        const parts = {
          did: `did:${sections[1]}:${sections[2]}`,
          method: sections[1],
          id: sections[2],
          didUrl
        };
        if (sections[4]) {
          const params = sections[4].slice(1).split(";");
          parts.params = {};
          for (const p of params) {
            const kv = p.split("=");
            parts.params[kv[0]] = kv[1];
          }
        }
        if (sections[6])
          parts.path = sections[6];
        if (sections[7])
          parts.query = sections[7].slice(1);
        if (sections[8])
          parts.fragment = sections[8].slice(1);
        return parts;
      }
      return null;
    };
  }
});

// node_modules/@sphereon/ssi-types/dist/types/pex.js
var require_pex = __commonJS({
  "node_modules/@sphereon/ssi-types/dist/types/pex.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/ssi-types/dist/types/vc.js
var require_vc = __commonJS({
  "node_modules/@sphereon/ssi-types/dist/types/vc.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JWT_PROOF_TYPE_2020 = exports.DocumentFormat = exports.OriginalType = void 0;
    var OriginalType;
    (function(OriginalType2) {
      OriginalType2["JSONLD"] = "json-ld";
      OriginalType2["JWT_ENCODED"] = "jwt-encoded";
      OriginalType2["JWT_DECODED"] = "jwt-decoded";
    })(OriginalType = exports.OriginalType || (exports.OriginalType = {}));
    var DocumentFormat;
    (function(DocumentFormat2) {
      DocumentFormat2[DocumentFormat2["JWT"] = 0] = "JWT";
      DocumentFormat2[DocumentFormat2["JSONLD"] = 1] = "JSONLD";
      DocumentFormat2[DocumentFormat2["EIP712"] = 2] = "EIP712";
    })(DocumentFormat = exports.DocumentFormat || (exports.DocumentFormat = {}));
    exports.JWT_PROOF_TYPE_2020 = "JwtProof2020";
  }
});

// node_modules/@sphereon/ssi-types/dist/types/generic.js
var require_generic = __commonJS({
  "node_modules/@sphereon/ssi-types/dist/types/generic.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/ssi-types/dist/types/index.js
var require_types2 = __commonJS({
  "node_modules/@sphereon/ssi-types/dist/types/index.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_did(), exports);
    __exportStar(require_pex(), exports);
    __exportStar(require_vc(), exports);
    __exportStar(require_generic(), exports);
  }
});

// node_modules/@sphereon/ssi-types/dist/utils/object.js
var require_object = __commonJS({
  "node_modules/@sphereon/ssi-types/dist/utils/object.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ObjectUtils = void 0;
    var ObjectUtils2 = class _ObjectUtils {
      static asArray(value) {
        return Array.isArray(value) ? value : [value];
      }
      static isObject(value) {
        return Object.prototype.toString.call(value) === "[object Object]";
      }
      static isUrlAbsolute(url) {
        const isAbsoluteRegex = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^\s]*$/;
        _ObjectUtils.isString(url) && isAbsoluteRegex.test(url);
      }
      static isString(value) {
        return typeof value === "string" || Object.prototype.toString.call(value) === "[object String]";
      }
    };
    exports.ObjectUtils = ObjectUtils2;
  }
});

// node_modules/@sphereon/ssi-types/dist/utils/index.js
var require_utils = __commonJS({
  "node_modules/@sphereon/ssi-types/dist/utils/index.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_object(), exports);
  }
});

// node_modules/@sphereon/ssi-types/node_modules/jwt-decode/build/jwt-decode.esm.js
var jwt_decode_esm_exports = {};
__export(jwt_decode_esm_exports, {
  InvalidTokenError: () => n,
  default: () => jwt_decode_esm_default
});
function e(e2) {
  this.message = e2;
}
function t(e2) {
  var t2 = e2.replace(/-/g, "+").replace(/_/g, "/");
  switch (t2.length % 4) {
    case 0:
      break;
    case 2:
      t2 += "==";
      break;
    case 3:
      t2 += "=";
      break;
    default:
      throw "Illegal base64url string!";
  }
  try {
    return function(e3) {
      return decodeURIComponent(r(e3).replace(/(.)/g, function(e4, r2) {
        var t3 = r2.charCodeAt(0).toString(16).toUpperCase();
        return t3.length < 2 && (t3 = "0" + t3), "%" + t3;
      }));
    }(t2);
  } catch (e3) {
    return r(t2);
  }
}
function n(e2) {
  this.message = e2;
}
function o(e2, r2) {
  if ("string" != typeof e2)
    throw new n("Invalid token specified");
  var o2 = true === (r2 = r2 || {}).header ? 0 : 1;
  try {
    return JSON.parse(t(e2.split(".")[o2]));
  } catch (e3) {
    throw new n("Invalid token specified: " + e3.message);
  }
}
var import_dist7, r, jwt_decode_esm_default;
var init_jwt_decode_esm = __esm({
  "node_modules/@sphereon/ssi-types/node_modules/jwt-decode/build/jwt-decode.esm.js"() {
    import_dist7 = __toESM(require_dist());
    e.prototype = new Error(), e.prototype.name = "InvalidCharacterError";
    r = "undefined" != typeof window && window.atob && window.atob.bind(window) || function(r2) {
      var t2 = String(r2).replace(/=+$/, "");
      if (t2.length % 4 == 1)
        throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
      for (var n2, o2, a = 0, i = 0, c = ""; o2 = t2.charAt(i++); ~o2 && (n2 = a % 4 ? 64 * n2 + o2 : o2, a++ % 4) ? c += String.fromCharCode(255 & n2 >> (-2 * a & 6)) : 0)
        o2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o2);
      return c;
    };
    n.prototype = new Error(), n.prototype.name = "InvalidTokenError";
    jwt_decode_esm_default = o;
  }
});

// node_modules/@sphereon/ssi-types/dist/mapper/credential-mapper.js
var require_credential_mapper = __commonJS({
  "node_modules/@sphereon/ssi-types/dist/mapper/credential-mapper.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var __rest = exports && exports.__rest || function(s, e2) {
      var t2 = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
          t2[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t2[p[i]] = s[p[i]];
        }
      return t2;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CredentialMapper = void 0;
    var types_1 = require_types2();
    var jwt_decode_1 = __importDefault((init_jwt_decode_esm(), __toCommonJS(jwt_decode_esm_exports)));
    var utils_1 = require_utils();
    var CredentialMapper3 = class _CredentialMapper {
      static decodeVerifiablePresentation(presentation) {
        var _a;
        if (_CredentialMapper.isJwtEncoded(presentation)) {
          const payload = (0, jwt_decode_1.default)(presentation);
          const header = (0, jwt_decode_1.default)(presentation, { header: true });
          payload.vp.proof = {
            type: types_1.IProofType.JwtProof2020,
            created: payload.nbf,
            proofPurpose: types_1.IProofPurpose.authentication,
            verificationMethod: (_a = header["kid"]) !== null && _a !== void 0 ? _a : payload.iss,
            jwt: presentation
          };
          return payload;
        } else if (_CredentialMapper.isJwtDecodedPresentation(presentation)) {
          return presentation;
        } else if (_CredentialMapper.isJsonLdAsString(presentation)) {
          return JSON.parse(presentation);
        } else {
          return presentation;
        }
      }
      static decodeVerifiableCredential(credential) {
        var _a;
        if (_CredentialMapper.isJwtEncoded(credential)) {
          const payload = (0, jwt_decode_1.default)(credential);
          const header = (0, jwt_decode_1.default)(credential, { header: true });
          payload.vc.proof = {
            type: types_1.IProofType.JwtProof2020,
            created: payload.nbf,
            proofPurpose: types_1.IProofPurpose.authentication,
            verificationMethod: (_a = header["kid"]) !== null && _a !== void 0 ? _a : payload.iss,
            jwt: credential
          };
          return payload;
        } else if (_CredentialMapper.isJwtDecodedCredential(credential)) {
          return credential;
        } else if (_CredentialMapper.isJsonLdAsString(credential)) {
          return JSON.parse(credential);
        } else {
          return credential;
        }
      }
      static toWrappedVerifiablePresentation(originalPresentation, opts) {
        const proof = _CredentialMapper.getFirstProof(originalPresentation);
        const original = typeof originalPresentation !== "string" && _CredentialMapper.hasJWTProofType(originalPresentation) ? proof === null || proof === void 0 ? void 0 : proof.jwt : originalPresentation;
        if (!original) {
          throw Error("Could not determine original presentation, probably it was a converted JWT presentation, that is now missing the JWT value in the proof");
        }
        const decoded = _CredentialMapper.decodeVerifiablePresentation(original);
        const isJwtEncoded = _CredentialMapper.isJwtEncoded(original);
        const isJwtDecoded = _CredentialMapper.isJwtDecodedPresentation(original);
        const type = isJwtEncoded ? types_1.OriginalType.JWT_ENCODED : isJwtDecoded ? types_1.OriginalType.JWT_DECODED : types_1.OriginalType.JSONLD;
        const format = isJwtDecoded || isJwtEncoded ? "jwt_vp" : "ldp_vp";
        let vp;
        if (isJwtEncoded || isJwtDecoded) {
          vp = _CredentialMapper.jwtDecodedPresentationToUniformPresentation(decoded, false, opts);
        } else {
          vp = decoded;
        }
        if (!vp || !("verifiableCredential" in vp) || !vp.verifiableCredential || vp.verifiableCredential.length === 0) {
          throw Error(`VP needs to have at least one verifiable credential at this point`);
        }
        const vcs = _CredentialMapper.toWrappedVerifiableCredentials(vp.verifiableCredential, opts);
        const presentation = Object.assign(Object.assign({}, vp), { verifiableCredential: vcs });
        return {
          type,
          format,
          original,
          decoded,
          presentation,
          vcs
        };
      }
      static toWrappedVerifiableCredentials(verifiableCredentials, opts) {
        return verifiableCredentials.map((vc) => _CredentialMapper.toWrappedVerifiableCredential(vc, opts));
      }
      static toWrappedVerifiableCredential(verifiableCredential, opts) {
        var _a;
        const proof = _CredentialMapper.getFirstProof(verifiableCredential);
        const original = _CredentialMapper.hasJWTProofType(verifiableCredential) && proof ? (_a = proof.jwt) !== null && _a !== void 0 ? _a : verifiableCredential : verifiableCredential;
        if (!original) {
          throw Error("Could not determine original credential, probably it was a converted JWT credential, that is now missing the JWT value in the proof");
        }
        const decoded = _CredentialMapper.decodeVerifiableCredential(original);
        const isJwtEncoded = _CredentialMapper.isJwtEncoded(original);
        const isJwtDecoded = _CredentialMapper.isJwtDecodedCredential(original);
        const type = isJwtEncoded ? types_1.OriginalType.JWT_ENCODED : isJwtDecoded ? types_1.OriginalType.JWT_DECODED : types_1.OriginalType.JSONLD;
        const credential = isJwtEncoded || isJwtDecoded ? _CredentialMapper.jwtDecodedCredentialToUniformCredential(decoded, opts) : decoded;
        const format = isJwtEncoded || isJwtDecoded ? "jwt_vc" : "ldp_vc";
        return {
          original,
          decoded,
          format,
          type,
          credential
        };
      }
      static isJwtEncoded(original) {
        return utils_1.ObjectUtils.isString(original) && original.startsWith("ey");
      }
      static isJsonLdAsString(original) {
        return utils_1.ObjectUtils.isString(original) && original.includes("@context");
      }
      static isJwtDecodedCredential(original) {
        return original["vc"] !== void 0 && original["iss"] !== void 0;
      }
      static isJwtDecodedPresentation(original) {
        return original["vp"] !== void 0 && original["iss"] !== void 0;
      }
      static jwtEncodedPresentationToUniformPresentation(jwt, makeCredentialsUniform = true, opts) {
        return _CredentialMapper.jwtDecodedPresentationToUniformPresentation((0, jwt_decode_1.default)(jwt), makeCredentialsUniform, opts);
      }
      static jwtDecodedPresentationToUniformPresentation(decoded, makeCredentialsUniform = true, opts) {
        const { iss, aud, jti, vp } = decoded, rest = __rest(decoded, ["iss", "aud", "jti", "vp"]);
        const presentation = Object.assign(Object.assign({}, rest), vp);
        if (makeCredentialsUniform) {
          if (!vp.verifiableCredential) {
            throw Error("Verifiable Presentation should have a verifiable credential at this point");
          }
          presentation.verifiableCredential = vp.verifiableCredential.map((vc) => _CredentialMapper.toUniformCredential(vc, opts));
        }
        if (iss) {
          const holder = presentation.holder;
          if (holder) {
            if (holder !== iss) {
              throw new Error(`Inconsistent holders between JWT claim (${iss}) and VC value (${holder})`);
            }
          }
          presentation.holder = iss;
        }
        if (aud) {
          const verifier = presentation.verifier;
          if (verifier) {
            if (verifier !== aud) {
              throw new Error(`Inconsistent holders between JWT claim (${aud}) and VC value (${verifier})`);
            }
          }
          presentation.verifier = aud;
        }
        if (jti) {
          const id = presentation.id;
          if (id && id !== jti) {
            throw new Error(`Inconsistent VP ids between JWT claim (${jti}) and VP value (${id})`);
          }
          presentation.id = jti;
        }
        return presentation;
      }
      static toUniformCredential(verifiableCredential, opts) {
        var _a;
        const original = typeof verifiableCredential !== "string" && _CredentialMapper.hasJWTProofType(verifiableCredential) ? (_a = _CredentialMapper.getFirstProof(verifiableCredential)) === null || _a === void 0 ? void 0 : _a.jwt : verifiableCredential;
        if (!original) {
          throw Error("Could not determine original credential from passed in credential. Probably because a JWT proof type was present, but now is not available anymore");
        }
        const decoded = _CredentialMapper.decodeVerifiableCredential(original);
        const isJwtEncoded = _CredentialMapper.isJwtEncoded(original);
        const isJwtDecoded = _CredentialMapper.isJwtDecodedCredential(original);
        if (isJwtDecoded || isJwtEncoded) {
          return _CredentialMapper.jwtDecodedCredentialToUniformCredential(decoded, opts);
        } else {
          return decoded;
        }
      }
      static toUniformPresentation(presentation, opts) {
        var _a;
        const proof = _CredentialMapper.getFirstProof(presentation);
        const original = typeof presentation !== "string" && _CredentialMapper.hasJWTProofType(presentation) ? proof === null || proof === void 0 ? void 0 : proof.jwt : presentation;
        if (!original) {
          throw Error("Could not determine original presentation, probably it was a converted JWT presentation, that is now missing the JWT value in the proof");
        }
        const decoded = _CredentialMapper.decodeVerifiablePresentation(original);
        const isJwtEncoded = _CredentialMapper.isJwtEncoded(original);
        const isJwtDecoded = _CredentialMapper.isJwtDecodedPresentation(original);
        const uniformPresentation = isJwtEncoded || isJwtDecoded ? _CredentialMapper.jwtDecodedPresentationToUniformPresentation(decoded, false) : decoded;
        if ((opts === null || opts === void 0 ? void 0 : opts.addContextIfMissing) && !uniformPresentation["@context"]) {
          uniformPresentation["@context"] = ["https://www.w3.org/2018/credentials/v1"];
        }
        uniformPresentation.verifiableCredential = (_a = uniformPresentation.verifiableCredential) === null || _a === void 0 ? void 0 : _a.map((vc) => _CredentialMapper.toUniformCredential(vc, opts));
        return uniformPresentation;
      }
      static jwtEncodedCredentialToUniformCredential(jwt, opts) {
        return _CredentialMapper.jwtDecodedCredentialToUniformCredential((0, jwt_decode_1.default)(jwt), opts);
      }
      static jwtDecodedCredentialToUniformCredential(decoded, opts) {
        const { exp, nbf, iss, vc, sub, jti } = decoded, rest = __rest(decoded, ["exp", "nbf", "iss", "vc", "sub", "jti"]);
        const credential = Object.assign(Object.assign({}, rest), vc);
        const maxSkewInMS = (opts === null || opts === void 0 ? void 0 : opts.maxTimeSkewInMS) !== void 0 ? opts.maxTimeSkewInMS : 999;
        if (exp) {
          const expDate = credential.expirationDate;
          const jwtExp = parseInt(exp.toString());
          const expDateAsStr = jwtExp < 9999999999 ? new Date(jwtExp * 1e3).toISOString().replace(/\.000Z/, "Z") : new Date(jwtExp).toISOString();
          if (expDate && expDate !== expDateAsStr) {
            const diff = Math.abs(new Date(expDateAsStr).getTime() - new Date(expDate).getTime());
            if (!maxSkewInMS || diff > maxSkewInMS) {
              throw new Error(`Inconsistent expiration dates between JWT claim (${expDateAsStr}) and VC value (${expDate})`);
            }
          }
          credential.expirationDate = expDateAsStr;
        }
        if (nbf) {
          const issuanceDate = credential.issuanceDate;
          const jwtNbf = parseInt(nbf.toString());
          const nbfDateAsStr = jwtNbf < 9999999999 ? new Date(jwtNbf * 1e3).toISOString().replace(/\.000Z/, "Z") : new Date(jwtNbf).toISOString();
          if (issuanceDate && issuanceDate !== nbfDateAsStr) {
            const diff = Math.abs(new Date(nbfDateAsStr).getTime() - new Date(issuanceDate).getTime());
            if (!maxSkewInMS || diff > maxSkewInMS) {
              throw new Error(`Inconsistent issuance dates between JWT claim (${nbfDateAsStr}) and VC value (${issuanceDate})`);
            }
          }
          credential.issuanceDate = nbfDateAsStr;
        }
        if (iss) {
          const issuer = credential.issuer;
          if (issuer) {
            if (typeof issuer === "string") {
              if (issuer !== iss) {
                throw new Error(`Inconsistent issuers between JWT claim (${iss}) and VC value (${issuer})`);
              }
            } else {
              if (issuer.id !== iss) {
                throw new Error(`Inconsistent issuers between JWT claim (${iss}) and VC value (${issuer.id})`);
              }
            }
          } else {
            credential.issuer = iss;
          }
        }
        if (sub) {
          const subjects = Array.isArray(credential.credentialSubject) ? credential.credentialSubject : [credential.credentialSubject];
          for (let i = 0; i < subjects.length; i++) {
            const csId = subjects[i].id;
            if (csId && csId !== sub) {
              throw new Error(`Inconsistent credential subject ids between JWT claim (${sub}) and VC value (${csId})`);
            }
            Array.isArray(credential.credentialSubject) ? credential.credentialSubject[i].id = sub : credential.credentialSubject.id = sub;
          }
        }
        if (jti) {
          const id = credential.id;
          if (id && id !== jti) {
            throw new Error(`Inconsistent credential ids between JWT claim (${jti}) and VC value (${id})`);
          }
          credential.id = jti;
        }
        return credential;
      }
      static toExternalVerifiableCredential(verifiableCredential) {
        let proof;
        if (verifiableCredential.proof) {
          if (!verifiableCredential.proof.type) {
            throw new Error("Verifiable credential proof is missing a type");
          }
          if (!verifiableCredential.proof.created) {
            throw new Error("Verifiable credential proof is missing a created date");
          }
          if (!verifiableCredential.proof.proofPurpose) {
            throw new Error("Verifiable credential proof is missing a proof purpose");
          }
          if (!verifiableCredential.proof.verificationMethod) {
            throw new Error("Verifiable credential proof is missing a verification method");
          }
          proof = Object.assign(Object.assign({}, verifiableCredential.proof), { type: verifiableCredential.proof.type, created: verifiableCredential.proof.created, proofPurpose: verifiableCredential.proof.proofPurpose, verificationMethod: verifiableCredential.proof.verificationMethod });
        }
        return Object.assign(Object.assign({}, verifiableCredential), { type: verifiableCredential.type ? typeof verifiableCredential.type === "string" ? [verifiableCredential.type] : verifiableCredential.type : ["VerifiableCredential"], proof });
      }
      static storedCredentialToOriginalFormat(credential) {
        const type = _CredentialMapper.detectDocumentType(credential);
        if (typeof credential === "string") {
          if (type === 0) {
            return _CredentialMapper.toCompactJWT(credential);
          } else if (type === 1) {
            return JSON.parse(credential);
          }
        }
        return credential;
      }
      static storedPresentationToOriginalFormat(presentation) {
        const type = _CredentialMapper.detectDocumentType(presentation);
        if (typeof presentation === "string") {
          if (type === 0) {
            return _CredentialMapper.toCompactJWT(presentation);
          } else if (type === 1) {
            return JSON.parse(presentation);
          }
        }
        return presentation;
      }
      static toCompactJWT(jwtDocument) {
        if (!jwtDocument || _CredentialMapper.detectDocumentType(jwtDocument) !== 0) {
          throw Error("Cannot convert non JWT credential to JWT");
        }
        if (typeof jwtDocument === "string") {
          return jwtDocument;
        }
        let proof;
        if ("vp" in jwtDocument) {
          proof = jwtDocument.vp.proof;
        } else if ("vc" in jwtDocument) {
          proof = jwtDocument.vc.proof;
        } else {
          proof = Array.isArray(jwtDocument.proof) ? jwtDocument.proof[0].jwt : jwtDocument.proof.jwt;
        }
        if (!proof) {
          throw Error(`Could not get JWT from supplied document`);
        }
        return proof;
      }
      static detectDocumentType(document2) {
        if (typeof document2 === "string") {
          return this.isJsonLdAsString(document2) ? 1 : 0;
        }
        const proofs = "vc" in document2 ? document2.vc.proof : "vp" in document2 ? document2.vp.proof : document2.proof;
        const proof = Array.isArray(proofs) ? proofs[0] : proofs;
        if (proof === null || proof === void 0 ? void 0 : proof.jwt) {
          return 0;
        } else if ((proof === null || proof === void 0 ? void 0 : proof.type) === "EthereumEip712Signature2021") {
          return 2;
        }
        return 1;
      }
      static hasJWTProofType(document2) {
        var _a;
        if (typeof document2 === "string") {
          return false;
        }
        return !!((_a = _CredentialMapper.getFirstProof(document2)) === null || _a === void 0 ? void 0 : _a.jwt);
      }
      static getFirstProof(document2) {
        if (!document2 || typeof document2 === "string") {
          return void 0;
        }
        const proofs = "vc" in document2 ? document2.vc.proof : "vp" in document2 ? document2.vp.proof : document2.proof;
        return Array.isArray(proofs) ? proofs[0] : proofs;
      }
    };
    exports.CredentialMapper = CredentialMapper3;
  }
});

// node_modules/@sphereon/ssi-types/dist/mapper/index.js
var require_mapper = __commonJS({
  "node_modules/@sphereon/ssi-types/dist/mapper/index.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_credential_mapper(), exports);
  }
});

// node_modules/@sphereon/ssi-types/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@sphereon/ssi-types/dist/index.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_types2(), exports);
    __exportStar(require_utils(), exports);
    __exportStar(require_mapper(), exports);
  }
});

// node_modules/escodegen/node_modules/estraverse/package.json
var require_package = __commonJS({
  "node_modules/escodegen/node_modules/estraverse/package.json"(exports, module) {
    module.exports = {
      name: "estraverse",
      description: "ECMAScript JS AST traversal functions",
      homepage: "https://github.com/estools/estraverse",
      main: "estraverse.js",
      version: "4.3.0",
      engines: {
        node: ">=4.0"
      },
      maintainers: [
        {
          name: "Yusuke Suzuki",
          email: "utatane.tea@gmail.com",
          web: "http://github.com/Constellation"
        }
      ],
      repository: {
        type: "git",
        url: "http://github.com/estools/estraverse.git"
      },
      devDependencies: {
        "babel-preset-env": "^1.6.1",
        "babel-register": "^6.3.13",
        chai: "^2.1.1",
        espree: "^1.11.0",
        gulp: "^3.8.10",
        "gulp-bump": "^0.2.2",
        "gulp-filter": "^2.0.0",
        "gulp-git": "^1.0.1",
        "gulp-tag-version": "^1.3.0",
        jshint: "^2.5.6",
        mocha: "^2.1.0"
      },
      license: "BSD-2-Clause",
      scripts: {
        test: "npm run-script lint && npm run-script unit-test",
        lint: "jshint estraverse.js",
        "unit-test": "mocha --compilers js:babel-register"
      }
    };
  }
});

// node_modules/escodegen/node_modules/estraverse/estraverse.js
var require_estraverse = __commonJS({
  "node_modules/escodegen/node_modules/estraverse/estraverse.js"(exports) {
    var import_dist68 = __toESM(require_dist());
    (function clone(exports2) {
      "use strict";
      var Syntax2, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE;
      function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            val = obj[key];
            if (typeof val === "object" && val !== null) {
              ret[key] = deepCopy(val);
            } else {
              ret[key] = val;
            }
          }
        }
        return ret;
      }
      function upperBound(array, func) {
        var diff, len, i, current;
        len = array.length;
        i = 0;
        while (len) {
          diff = len >>> 1;
          current = i + diff;
          if (func(array[current])) {
            len = diff;
          } else {
            i = current + 1;
            len -= diff + 1;
          }
        }
        return i;
      }
      Syntax2 = {
        AssignmentExpression: "AssignmentExpression",
        AssignmentPattern: "AssignmentPattern",
        ArrayExpression: "ArrayExpression",
        ArrayPattern: "ArrayPattern",
        ArrowFunctionExpression: "ArrowFunctionExpression",
        AwaitExpression: "AwaitExpression",
        // CAUTION: It's deferred to ES7.
        BlockStatement: "BlockStatement",
        BinaryExpression: "BinaryExpression",
        BreakStatement: "BreakStatement",
        CallExpression: "CallExpression",
        CatchClause: "CatchClause",
        ClassBody: "ClassBody",
        ClassDeclaration: "ClassDeclaration",
        ClassExpression: "ClassExpression",
        ComprehensionBlock: "ComprehensionBlock",
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: "ComprehensionExpression",
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: "ConditionalExpression",
        ContinueStatement: "ContinueStatement",
        DebuggerStatement: "DebuggerStatement",
        DirectiveStatement: "DirectiveStatement",
        DoWhileStatement: "DoWhileStatement",
        EmptyStatement: "EmptyStatement",
        ExportAllDeclaration: "ExportAllDeclaration",
        ExportDefaultDeclaration: "ExportDefaultDeclaration",
        ExportNamedDeclaration: "ExportNamedDeclaration",
        ExportSpecifier: "ExportSpecifier",
        ExpressionStatement: "ExpressionStatement",
        ForStatement: "ForStatement",
        ForInStatement: "ForInStatement",
        ForOfStatement: "ForOfStatement",
        FunctionDeclaration: "FunctionDeclaration",
        FunctionExpression: "FunctionExpression",
        GeneratorExpression: "GeneratorExpression",
        // CAUTION: It's deferred to ES7.
        Identifier: "Identifier",
        IfStatement: "IfStatement",
        ImportExpression: "ImportExpression",
        ImportDeclaration: "ImportDeclaration",
        ImportDefaultSpecifier: "ImportDefaultSpecifier",
        ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
        ImportSpecifier: "ImportSpecifier",
        Literal: "Literal",
        LabeledStatement: "LabeledStatement",
        LogicalExpression: "LogicalExpression",
        MemberExpression: "MemberExpression",
        MetaProperty: "MetaProperty",
        MethodDefinition: "MethodDefinition",
        ModuleSpecifier: "ModuleSpecifier",
        NewExpression: "NewExpression",
        ObjectExpression: "ObjectExpression",
        ObjectPattern: "ObjectPattern",
        Program: "Program",
        Property: "Property",
        RestElement: "RestElement",
        ReturnStatement: "ReturnStatement",
        SequenceExpression: "SequenceExpression",
        SpreadElement: "SpreadElement",
        Super: "Super",
        SwitchStatement: "SwitchStatement",
        SwitchCase: "SwitchCase",
        TaggedTemplateExpression: "TaggedTemplateExpression",
        TemplateElement: "TemplateElement",
        TemplateLiteral: "TemplateLiteral",
        ThisExpression: "ThisExpression",
        ThrowStatement: "ThrowStatement",
        TryStatement: "TryStatement",
        UnaryExpression: "UnaryExpression",
        UpdateExpression: "UpdateExpression",
        VariableDeclaration: "VariableDeclaration",
        VariableDeclarator: "VariableDeclarator",
        WhileStatement: "WhileStatement",
        WithStatement: "WithStatement",
        YieldExpression: "YieldExpression"
      };
      VisitorKeys = {
        AssignmentExpression: ["left", "right"],
        AssignmentPattern: ["left", "right"],
        ArrayExpression: ["elements"],
        ArrayPattern: ["elements"],
        ArrowFunctionExpression: ["params", "body"],
        AwaitExpression: ["argument"],
        // CAUTION: It's deferred to ES7.
        BlockStatement: ["body"],
        BinaryExpression: ["left", "right"],
        BreakStatement: ["label"],
        CallExpression: ["callee", "arguments"],
        CatchClause: ["param", "body"],
        ClassBody: ["body"],
        ClassDeclaration: ["id", "superClass", "body"],
        ClassExpression: ["id", "superClass", "body"],
        ComprehensionBlock: ["left", "right"],
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: ["test", "consequent", "alternate"],
        ContinueStatement: ["label"],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ["body", "test"],
        EmptyStatement: [],
        ExportAllDeclaration: ["source"],
        ExportDefaultDeclaration: ["declaration"],
        ExportNamedDeclaration: ["declaration", "specifiers", "source"],
        ExportSpecifier: ["exported", "local"],
        ExpressionStatement: ["expression"],
        ForStatement: ["init", "test", "update", "body"],
        ForInStatement: ["left", "right", "body"],
        ForOfStatement: ["left", "right", "body"],
        FunctionDeclaration: ["id", "params", "body"],
        FunctionExpression: ["id", "params", "body"],
        GeneratorExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ["test", "consequent", "alternate"],
        ImportExpression: ["source"],
        ImportDeclaration: ["specifiers", "source"],
        ImportDefaultSpecifier: ["local"],
        ImportNamespaceSpecifier: ["local"],
        ImportSpecifier: ["imported", "local"],
        Literal: [],
        LabeledStatement: ["label", "body"],
        LogicalExpression: ["left", "right"],
        MemberExpression: ["object", "property"],
        MetaProperty: ["meta", "property"],
        MethodDefinition: ["key", "value"],
        ModuleSpecifier: [],
        NewExpression: ["callee", "arguments"],
        ObjectExpression: ["properties"],
        ObjectPattern: ["properties"],
        Program: ["body"],
        Property: ["key", "value"],
        RestElement: ["argument"],
        ReturnStatement: ["argument"],
        SequenceExpression: ["expressions"],
        SpreadElement: ["argument"],
        Super: [],
        SwitchStatement: ["discriminant", "cases"],
        SwitchCase: ["test", "consequent"],
        TaggedTemplateExpression: ["tag", "quasi"],
        TemplateElement: [],
        TemplateLiteral: ["quasis", "expressions"],
        ThisExpression: [],
        ThrowStatement: ["argument"],
        TryStatement: ["block", "handler", "finalizer"],
        UnaryExpression: ["argument"],
        UpdateExpression: ["argument"],
        VariableDeclaration: ["declarations"],
        VariableDeclarator: ["id", "init"],
        WhileStatement: ["test", "body"],
        WithStatement: ["object", "body"],
        YieldExpression: ["argument"]
      };
      BREAK = {};
      SKIP = {};
      REMOVE = {};
      VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE
      };
      function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
      }
      Reference.prototype.replace = function replace2(node) {
        this.parent[this.key] = node;
      };
      Reference.prototype.remove = function remove() {
        if (Array.isArray(this.parent)) {
          this.parent.splice(this.key, 1);
          return true;
        } else {
          this.replace(null);
          return false;
        }
      };
      function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
      }
      function Controller() {
      }
      Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;
        function addToPath(result2, path2) {
          if (Array.isArray(path2)) {
            for (j = 0, jz = path2.length; j < jz; ++j) {
              result2.push(path2[j]);
            }
          } else {
            result2.push(path2);
          }
        }
        if (!this.__current.path) {
          return null;
        }
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
          element = this.__leavelist[i];
          addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
      };
      Controller.prototype.type = function() {
        var node = this.current();
        return node.type || this.__current.wrap;
      };
      Controller.prototype.parents = function parents() {
        var i, iz, result;
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
          result.push(this.__leavelist[i].node);
        }
        return result;
      };
      Controller.prototype.current = function current() {
        return this.__current.node;
      };
      Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;
        result = void 0;
        previous = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
          result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;
        return result;
      };
      Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
      };
      Controller.prototype.skip = function() {
        this.notify(SKIP);
      };
      Controller.prototype["break"] = function() {
        this.notify(BREAK);
      };
      Controller.prototype.remove = function() {
        this.notify(REMOVE);
      };
      Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
        this.__fallback = null;
        if (visitor.fallback === "iteration") {
          this.__fallback = Object.keys;
        } else if (typeof visitor.fallback === "function") {
          this.__fallback = visitor.fallback;
        }
        this.__keys = VisitorKeys;
        if (visitor.keys) {
          this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
        }
      };
      function isNode(node) {
        if (node == null) {
          return false;
        }
        return typeof node === "object" && typeof node.type === "string";
      }
      function isProperty(nodeType, key) {
        return (nodeType === Syntax2.ObjectExpression || nodeType === Syntax2.ObjectPattern) && "properties" === key;
      }
      Controller.prototype.traverse = function traverse2(root, visitor) {
        var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));
        while (worklist.length) {
          element = worklist.pop();
          if (element === sentinel) {
            element = leavelist.pop();
            ret = this.__execute(visitor.leave, element);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            continue;
          }
          if (element.node) {
            ret = this.__execute(visitor.enter, element);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            worklist.push(sentinel);
            leavelist.push(element);
            if (this.__state === SKIP || ret === SKIP) {
              continue;
            }
            node = element.node;
            nodeType = node.type || element.wrap;
            candidates = this.__keys[nodeType];
            if (!candidates) {
              if (this.__fallback) {
                candidates = this.__fallback(node);
              } else {
                throw new Error("Unknown node type " + nodeType + ".");
              }
            }
            current = candidates.length;
            while ((current -= 1) >= 0) {
              key = candidates[current];
              candidate = node[key];
              if (!candidate) {
                continue;
              }
              if (Array.isArray(candidate)) {
                current2 = candidate.length;
                while ((current2 -= 1) >= 0) {
                  if (!candidate[current2]) {
                    continue;
                  }
                  if (isProperty(nodeType, candidates[current])) {
                    element = new Element(candidate[current2], [key, current2], "Property", null);
                  } else if (isNode(candidate[current2])) {
                    element = new Element(candidate[current2], [key, current2], null, null);
                  } else {
                    continue;
                  }
                  worklist.push(element);
                }
              } else if (isNode(candidate)) {
                worklist.push(new Element(candidate, key, null, null));
              }
            }
          }
        }
      };
      Controller.prototype.replace = function replace2(root, visitor) {
        var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;
        function removeElem(element2) {
          var i, key2, nextElem, parent;
          if (element2.ref.remove()) {
            key2 = element2.ref.key;
            parent = element2.ref.parent;
            i = worklist.length;
            while (i--) {
              nextElem = worklist[i];
              if (nextElem.ref && nextElem.ref.parent === parent) {
                if (nextElem.ref.key < key2) {
                  break;
                }
                --nextElem.ref.key;
              }
            }
          }
        }
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        outer = {
          root
        };
        element = new Element(root, null, null, new Reference(outer, "root"));
        worklist.push(element);
        leavelist.push(element);
        while (worklist.length) {
          element = worklist.pop();
          if (element === sentinel) {
            element = leavelist.pop();
            target = this.__execute(visitor.leave, element);
            if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE) {
              element.ref.replace(target);
            }
            if (this.__state === REMOVE || target === REMOVE) {
              removeElem(element);
            }
            if (this.__state === BREAK || target === BREAK) {
              return outer.root;
            }
            continue;
          }
          target = this.__execute(visitor.enter, element);
          if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE) {
            element.ref.replace(target);
            element.node = target;
          }
          if (this.__state === REMOVE || target === REMOVE) {
            removeElem(element);
            element.node = null;
          }
          if (this.__state === BREAK || target === BREAK) {
            return outer.root;
          }
          node = element.node;
          if (!node) {
            continue;
          }
          worklist.push(sentinel);
          leavelist.push(element);
          if (this.__state === SKIP || target === SKIP) {
            continue;
          }
          nodeType = node.type || element.wrap;
          candidates = this.__keys[nodeType];
          if (!candidates) {
            if (this.__fallback) {
              candidates = this.__fallback(node);
            } else {
              throw new Error("Unknown node type " + nodeType + ".");
            }
          }
          current = candidates.length;
          while ((current -= 1) >= 0) {
            key = candidates[current];
            candidate = node[key];
            if (!candidate) {
              continue;
            }
            if (Array.isArray(candidate)) {
              current2 = candidate.length;
              while ((current2 -= 1) >= 0) {
                if (!candidate[current2]) {
                  continue;
                }
                if (isProperty(nodeType, candidates[current])) {
                  element = new Element(candidate[current2], [key, current2], "Property", new Reference(candidate, current2));
                } else if (isNode(candidate[current2])) {
                  element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                } else {
                  continue;
                }
                worklist.push(element);
              }
            } else if (isNode(candidate)) {
              worklist.push(new Element(candidate, key, null, new Reference(node, key)));
            }
          }
        }
        return outer.root;
      };
      function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
      }
      function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
      }
      function extendCommentRange(comment, tokens) {
        var target;
        target = upperBound(tokens, function search(token) {
          return token.range[0] > comment.range[0];
        });
        comment.extendedRange = [comment.range[0], comment.range[1]];
        if (target !== tokens.length) {
          comment.extendedRange[1] = tokens[target].range[0];
        }
        target -= 1;
        if (target >= 0) {
          comment.extendedRange[0] = tokens[target].range[1];
        }
        return comment;
      }
      function attachComments(tree, providedComments, tokens) {
        var comments = [], comment, len, i, cursor;
        if (!tree.range) {
          throw new Error("attachComments needs range information");
        }
        if (!tokens.length) {
          if (providedComments.length) {
            for (i = 0, len = providedComments.length; i < len; i += 1) {
              comment = deepCopy(providedComments[i]);
              comment.extendedRange = [0, tree.range[0]];
              comments.push(comment);
            }
            tree.leadingComments = comments;
          }
          return tree;
        }
        for (i = 0, len = providedComments.length; i < len; i += 1) {
          comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }
        cursor = 0;
        traverse(tree, {
          enter: function(node) {
            var comment2;
            while (cursor < comments.length) {
              comment2 = comments[cursor];
              if (comment2.extendedRange[1] > node.range[0]) {
                break;
              }
              if (comment2.extendedRange[1] === node.range[0]) {
                if (!node.leadingComments) {
                  node.leadingComments = [];
                }
                node.leadingComments.push(comment2);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        cursor = 0;
        traverse(tree, {
          leave: function(node) {
            var comment2;
            while (cursor < comments.length) {
              comment2 = comments[cursor];
              if (node.range[1] < comment2.extendedRange[0]) {
                break;
              }
              if (node.range[1] === comment2.extendedRange[0]) {
                if (!node.trailingComments) {
                  node.trailingComments = [];
                }
                node.trailingComments.push(comment2);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        return tree;
      }
      exports2.version = require_package().version;
      exports2.Syntax = Syntax2;
      exports2.traverse = traverse;
      exports2.replace = replace;
      exports2.attachComments = attachComments;
      exports2.VisitorKeys = VisitorKeys;
      exports2.VisitorOption = VisitorOption;
      exports2.Controller = Controller;
      exports2.cloneEnvironment = function() {
        return clone({});
      };
      return exports2;
    })(exports);
  }
});

// node_modules/esutils/lib/ast.js
var require_ast = __commonJS({
  "node_modules/esutils/lib/ast.js"(exports, module) {
    var import_dist68 = __toESM(require_dist());
    (function() {
      "use strict";
      function isExpression(node) {
        if (node == null) {
          return false;
        }
        switch (node.type) {
          case "ArrayExpression":
          case "AssignmentExpression":
          case "BinaryExpression":
          case "CallExpression":
          case "ConditionalExpression":
          case "FunctionExpression":
          case "Identifier":
          case "Literal":
          case "LogicalExpression":
          case "MemberExpression":
          case "NewExpression":
          case "ObjectExpression":
          case "SequenceExpression":
          case "ThisExpression":
          case "UnaryExpression":
          case "UpdateExpression":
            return true;
        }
        return false;
      }
      function isIterationStatement(node) {
        if (node == null) {
          return false;
        }
        switch (node.type) {
          case "DoWhileStatement":
          case "ForInStatement":
          case "ForStatement":
          case "WhileStatement":
            return true;
        }
        return false;
      }
      function isStatement(node) {
        if (node == null) {
          return false;
        }
        switch (node.type) {
          case "BlockStatement":
          case "BreakStatement":
          case "ContinueStatement":
          case "DebuggerStatement":
          case "DoWhileStatement":
          case "EmptyStatement":
          case "ExpressionStatement":
          case "ForInStatement":
          case "ForStatement":
          case "IfStatement":
          case "LabeledStatement":
          case "ReturnStatement":
          case "SwitchStatement":
          case "ThrowStatement":
          case "TryStatement":
          case "VariableDeclaration":
          case "WhileStatement":
          case "WithStatement":
            return true;
        }
        return false;
      }
      function isSourceElement(node) {
        return isStatement(node) || node != null && node.type === "FunctionDeclaration";
      }
      function trailingStatement(node) {
        switch (node.type) {
          case "IfStatement":
            if (node.alternate != null) {
              return node.alternate;
            }
            return node.consequent;
          case "LabeledStatement":
          case "ForStatement":
          case "ForInStatement":
          case "WhileStatement":
          case "WithStatement":
            return node.body;
        }
        return null;
      }
      function isProblematicIfStatement(node) {
        var current;
        if (node.type !== "IfStatement") {
          return false;
        }
        if (node.alternate == null) {
          return false;
        }
        current = node.consequent;
        do {
          if (current.type === "IfStatement") {
            if (current.alternate == null) {
              return true;
            }
          }
          current = trailingStatement(current);
        } while (current);
        return false;
      }
      module.exports = {
        isExpression,
        isStatement,
        isIterationStatement,
        isSourceElement,
        isProblematicIfStatement,
        trailingStatement
      };
    })();
  }
});

// node_modules/esutils/lib/code.js
var require_code3 = __commonJS({
  "node_modules/esutils/lib/code.js"(exports, module) {
    var import_dist68 = __toESM(require_dist());
    (function() {
      "use strict";
      var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;
      ES5Regex = {
        // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
        // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
      };
      ES6Regex = {
        // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
        // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
      };
      function isDecimalDigit2(ch2) {
        return 48 <= ch2 && ch2 <= 57;
      }
      function isHexDigit2(ch2) {
        return 48 <= ch2 && ch2 <= 57 || // 0..9
        97 <= ch2 && ch2 <= 102 || // a..f
        65 <= ch2 && ch2 <= 70;
      }
      function isOctalDigit2(ch2) {
        return ch2 >= 48 && ch2 <= 55;
      }
      NON_ASCII_WHITESPACES = [
        5760,
        8192,
        8193,
        8194,
        8195,
        8196,
        8197,
        8198,
        8199,
        8200,
        8201,
        8202,
        8239,
        8287,
        12288,
        65279
      ];
      function isWhiteSpace2(ch2) {
        return ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && NON_ASCII_WHITESPACES.indexOf(ch2) >= 0;
      }
      function isLineTerminator2(ch2) {
        return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233;
      }
      function fromCodePoint(cp) {
        if (cp <= 65535) {
          return String.fromCharCode(cp);
        }
        var cu1 = String.fromCharCode(Math.floor((cp - 65536) / 1024) + 55296);
        var cu2 = String.fromCharCode((cp - 65536) % 1024 + 56320);
        return cu1 + cu2;
      }
      IDENTIFIER_START = new Array(128);
      for (ch = 0; ch < 128; ++ch) {
        IDENTIFIER_START[ch] = ch >= 97 && ch <= 122 || // a..z
        ch >= 65 && ch <= 90 || // A..Z
        ch === 36 || ch === 95;
      }
      IDENTIFIER_PART = new Array(128);
      for (ch = 0; ch < 128; ++ch) {
        IDENTIFIER_PART[ch] = ch >= 97 && ch <= 122 || // a..z
        ch >= 65 && ch <= 90 || // A..Z
        ch >= 48 && ch <= 57 || // 0..9
        ch === 36 || ch === 95;
      }
      function isIdentifierStartES5(ch2) {
        return ch2 < 128 ? IDENTIFIER_START[ch2] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch2));
      }
      function isIdentifierPartES5(ch2) {
        return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch2));
      }
      function isIdentifierStartES6(ch2) {
        return ch2 < 128 ? IDENTIFIER_START[ch2] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch2));
      }
      function isIdentifierPartES6(ch2) {
        return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch2));
      }
      module.exports = {
        isDecimalDigit: isDecimalDigit2,
        isHexDigit: isHexDigit2,
        isOctalDigit: isOctalDigit2,
        isWhiteSpace: isWhiteSpace2,
        isLineTerminator: isLineTerminator2,
        isIdentifierStartES5,
        isIdentifierPartES5,
        isIdentifierStartES6,
        isIdentifierPartES6
      };
    })();
  }
});

// node_modules/esutils/lib/keyword.js
var require_keyword2 = __commonJS({
  "node_modules/esutils/lib/keyword.js"(exports, module) {
    var import_dist68 = __toESM(require_dist());
    (function() {
      "use strict";
      var code = require_code3();
      function isStrictModeReservedWordES6(id) {
        switch (id) {
          case "implements":
          case "interface":
          case "package":
          case "private":
          case "protected":
          case "public":
          case "static":
          case "let":
            return true;
          default:
            return false;
        }
      }
      function isKeywordES5(id, strict2) {
        if (!strict2 && id === "yield") {
          return false;
        }
        return isKeywordES6(id, strict2);
      }
      function isKeywordES6(id, strict2) {
        if (strict2 && isStrictModeReservedWordES6(id)) {
          return true;
        }
        switch (id.length) {
          case 2:
            return id === "if" || id === "in" || id === "do";
          case 3:
            return id === "var" || id === "for" || id === "new" || id === "try";
          case 4:
            return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
          case 5:
            return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
          case 6:
            return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
          case 7:
            return id === "default" || id === "finally" || id === "extends";
          case 8:
            return id === "function" || id === "continue" || id === "debugger";
          case 10:
            return id === "instanceof";
          default:
            return false;
        }
      }
      function isReservedWordES5(id, strict2) {
        return id === "null" || id === "true" || id === "false" || isKeywordES5(id, strict2);
      }
      function isReservedWordES6(id, strict2) {
        return id === "null" || id === "true" || id === "false" || isKeywordES6(id, strict2);
      }
      function isRestrictedWord2(id) {
        return id === "eval" || id === "arguments";
      }
      function isIdentifierNameES5(id) {
        var i, iz, ch;
        if (id.length === 0) {
          return false;
        }
        ch = id.charCodeAt(0);
        if (!code.isIdentifierStartES5(ch)) {
          return false;
        }
        for (i = 1, iz = id.length; i < iz; ++i) {
          ch = id.charCodeAt(i);
          if (!code.isIdentifierPartES5(ch)) {
            return false;
          }
        }
        return true;
      }
      function decodeUtf16(lead, trail) {
        return (lead - 55296) * 1024 + (trail - 56320) + 65536;
      }
      function isIdentifierNameES6(id) {
        var i, iz, ch, lowCh, check;
        if (id.length === 0) {
          return false;
        }
        check = code.isIdentifierStartES6;
        for (i = 0, iz = id.length; i < iz; ++i) {
          ch = id.charCodeAt(i);
          if (55296 <= ch && ch <= 56319) {
            ++i;
            if (i >= iz) {
              return false;
            }
            lowCh = id.charCodeAt(i);
            if (!(56320 <= lowCh && lowCh <= 57343)) {
              return false;
            }
            ch = decodeUtf16(ch, lowCh);
          }
          if (!check(ch)) {
            return false;
          }
          check = code.isIdentifierPartES6;
        }
        return true;
      }
      function isIdentifierES5(id, strict2) {
        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict2);
      }
      function isIdentifierES6(id, strict2) {
        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict2);
      }
      module.exports = {
        isKeywordES5,
        isKeywordES6,
        isReservedWordES5,
        isReservedWordES6,
        isRestrictedWord: isRestrictedWord2,
        isIdentifierNameES5,
        isIdentifierNameES6,
        isIdentifierES5,
        isIdentifierES6
      };
    })();
  }
});

// node_modules/esutils/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/esutils/lib/utils.js"(exports) {
    var import_dist68 = __toESM(require_dist());
    (function() {
      "use strict";
      exports.ast = require_ast();
      exports.code = require_code3();
      exports.keyword = require_keyword2();
    })();
  }
});

// node_modules/source-map/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/source-map/lib/base64.js"(exports) {
    var import_dist68 = __toESM(require_dist());
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "node_modules/source-map/lib/base64-vlq.js"(exports) {
    var import_dist68 = __toESM(require_dist());
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// node_modules/source-map/lib/util.js
var require_util2 = __commonJS({
  "node_modules/source-map/lib/util.js"(exports) {
    var import_dist68 = __toESM(require_dist());
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match2 = aUrl.match(urlRegexp);
      if (!match2) {
        return null;
      }
      return {
        scheme: match2[1],
        auth: match2[2],
        host: match2[3],
        port: match2[4],
        path: match2[5]
      };
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports.isAbsolute(path);
      var parts = path.split(/\/+/);
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    }
    exports.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports.join = join;
    exports.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index2 = aRoot.lastIndexOf("/");
        if (index2 < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index2);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length2 = s.length;
      if (length2 < 9) {
        return false;
      }
      if (s.charCodeAt(length2 - 1) !== 95 || s.charCodeAt(length2 - 2) !== 95 || s.charCodeAt(length2 - 3) !== 111 || s.charCodeAt(length2 - 4) !== 116 || s.charCodeAt(length2 - 5) !== 111 || s.charCodeAt(length2 - 6) !== 114 || s.charCodeAt(length2 - 7) !== 112 || s.charCodeAt(length2 - 8) !== 95 || s.charCodeAt(length2 - 9) !== 95) {
        return false;
      }
      for (var i = length2 - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index2 = parsed.path.lastIndexOf("/");
          if (index2 >= 0) {
            parsed.path = parsed.path.substring(0, index2 + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports.computeSourceURL = computeSourceURL;
  }
});

// node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS({
  "node_modules/source-map/lib/array-set.js"(exports) {
    var import_dist68 = __toESM(require_dist());
    var util = require_util2();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports.ArraySet = ArraySet;
  }
});

// node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "node_modules/source-map/lib/mapping-list.js"(exports) {
    var import_dist68 = __toESM(require_dist());
    var util = require_util2();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports.MappingList = MappingList;
  }
});

// node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "node_modules/source-map/lib/source-map-generator.js"(exports) {
    var import_dist68 = __toESM(require_dist());
    var base64VLQ = require_base64_vlq();
    var util = require_util2();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source2 = util.getArg(aArgs, "source", null);
      var name = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source2, name);
      }
      if (source2 != null) {
        source2 = String(source2);
        if (!this._sources.has(source2)) {
          this._sources.add(source2);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source2,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source2 = aSourceFile;
      if (this._sourceRoot != null) {
        source2 = util.relative(this._sourceRoot, source2);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util.toSetString(source2)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source2)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source2 = mapping.source;
        if (source2 != null && !newSources.has(source2)) {
          newSources.add(source2);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error(
          "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
        );
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source2) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source2 = util.relative(aSourceRoot, source2);
        }
        var key = util.toSetString(source2);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports.SourceMapGenerator = SourceMapGenerator;
  }
});

// node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS({
  "node_modules/source-map/lib/binary-search.js"(exports) {
    var import_dist68 = __toESM(require_dist());
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index2 = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports.GREATEST_LOWER_BOUND
      );
      if (index2 < 0) {
        return -1;
      }
      while (index2 - 1 >= 0) {
        if (aCompare(aHaystack[index2], aHaystack[index2 - 1], true) !== 0) {
          break;
        }
        --index2;
      }
      return index2;
    };
  }
});

// node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS({
  "node_modules/source-map/lib/quick-sort.js"(exports) {
    var import_dist68 = __toESM(require_dist());
    function swap(ary, x, y) {
      var temp = ary[x];
      ary[x] = ary[y];
      ary[y] = temp;
    }
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    function doQuickSort(ary, comparator, p, r2) {
      if (p < r2) {
        var pivotIndex = randomIntInRange(p, r2);
        var i = p - 1;
        swap(ary, pivotIndex, r2);
        var pivot = ary[r2];
        for (var j = p; j < r2; j++) {
          if (comparator(ary[j], pivot) <= 0) {
            i += 1;
            swap(ary, i, j);
          }
        }
        swap(ary, i + 1, j);
        var q = i + 1;
        doQuickSort(ary, comparator, p, q - 1);
        doQuickSort(ary, comparator, q + 1, r2);
      }
    }
    exports.quickSort = function(ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
  }
});

// node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "node_modules/source-map/lib/source-map-consumer.js"(exports) {
    var import_dist68 = __toESM(require_dist());
    var util = require_util2();
    var binarySearch = require_binary_search();
    var ArraySet = require_array_set().ArraySet;
    var base64VLQ = require_base64_vlq();
    var quickSort = require_quick_sort().quickSort;
    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index2) {
      var c = aStr.charAt(index2);
      return c === ";" || c === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source2 = mapping.source === null ? null : this._sources.at(mapping.source);
        source2 = util.computeSourceURL(sourceRoot, source2, this._sourceMapURL);
        return {
          source: source2,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, "line");
      var needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0)
      };
      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }
      var mappings = [];
      var index2 = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        binarySearch.LEAST_UPPER_BOUND
      );
      if (index2 >= 0) {
        var mapping = this._originalMappings[index2];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index2];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index2];
          }
        }
      }
      return mappings;
    };
    exports.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sources = util.getArg(sourceMap, "sources");
      var names = util.getArg(sourceMap, "names", []);
      var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
      var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
      var mappings = util.getArg(sourceMap, "mappings");
      var file = util.getArg(sourceMap, "file", null);
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      if (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
      }
      sources = sources.map(String).map(util.normalize).map(function(source2) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source2) ? util.relative(sourceRoot, source2) : source2;
      });
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this._absoluteSources = this._sources.toArray().map(function(s) {
        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
      });
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this._sourceMapURL = aSourceMapURL;
      this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
      }
      var i;
      for (i = 0; i < this._absoluteSources.length; ++i) {
        if (this._absoluteSources[i] == aSource) {
          return i;
        }
      }
      return -1;
    };
    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(
        smc._sources.toArray(),
        smc.sourceRoot
      );
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function(s) {
        return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
      });
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i = 0, length2 = generatedMappings.length; i < length2; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
      return smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._absoluteSources.slice();
      }
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length2 = aStr.length;
      var index2 = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;
      while (index2 < length2) {
        if (aStr.charAt(index2) === ";") {
          generatedLine++;
          index2++;
          previousGeneratedColumn = 0;
        } else if (aStr.charAt(index2) === ",") {
          index2++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index2; end < length2; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index2, end);
          segment = cachedSegments[str];
          if (segment) {
            index2 += str.length;
          } else {
            segment = [];
            while (index2 < end) {
              base64VLQ.decode(aStr, index2, temp);
              value = temp.value;
              index2 = temp.rest;
              segment.push(value);
            }
            if (segment.length === 2) {
              throw new Error("Found a source, but no line and column");
            }
            if (segment.length === 3) {
              throw new Error("Found a source and line, but no column");
            }
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            originalMappings.push(mapping);
          }
        }
      }
      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;
      quickSort(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };
    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index2 = 0; index2 < this._generatedMappings.length; ++index2) {
        var mapping = this._generatedMappings[index2];
        if (index2 + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index2 + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var index2 = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util.compareByGeneratedPositionsDeflated,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index2 >= 0) {
        var mapping = this._generatedMappings[index2];
        if (mapping.generatedLine === needle.generatedLine) {
          var source2 = util.getArg(mapping, "source", null);
          if (source2 !== null) {
            source2 = this._sources.at(source2);
            source2 = util.computeSourceURL(this.sourceRoot, source2, this._sourceMapURL);
          }
          var name = util.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source: source2,
            line: util.getArg(mapping, "originalLine", null),
            column: util.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      var index2 = this._findSourceIndex(aSource);
      if (index2 >= 0) {
        return this.sourcesContent[index2];
      }
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      var url;
      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source2 = util.getArg(aArgs, "source");
      source2 = this._findSourceIndex(source2);
      if (source2 < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      var needle = {
        source: source2,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column")
      };
      var index2 = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index2 >= 0) {
        var mapping = this._originalMappings[index2];
        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sections = util.getArg(sourceMap, "sections");
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s) {
        if (s.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset = util.getArg(s, "offset");
        var offsetLine = util.getArg(offset, "line");
        var offsetColumn = util.getArg(offset, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset;
        return {
          generatedOffset: {
            // The offset fields are 0-based, but we use 1-based indices when
            // encoding/decoding from VLQ.
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i = 0; i < this._sections.length; i++) {
          for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch.search(
        needle,
        this._sections,
        function(needle2, section2) {
          var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }
          return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
        }
      );
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];
          var source2 = section.consumer._sources.at(mapping.source);
          source2 = util.computeSourceURL(section.consumer.sourceRoot, source2, this._sourceMapURL);
          this._sources.add(source2);
          source2 = this._sources.indexOf(source2);
          var name = null;
          if (mapping.name) {
            name = section.consumer._names.at(mapping.name);
            this._names.add(name);
            name = this._names.indexOf(name);
          }
          var adjustedMapping = {
            source: source2,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };
    exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS({
  "node_modules/source-map/lib/source-node.js"(exports) {
    var import_dist68 = __toESM(require_dist());
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    var util = require_util2();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null)
        this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      };
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node.add(code);
        } else {
          var source2 = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(
            mapping.originalLine,
            mapping.originalColumn,
            source2,
            code,
            mapping.name
          ));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i = aChunk.length - 1; i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i = 0, len = this.children.length; i < len; i++) {
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i = 0; i < len - 1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length2 = chunk.length; idx < length2; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length2) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map };
    };
    exports.SourceNode = SourceNode;
  }
});

// node_modules/source-map/source-map.js
var require_source_map = __commonJS({
  "node_modules/source-map/source-map.js"(exports) {
    var import_dist68 = __toESM(require_dist());
    exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports.SourceNode = require_source_node().SourceNode;
  }
});

// node_modules/escodegen/package.json
var require_package2 = __commonJS({
  "node_modules/escodegen/package.json"(exports, module) {
    module.exports = {
      name: "escodegen",
      description: "ECMAScript code generator",
      homepage: "http://github.com/estools/escodegen",
      main: "escodegen.js",
      bin: {
        esgenerate: "./bin/esgenerate.js",
        escodegen: "./bin/escodegen.js"
      },
      files: [
        "LICENSE.BSD",
        "README.md",
        "bin",
        "escodegen.js",
        "package.json"
      ],
      version: "1.14.3",
      engines: {
        node: ">=4.0"
      },
      maintainers: [
        {
          name: "Yusuke Suzuki",
          email: "utatane.tea@gmail.com",
          web: "http://github.com/Constellation"
        }
      ],
      repository: {
        type: "git",
        url: "http://github.com/estools/escodegen.git"
      },
      dependencies: {
        estraverse: "^4.2.0",
        esutils: "^2.0.2",
        esprima: "^4.0.1",
        optionator: "^0.8.1"
      },
      optionalDependencies: {
        "source-map": "~0.6.1"
      },
      devDependencies: {
        acorn: "^7.1.0",
        bluebird: "^3.4.7",
        "bower-registry-client": "^1.0.0",
        chai: "^3.5.0",
        "commonjs-everywhere": "^0.9.7",
        gulp: "^3.8.10",
        "gulp-eslint": "^3.0.1",
        "gulp-mocha": "^3.0.1",
        semver: "^5.1.0"
      },
      license: "BSD-2-Clause",
      scripts: {
        test: "gulp travis",
        "unit-test": "gulp test",
        lint: "gulp lint",
        release: "node tools/release.js",
        "build-min": "./node_modules/.bin/cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js",
        build: "./node_modules/.bin/cjsify -a path: tools/entry-point.js > escodegen.browser.js"
      }
    };
  }
});

// node_modules/escodegen/escodegen.js
var require_escodegen = __commonJS({
  "node_modules/escodegen/escodegen.js"(exports) {
    var import_dist68 = __toESM(require_dist());
    (function() {
      "use strict";
      var Syntax2, Precedence, BinaryPrecedence, SourceNode, estraverse, esutils, base, indent, json, renumber, hexadecimal, quotes, escapeless, newline, space, parentheses, semicolons, safeConcatenation, directive, extra2, parse2, sourceMap, sourceCode, preserveBlankLines, FORMAT_MINIFY, FORMAT_DEFAULTS;
      estraverse = require_estraverse();
      esutils = require_utils2();
      Syntax2 = estraverse.Syntax;
      function isExpression(node) {
        return CodeGenerator.Expression.hasOwnProperty(node.type);
      }
      function isStatement(node) {
        return CodeGenerator.Statement.hasOwnProperty(node.type);
      }
      Precedence = {
        Sequence: 0,
        Yield: 1,
        Assignment: 1,
        Conditional: 2,
        ArrowFunction: 2,
        LogicalOR: 3,
        LogicalAND: 4,
        BitwiseOR: 5,
        BitwiseXOR: 6,
        BitwiseAND: 7,
        Equality: 8,
        Relational: 9,
        BitwiseSHIFT: 10,
        Additive: 11,
        Multiplicative: 12,
        Exponentiation: 13,
        Await: 14,
        Unary: 14,
        Postfix: 15,
        Call: 16,
        New: 17,
        TaggedTemplate: 18,
        Member: 19,
        Primary: 20
      };
      BinaryPrecedence = {
        "||": Precedence.LogicalOR,
        "&&": Precedence.LogicalAND,
        "|": Precedence.BitwiseOR,
        "^": Precedence.BitwiseXOR,
        "&": Precedence.BitwiseAND,
        "==": Precedence.Equality,
        "!=": Precedence.Equality,
        "===": Precedence.Equality,
        "!==": Precedence.Equality,
        "is": Precedence.Equality,
        "isnt": Precedence.Equality,
        "<": Precedence.Relational,
        ">": Precedence.Relational,
        "<=": Precedence.Relational,
        ">=": Precedence.Relational,
        "in": Precedence.Relational,
        "instanceof": Precedence.Relational,
        "<<": Precedence.BitwiseSHIFT,
        ">>": Precedence.BitwiseSHIFT,
        ">>>": Precedence.BitwiseSHIFT,
        "+": Precedence.Additive,
        "-": Precedence.Additive,
        "*": Precedence.Multiplicative,
        "%": Precedence.Multiplicative,
        "/": Precedence.Multiplicative,
        "**": Precedence.Exponentiation
      };
      var F_ALLOW_IN = 1, F_ALLOW_CALL = 1 << 1, F_ALLOW_UNPARATH_NEW = 1 << 2, F_FUNC_BODY = 1 << 3, F_DIRECTIVE_CTX = 1 << 4, F_SEMICOLON_OPT = 1 << 5;
      var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW, E_TTF = F_ALLOW_IN | F_ALLOW_CALL, E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW, E_TFF = F_ALLOW_IN, E_FFT = F_ALLOW_UNPARATH_NEW, E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;
      var S_TFFF = F_ALLOW_IN, S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT, S_FFFF = 0, S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX, S_TTFF = F_ALLOW_IN | F_FUNC_BODY;
      function getDefaultOptions() {
        return {
          indent: null,
          base: null,
          parse: null,
          comment: false,
          format: {
            indent: {
              style: "    ",
              base: 0,
              adjustMultilineComment: false
            },
            newline: "\n",
            space: " ",
            json: false,
            renumber: false,
            hexadecimal: false,
            quotes: "single",
            escapeless: false,
            compact: false,
            parentheses: true,
            semicolons: true,
            safeConcatenation: false,
            preserveBlankLines: false
          },
          moz: {
            comprehensionExpressionStartsWithAssignment: false,
            starlessGenerator: false
          },
          sourceMap: null,
          sourceMapRoot: null,
          sourceMapWithCode: false,
          directive: false,
          raw: true,
          verbatim: null,
          sourceCode: null
        };
      }
      function stringRepeat(str, num) {
        var result = "";
        for (num |= 0; num > 0; num >>>= 1, str += str) {
          if (num & 1) {
            result += str;
          }
        }
        return result;
      }
      function hasLineTerminator(str) {
        return /[\r\n]/g.test(str);
      }
      function endsWithLineTerminator(str) {
        var len = str.length;
        return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));
      }
      function merge(target, override) {
        var key;
        for (key in override) {
          if (override.hasOwnProperty(key)) {
            target[key] = override[key];
          }
        }
        return target;
      }
      function updateDeeply(target, override) {
        var key, val;
        function isHashObject(target2) {
          return typeof target2 === "object" && target2 instanceof Object && !(target2 instanceof RegExp);
        }
        for (key in override) {
          if (override.hasOwnProperty(key)) {
            val = override[key];
            if (isHashObject(val)) {
              if (isHashObject(target[key])) {
                updateDeeply(target[key], val);
              } else {
                target[key] = updateDeeply({}, val);
              }
            } else {
              target[key] = val;
            }
          }
        }
        return target;
      }
      function generateNumber(value) {
        var result, point, temp, exponent, pos;
        if (value !== value) {
          throw new Error("Numeric literal whose value is NaN");
        }
        if (value < 0 || value === 0 && 1 / value < 0) {
          throw new Error("Numeric literal whose value is negative");
        }
        if (value === 1 / 0) {
          return json ? "null" : renumber ? "1e400" : "1e+400";
        }
        result = "" + value;
        if (!renumber || result.length < 3) {
          return result;
        }
        point = result.indexOf(".");
        if (!json && result.charCodeAt(0) === 48 && point === 1) {
          point = 0;
          result = result.slice(1);
        }
        temp = result;
        result = result.replace("e+", "e");
        exponent = 0;
        if ((pos = temp.indexOf("e")) > 0) {
          exponent = +temp.slice(pos + 1);
          temp = temp.slice(0, pos);
        }
        if (point >= 0) {
          exponent -= temp.length - point - 1;
          temp = +(temp.slice(0, point) + temp.slice(point + 1)) + "";
        }
        pos = 0;
        while (temp.charCodeAt(temp.length + pos - 1) === 48) {
          --pos;
        }
        if (pos !== 0) {
          exponent -= pos;
          temp = temp.slice(0, pos);
        }
        if (exponent !== 0) {
          temp += "e" + exponent;
        }
        if ((temp.length < result.length || hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = "0x" + value.toString(16)).length < result.length) && +temp === value) {
          result = temp;
        }
        return result;
      }
      function escapeRegExpCharacter(ch, previousIsBackslash) {
        if ((ch & ~1) === 8232) {
          return (previousIsBackslash ? "u" : "\\u") + (ch === 8232 ? "2028" : "2029");
        } else if (ch === 10 || ch === 13) {
          return (previousIsBackslash ? "" : "\\") + (ch === 10 ? "n" : "r");
        }
        return String.fromCharCode(ch);
      }
      function generateRegExp(reg) {
        var match2, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;
        result = reg.toString();
        if (reg.source) {
          match2 = result.match(/\/([^/]*)$/);
          if (!match2) {
            return result;
          }
          flags = match2[1];
          result = "";
          characterInBrack = false;
          previousIsBackslash = false;
          for (i = 0, iz = reg.source.length; i < iz; ++i) {
            ch = reg.source.charCodeAt(i);
            if (!previousIsBackslash) {
              if (characterInBrack) {
                if (ch === 93) {
                  characterInBrack = false;
                }
              } else {
                if (ch === 47) {
                  result += "\\";
                } else if (ch === 91) {
                  characterInBrack = true;
                }
              }
              result += escapeRegExpCharacter(ch, previousIsBackslash);
              previousIsBackslash = ch === 92;
            } else {
              result += escapeRegExpCharacter(ch, previousIsBackslash);
              previousIsBackslash = false;
            }
          }
          return "/" + result + "/" + flags;
        }
        return result;
      }
      function escapeAllowedCharacter(code, next) {
        var hex;
        if (code === 8) {
          return "\\b";
        }
        if (code === 12) {
          return "\\f";
        }
        if (code === 9) {
          return "\\t";
        }
        hex = code.toString(16).toUpperCase();
        if (json || code > 255) {
          return "\\u" + "0000".slice(hex.length) + hex;
        } else if (code === 0 && !esutils.code.isDecimalDigit(next)) {
          return "\\0";
        } else if (code === 11) {
          return "\\x0B";
        } else {
          return "\\x" + "00".slice(hex.length) + hex;
        }
      }
      function escapeDisallowedCharacter(code) {
        if (code === 92) {
          return "\\\\";
        }
        if (code === 10) {
          return "\\n";
        }
        if (code === 13) {
          return "\\r";
        }
        if (code === 8232) {
          return "\\u2028";
        }
        if (code === 8233) {
          return "\\u2029";
        }
        throw new Error("Incorrectly classified character");
      }
      function escapeDirective(str) {
        var i, iz, code, quote;
        quote = quotes === "double" ? '"' : "'";
        for (i = 0, iz = str.length; i < iz; ++i) {
          code = str.charCodeAt(i);
          if (code === 39) {
            quote = '"';
            break;
          } else if (code === 34) {
            quote = "'";
            break;
          } else if (code === 92) {
            ++i;
          }
        }
        return quote + str + quote;
      }
      function escapeString(str) {
        var result = "", i, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;
        for (i = 0, len = str.length; i < len; ++i) {
          code = str.charCodeAt(i);
          if (code === 39) {
            ++singleQuotes;
          } else if (code === 34) {
            ++doubleQuotes;
          } else if (code === 47 && json) {
            result += "\\";
          } else if (esutils.code.isLineTerminator(code) || code === 92) {
            result += escapeDisallowedCharacter(code);
            continue;
          } else if (!esutils.code.isIdentifierPartES5(code) && (json && code < 32 || !json && !escapeless && (code < 32 || code > 126))) {
            result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));
            continue;
          }
          result += String.fromCharCode(code);
        }
        single = !(quotes === "double" || quotes === "auto" && doubleQuotes < singleQuotes);
        quote = single ? "'" : '"';
        if (!(single ? singleQuotes : doubleQuotes)) {
          return quote + result + quote;
        }
        str = result;
        result = quote;
        for (i = 0, len = str.length; i < len; ++i) {
          code = str.charCodeAt(i);
          if (code === 39 && single || code === 34 && !single) {
            result += "\\";
          }
          result += String.fromCharCode(code);
        }
        return result + quote;
      }
      function flattenToString(arr) {
        var i, iz, elem, result = "";
        for (i = 0, iz = arr.length; i < iz; ++i) {
          elem = arr[i];
          result += Array.isArray(elem) ? flattenToString(elem) : elem;
        }
        return result;
      }
      function toSourceNodeWhenNeeded(generated, node) {
        if (!sourceMap) {
          if (Array.isArray(generated)) {
            return flattenToString(generated);
          } else {
            return generated;
          }
        }
        if (node == null) {
          if (generated instanceof SourceNode) {
            return generated;
          } else {
            node = {};
          }
        }
        if (node.loc == null) {
          return new SourceNode(null, null, sourceMap, generated, node.name || null);
        }
        return new SourceNode(node.loc.start.line, node.loc.start.column, sourceMap === true ? node.loc.source || null : sourceMap, generated, node.name || null);
      }
      function noEmptySpace() {
        return space ? space : " ";
      }
      function join(left, right) {
        var leftSource, rightSource, leftCharCode, rightCharCode;
        leftSource = toSourceNodeWhenNeeded(left).toString();
        if (leftSource.length === 0) {
          return [right];
        }
        rightSource = toSourceNodeWhenNeeded(right).toString();
        if (rightSource.length === 0) {
          return [left];
        }
        leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
        rightCharCode = rightSource.charCodeAt(0);
        if ((leftCharCode === 43 || leftCharCode === 45) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode) || leftCharCode === 47 && rightCharCode === 105) {
          return [left, noEmptySpace(), right];
        } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) || esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {
          return [left, right];
        }
        return [left, space, right];
      }
      function addIndent(stmt) {
        return [base, stmt];
      }
      function withIndent(fn) {
        var previousBase;
        previousBase = base;
        base += indent;
        fn(base);
        base = previousBase;
      }
      function calculateSpaces(str) {
        var i;
        for (i = str.length - 1; i >= 0; --i) {
          if (esutils.code.isLineTerminator(str.charCodeAt(i))) {
            break;
          }
        }
        return str.length - 1 - i;
      }
      function adjustMultilineComment(value, specialBase) {
        var array, i, len, line, j, spaces, previousBase, sn;
        array = value.split(/\r\n|[\r\n]/);
        spaces = Number.MAX_VALUE;
        for (i = 1, len = array.length; i < len; ++i) {
          line = array[i];
          j = 0;
          while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {
            ++j;
          }
          if (spaces > j) {
            spaces = j;
          }
        }
        if (typeof specialBase !== "undefined") {
          previousBase = base;
          if (array[1][spaces] === "*") {
            specialBase += " ";
          }
          base = specialBase;
        } else {
          if (spaces & 1) {
            --spaces;
          }
          previousBase = base;
        }
        for (i = 1, len = array.length; i < len; ++i) {
          sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));
          array[i] = sourceMap ? sn.join("") : sn;
        }
        base = previousBase;
        return array.join("\n");
      }
      function generateComment(comment, specialBase) {
        if (comment.type === "Line") {
          if (endsWithLineTerminator(comment.value)) {
            return "//" + comment.value;
          } else {
            var result = "//" + comment.value;
            if (!preserveBlankLines) {
              result += "\n";
            }
            return result;
          }
        }
        if (extra2.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
          return adjustMultilineComment("/*" + comment.value + "*/", specialBase);
        }
        return "/*" + comment.value + "*/";
      }
      function addComments(stmt, result) {
        var i, len, comment, save, tailingToStatement, specialBase, fragment, extRange, range, prevRange, prefix, infix, suffix, count;
        if (stmt.leadingComments && stmt.leadingComments.length > 0) {
          save = result;
          if (preserveBlankLines) {
            comment = stmt.leadingComments[0];
            result = [];
            extRange = comment.extendedRange;
            range = comment.range;
            prefix = sourceCode.substring(extRange[0], range[0]);
            count = (prefix.match(/\n/g) || []).length;
            if (count > 0) {
              result.push(stringRepeat("\n", count));
              result.push(addIndent(generateComment(comment)));
            } else {
              result.push(prefix);
              result.push(generateComment(comment));
            }
            prevRange = range;
            for (i = 1, len = stmt.leadingComments.length; i < len; i++) {
              comment = stmt.leadingComments[i];
              range = comment.range;
              infix = sourceCode.substring(prevRange[1], range[0]);
              count = (infix.match(/\n/g) || []).length;
              result.push(stringRepeat("\n", count));
              result.push(addIndent(generateComment(comment)));
              prevRange = range;
            }
            suffix = sourceCode.substring(range[1], extRange[1]);
            count = (suffix.match(/\n/g) || []).length;
            result.push(stringRepeat("\n", count));
          } else {
            comment = stmt.leadingComments[0];
            result = [];
            if (safeConcatenation && stmt.type === Syntax2.Program && stmt.body.length === 0) {
              result.push("\n");
            }
            result.push(generateComment(comment));
            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
              result.push("\n");
            }
            for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {
              comment = stmt.leadingComments[i];
              fragment = [generateComment(comment)];
              if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                fragment.push("\n");
              }
              result.push(addIndent(fragment));
            }
          }
          result.push(addIndent(save));
        }
        if (stmt.trailingComments) {
          if (preserveBlankLines) {
            comment = stmt.trailingComments[0];
            extRange = comment.extendedRange;
            range = comment.range;
            prefix = sourceCode.substring(extRange[0], range[0]);
            count = (prefix.match(/\n/g) || []).length;
            if (count > 0) {
              result.push(stringRepeat("\n", count));
              result.push(addIndent(generateComment(comment)));
            } else {
              result.push(prefix);
              result.push(generateComment(comment));
            }
          } else {
            tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
            specialBase = stringRepeat(" ", calculateSpaces(toSourceNodeWhenNeeded([base, result, indent]).toString()));
            for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {
              comment = stmt.trailingComments[i];
              if (tailingToStatement) {
                if (i === 0) {
                  result = [result, indent];
                } else {
                  result = [result, specialBase];
                }
                result.push(generateComment(comment, specialBase));
              } else {
                result = [result, addIndent(generateComment(comment))];
              }
              if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result = [result, "\n"];
              }
            }
          }
        }
        return result;
      }
      function generateBlankLines(start, end, result) {
        var j, newlineCount = 0;
        for (j = start; j < end; j++) {
          if (sourceCode[j] === "\n") {
            newlineCount++;
          }
        }
        for (j = 1; j < newlineCount; j++) {
          result.push(newline);
        }
      }
      function parenthesize(text, current, should) {
        if (current < should) {
          return ["(", text, ")"];
        }
        return text;
      }
      function generateVerbatimString(string) {
        var i, iz, result;
        result = string.split(/\r\n|\n/);
        for (i = 1, iz = result.length; i < iz; i++) {
          result[i] = newline + base + result[i];
        }
        return result;
      }
      function generateVerbatim(expr, precedence) {
        var verbatim, result, prec;
        verbatim = expr[extra2.verbatim];
        if (typeof verbatim === "string") {
          result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);
        } else {
          result = generateVerbatimString(verbatim.content);
          prec = verbatim.precedence != null ? verbatim.precedence : Precedence.Sequence;
          result = parenthesize(result, prec, precedence);
        }
        return toSourceNodeWhenNeeded(result, expr);
      }
      function CodeGenerator() {
      }
      CodeGenerator.prototype.maybeBlock = function(stmt, flags) {
        var result, noLeadingComment, that = this;
        noLeadingComment = !extra2.comment || !stmt.leadingComments;
        if (stmt.type === Syntax2.BlockStatement && noLeadingComment) {
          return [space, this.generateStatement(stmt, flags)];
        }
        if (stmt.type === Syntax2.EmptyStatement && noLeadingComment) {
          return ";";
        }
        withIndent(function() {
          result = [
            newline,
            addIndent(that.generateStatement(stmt, flags))
          ];
        });
        return result;
      };
      CodeGenerator.prototype.maybeBlockSuffix = function(stmt, result) {
        var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
        if (stmt.type === Syntax2.BlockStatement && (!extra2.comment || !stmt.leadingComments) && !ends) {
          return [result, space];
        }
        if (ends) {
          return [result, base];
        }
        return [result, newline, base];
      };
      function generateIdentifier(node) {
        return toSourceNodeWhenNeeded(node.name, node);
      }
      function generateAsyncPrefix(node, spaceRequired) {
        return node.async ? "async" + (spaceRequired ? noEmptySpace() : space) : "";
      }
      function generateStarSuffix(node) {
        var isGenerator = node.generator && !extra2.moz.starlessGenerator;
        return isGenerator ? "*" + space : "";
      }
      function generateMethodPrefix(prop) {
        var func = prop.value, prefix = "";
        if (func.async) {
          prefix += generateAsyncPrefix(func, !prop.computed);
        }
        if (func.generator) {
          prefix += generateStarSuffix(func) ? "*" : "";
        }
        return prefix;
      }
      CodeGenerator.prototype.generatePattern = function(node, precedence, flags) {
        if (node.type === Syntax2.Identifier) {
          return generateIdentifier(node);
        }
        return this.generateExpression(node, precedence, flags);
      };
      CodeGenerator.prototype.generateFunctionParams = function(node) {
        var i, iz, result, hasDefault;
        hasDefault = false;
        if (node.type === Syntax2.ArrowFunctionExpression && !node.rest && (!node.defaults || node.defaults.length === 0) && node.params.length === 1 && node.params[0].type === Syntax2.Identifier) {
          result = [generateAsyncPrefix(node, true), generateIdentifier(node.params[0])];
        } else {
          result = node.type === Syntax2.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : [];
          result.push("(");
          if (node.defaults) {
            hasDefault = true;
          }
          for (i = 0, iz = node.params.length; i < iz; ++i) {
            if (hasDefault && node.defaults[i]) {
              result.push(this.generateAssignment(node.params[i], node.defaults[i], "=", Precedence.Assignment, E_TTT));
            } else {
              result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));
            }
            if (i + 1 < iz) {
              result.push("," + space);
            }
          }
          if (node.rest) {
            if (node.params.length) {
              result.push("," + space);
            }
            result.push("...");
            result.push(generateIdentifier(node.rest));
          }
          result.push(")");
        }
        return result;
      };
      CodeGenerator.prototype.generateFunctionBody = function(node) {
        var result, expr;
        result = this.generateFunctionParams(node);
        if (node.type === Syntax2.ArrowFunctionExpression) {
          result.push(space);
          result.push("=>");
        }
        if (node.expression) {
          result.push(space);
          expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);
          if (expr.toString().charAt(0) === "{") {
            expr = ["(", expr, ")"];
          }
          result.push(expr);
        } else {
          result.push(this.maybeBlock(node.body, S_TTFF));
        }
        return result;
      };
      CodeGenerator.prototype.generateIterationForStatement = function(operator, stmt, flags) {
        var result = ["for" + (stmt.await ? noEmptySpace() + "await" : "") + space + "("], that = this;
        withIndent(function() {
          if (stmt.left.type === Syntax2.VariableDeclaration) {
            withIndent(function() {
              result.push(stmt.left.kind + noEmptySpace());
              result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));
            });
          } else {
            result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));
          }
          result = join(result, operator);
          result = [join(
            result,
            that.generateExpression(stmt.right, Precedence.Assignment, E_TTT)
          ), ")"];
        });
        result.push(this.maybeBlock(stmt.body, flags));
        return result;
      };
      CodeGenerator.prototype.generatePropertyKey = function(expr, computed) {
        var result = [];
        if (computed) {
          result.push("[");
        }
        result.push(this.generateExpression(expr, Precedence.Assignment, E_TTT));
        if (computed) {
          result.push("]");
        }
        return result;
      };
      CodeGenerator.prototype.generateAssignment = function(left, right, operator, precedence, flags) {
        if (Precedence.Assignment < precedence) {
          flags |= F_ALLOW_IN;
        }
        return parenthesize(
          [
            this.generateExpression(left, Precedence.Call, flags),
            space + operator + space,
            this.generateExpression(right, Precedence.Assignment, flags)
          ],
          Precedence.Assignment,
          precedence
        );
      };
      CodeGenerator.prototype.semicolon = function(flags) {
        if (!semicolons && flags & F_SEMICOLON_OPT) {
          return "";
        }
        return ";";
      };
      CodeGenerator.Statement = {
        BlockStatement: function(stmt, flags) {
          var range, content, result = ["{", newline], that = this;
          withIndent(function() {
            if (stmt.body.length === 0 && preserveBlankLines) {
              range = stmt.range;
              if (range[1] - range[0] > 2) {
                content = sourceCode.substring(range[0] + 1, range[1] - 1);
                if (content[0] === "\n") {
                  result = ["{"];
                }
                result.push(content);
              }
            }
            var i, iz, fragment, bodyFlags;
            bodyFlags = S_TFFF;
            if (flags & F_FUNC_BODY) {
              bodyFlags |= F_DIRECTIVE_CTX;
            }
            for (i = 0, iz = stmt.body.length; i < iz; ++i) {
              if (preserveBlankLines) {
                if (i === 0) {
                  if (stmt.body[0].leadingComments) {
                    range = stmt.body[0].leadingComments[0].extendedRange;
                    content = sourceCode.substring(range[0], range[1]);
                    if (content[0] === "\n") {
                      result = ["{"];
                    }
                  }
                  if (!stmt.body[0].leadingComments) {
                    generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);
                  }
                }
                if (i > 0) {
                  if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {
                    generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                  }
                }
              }
              if (i === iz - 1) {
                bodyFlags |= F_SEMICOLON_OPT;
              }
              if (stmt.body[i].leadingComments && preserveBlankLines) {
                fragment = that.generateStatement(stmt.body[i], bodyFlags);
              } else {
                fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));
              }
              result.push(fragment);
              if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                if (preserveBlankLines && i < iz - 1) {
                  if (!stmt.body[i + 1].leadingComments) {
                    result.push(newline);
                  }
                } else {
                  result.push(newline);
                }
              }
              if (preserveBlankLines) {
                if (i === iz - 1) {
                  if (!stmt.body[i].trailingComments) {
                    generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                  }
                }
              }
            }
          });
          result.push(addIndent("}"));
          return result;
        },
        BreakStatement: function(stmt, flags) {
          if (stmt.label) {
            return "break " + stmt.label.name + this.semicolon(flags);
          }
          return "break" + this.semicolon(flags);
        },
        ContinueStatement: function(stmt, flags) {
          if (stmt.label) {
            return "continue " + stmt.label.name + this.semicolon(flags);
          }
          return "continue" + this.semicolon(flags);
        },
        ClassBody: function(stmt, flags) {
          var result = ["{", newline], that = this;
          withIndent(function(indent2) {
            var i, iz;
            for (i = 0, iz = stmt.body.length; i < iz; ++i) {
              result.push(indent2);
              result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));
              if (i + 1 < iz) {
                result.push(newline);
              }
            }
          });
          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push(newline);
          }
          result.push(base);
          result.push("}");
          return result;
        },
        ClassDeclaration: function(stmt, flags) {
          var result, fragment;
          result = ["class"];
          if (stmt.id) {
            result = join(result, this.generateExpression(stmt.id, Precedence.Sequence, E_TTT));
          }
          if (stmt.superClass) {
            fragment = join("extends", this.generateExpression(stmt.superClass, Precedence.Unary, E_TTT));
            result = join(result, fragment);
          }
          result.push(space);
          result.push(this.generateStatement(stmt.body, S_TFFT));
          return result;
        },
        DirectiveStatement: function(stmt, flags) {
          if (extra2.raw && stmt.raw) {
            return stmt.raw + this.semicolon(flags);
          }
          return escapeDirective(stmt.directive) + this.semicolon(flags);
        },
        DoWhileStatement: function(stmt, flags) {
          var result = join("do", this.maybeBlock(stmt.body, S_TFFF));
          result = this.maybeBlockSuffix(stmt.body, result);
          return join(result, [
            "while" + space + "(",
            this.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
            ")" + this.semicolon(flags)
          ]);
        },
        CatchClause: function(stmt, flags) {
          var result, that = this;
          withIndent(function() {
            var guard;
            if (stmt.param) {
              result = [
                "catch" + space + "(",
                that.generateExpression(stmt.param, Precedence.Sequence, E_TTT),
                ")"
              ];
              if (stmt.guard) {
                guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);
                result.splice(2, 0, " if ", guard);
              }
            } else {
              result = ["catch"];
            }
          });
          result.push(this.maybeBlock(stmt.body, S_TFFF));
          return result;
        },
        DebuggerStatement: function(stmt, flags) {
          return "debugger" + this.semicolon(flags);
        },
        EmptyStatement: function(stmt, flags) {
          return ";";
        },
        ExportDefaultDeclaration: function(stmt, flags) {
          var result = ["export"], bodyFlags;
          bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF;
          result = join(result, "default");
          if (isStatement(stmt.declaration)) {
            result = join(result, this.generateStatement(stmt.declaration, bodyFlags));
          } else {
            result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));
          }
          return result;
        },
        ExportNamedDeclaration: function(stmt, flags) {
          var result = ["export"], bodyFlags, that = this;
          bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF;
          if (stmt.declaration) {
            return join(result, this.generateStatement(stmt.declaration, bodyFlags));
          }
          if (stmt.specifiers) {
            if (stmt.specifiers.length === 0) {
              result = join(result, "{" + space + "}");
            } else if (stmt.specifiers[0].type === Syntax2.ExportBatchSpecifier) {
              result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));
            } else {
              result = join(result, "{");
              withIndent(function(indent2) {
                var i, iz;
                result.push(newline);
                for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {
                  result.push(indent2);
                  result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                  if (i + 1 < iz) {
                    result.push("," + newline);
                  }
                }
              });
              if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
              }
              result.push(base + "}");
            }
            if (stmt.source) {
              result = join(result, [
                "from" + space,
                // ModuleSpecifier
                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                this.semicolon(flags)
              ]);
            } else {
              result.push(this.semicolon(flags));
            }
          }
          return result;
        },
        ExportAllDeclaration: function(stmt, flags) {
          return [
            "export" + space,
            "*" + space,
            "from" + space,
            // ModuleSpecifier
            this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
            this.semicolon(flags)
          ];
        },
        ExpressionStatement: function(stmt, flags) {
          var result, fragment;
          function isClassPrefixed(fragment2) {
            var code;
            if (fragment2.slice(0, 5) !== "class") {
              return false;
            }
            code = fragment2.charCodeAt(5);
            return code === 123 || esutils.code.isWhiteSpace(code) || esutils.code.isLineTerminator(code);
          }
          function isFunctionPrefixed(fragment2) {
            var code;
            if (fragment2.slice(0, 8) !== "function") {
              return false;
            }
            code = fragment2.charCodeAt(8);
            return code === 40 || esutils.code.isWhiteSpace(code) || code === 42 || esutils.code.isLineTerminator(code);
          }
          function isAsyncPrefixed(fragment2) {
            var code, i, iz;
            if (fragment2.slice(0, 5) !== "async") {
              return false;
            }
            if (!esutils.code.isWhiteSpace(fragment2.charCodeAt(5))) {
              return false;
            }
            for (i = 6, iz = fragment2.length; i < iz; ++i) {
              if (!esutils.code.isWhiteSpace(fragment2.charCodeAt(i))) {
                break;
              }
            }
            if (i === iz) {
              return false;
            }
            if (fragment2.slice(i, i + 8) !== "function") {
              return false;
            }
            code = fragment2.charCodeAt(i + 8);
            return code === 40 || esutils.code.isWhiteSpace(code) || code === 42 || esutils.code.isLineTerminator(code);
          }
          result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)];
          fragment = toSourceNodeWhenNeeded(result).toString();
          if (fragment.charCodeAt(0) === 123 || // ObjectExpression
          isClassPrefixed(fragment) || isFunctionPrefixed(fragment) || isAsyncPrefixed(fragment) || directive && flags & F_DIRECTIVE_CTX && stmt.expression.type === Syntax2.Literal && typeof stmt.expression.value === "string") {
            result = ["(", result, ")" + this.semicolon(flags)];
          } else {
            result.push(this.semicolon(flags));
          }
          return result;
        },
        ImportDeclaration: function(stmt, flags) {
          var result, cursor, that = this;
          if (stmt.specifiers.length === 0) {
            return [
              "import",
              space,
              // ModuleSpecifier
              this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
              this.semicolon(flags)
            ];
          }
          result = [
            "import"
          ];
          cursor = 0;
          if (stmt.specifiers[cursor].type === Syntax2.ImportDefaultSpecifier) {
            result = join(result, [
              this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
            ]);
            ++cursor;
          }
          if (stmt.specifiers[cursor]) {
            if (cursor !== 0) {
              result.push(",");
            }
            if (stmt.specifiers[cursor].type === Syntax2.ImportNamespaceSpecifier) {
              result = join(result, [
                space,
                this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
              ]);
            } else {
              result.push(space + "{");
              if (stmt.specifiers.length - cursor === 1) {
                result.push(space);
                result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));
                result.push(space + "}" + space);
              } else {
                withIndent(function(indent2) {
                  var i, iz;
                  result.push(newline);
                  for (i = cursor, iz = stmt.specifiers.length; i < iz; ++i) {
                    result.push(indent2);
                    result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                    if (i + 1 < iz) {
                      result.push("," + newline);
                    }
                  }
                });
                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                  result.push(newline);
                }
                result.push(base + "}" + space);
              }
            }
          }
          result = join(result, [
            "from" + space,
            // ModuleSpecifier
            this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
            this.semicolon(flags)
          ]);
          return result;
        },
        VariableDeclarator: function(stmt, flags) {
          var itemFlags = flags & F_ALLOW_IN ? E_TTT : E_FTT;
          if (stmt.init) {
            return [
              this.generateExpression(stmt.id, Precedence.Assignment, itemFlags),
              space,
              "=",
              space,
              this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)
            ];
          }
          return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);
        },
        VariableDeclaration: function(stmt, flags) {
          var result, i, iz, node, bodyFlags, that = this;
          result = [stmt.kind];
          bodyFlags = flags & F_ALLOW_IN ? S_TFFF : S_FFFF;
          function block() {
            node = stmt.declarations[0];
            if (extra2.comment && node.leadingComments) {
              result.push("\n");
              result.push(addIndent(that.generateStatement(node, bodyFlags)));
            } else {
              result.push(noEmptySpace());
              result.push(that.generateStatement(node, bodyFlags));
            }
            for (i = 1, iz = stmt.declarations.length; i < iz; ++i) {
              node = stmt.declarations[i];
              if (extra2.comment && node.leadingComments) {
                result.push("," + newline);
                result.push(addIndent(that.generateStatement(node, bodyFlags)));
              } else {
                result.push("," + space);
                result.push(that.generateStatement(node, bodyFlags));
              }
            }
          }
          if (stmt.declarations.length > 1) {
            withIndent(block);
          } else {
            block();
          }
          result.push(this.semicolon(flags));
          return result;
        },
        ThrowStatement: function(stmt, flags) {
          return [join(
            "throw",
            this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
          ), this.semicolon(flags)];
        },
        TryStatement: function(stmt, flags) {
          var result, i, iz, guardedHandlers;
          result = ["try", this.maybeBlock(stmt.block, S_TFFF)];
          result = this.maybeBlockSuffix(stmt.block, result);
          if (stmt.handlers) {
            for (i = 0, iz = stmt.handlers.length; i < iz; ++i) {
              result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));
              if (stmt.finalizer || i + 1 !== iz) {
                result = this.maybeBlockSuffix(stmt.handlers[i].body, result);
              }
            }
          } else {
            guardedHandlers = stmt.guardedHandlers || [];
            for (i = 0, iz = guardedHandlers.length; i < iz; ++i) {
              result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));
              if (stmt.finalizer || i + 1 !== iz) {
                result = this.maybeBlockSuffix(guardedHandlers[i].body, result);
              }
            }
            if (stmt.handler) {
              if (Array.isArray(stmt.handler)) {
                for (i = 0, iz = stmt.handler.length; i < iz; ++i) {
                  result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));
                  if (stmt.finalizer || i + 1 !== iz) {
                    result = this.maybeBlockSuffix(stmt.handler[i].body, result);
                  }
                }
              } else {
                result = join(result, this.generateStatement(stmt.handler, S_TFFF));
                if (stmt.finalizer) {
                  result = this.maybeBlockSuffix(stmt.handler.body, result);
                }
              }
            }
          }
          if (stmt.finalizer) {
            result = join(result, ["finally", this.maybeBlock(stmt.finalizer, S_TFFF)]);
          }
          return result;
        },
        SwitchStatement: function(stmt, flags) {
          var result, fragment, i, iz, bodyFlags, that = this;
          withIndent(function() {
            result = [
              "switch" + space + "(",
              that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT),
              ")" + space + "{" + newline
            ];
          });
          if (stmt.cases) {
            bodyFlags = S_TFFF;
            for (i = 0, iz = stmt.cases.length; i < iz; ++i) {
              if (i === iz - 1) {
                bodyFlags |= F_SEMICOLON_OPT;
              }
              fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));
              result.push(fragment);
              if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                result.push(newline);
              }
            }
          }
          result.push(addIndent("}"));
          return result;
        },
        SwitchCase: function(stmt, flags) {
          var result, fragment, i, iz, bodyFlags, that = this;
          withIndent(function() {
            if (stmt.test) {
              result = [
                join("case", that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)),
                ":"
              ];
            } else {
              result = ["default:"];
            }
            i = 0;
            iz = stmt.consequent.length;
            if (iz && stmt.consequent[0].type === Syntax2.BlockStatement) {
              fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);
              result.push(fragment);
              i = 1;
            }
            if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
              result.push(newline);
            }
            bodyFlags = S_TFFF;
            for (; i < iz; ++i) {
              if (i === iz - 1 && flags & F_SEMICOLON_OPT) {
                bodyFlags |= F_SEMICOLON_OPT;
              }
              fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));
              result.push(fragment);
              if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                result.push(newline);
              }
            }
          });
          return result;
        },
        IfStatement: function(stmt, flags) {
          var result, bodyFlags, semicolonOptional, that = this;
          withIndent(function() {
            result = [
              "if" + space + "(",
              that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
              ")"
            ];
          });
          semicolonOptional = flags & F_SEMICOLON_OPT;
          bodyFlags = S_TFFF;
          if (semicolonOptional) {
            bodyFlags |= F_SEMICOLON_OPT;
          }
          if (stmt.alternate) {
            result.push(this.maybeBlock(stmt.consequent, S_TFFF));
            result = this.maybeBlockSuffix(stmt.consequent, result);
            if (stmt.alternate.type === Syntax2.IfStatement) {
              result = join(result, ["else ", this.generateStatement(stmt.alternate, bodyFlags)]);
            } else {
              result = join(result, join("else", this.maybeBlock(stmt.alternate, bodyFlags)));
            }
          } else {
            result.push(this.maybeBlock(stmt.consequent, bodyFlags));
          }
          return result;
        },
        ForStatement: function(stmt, flags) {
          var result, that = this;
          withIndent(function() {
            result = ["for" + space + "("];
            if (stmt.init) {
              if (stmt.init.type === Syntax2.VariableDeclaration) {
                result.push(that.generateStatement(stmt.init, S_FFFF));
              } else {
                result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));
                result.push(";");
              }
            } else {
              result.push(";");
            }
            if (stmt.test) {
              result.push(space);
              result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));
              result.push(";");
            } else {
              result.push(";");
            }
            if (stmt.update) {
              result.push(space);
              result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));
              result.push(")");
            } else {
              result.push(")");
            }
          });
          result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
          return result;
        },
        ForInStatement: function(stmt, flags) {
          return this.generateIterationForStatement("in", stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
        },
        ForOfStatement: function(stmt, flags) {
          return this.generateIterationForStatement("of", stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
        },
        LabeledStatement: function(stmt, flags) {
          return [stmt.label.name + ":", this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];
        },
        Program: function(stmt, flags) {
          var result, fragment, i, iz, bodyFlags;
          iz = stmt.body.length;
          result = [safeConcatenation && iz > 0 ? "\n" : ""];
          bodyFlags = S_TFTF;
          for (i = 0; i < iz; ++i) {
            if (!safeConcatenation && i === iz - 1) {
              bodyFlags |= F_SEMICOLON_OPT;
            }
            if (preserveBlankLines) {
              if (i === 0) {
                if (!stmt.body[0].leadingComments) {
                  generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);
                }
              }
              if (i > 0) {
                if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {
                  generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                }
              }
            }
            fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));
            result.push(fragment);
            if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
              if (preserveBlankLines) {
                if (!stmt.body[i + 1].leadingComments) {
                  result.push(newline);
                }
              } else {
                result.push(newline);
              }
            }
            if (preserveBlankLines) {
              if (i === iz - 1) {
                if (!stmt.body[i].trailingComments) {
                  generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                }
              }
            }
          }
          return result;
        },
        FunctionDeclaration: function(stmt, flags) {
          return [
            generateAsyncPrefix(stmt, true),
            "function",
            generateStarSuffix(stmt) || noEmptySpace(),
            stmt.id ? generateIdentifier(stmt.id) : "",
            this.generateFunctionBody(stmt)
          ];
        },
        ReturnStatement: function(stmt, flags) {
          if (stmt.argument) {
            return [join(
              "return",
              this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
            ), this.semicolon(flags)];
          }
          return ["return" + this.semicolon(flags)];
        },
        WhileStatement: function(stmt, flags) {
          var result, that = this;
          withIndent(function() {
            result = [
              "while" + space + "(",
              that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
              ")"
            ];
          });
          result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
          return result;
        },
        WithStatement: function(stmt, flags) {
          var result, that = this;
          withIndent(function() {
            result = [
              "with" + space + "(",
              that.generateExpression(stmt.object, Precedence.Sequence, E_TTT),
              ")"
            ];
          });
          result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
          return result;
        }
      };
      merge(CodeGenerator.prototype, CodeGenerator.Statement);
      CodeGenerator.Expression = {
        SequenceExpression: function(expr, precedence, flags) {
          var result, i, iz;
          if (Precedence.Sequence < precedence) {
            flags |= F_ALLOW_IN;
          }
          result = [];
          for (i = 0, iz = expr.expressions.length; i < iz; ++i) {
            result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));
            if (i + 1 < iz) {
              result.push("," + space);
            }
          }
          return parenthesize(result, Precedence.Sequence, precedence);
        },
        AssignmentExpression: function(expr, precedence, flags) {
          return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);
        },
        ArrowFunctionExpression: function(expr, precedence, flags) {
          return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
        },
        ConditionalExpression: function(expr, precedence, flags) {
          if (Precedence.Conditional < precedence) {
            flags |= F_ALLOW_IN;
          }
          return parenthesize(
            [
              this.generateExpression(expr.test, Precedence.LogicalOR, flags),
              space + "?" + space,
              this.generateExpression(expr.consequent, Precedence.Assignment, flags),
              space + ":" + space,
              this.generateExpression(expr.alternate, Precedence.Assignment, flags)
            ],
            Precedence.Conditional,
            precedence
          );
        },
        LogicalExpression: function(expr, precedence, flags) {
          return this.BinaryExpression(expr, precedence, flags);
        },
        BinaryExpression: function(expr, precedence, flags) {
          var result, leftPrecedence, rightPrecedence, currentPrecedence, fragment, leftSource;
          currentPrecedence = BinaryPrecedence[expr.operator];
          leftPrecedence = expr.operator === "**" ? Precedence.Postfix : currentPrecedence;
          rightPrecedence = expr.operator === "**" ? currentPrecedence : currentPrecedence + 1;
          if (currentPrecedence < precedence) {
            flags |= F_ALLOW_IN;
          }
          fragment = this.generateExpression(expr.left, leftPrecedence, flags);
          leftSource = fragment.toString();
          if (leftSource.charCodeAt(leftSource.length - 1) === 47 && esutils.code.isIdentifierPartES5(expr.operator.charCodeAt(0))) {
            result = [fragment, noEmptySpace(), expr.operator];
          } else {
            result = join(fragment, expr.operator);
          }
          fragment = this.generateExpression(expr.right, rightPrecedence, flags);
          if (expr.operator === "/" && fragment.toString().charAt(0) === "/" || expr.operator.slice(-1) === "<" && fragment.toString().slice(0, 3) === "!--") {
            result.push(noEmptySpace());
            result.push(fragment);
          } else {
            result = join(result, fragment);
          }
          if (expr.operator === "in" && !(flags & F_ALLOW_IN)) {
            return ["(", result, ")"];
          }
          return parenthesize(result, currentPrecedence, precedence);
        },
        CallExpression: function(expr, precedence, flags) {
          var result, i, iz;
          result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];
          result.push("(");
          for (i = 0, iz = expr["arguments"].length; i < iz; ++i) {
            result.push(this.generateExpression(expr["arguments"][i], Precedence.Assignment, E_TTT));
            if (i + 1 < iz) {
              result.push("," + space);
            }
          }
          result.push(")");
          if (!(flags & F_ALLOW_CALL)) {
            return ["(", result, ")"];
          }
          return parenthesize(result, Precedence.Call, precedence);
        },
        NewExpression: function(expr, precedence, flags) {
          var result, length2, i, iz, itemFlags;
          length2 = expr["arguments"].length;
          itemFlags = flags & F_ALLOW_UNPARATH_NEW && !parentheses && length2 === 0 ? E_TFT : E_TFF;
          result = join(
            "new",
            this.generateExpression(expr.callee, Precedence.New, itemFlags)
          );
          if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length2 > 0) {
            result.push("(");
            for (i = 0, iz = length2; i < iz; ++i) {
              result.push(this.generateExpression(expr["arguments"][i], Precedence.Assignment, E_TTT));
              if (i + 1 < iz) {
                result.push("," + space);
              }
            }
            result.push(")");
          }
          return parenthesize(result, Precedence.New, precedence);
        },
        MemberExpression: function(expr, precedence, flags) {
          var result, fragment;
          result = [this.generateExpression(expr.object, Precedence.Call, flags & F_ALLOW_CALL ? E_TTF : E_TFF)];
          if (expr.computed) {
            result.push("[");
            result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));
            result.push("]");
          } else {
            if (expr.object.type === Syntax2.Literal && typeof expr.object.value === "number") {
              fragment = toSourceNodeWhenNeeded(result).toString();
              if (fragment.indexOf(".") < 0 && !/[eExX]/.test(fragment) && esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) && !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)) {
                result.push(" ");
              }
            }
            result.push(".");
            result.push(generateIdentifier(expr.property));
          }
          return parenthesize(result, Precedence.Member, precedence);
        },
        MetaProperty: function(expr, precedence, flags) {
          var result;
          result = [];
          result.push(typeof expr.meta === "string" ? expr.meta : generateIdentifier(expr.meta));
          result.push(".");
          result.push(typeof expr.property === "string" ? expr.property : generateIdentifier(expr.property));
          return parenthesize(result, Precedence.Member, precedence);
        },
        UnaryExpression: function(expr, precedence, flags) {
          var result, fragment, rightCharCode, leftSource, leftCharCode;
          fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);
          if (space === "") {
            result = join(expr.operator, fragment);
          } else {
            result = [expr.operator];
            if (expr.operator.length > 2) {
              result = join(result, fragment);
            } else {
              leftSource = toSourceNodeWhenNeeded(result).toString();
              leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
              rightCharCode = fragment.toString().charCodeAt(0);
              if ((leftCharCode === 43 || leftCharCode === 45) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode)) {
                result.push(noEmptySpace());
                result.push(fragment);
              } else {
                result.push(fragment);
              }
            }
          }
          return parenthesize(result, Precedence.Unary, precedence);
        },
        YieldExpression: function(expr, precedence, flags) {
          var result;
          if (expr.delegate) {
            result = "yield*";
          } else {
            result = "yield";
          }
          if (expr.argument) {
            result = join(
              result,
              this.generateExpression(expr.argument, Precedence.Yield, E_TTT)
            );
          }
          return parenthesize(result, Precedence.Yield, precedence);
        },
        AwaitExpression: function(expr, precedence, flags) {
          var result = join(
            expr.all ? "await*" : "await",
            this.generateExpression(expr.argument, Precedence.Await, E_TTT)
          );
          return parenthesize(result, Precedence.Await, precedence);
        },
        UpdateExpression: function(expr, precedence, flags) {
          if (expr.prefix) {
            return parenthesize(
              [
                expr.operator,
                this.generateExpression(expr.argument, Precedence.Unary, E_TTT)
              ],
              Precedence.Unary,
              precedence
            );
          }
          return parenthesize(
            [
              this.generateExpression(expr.argument, Precedence.Postfix, E_TTT),
              expr.operator
            ],
            Precedence.Postfix,
            precedence
          );
        },
        FunctionExpression: function(expr, precedence, flags) {
          var result = [
            generateAsyncPrefix(expr, true),
            "function"
          ];
          if (expr.id) {
            result.push(generateStarSuffix(expr) || noEmptySpace());
            result.push(generateIdentifier(expr.id));
          } else {
            result.push(generateStarSuffix(expr) || space);
          }
          result.push(this.generateFunctionBody(expr));
          return result;
        },
        ArrayPattern: function(expr, precedence, flags) {
          return this.ArrayExpression(expr, precedence, flags, true);
        },
        ArrayExpression: function(expr, precedence, flags, isPattern) {
          var result, multiline, that = this;
          if (!expr.elements.length) {
            return "[]";
          }
          multiline = isPattern ? false : expr.elements.length > 1;
          result = ["[", multiline ? newline : ""];
          withIndent(function(indent2) {
            var i, iz;
            for (i = 0, iz = expr.elements.length; i < iz; ++i) {
              if (!expr.elements[i]) {
                if (multiline) {
                  result.push(indent2);
                }
                if (i + 1 === iz) {
                  result.push(",");
                }
              } else {
                result.push(multiline ? indent2 : "");
                result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));
              }
              if (i + 1 < iz) {
                result.push("," + (multiline ? newline : space));
              }
            }
          });
          if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push(newline);
          }
          result.push(multiline ? base : "");
          result.push("]");
          return result;
        },
        RestElement: function(expr, precedence, flags) {
          return "..." + this.generatePattern(expr.argument);
        },
        ClassExpression: function(expr, precedence, flags) {
          var result, fragment;
          result = ["class"];
          if (expr.id) {
            result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));
          }
          if (expr.superClass) {
            fragment = join("extends", this.generateExpression(expr.superClass, Precedence.Unary, E_TTT));
            result = join(result, fragment);
          }
          result.push(space);
          result.push(this.generateStatement(expr.body, S_TFFT));
          return result;
        },
        MethodDefinition: function(expr, precedence, flags) {
          var result, fragment;
          if (expr["static"]) {
            result = ["static" + space];
          } else {
            result = [];
          }
          if (expr.kind === "get" || expr.kind === "set") {
            fragment = [
              join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)),
              this.generateFunctionBody(expr.value)
            ];
          } else {
            fragment = [
              generateMethodPrefix(expr),
              this.generatePropertyKey(expr.key, expr.computed),
              this.generateFunctionBody(expr.value)
            ];
          }
          return join(result, fragment);
        },
        Property: function(expr, precedence, flags) {
          if (expr.kind === "get" || expr.kind === "set") {
            return [
              expr.kind,
              noEmptySpace(),
              this.generatePropertyKey(expr.key, expr.computed),
              this.generateFunctionBody(expr.value)
            ];
          }
          if (expr.shorthand) {
            if (expr.value.type === "AssignmentPattern") {
              return this.AssignmentPattern(expr.value, Precedence.Sequence, E_TTT);
            }
            return this.generatePropertyKey(expr.key, expr.computed);
          }
          if (expr.method) {
            return [
              generateMethodPrefix(expr),
              this.generatePropertyKey(expr.key, expr.computed),
              this.generateFunctionBody(expr.value)
            ];
          }
          return [
            this.generatePropertyKey(expr.key, expr.computed),
            ":" + space,
            this.generateExpression(expr.value, Precedence.Assignment, E_TTT)
          ];
        },
        ObjectExpression: function(expr, precedence, flags) {
          var multiline, result, fragment, that = this;
          if (!expr.properties.length) {
            return "{}";
          }
          multiline = expr.properties.length > 1;
          withIndent(function() {
            fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);
          });
          if (!multiline) {
            if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
              return ["{", space, fragment, space, "}"];
            }
          }
          withIndent(function(indent2) {
            var i, iz;
            result = ["{", newline, indent2, fragment];
            if (multiline) {
              result.push("," + newline);
              for (i = 1, iz = expr.properties.length; i < iz; ++i) {
                result.push(indent2);
                result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
                if (i + 1 < iz) {
                  result.push("," + newline);
                }
              }
            }
          });
          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push(newline);
          }
          result.push(base);
          result.push("}");
          return result;
        },
        AssignmentPattern: function(expr, precedence, flags) {
          return this.generateAssignment(expr.left, expr.right, "=", precedence, flags);
        },
        ObjectPattern: function(expr, precedence, flags) {
          var result, i, iz, multiline, property, that = this;
          if (!expr.properties.length) {
            return "{}";
          }
          multiline = false;
          if (expr.properties.length === 1) {
            property = expr.properties[0];
            if (property.type === Syntax2.Property && property.value.type !== Syntax2.Identifier) {
              multiline = true;
            }
          } else {
            for (i = 0, iz = expr.properties.length; i < iz; ++i) {
              property = expr.properties[i];
              if (property.type === Syntax2.Property && !property.shorthand) {
                multiline = true;
                break;
              }
            }
          }
          result = ["{", multiline ? newline : ""];
          withIndent(function(indent2) {
            var i2, iz2;
            for (i2 = 0, iz2 = expr.properties.length; i2 < iz2; ++i2) {
              result.push(multiline ? indent2 : "");
              result.push(that.generateExpression(expr.properties[i2], Precedence.Sequence, E_TTT));
              if (i2 + 1 < iz2) {
                result.push("," + (multiline ? newline : space));
              }
            }
          });
          if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push(newline);
          }
          result.push(multiline ? base : "");
          result.push("}");
          return result;
        },
        ThisExpression: function(expr, precedence, flags) {
          return "this";
        },
        Super: function(expr, precedence, flags) {
          return "super";
        },
        Identifier: function(expr, precedence, flags) {
          return generateIdentifier(expr);
        },
        ImportDefaultSpecifier: function(expr, precedence, flags) {
          return generateIdentifier(expr.id || expr.local);
        },
        ImportNamespaceSpecifier: function(expr, precedence, flags) {
          var result = ["*"];
          var id = expr.id || expr.local;
          if (id) {
            result.push(space + "as" + noEmptySpace() + generateIdentifier(id));
          }
          return result;
        },
        ImportSpecifier: function(expr, precedence, flags) {
          var imported = expr.imported;
          var result = [imported.name];
          var local = expr.local;
          if (local && local.name !== imported.name) {
            result.push(noEmptySpace() + "as" + noEmptySpace() + generateIdentifier(local));
          }
          return result;
        },
        ExportSpecifier: function(expr, precedence, flags) {
          var local = expr.local;
          var result = [local.name];
          var exported = expr.exported;
          if (exported && exported.name !== local.name) {
            result.push(noEmptySpace() + "as" + noEmptySpace() + generateIdentifier(exported));
          }
          return result;
        },
        Literal: function(expr, precedence, flags) {
          var raw;
          if (expr.hasOwnProperty("raw") && parse2 && extra2.raw) {
            try {
              raw = parse2(expr.raw).body[0].expression;
              if (raw.type === Syntax2.Literal) {
                if (raw.value === expr.value) {
                  return expr.raw;
                }
              }
            } catch (e2) {
            }
          }
          if (expr.regex) {
            return "/" + expr.regex.pattern + "/" + expr.regex.flags;
          }
          if (expr.value === null) {
            return "null";
          }
          if (typeof expr.value === "string") {
            return escapeString(expr.value);
          }
          if (typeof expr.value === "number") {
            return generateNumber(expr.value);
          }
          if (typeof expr.value === "boolean") {
            return expr.value ? "true" : "false";
          }
          return generateRegExp(expr.value);
        },
        GeneratorExpression: function(expr, precedence, flags) {
          return this.ComprehensionExpression(expr, precedence, flags);
        },
        ComprehensionExpression: function(expr, precedence, flags) {
          var result, i, iz, fragment, that = this;
          result = expr.type === Syntax2.GeneratorExpression ? ["("] : ["["];
          if (extra2.moz.comprehensionExpressionStartsWithAssignment) {
            fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
            result.push(fragment);
          }
          if (expr.blocks) {
            withIndent(function() {
              for (i = 0, iz = expr.blocks.length; i < iz; ++i) {
                fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);
                if (i > 0 || extra2.moz.comprehensionExpressionStartsWithAssignment) {
                  result = join(result, fragment);
                } else {
                  result.push(fragment);
                }
              }
            });
          }
          if (expr.filter) {
            result = join(result, "if" + space);
            fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);
            result = join(result, ["(", fragment, ")"]);
          }
          if (!extra2.moz.comprehensionExpressionStartsWithAssignment) {
            fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
            result = join(result, fragment);
          }
          result.push(expr.type === Syntax2.GeneratorExpression ? ")" : "]");
          return result;
        },
        ComprehensionBlock: function(expr, precedence, flags) {
          var fragment;
          if (expr.left.type === Syntax2.VariableDeclaration) {
            fragment = [
              expr.left.kind,
              noEmptySpace(),
              this.generateStatement(expr.left.declarations[0], S_FFFF)
            ];
          } else {
            fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);
          }
          fragment = join(fragment, expr.of ? "of" : "in");
          fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));
          return ["for" + space + "(", fragment, ")"];
        },
        SpreadElement: function(expr, precedence, flags) {
          return [
            "...",
            this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)
          ];
        },
        TaggedTemplateExpression: function(expr, precedence, flags) {
          var itemFlags = E_TTF;
          if (!(flags & F_ALLOW_CALL)) {
            itemFlags = E_TFF;
          }
          var result = [
            this.generateExpression(expr.tag, Precedence.Call, itemFlags),
            this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)
          ];
          return parenthesize(result, Precedence.TaggedTemplate, precedence);
        },
        TemplateElement: function(expr, precedence, flags) {
          return expr.value.raw;
        },
        TemplateLiteral: function(expr, precedence, flags) {
          var result, i, iz;
          result = ["`"];
          for (i = 0, iz = expr.quasis.length; i < iz; ++i) {
            result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));
            if (i + 1 < iz) {
              result.push("${" + space);
              result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));
              result.push(space + "}");
            }
          }
          result.push("`");
          return result;
        },
        ModuleSpecifier: function(expr, precedence, flags) {
          return this.Literal(expr, precedence, flags);
        },
        ImportExpression: function(expr, precedence, flag) {
          return parenthesize([
            "import(",
            this.generateExpression(expr.source, Precedence.Assignment, E_TTT),
            ")"
          ], Precedence.Call, precedence);
        }
      };
      merge(CodeGenerator.prototype, CodeGenerator.Expression);
      CodeGenerator.prototype.generateExpression = function(expr, precedence, flags) {
        var result, type;
        type = expr.type || Syntax2.Property;
        if (extra2.verbatim && expr.hasOwnProperty(extra2.verbatim)) {
          return generateVerbatim(expr, precedence);
        }
        result = this[type](expr, precedence, flags);
        if (extra2.comment) {
          result = addComments(expr, result);
        }
        return toSourceNodeWhenNeeded(result, expr);
      };
      CodeGenerator.prototype.generateStatement = function(stmt, flags) {
        var result, fragment;
        result = this[stmt.type](stmt, flags);
        if (extra2.comment) {
          result = addComments(stmt, result);
        }
        fragment = toSourceNodeWhenNeeded(result).toString();
        if (stmt.type === Syntax2.Program && !safeConcatenation && newline === "" && fragment.charAt(fragment.length - 1) === "\n") {
          result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, "") : fragment.replace(/\s+$/, "");
        }
        return toSourceNodeWhenNeeded(result, stmt);
      };
      function generateInternal(node) {
        var codegen;
        codegen = new CodeGenerator();
        if (isStatement(node)) {
          return codegen.generateStatement(node, S_TFFF);
        }
        if (isExpression(node)) {
          return codegen.generateExpression(node, Precedence.Sequence, E_TTT);
        }
        throw new Error("Unknown node type: " + node.type);
      }
      function generate(node, options) {
        var defaultOptions = getDefaultOptions(), result, pair;
        if (options != null) {
          if (typeof options.indent === "string") {
            defaultOptions.format.indent.style = options.indent;
          }
          if (typeof options.base === "number") {
            defaultOptions.format.indent.base = options.base;
          }
          options = updateDeeply(defaultOptions, options);
          indent = options.format.indent.style;
          if (typeof options.base === "string") {
            base = options.base;
          } else {
            base = stringRepeat(indent, options.format.indent.base);
          }
        } else {
          options = defaultOptions;
          indent = options.format.indent.style;
          base = stringRepeat(indent, options.format.indent.base);
        }
        json = options.format.json;
        renumber = options.format.renumber;
        hexadecimal = json ? false : options.format.hexadecimal;
        quotes = json ? "double" : options.format.quotes;
        escapeless = options.format.escapeless;
        newline = options.format.newline;
        space = options.format.space;
        if (options.format.compact) {
          newline = space = indent = base = "";
        }
        parentheses = options.format.parentheses;
        semicolons = options.format.semicolons;
        safeConcatenation = options.format.safeConcatenation;
        directive = options.directive;
        parse2 = json ? null : options.parse;
        sourceMap = options.sourceMap;
        sourceCode = options.sourceCode;
        preserveBlankLines = options.format.preserveBlankLines && sourceCode !== null;
        extra2 = options;
        if (sourceMap) {
          if (!exports.browser) {
            SourceNode = require_source_map().SourceNode;
          } else {
            SourceNode = global.sourceMap.SourceNode;
          }
        }
        result = generateInternal(node);
        if (!sourceMap) {
          pair = { code: result.toString(), map: null };
          return options.sourceMapWithCode ? pair : pair.code;
        }
        pair = result.toStringWithSourceMap({
          file: options.file,
          sourceRoot: options.sourceMapRoot
        });
        if (options.sourceContent) {
          pair.map.setSourceContent(
            options.sourceMap,
            options.sourceContent
          );
        }
        if (options.sourceMapWithCode) {
          return pair;
        }
        return pair.map.toString();
      }
      FORMAT_MINIFY = {
        indent: {
          style: "",
          base: 0
        },
        renumber: true,
        hexadecimal: true,
        quotes: "auto",
        escapeless: true,
        compact: true,
        parentheses: false,
        semicolons: false
      };
      FORMAT_DEFAULTS = getDefaultOptions().format;
      exports.version = require_package2().version;
      exports.generate = generate;
      exports.attachComments = estraverse.attachComments;
      exports.Precedence = updateDeeply({}, Precedence);
      exports.browser = false;
      exports.FORMAT_MINIFY = FORMAT_MINIFY;
      exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
    })();
  }
});

// node_modules/static-eval/index.js
var require_static_eval = __commonJS({
  "node_modules/static-eval/index.js"(exports, module) {
    var import_dist68 = __toESM(require_dist());
    var unparse = require_escodegen().generate;
    module.exports = function(ast, vars) {
      if (!vars)
        vars = {};
      var FAIL = {};
      var result = function walk(node, scopeVars) {
        if (node.type === "Literal") {
          return node.value;
        } else if (node.type === "UnaryExpression") {
          var val = walk(node.argument);
          if (node.operator === "+")
            return +val;
          if (node.operator === "-")
            return -val;
          if (node.operator === "~")
            return ~val;
          if (node.operator === "!")
            return !val;
          return FAIL;
        } else if (node.type === "ArrayExpression") {
          var xs = [];
          for (var i = 0, l = node.elements.length; i < l; i++) {
            var x = walk(node.elements[i]);
            if (x === FAIL)
              return FAIL;
            xs.push(x);
          }
          return xs;
        } else if (node.type === "ObjectExpression") {
          var obj = {};
          for (var i = 0; i < node.properties.length; i++) {
            var prop = node.properties[i];
            var value = prop.value === null ? prop.value : walk(prop.value);
            if (value === FAIL)
              return FAIL;
            obj[prop.key.value || prop.key.name] = value;
          }
          return obj;
        } else if (node.type === "BinaryExpression" || node.type === "LogicalExpression") {
          var l = walk(node.left);
          if (l === FAIL)
            return FAIL;
          var r2 = walk(node.right);
          if (r2 === FAIL)
            return FAIL;
          var op = node.operator;
          if (op === "==")
            return l == r2;
          if (op === "===")
            return l === r2;
          if (op === "!=")
            return l != r2;
          if (op === "!==")
            return l !== r2;
          if (op === "+")
            return l + r2;
          if (op === "-")
            return l - r2;
          if (op === "*")
            return l * r2;
          if (op === "/")
            return l / r2;
          if (op === "%")
            return l % r2;
          if (op === "<")
            return l < r2;
          if (op === "<=")
            return l <= r2;
          if (op === ">")
            return l > r2;
          if (op === ">=")
            return l >= r2;
          if (op === "|")
            return l | r2;
          if (op === "&")
            return l & r2;
          if (op === "^")
            return l ^ r2;
          if (op === "&&")
            return l && r2;
          if (op === "||")
            return l || r2;
          return FAIL;
        } else if (node.type === "Identifier") {
          if ({}.hasOwnProperty.call(vars, node.name)) {
            return vars[node.name];
          } else
            return FAIL;
        } else if (node.type === "ThisExpression") {
          if ({}.hasOwnProperty.call(vars, "this")) {
            return vars["this"];
          } else
            return FAIL;
        } else if (node.type === "CallExpression") {
          var callee = walk(node.callee);
          if (callee === FAIL)
            return FAIL;
          if (typeof callee !== "function")
            return FAIL;
          var ctx = node.callee.object ? walk(node.callee.object) : FAIL;
          if (ctx === FAIL)
            ctx = null;
          var args = [];
          for (var i = 0, l = node.arguments.length; i < l; i++) {
            var x = walk(node.arguments[i]);
            if (x === FAIL)
              return FAIL;
            args.push(x);
          }
          return callee.apply(ctx, args);
        } else if (node.type === "MemberExpression") {
          var obj = walk(node.object);
          if (obj === FAIL || typeof obj == "function") {
            return FAIL;
          }
          if (node.property.type === "Identifier") {
            return obj[node.property.name];
          }
          var prop = walk(node.property);
          if (prop === FAIL)
            return FAIL;
          return obj[prop];
        } else if (node.type === "ConditionalExpression") {
          var val = walk(node.test);
          if (val === FAIL)
            return FAIL;
          return val ? walk(node.consequent) : walk(node.alternate);
        } else if (node.type === "ExpressionStatement") {
          var val = walk(node.expression);
          if (val === FAIL)
            return FAIL;
          return val;
        } else if (node.type === "ReturnStatement") {
          return walk(node.argument);
        } else if (node.type === "FunctionExpression") {
          var bodies = node.body.body;
          var oldVars = {};
          Object.keys(vars).forEach(function(element) {
            oldVars[element] = vars[element];
          });
          for (var i = 0; i < node.params.length; i++) {
            var key = node.params[i];
            if (key.type == "Identifier") {
              vars[key.name] = null;
            } else
              return FAIL;
          }
          for (var i in bodies) {
            if (walk(bodies[i]) === FAIL) {
              return FAIL;
            }
          }
          vars = oldVars;
          var keys = Object.keys(vars);
          var vals = keys.map(function(key2) {
            return vars[key2];
          });
          return Function(keys.join(", "), "return " + unparse(node)).apply(null, vals);
        } else if (node.type === "TemplateLiteral") {
          var str = "";
          for (var i = 0; i < node.expressions.length; i++) {
            str += walk(node.quasis[i]);
            str += walk(node.expressions[i]);
          }
          str += walk(node.quasis[i]);
          return str;
        } else if (node.type === "TaggedTemplateExpression") {
          var tag = walk(node.tag);
          var quasi = node.quasi;
          var strings = quasi.quasis.map(walk);
          var values = quasi.expressions.map(walk);
          return tag.apply(null, [strings].concat(values));
        } else if (node.type === "TemplateElement") {
          return node.value.cooked;
        } else
          return FAIL;
      }(ast);
      return result === FAIL ? void 0 : result;
    };
  }
});

// node_modules/@astronautlabs/jsonpath/generated/parser.js
var require_parser = __commonJS({
  "node_modules/@astronautlabs/jsonpath/generated/parser.js"(exports) {
    var import_dist68 = __toESM(require_dist());
    var parser = function() {
      var o2 = function(k, v, o3, l) {
        for (o3 = o3 || {}, l = k.length; l--; o3[k[l]] = v)
          ;
        return o3;
      }, $V0 = [1, 5], $V1 = [1, 6], $V2 = [1, 7], $V3 = [1, 8], $V4 = [1, 9], $V5 = [1, 18], $V6 = [1, 19], $V7 = [1, 20], $V8 = [1, 12, 14, 22], $V9 = [1, 29], $Va = [1, 30], $Vb = [1, 33], $Vc = [1, 35], $Vd = [1, 31], $Ve = [1, 36], $Vf = [1, 37], $Vg = [24, 28];
      var parser2 = {
        trace: function trace() {
        },
        yy: {},
        symbols_: { "error": 2, "JSON_PATH": 3, "DOLLAR": 4, "PATH_COMPONENTS": 5, "LEADING_CHILD_MEMBER_EXPRESSION": 6, "PATH_COMPONENT": 7, "MEMBER_COMPONENT": 8, "SUBSCRIPT_COMPONENT": 9, "CHILD_MEMBER_COMPONENT": 10, "DESCENDANT_MEMBER_COMPONENT": 11, "DOT": 12, "MEMBER_EXPRESSION": 13, "DOT_DOT": 14, "STAR": 15, "IDENTIFIER": 16, "SCRIPT_EXPRESSION": 17, "INTEGER": 18, "END": 19, "CHILD_SUBSCRIPT_COMPONENT": 20, "DESCENDANT_SUBSCRIPT_COMPONENT": 21, "[": 22, "SUBSCRIPT": 23, "]": 24, "SUBSCRIPT_EXPRESSION": 25, "SUBSCRIPT_EXPRESSION_LIST": 26, "SUBSCRIPT_EXPRESSION_LISTABLE": 27, ",": 28, "STRING_LITERAL": 29, "ARRAY_SLICE": 30, "FILTER_EXPRESSION": 31, "QQ_STRING": 32, "Q_STRING": 33, "$accept": 0, "$end": 1 },
        terminals_: { 2: "error", 4: "DOLLAR", 12: "DOT", 14: "DOT_DOT", 15: "STAR", 16: "IDENTIFIER", 17: "SCRIPT_EXPRESSION", 18: "INTEGER", 19: "END", 22: "[", 24: "]", 28: ",", 30: "ARRAY_SLICE", 31: "FILTER_EXPRESSION", 32: "QQ_STRING", 33: "Q_STRING" },
        productions_: [0, [3, 1], [3, 2], [3, 1], [3, 2], [5, 1], [5, 2], [7, 1], [7, 1], [8, 1], [8, 1], [10, 2], [6, 1], [11, 2], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [9, 1], [9, 1], [20, 3], [21, 4], [23, 1], [23, 1], [26, 1], [26, 3], [27, 1], [27, 1], [27, 1], [25, 1], [25, 1], [25, 1], [29, 1], [29, 1]],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
          if (!yy.ast) {
            yy.ast = _ast;
            _ast.initialize();
          }
          var $0 = $$.length - 1;
          switch (yystate) {
            case 1:
              yy.ast.set({ expression: { type: "root", value: $$[$0] } });
              yy.ast.unshift();
              return yy.ast.yield();
              break;
            case 2:
              yy.ast.set({ expression: { type: "root", value: $$[$0 - 1] } });
              yy.ast.unshift();
              return yy.ast.yield();
              break;
            case 3:
              yy.ast.unshift();
              return yy.ast.yield();
              break;
            case 4:
              yy.ast.set({ operation: "member", scope: "child", expression: { type: "identifier", value: $$[$0 - 1] } });
              yy.ast.unshift();
              return yy.ast.yield();
              break;
            case 5:
            case 6:
            case 11:
            case 13:
            case 18:
            case 21:
            case 22:
            case 23:
              break;
            case 7:
              yy.ast.set({ operation: "member" });
              yy.ast.push();
              break;
            case 8:
              yy.ast.set({ operation: "subscript" });
              yy.ast.push();
              break;
            case 9:
            case 19:
              yy.ast.set({ scope: "child" });
              break;
            case 10:
            case 20:
              yy.ast.set({ scope: "descendant" });
              break;
            case 12:
              yy.ast.set({ scope: "child", operation: "member" });
              break;
            case 14:
              yy.ast.set({ expression: { type: "wildcard", value: $$[$0] } });
              break;
            case 15:
              yy.ast.set({ expression: { type: "identifier", value: $$[$0] } });
              break;
            case 16:
              yy.ast.set({ expression: { type: "script_expression", value: $$[$0] } });
              break;
            case 17:
              yy.ast.set({ expression: { type: "numeric_literal", value: parseInt($$[$0]) } });
              break;
            case 24:
              $$[$0].length > 1 ? yy.ast.set({ expression: { type: "union", value: $$[$0] } }) : this.$ = $$[$0];
              break;
            case 25:
              this.$ = [$$[$0]];
              break;
            case 26:
              this.$ = $$[$0 - 2].concat($$[$0]);
              break;
            case 27:
              this.$ = { expression: { type: "numeric_literal", value: parseInt($$[$0]) } };
              yy.ast.set(this.$);
              break;
            case 28:
              this.$ = { expression: { type: "string_literal", value: $$[$0] } };
              yy.ast.set(this.$);
              break;
            case 29:
              this.$ = { expression: { type: "slice", value: $$[$0] } };
              yy.ast.set(this.$);
              break;
            case 30:
              this.$ = { expression: { type: "wildcard", value: $$[$0] } };
              yy.ast.set(this.$);
              break;
            case 31:
              this.$ = { expression: { type: "script_expression", value: $$[$0] } };
              yy.ast.set(this.$);
              break;
            case 32:
              this.$ = { expression: { type: "filter_expression", value: $$[$0] } };
              yy.ast.set(this.$);
              break;
            case 33:
            case 34:
              this.$ = $$[$0];
              break;
          }
        },
        table: [{ 3: 1, 4: [1, 2], 6: 3, 13: 4, 15: $V0, 16: $V1, 17: $V2, 18: $V3, 19: $V4 }, { 1: [3] }, { 1: [2, 1], 5: 10, 7: 11, 8: 12, 9: 13, 10: 14, 11: 15, 12: $V5, 14: $V6, 20: 16, 21: 17, 22: $V7 }, { 1: [2, 3], 5: 21, 7: 11, 8: 12, 9: 13, 10: 14, 11: 15, 12: $V5, 14: $V6, 20: 16, 21: 17, 22: $V7 }, o2($V8, [2, 12]), o2($V8, [2, 14]), o2($V8, [2, 15]), o2($V8, [2, 16]), o2($V8, [2, 17]), o2($V8, [2, 18]), { 1: [2, 2], 7: 22, 8: 12, 9: 13, 10: 14, 11: 15, 12: $V5, 14: $V6, 20: 16, 21: 17, 22: $V7 }, o2($V8, [2, 5]), o2($V8, [2, 7]), o2($V8, [2, 8]), o2($V8, [2, 9]), o2($V8, [2, 10]), o2($V8, [2, 19]), o2($V8, [2, 20]), { 13: 23, 15: $V0, 16: $V1, 17: $V2, 18: $V3, 19: $V4 }, { 13: 24, 15: $V0, 16: $V1, 17: $V2, 18: $V3, 19: $V4, 22: [1, 25] }, { 15: $V9, 17: $Va, 18: $Vb, 23: 26, 25: 27, 26: 28, 27: 32, 29: 34, 30: $Vc, 31: $Vd, 32: $Ve, 33: $Vf }, { 1: [2, 4], 7: 22, 8: 12, 9: 13, 10: 14, 11: 15, 12: $V5, 14: $V6, 20: 16, 21: 17, 22: $V7 }, o2($V8, [2, 6]), o2($V8, [2, 11]), o2($V8, [2, 13]), { 15: $V9, 17: $Va, 18: $Vb, 23: 38, 25: 27, 26: 28, 27: 32, 29: 34, 30: $Vc, 31: $Vd, 32: $Ve, 33: $Vf }, { 24: [1, 39] }, { 24: [2, 23] }, { 24: [2, 24], 28: [1, 40] }, { 24: [2, 30] }, { 24: [2, 31] }, { 24: [2, 32] }, o2($Vg, [2, 25]), o2($Vg, [2, 27]), o2($Vg, [2, 28]), o2($Vg, [2, 29]), o2($Vg, [2, 33]), o2($Vg, [2, 34]), { 24: [1, 41] }, o2($V8, [2, 21]), { 18: $Vb, 27: 42, 29: 34, 30: $Vc, 32: $Ve, 33: $Vf }, o2($V8, [2, 22]), o2($Vg, [2, 26])],
        defaultActions: { 27: [2, 23], 29: [2, 30], 30: [2, 31], 31: [2, 32] },
        parseError: function parseError(str, hash) {
          if (hash.recoverable) {
            this.trace(str);
          } else {
            var error = new Error(str);
            error.hash = hash;
            throw error;
          }
        },
        parse: function parse2(input) {
          var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
          var args = lstack.slice.call(arguments, 1);
          var lexer2 = Object.create(this.lexer);
          var sharedState = { yy: {} };
          for (var k in this.yy) {
            if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
              sharedState.yy[k] = this.yy[k];
            }
          }
          lexer2.setInput(input, sharedState.yy);
          sharedState.yy.lexer = lexer2;
          sharedState.yy.parser = this;
          if (typeof lexer2.yylloc == "undefined") {
            lexer2.yylloc = {};
          }
          var yyloc = lexer2.yylloc;
          lstack.push(yyloc);
          var ranges = lexer2.options && lexer2.options.ranges;
          if (typeof sharedState.yy.parseError === "function") {
            this.parseError = sharedState.yy.parseError;
          } else {
            this.parseError = Object.getPrototypeOf(this).parseError;
          }
          function popStack(n2) {
            stack.length = stack.length - 2 * n2;
            vstack.length = vstack.length - n2;
            lstack.length = lstack.length - n2;
          }
          _token_stack:
            var lex2 = function() {
              var token;
              token = lexer2.lex() || EOF;
              if (typeof token !== "number") {
                token = self.symbols_[token] || token;
              }
              return token;
            };
          var symbol, preErrorSymbol, state2, action, a, r2, yyval = {}, p, len, newState, expected;
          while (true) {
            state2 = stack[stack.length - 1];
            if (this.defaultActions[state2]) {
              action = this.defaultActions[state2];
            } else {
              if (symbol === null || typeof symbol == "undefined") {
                symbol = lex2();
              }
              action = table[state2] && table[state2][symbol];
            }
            if (typeof action === "undefined" || !action.length || !action[0]) {
              var errStr = "";
              expected = [];
              for (p in table[state2]) {
                if (this.terminals_[p] && p > TERROR) {
                  expected.push("'" + this.terminals_[p] + "'");
                }
              }
              if (lexer2.showPosition) {
                errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
              } else {
                errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == EOF ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
              }
              this.parseError(errStr, {
                text: lexer2.match,
                token: this.terminals_[symbol] || symbol,
                line: lexer2.yylineno,
                loc: yyloc,
                expected
              });
            }
            if (action[0] instanceof Array && action.length > 1) {
              throw new Error("Parse Error: multiple actions possible at state: " + state2 + ", token: " + symbol);
            }
            switch (action[0]) {
              case 1:
                stack.push(symbol);
                vstack.push(lexer2.yytext);
                lstack.push(lexer2.yylloc);
                stack.push(action[1]);
                symbol = null;
                if (!preErrorSymbol) {
                  yyleng = lexer2.yyleng;
                  yytext = lexer2.yytext;
                  yylineno = lexer2.yylineno;
                  yyloc = lexer2.yylloc;
                  if (recovering > 0) {
                    recovering--;
                  }
                } else {
                  symbol = preErrorSymbol;
                  preErrorSymbol = null;
                }
                break;
              case 2:
                len = this.productions_[action[1]][1];
                yyval.$ = vstack[vstack.length - len];
                yyval._$ = {
                  first_line: lstack[lstack.length - (len || 1)].first_line,
                  last_line: lstack[lstack.length - 1].last_line,
                  first_column: lstack[lstack.length - (len || 1)].first_column,
                  last_column: lstack[lstack.length - 1].last_column
                };
                if (ranges) {
                  yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                  ];
                }
                r2 = this.performAction.apply(yyval, [
                  yytext,
                  yyleng,
                  yylineno,
                  sharedState.yy,
                  action[1],
                  vstack,
                  lstack
                ].concat(args));
                if (typeof r2 !== "undefined") {
                  return r2;
                }
                if (len) {
                  stack = stack.slice(0, -1 * len * 2);
                  vstack = vstack.slice(0, -1 * len);
                  lstack = lstack.slice(0, -1 * len);
                }
                stack.push(this.productions_[action[1]][0]);
                vstack.push(yyval.$);
                lstack.push(yyval._$);
                newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                stack.push(newState);
                break;
              case 3:
                return true;
            }
          }
          return true;
        }
      };
      var _ast = {
        initialize: function() {
          this._nodes = [];
          this._node = {};
          this._stash = [];
        },
        set: function(props) {
          for (var k in props)
            this._node[k] = props[k];
          return this._node;
        },
        node: function(obj) {
          if (arguments.length)
            this._node = obj;
          return this._node;
        },
        push: function() {
          this._nodes.push(this._node);
          this._node = {};
        },
        unshift: function() {
          this._nodes.unshift(this._node);
          this._node = {};
        },
        yield: function() {
          var _nodes = this._nodes;
          this.initialize();
          return _nodes;
        }
      };
      var lexer = function() {
        var lexer2 = {
          EOF: 1,
          parseError: function parseError(str, hash) {
            if (this.yy.parser) {
              this.yy.parser.parseError(str, hash);
            } else {
              throw new Error(str);
            }
          },
          // resets the lexer, sets new input
          setInput: function(input, yy) {
            this.yy = yy || this.yy || {};
            this._input = input;
            this._more = this._backtrack = this.done = false;
            this.yylineno = this.yyleng = 0;
            this.yytext = this.matched = this.match = "";
            this.conditionStack = ["INITIAL"];
            this.yylloc = {
              first_line: 1,
              first_column: 0,
              last_line: 1,
              last_column: 0
            };
            if (this.options.ranges) {
              this.yylloc.range = [0, 0];
            }
            this.offset = 0;
            return this;
          },
          // consumes and returns one char from the input
          input: function() {
            var ch = this._input[0];
            this.yytext += ch;
            this.yyleng++;
            this.offset++;
            this.match += ch;
            this.matched += ch;
            var lines = ch.match(/(?:\r\n?|\n).*/g);
            if (lines) {
              this.yylineno++;
              this.yylloc.last_line++;
            } else {
              this.yylloc.last_column++;
            }
            if (this.options.ranges) {
              this.yylloc.range[1]++;
            }
            this._input = this._input.slice(1);
            return ch;
          },
          // unshifts one char (or a string) into the input
          unput: function(ch) {
            var len = ch.length;
            var lines = ch.split(/(?:\r\n?|\n)/g);
            this._input = ch + this._input;
            this.yytext = this.yytext.substr(0, this.yytext.length - len);
            this.offset -= len;
            var oldLines = this.match.split(/(?:\r\n?|\n)/g);
            this.match = this.match.substr(0, this.match.length - 1);
            this.matched = this.matched.substr(0, this.matched.length - 1);
            if (lines.length - 1) {
              this.yylineno -= lines.length - 1;
            }
            var r2 = this.yylloc.range;
            this.yylloc = {
              first_line: this.yylloc.first_line,
              last_line: this.yylineno + 1,
              first_column: this.yylloc.first_column,
              last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
            };
            if (this.options.ranges) {
              this.yylloc.range = [r2[0], r2[0] + this.yyleng - len];
            }
            this.yyleng = this.yytext.length;
            return this;
          },
          // When called from action, caches matched text and appends it on next action
          more: function() {
            this._more = true;
            return this;
          },
          // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
          reject: function() {
            if (this.options.backtrack_lexer) {
              this._backtrack = true;
            } else {
              return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
              });
            }
            return this;
          },
          // retain first n characters of the match
          less: function(n2) {
            this.unput(this.match.slice(n2));
          },
          // displays already matched input, i.e. for error messages
          pastInput: function() {
            var past = this.matched.substr(0, this.matched.length - this.match.length);
            return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
          },
          // displays upcoming input, i.e. for error messages
          upcomingInput: function() {
            var next = this.match;
            if (next.length < 20) {
              next += this._input.substr(0, 20 - next.length);
            }
            return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
          },
          // displays the character position where the lexing error occurred, i.e. for error messages
          showPosition: function() {
            var pre = this.pastInput();
            var c = new Array(pre.length + 1).join("-");
            return pre + this.upcomingInput() + "\n" + c + "^";
          },
          // test the lexed token: return FALSE when not a match, otherwise return token
          test_match: function(match2, indexed_rule) {
            var token, lines, backup;
            if (this.options.backtrack_lexer) {
              backup = {
                yylineno: this.yylineno,
                yylloc: {
                  first_line: this.yylloc.first_line,
                  last_line: this.last_line,
                  first_column: this.yylloc.first_column,
                  last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
              };
              if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
              }
            }
            lines = match2[0].match(/(?:\r\n?|\n).*/g);
            if (lines) {
              this.yylineno += lines.length;
            }
            this.yylloc = {
              first_line: this.yylloc.last_line,
              last_line: this.yylineno + 1,
              first_column: this.yylloc.last_column,
              last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match2[0].length
            };
            this.yytext += match2[0];
            this.match += match2[0];
            this.matches = match2;
            this.yyleng = this.yytext.length;
            if (this.options.ranges) {
              this.yylloc.range = [this.offset, this.offset += this.yyleng];
            }
            this._more = false;
            this._backtrack = false;
            this._input = this._input.slice(match2[0].length);
            this.matched += match2[0];
            token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
            if (this.done && this._input) {
              this.done = false;
            }
            if (token) {
              return token;
            } else if (this._backtrack) {
              for (var k in backup) {
                this[k] = backup[k];
              }
              return false;
            }
            return false;
          },
          // return next match in input
          next: function() {
            if (this.done) {
              return this.EOF;
            }
            if (!this._input) {
              this.done = true;
            }
            var token, match2, tempMatch, index2;
            if (!this._more) {
              this.yytext = "";
              this.match = "";
            }
            var rules = this._currentRules();
            for (var i = 0; i < rules.length; i++) {
              tempMatch = this._input.match(this.rules[rules[i]]);
              if (tempMatch && (!match2 || tempMatch[0].length > match2[0].length)) {
                match2 = tempMatch;
                index2 = i;
                if (this.options.backtrack_lexer) {
                  token = this.test_match(tempMatch, rules[i]);
                  if (token !== false) {
                    return token;
                  } else if (this._backtrack) {
                    match2 = false;
                    continue;
                  } else {
                    return false;
                  }
                } else if (!this.options.flex) {
                  break;
                }
              }
            }
            if (match2) {
              token = this.test_match(match2, rules[index2]);
              if (token !== false) {
                return token;
              }
              return false;
            }
            if (this._input === "") {
              return this.EOF;
            } else {
              return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
              });
            }
          },
          // return next match that has a token
          lex: function lex2() {
            var r2 = this.next();
            if (r2) {
              return r2;
            } else {
              return this.lex();
            }
          },
          // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
          begin: function begin(condition) {
            this.conditionStack.push(condition);
          },
          // pop the previously active lexer condition state off the condition stack
          popState: function popState() {
            var n2 = this.conditionStack.length - 1;
            if (n2 > 0) {
              return this.conditionStack.pop();
            } else {
              return this.conditionStack[0];
            }
          },
          // produce the lexer rule set which is active for the currently active lexer condition state
          _currentRules: function _currentRules() {
            if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
              return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
            } else {
              return this.conditions["INITIAL"].rules;
            }
          },
          // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
          topState: function topState(n2) {
            n2 = this.conditionStack.length - 1 - Math.abs(n2 || 0);
            if (n2 >= 0) {
              return this.conditionStack[n2];
            } else {
              return "INITIAL";
            }
          },
          // alias for begin(condition)
          pushState: function pushState(condition) {
            this.begin(condition);
          },
          // return the number of states currently on the stack
          stateStackSize: function stateStackSize() {
            return this.conditionStack.length;
          },
          options: {},
          performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
            var YYSTATE = YY_START;
            switch ($avoiding_name_collisions) {
              case 0:
                return 4;
                break;
              case 1:
                return 14;
                break;
              case 2:
                return 12;
                break;
              case 3:
                return 15;
                break;
              case 4:
                return 16;
                break;
              case 5:
                return 22;
                break;
              case 6:
                return 24;
                break;
              case 7:
                return 28;
                break;
              case 8:
                return 30;
                break;
              case 9:
                return 18;
                break;
              case 10:
                yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2);
                return 32;
                break;
              case 11:
                yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2);
                return 33;
                break;
              case 12:
                return 17;
                break;
              case 13:
                return 31;
                break;
            }
          },
          rules: [/^(?:\$)/, /^(?:\.\.)/, /^(?:\.)/, /^(?:\*)/, /^(?:[a-zA-Z_]+[a-zA-Z0-9_]*)/, /^(?:\[)/, /^(?:\])/, /^(?:,)/, /^(?:((-?(?:0|[1-9][0-9]*)))?\:((-?(?:0|[1-9][0-9]*)))?(\:((-?(?:0|[1-9][0-9]*)))?)?)/, /^(?:(-?(?:0|[1-9][0-9]*)))/, /^(?:"(?:\\["bfnrt\/\\]|\\u[a-fA-F0-9]{4}|[^"\\])*")/, /^(?:'(?:\\['bfnrt\/\\]|\\u[a-fA-F0-9]{4}|[^'\\])*')/, /^(?:\(.+?\)(?=\]))/, /^(?:\?\(.+?\)(?=\]))/],
          conditions: { "INITIAL": { "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], "inclusive": true } }
        };
        return lexer2;
      }();
      parser2.lexer = lexer;
      function Parser3() {
        this.yy = {};
      }
      Parser3.prototype = parser2;
      parser2.Parser = Parser3;
      return new Parser3();
    }();
    if (typeof __require !== "undefined" && typeof exports !== "undefined") {
      exports.parser = parser;
      exports.Parser = parser.Parser;
      exports.parse = function() {
        return parser.parse.apply(parser, arguments);
      };
    }
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    module.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    module.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range = __commonJS({
  "node_modules/es-errors/range.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    module.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref2 = __commonJS({
  "node_modules/es-errors/ref.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    module.exports = ReferenceError;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    module.exports = SyntaxError;
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/es-errors/type.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    module.exports = TypeError;
  }
});

// node_modules/es-errors/uri.js
var require_uri2 = __commonJS({
  "node_modules/es-errors/uri.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    module.exports = URIError;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/has-proto/index.js
var require_has_proto = __commonJS({
  "node_modules/has-proto/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var test = {
      __proto__: null,
      foo: {}
    };
    var $Object = Object;
    module.exports = function hasProto() {
      return { __proto__: test }.foo === test.foo && !(test instanceof $Object);
    };
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var undefined2;
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref2();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri2();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e2) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e2) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var hasProto = require_has_proto()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
      return x.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e2) {
        errorProto = getProto(getProto(e2));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match2, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match2;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true) || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e2) {
        $defineProperty = false;
      }
    }
    module.exports = $defineProperty;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e2) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "node_modules/define-data-property/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var $defineProperty = require_es_define_property();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var gopd = require_gopd();
    module.exports = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var $defineProperty = require_es_define_property();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e2) {
        return true;
      }
    };
    module.exports = hasPropertyDescriptors;
  }
});

// node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "node_modules/set-function-length/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var GetIntrinsic = require_get_intrinsic();
    var define = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = require_type();
    var $floor = GetIntrinsic("%Math.floor%");
    module.exports = function setFunctionLength(fn, length2) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length2 !== "number" || length2 < 0 || length2 > 4294967295 || $floor(length2) !== length2) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length2,
            true,
            true
          );
        } else {
          define(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length2
          );
        }
      }
      return fn;
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var setFunctionLength = require_set_function_length();
    var $TypeError = require_type();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $defineProperty = require_es_define_property();
    var $max = GetIntrinsic("%Math.max%");
    module.exports = function callBind(originalFunction) {
      if (typeof originalFunction !== "function") {
        throw new $TypeError("a function is required");
      }
      var func = $reflectApply(bind, $call, arguments);
      return setFunctionLength(
        func,
        1 + $max(0, originalFunction.length - (arguments.length - 1)),
        true
      );
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});

// node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/object-keys/isArguments.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var toStr = Object.prototype.toString;
    module.exports = function isArguments(value) {
      var str = toStr.call(value);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// node_modules/object-keys/implementation.js
var require_implementation2 = __commonJS({
  "node_modules/object-keys/implementation.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o2) {
        var ctor = o2.constructor;
        return ctor && ctor.prototype === o2;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k in window) {
          try {
            if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
              try {
                equalsConstructorPrototype(window[k]);
              } catch (e2) {
                return true;
              }
            }
          } catch (e2) {
            return true;
          }
        }
        return false;
      }();
      equalsConstructorPrototypeIfNotBuggy = function(o2) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o2);
        }
        try {
          return equalsConstructorPrototype(o2);
        } catch (e2) {
          return false;
        }
      };
      keysShim = function keys(object) {
        var isObject = object !== null && typeof object === "object";
        var isFunction = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString = isObject && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject && !isFunction && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object.length > 0 && !has.call(object, 0)) {
          for (var i = 0; i < object.length; ++i) {
            theKeys.push(String(i));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j = 0; j < object.length; ++j) {
            theKeys.push(String(j));
          }
        } else {
          for (var name in object) {
            if (!(skipProto && name === "prototype") && has.call(object, name)) {
              theKeys.push(String(name));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k = 0; k < dontEnums.length; ++k) {
            if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
              theKeys.push(dontEnums[k]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module.exports = keysShim;
  }
});

// node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "node_modules/object-keys/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var slice2 = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o2) {
      return origKeys(o2);
    } : require_implementation2();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object) {
            if (isArgs(object)) {
              return originalKeys(slice2.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module.exports = keysShim;
  }
});

// node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "node_modules/define-properties/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var keys = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var defineDataProperty = require_define_data_property();
    var isFunction = function(fn) {
      return typeof fn === "function" && toStr.call(fn) === "[object Function]";
    };
    var supportsDescriptors = require_has_property_descriptors()();
    var defineProperty = function(object, name, value, predicate) {
      if (name in object) {
        if (predicate === true) {
          if (object[name] === value) {
            return;
          }
        } else if (!isFunction(predicate) || !predicate()) {
          return;
        }
      }
      if (supportsDescriptors) {
        defineDataProperty(object, name, value, true);
      } else {
        defineDataProperty(object, name, value);
      }
    };
    var defineProperties = function(object, map) {
      var predicates = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map);
      if (hasSymbols) {
        props = concat.call(props, Object.getOwnPropertySymbols(map));
      }
      for (var i = 0; i < props.length; i += 1) {
        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module.exports = defineProperties;
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// node_modules/es-abstract/helpers/IsArray.js
var require_IsArray = __commonJS({
  "node_modules/es-abstract/helpers/IsArray.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var GetIntrinsic = require_get_intrinsic();
    var $Array = GetIntrinsic("%Array%");
    var toStr = !$Array.isArray && require_callBound()("Object.prototype.toString");
    module.exports = $Array.isArray || function IsArray(argument) {
      return toStr(argument) === "[object Array]";
    };
  }
});

// node_modules/es-abstract/2023/IsArray.js
var require_IsArray2 = __commonJS({
  "node_modules/es-abstract/2023/IsArray.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    module.exports = require_IsArray();
  }
});

// node_modules/es-abstract/2023/Call.js
var require_Call = __commonJS({
  "node_modules/es-abstract/2023/Call.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var $TypeError = require_type();
    var IsArray = require_IsArray2();
    var $apply = GetIntrinsic("%Reflect.apply%", true) || callBound("Function.prototype.apply");
    module.exports = function Call(F, V) {
      var argumentsList = arguments.length > 2 ? arguments[2] : [];
      if (!IsArray(argumentsList)) {
        throw new $TypeError("Assertion failed: optional `argumentsList`, if provided, must be a List");
      }
      return $apply(F, V, argumentsList);
    };
  }
});

// (disabled):node_modules/object-inspect/util.inspect
var require_util3 = __commonJS({
  "(disabled):node_modules/object-inspect/util.inspect"() {
    var import_dist68 = __toESM(require_dist());
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports, module) {
    var import_dist68 = __toESM(require_dist());
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util3();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    module.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (obj === global) {
        return "{ [object globalThis] }";
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    function isArray(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e2) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e2) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    function isMap(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e2) {
      }
      return false;
    }
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e2) {
      }
      return false;
    }
    function isWeakRef(x) {
      if (!weakRefDeref || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x);
        return true;
      } catch (e2) {
      }
      return false;
    }
    function isSet(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e2) {
      }
      return false;
    }
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e2) {
      }
      return false;
    }
    function isElement(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
      var n2 = c.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n2];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n2 < 16 ? "0" : "") + $toUpperCase.call(n2.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/es-abstract/2023/IsPropertyKey.js
var require_IsPropertyKey = __commonJS({
  "node_modules/es-abstract/2023/IsPropertyKey.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    module.exports = function IsPropertyKey(argument) {
      return typeof argument === "string" || typeof argument === "symbol";
    };
  }
});

// node_modules/es-abstract/5/Type.js
var require_Type = __commonJS({
  "node_modules/es-abstract/5/Type.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    module.exports = function Type(x) {
      if (x === null) {
        return "Null";
      }
      if (typeof x === "undefined") {
        return "Undefined";
      }
      if (typeof x === "function" || typeof x === "object") {
        return "Object";
      }
      if (typeof x === "number") {
        return "Number";
      }
      if (typeof x === "boolean") {
        return "Boolean";
      }
      if (typeof x === "string") {
        return "String";
      }
    };
  }
});

// node_modules/es-abstract/2023/Type.js
var require_Type2 = __commonJS({
  "node_modules/es-abstract/2023/Type.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var ES5Type = require_Type();
    module.exports = function Type(x) {
      if (typeof x === "symbol") {
        return "Symbol";
      }
      if (typeof x === "bigint") {
        return "BigInt";
      }
      return ES5Type(x);
    };
  }
});

// node_modules/es-abstract/2023/Get.js
var require_Get = __commonJS({
  "node_modules/es-abstract/2023/Get.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var $TypeError = require_type();
    var inspect = require_object_inspect();
    var IsPropertyKey = require_IsPropertyKey();
    var Type = require_Type2();
    module.exports = function Get(O, P) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true, got " + inspect(P));
      }
      return O[P];
    };
  }
});

// node_modules/es-abstract/2023/GetV.js
var require_GetV = __commonJS({
  "node_modules/es-abstract/2023/GetV.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var $TypeError = require_type();
    var inspect = require_object_inspect();
    var IsPropertyKey = require_IsPropertyKey();
    module.exports = function GetV(V, P) {
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true, got " + inspect(P));
      }
      return V[P];
    };
  }
});

// node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "node_modules/is-callable/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_) {
        if (_ !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e2) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e2) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      all = document.all;
      if (toStr.call(all) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e2) {
            }
          }
          return false;
        };
      }
    }
    var all;
    module.exports = reflectApply ? function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e2) {
        if (e2 !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    };
  }
});

// node_modules/es-abstract/2023/IsCallable.js
var require_IsCallable = __commonJS({
  "node_modules/es-abstract/2023/IsCallable.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    module.exports = require_is_callable();
  }
});

// node_modules/es-abstract/2023/GetMethod.js
var require_GetMethod = __commonJS({
  "node_modules/es-abstract/2023/GetMethod.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var $TypeError = require_type();
    var GetV = require_GetV();
    var IsCallable = require_IsCallable();
    var IsPropertyKey = require_IsPropertyKey();
    var inspect = require_object_inspect();
    module.exports = function GetMethod(O, P) {
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var func = GetV(O, P);
      if (func == null) {
        return void 0;
      }
      if (!IsCallable(func)) {
        throw new $TypeError(inspect(P) + " is not a function: " + inspect(func));
      }
      return func;
    };
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var hasSymbols = require_shams();
    module.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/is-regex/index.js
var require_is_regex = __commonJS({
  "node_modules/is-regex/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var callBound = require_callBound();
    var hasToStringTag = require_shams2()();
    var has;
    var $exec;
    var isRegexMarker;
    var badStringifier;
    if (hasToStringTag) {
      has = callBound("Object.prototype.hasOwnProperty");
      $exec = callBound("RegExp.prototype.exec");
      isRegexMarker = {};
      throwRegexMarker = function() {
        throw isRegexMarker;
      };
      badStringifier = {
        toString: throwRegexMarker,
        valueOf: throwRegexMarker
      };
      if (typeof Symbol.toPrimitive === "symbol") {
        badStringifier[Symbol.toPrimitive] = throwRegexMarker;
      }
    }
    var throwRegexMarker;
    var $toString = callBound("Object.prototype.toString");
    var gOPD = Object.getOwnPropertyDescriptor;
    var regexClass = "[object RegExp]";
    module.exports = hasToStringTag ? function isRegex(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      var descriptor = gOPD(value, "lastIndex");
      var hasLastIndexDataProperty = descriptor && has(descriptor, "value");
      if (!hasLastIndexDataProperty) {
        return false;
      }
      try {
        $exec(value, badStringifier);
      } catch (e2) {
        return e2 === isRegexMarker;
      }
    } : function isRegex(value) {
      if (!value || typeof value !== "object" && typeof value !== "function") {
        return false;
      }
      return $toString(value) === regexClass;
    };
  }
});

// node_modules/es-abstract/2023/ToBoolean.js
var require_ToBoolean = __commonJS({
  "node_modules/es-abstract/2023/ToBoolean.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    module.exports = function ToBoolean(value) {
      return !!value;
    };
  }
});

// node_modules/es-abstract/2023/IsRegExp.js
var require_IsRegExp = __commonJS({
  "node_modules/es-abstract/2023/IsRegExp.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var GetIntrinsic = require_get_intrinsic();
    var $match = GetIntrinsic("%Symbol.match%", true);
    var hasRegExpMatcher = require_is_regex();
    var ToBoolean = require_ToBoolean();
    module.exports = function IsRegExp(argument) {
      if (!argument || typeof argument !== "object") {
        return false;
      }
      if ($match) {
        var isRegExp = argument[$match];
        if (typeof isRegExp !== "undefined") {
          return ToBoolean(isRegExp);
        }
      }
      return hasRegExpMatcher(argument);
    };
  }
});

// node_modules/es-abstract/2023/ToString.js
var require_ToString = __commonJS({
  "node_modules/es-abstract/2023/ToString.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var GetIntrinsic = require_get_intrinsic();
    var $String = GetIntrinsic("%String%");
    var $TypeError = require_type();
    module.exports = function ToString(argument) {
      if (typeof argument === "symbol") {
        throw new $TypeError("Cannot convert a Symbol value to a string");
      }
      return $String(argument);
    };
  }
});

// node_modules/es-abstract/5/CheckObjectCoercible.js
var require_CheckObjectCoercible = __commonJS({
  "node_modules/es-abstract/5/CheckObjectCoercible.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var $TypeError = require_type();
    module.exports = function CheckObjectCoercible(value, optMessage) {
      if (value == null) {
        throw new $TypeError(optMessage || "Cannot call method on " + value);
      }
      return value;
    };
  }
});

// node_modules/es-abstract/2023/RequireObjectCoercible.js
var require_RequireObjectCoercible = __commonJS({
  "node_modules/es-abstract/2023/RequireObjectCoercible.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    module.exports = require_CheckObjectCoercible();
  }
});

// node_modules/functions-have-names/index.js
var require_functions_have_names = __commonJS({
  "node_modules/functions-have-names/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var functionsHaveNames = function functionsHaveNames2() {
      return typeof (function f() {
      }).name === "string";
    };
    var gOPD = Object.getOwnPropertyDescriptor;
    if (gOPD) {
      try {
        gOPD([], "length");
      } catch (e2) {
        gOPD = null;
      }
    }
    functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
      if (!functionsHaveNames() || !gOPD) {
        return false;
      }
      var desc = gOPD(function() {
      }, "name");
      return !!desc && !!desc.configurable;
    };
    var $bind = Function.prototype.bind;
    functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
      return functionsHaveNames() && typeof $bind === "function" && (function f() {
      }).bind().name !== "";
    };
    module.exports = functionsHaveNames;
  }
});

// node_modules/set-function-name/index.js
var require_set_function_name = __commonJS({
  "node_modules/set-function-name/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var define = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var functionsHaveConfigurableNames = require_functions_have_names().functionsHaveConfigurableNames();
    var $TypeError = require_type();
    module.exports = function setFunctionName(fn, name) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      if (!loose || functionsHaveConfigurableNames) {
        if (hasDescriptors) {
          define(
            /** @type {Parameters<define>[0]} */
            fn,
            "name",
            name,
            true,
            true
          );
        } else {
          define(
            /** @type {Parameters<define>[0]} */
            fn,
            "name",
            name
          );
        }
      }
      return fn;
    };
  }
});

// node_modules/regexp.prototype.flags/implementation.js
var require_implementation3 = __commonJS({
  "node_modules/regexp.prototype.flags/implementation.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var setFunctionName = require_set_function_name();
    var $TypeError = require_type();
    var $Object = Object;
    module.exports = setFunctionName(function flags() {
      if (this == null || this !== $Object(this)) {
        throw new $TypeError("RegExp.prototype.flags getter called on non-object");
      }
      var result = "";
      if (this.hasIndices) {
        result += "d";
      }
      if (this.global) {
        result += "g";
      }
      if (this.ignoreCase) {
        result += "i";
      }
      if (this.multiline) {
        result += "m";
      }
      if (this.dotAll) {
        result += "s";
      }
      if (this.unicode) {
        result += "u";
      }
      if (this.unicodeSets) {
        result += "v";
      }
      if (this.sticky) {
        result += "y";
      }
      return result;
    }, "get flags", true);
  }
});

// node_modules/regexp.prototype.flags/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/regexp.prototype.flags/polyfill.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var implementation = require_implementation3();
    var supportsDescriptors = require_define_properties().supportsDescriptors;
    var $gOPD = Object.getOwnPropertyDescriptor;
    module.exports = function getPolyfill() {
      if (supportsDescriptors && /a/mig.flags === "gim") {
        var descriptor = $gOPD(RegExp.prototype, "flags");
        if (descriptor && typeof descriptor.get === "function" && typeof RegExp.prototype.dotAll === "boolean" && typeof RegExp.prototype.hasIndices === "boolean") {
          var calls = "";
          var o2 = {};
          Object.defineProperty(o2, "hasIndices", {
            get: function() {
              calls += "d";
            }
          });
          Object.defineProperty(o2, "sticky", {
            get: function() {
              calls += "y";
            }
          });
          if (calls === "dy") {
            return descriptor.get;
          }
        }
      }
      return implementation;
    };
  }
});

// node_modules/regexp.prototype.flags/shim.js
var require_shim = __commonJS({
  "node_modules/regexp.prototype.flags/shim.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var supportsDescriptors = require_define_properties().supportsDescriptors;
    var getPolyfill = require_polyfill();
    var gOPD = Object.getOwnPropertyDescriptor;
    var defineProperty = Object.defineProperty;
    var TypeErr = TypeError;
    var getProto = Object.getPrototypeOf;
    var regex = /a/;
    module.exports = function shimFlags() {
      if (!supportsDescriptors || !getProto) {
        throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
      }
      var polyfill = getPolyfill();
      var proto = getProto(regex);
      var descriptor = gOPD(proto, "flags");
      if (!descriptor || descriptor.get !== polyfill) {
        defineProperty(proto, "flags", {
          configurable: true,
          enumerable: false,
          get: polyfill
        });
      }
      return polyfill;
    };
  }
});

// node_modules/regexp.prototype.flags/index.js
var require_regexp_prototype = __commonJS({
  "node_modules/regexp.prototype.flags/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var define = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation3();
    var getPolyfill = require_polyfill();
    var shim = require_shim();
    var flagsBound = callBind(getPolyfill());
    define(flagsBound, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = flagsBound;
  }
});

// node_modules/es-abstract/helpers/isLeadingSurrogate.js
var require_isLeadingSurrogate = __commonJS({
  "node_modules/es-abstract/helpers/isLeadingSurrogate.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    module.exports = function isLeadingSurrogate(charCode) {
      return typeof charCode === "number" && charCode >= 55296 && charCode <= 56319;
    };
  }
});

// node_modules/es-abstract/helpers/isTrailingSurrogate.js
var require_isTrailingSurrogate = __commonJS({
  "node_modules/es-abstract/helpers/isTrailingSurrogate.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    module.exports = function isTrailingSurrogate(charCode) {
      return typeof charCode === "number" && charCode >= 56320 && charCode <= 57343;
    };
  }
});

// node_modules/es-abstract/2023/UTF16SurrogatePairToCodePoint.js
var require_UTF16SurrogatePairToCodePoint = __commonJS({
  "node_modules/es-abstract/2023/UTF16SurrogatePairToCodePoint.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = require_type();
    var $fromCharCode = GetIntrinsic("%String.fromCharCode%");
    var isLeadingSurrogate = require_isLeadingSurrogate();
    var isTrailingSurrogate = require_isTrailingSurrogate();
    module.exports = function UTF16SurrogatePairToCodePoint(lead, trail) {
      if (!isLeadingSurrogate(lead) || !isTrailingSurrogate(trail)) {
        throw new $TypeError("Assertion failed: `lead` must be a leading surrogate char code, and `trail` must be a trailing surrogate char code");
      }
      return $fromCharCode(lead) + $fromCharCode(trail);
    };
  }
});

// node_modules/es-abstract/2023/CodePointAt.js
var require_CodePointAt = __commonJS({
  "node_modules/es-abstract/2023/CodePointAt.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var $TypeError = require_type();
    var callBound = require_callBound();
    var isLeadingSurrogate = require_isLeadingSurrogate();
    var isTrailingSurrogate = require_isTrailingSurrogate();
    var UTF16SurrogatePairToCodePoint = require_UTF16SurrogatePairToCodePoint();
    var $charAt = callBound("String.prototype.charAt");
    var $charCodeAt = callBound("String.prototype.charCodeAt");
    module.exports = function CodePointAt(string, position) {
      if (typeof string !== "string") {
        throw new $TypeError("Assertion failed: `string` must be a String");
      }
      var size = string.length;
      if (position < 0 || position >= size) {
        throw new $TypeError("Assertion failed: `position` must be >= 0, and < the length of `string`");
      }
      var first = $charCodeAt(string, position);
      var cp = $charAt(string, position);
      var firstIsLeading = isLeadingSurrogate(first);
      var firstIsTrailing = isTrailingSurrogate(first);
      if (!firstIsLeading && !firstIsTrailing) {
        return {
          "[[CodePoint]]": cp,
          "[[CodeUnitCount]]": 1,
          "[[IsUnpairedSurrogate]]": false
        };
      }
      if (firstIsTrailing || position + 1 === size) {
        return {
          "[[CodePoint]]": cp,
          "[[CodeUnitCount]]": 1,
          "[[IsUnpairedSurrogate]]": true
        };
      }
      var second = $charCodeAt(string, position + 1);
      if (!isTrailingSurrogate(second)) {
        return {
          "[[CodePoint]]": cp,
          "[[CodeUnitCount]]": 1,
          "[[IsUnpairedSurrogate]]": true
        };
      }
      return {
        "[[CodePoint]]": UTF16SurrogatePairToCodePoint(first, second),
        "[[CodeUnitCount]]": 2,
        "[[IsUnpairedSurrogate]]": false
      };
    };
  }
});

// node_modules/es-abstract/helpers/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/es-abstract/helpers/isNaN.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    module.exports = Number.isNaN || function isNaN2(a) {
      return a !== a;
    };
  }
});

// node_modules/es-abstract/helpers/isFinite.js
var require_isFinite = __commonJS({
  "node_modules/es-abstract/helpers/isFinite.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var $isNaN = require_isNaN();
    module.exports = function(x) {
      return (typeof x === "number" || typeof x === "bigint") && !$isNaN(x) && x !== Infinity && x !== -Infinity;
    };
  }
});

// node_modules/es-abstract/helpers/isInteger.js
var require_isInteger = __commonJS({
  "node_modules/es-abstract/helpers/isInteger.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var GetIntrinsic = require_get_intrinsic();
    var $abs = GetIntrinsic("%Math.abs%");
    var $floor = GetIntrinsic("%Math.floor%");
    var $isNaN = require_isNaN();
    var $isFinite = require_isFinite();
    module.exports = function isInteger(argument) {
      if (typeof argument !== "number" || $isNaN(argument) || !$isFinite(argument)) {
        return false;
      }
      var absValue = $abs(argument);
      return $floor(absValue) === absValue;
    };
  }
});

// node_modules/es-abstract/helpers/maxSafeInteger.js
var require_maxSafeInteger = __commonJS({
  "node_modules/es-abstract/helpers/maxSafeInteger.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    module.exports = Number.MAX_SAFE_INTEGER || 9007199254740991;
  }
});

// node_modules/es-abstract/2023/AdvanceStringIndex.js
var require_AdvanceStringIndex = __commonJS({
  "node_modules/es-abstract/2023/AdvanceStringIndex.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var CodePointAt = require_CodePointAt();
    var isInteger = require_isInteger();
    var MAX_SAFE_INTEGER = require_maxSafeInteger();
    var $TypeError = require_type();
    module.exports = function AdvanceStringIndex(S, index2, unicode) {
      if (typeof S !== "string") {
        throw new $TypeError("Assertion failed: `S` must be a String");
      }
      if (!isInteger(index2) || index2 < 0 || index2 > MAX_SAFE_INTEGER) {
        throw new $TypeError("Assertion failed: `length` must be an integer >= 0 and <= 2**53");
      }
      if (typeof unicode !== "boolean") {
        throw new $TypeError("Assertion failed: `unicode` must be a Boolean");
      }
      if (!unicode) {
        return index2 + 1;
      }
      var length2 = S.length;
      if (index2 + 1 >= length2) {
        return index2 + 1;
      }
      var cp = CodePointAt(S, index2);
      return index2 + cp["[[CodeUnitCount]]"];
    };
  }
});

// node_modules/es-abstract/2023/CreateIterResultObject.js
var require_CreateIterResultObject = __commonJS({
  "node_modules/es-abstract/2023/CreateIterResultObject.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var $TypeError = require_type();
    module.exports = function CreateIterResultObject(value, done) {
      if (typeof done !== "boolean") {
        throw new $TypeError("Assertion failed: Type(done) is not Boolean");
      }
      return {
        value,
        done
      };
    };
  }
});

// node_modules/es-abstract/helpers/DefineOwnProperty.js
var require_DefineOwnProperty = __commonJS({
  "node_modules/es-abstract/helpers/DefineOwnProperty.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var hasPropertyDescriptors = require_has_property_descriptors();
    var $defineProperty = require_es_define_property();
    var hasArrayLengthDefineBug = hasPropertyDescriptors.hasArrayLengthDefineBug();
    var isArray = hasArrayLengthDefineBug && require_IsArray();
    var callBound = require_callBound();
    var $isEnumerable = callBound("Object.prototype.propertyIsEnumerable");
    module.exports = function DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, desc) {
      if (!$defineProperty) {
        if (!IsDataDescriptor(desc)) {
          return false;
        }
        if (!desc["[[Configurable]]"] || !desc["[[Writable]]"]) {
          return false;
        }
        if (P in O && $isEnumerable(O, P) !== !!desc["[[Enumerable]]"]) {
          return false;
        }
        var V = desc["[[Value]]"];
        O[P] = V;
        return SameValue(O[P], V);
      }
      if (hasArrayLengthDefineBug && P === "length" && "[[Value]]" in desc && isArray(O) && O.length !== desc["[[Value]]"]) {
        O.length = desc["[[Value]]"];
        return O.length === desc["[[Value]]"];
      }
      $defineProperty(O, P, FromPropertyDescriptor(desc));
      return true;
    };
  }
});

// node_modules/es-abstract/helpers/records/property-descriptor.js
var require_property_descriptor = __commonJS({
  "node_modules/es-abstract/helpers/records/property-descriptor.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var $TypeError = require_type();
    var hasOwn = require_hasown();
    var allowed = {
      __proto__: null,
      "[[Configurable]]": true,
      "[[Enumerable]]": true,
      "[[Get]]": true,
      "[[Set]]": true,
      "[[Value]]": true,
      "[[Writable]]": true
    };
    module.exports = function isPropertyDescriptor(Desc) {
      if (!Desc || typeof Desc !== "object") {
        return false;
      }
      for (var key in Desc) {
        if (hasOwn(Desc, key) && !allowed[key]) {
          return false;
        }
      }
      var isData = hasOwn(Desc, "[[Value]]") || hasOwn(Desc, "[[Writable]]");
      var IsAccessor = hasOwn(Desc, "[[Get]]") || hasOwn(Desc, "[[Set]]");
      if (isData && IsAccessor) {
        throw new $TypeError("Property Descriptors may not be both accessor and data descriptors");
      }
      return true;
    };
  }
});

// node_modules/es-abstract/helpers/fromPropertyDescriptor.js
var require_fromPropertyDescriptor = __commonJS({
  "node_modules/es-abstract/helpers/fromPropertyDescriptor.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    module.exports = function fromPropertyDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return Desc;
      }
      var obj = {};
      if ("[[Value]]" in Desc) {
        obj.value = Desc["[[Value]]"];
      }
      if ("[[Writable]]" in Desc) {
        obj.writable = !!Desc["[[Writable]]"];
      }
      if ("[[Get]]" in Desc) {
        obj.get = Desc["[[Get]]"];
      }
      if ("[[Set]]" in Desc) {
        obj.set = Desc["[[Set]]"];
      }
      if ("[[Enumerable]]" in Desc) {
        obj.enumerable = !!Desc["[[Enumerable]]"];
      }
      if ("[[Configurable]]" in Desc) {
        obj.configurable = !!Desc["[[Configurable]]"];
      }
      return obj;
    };
  }
});

// node_modules/es-abstract/2023/FromPropertyDescriptor.js
var require_FromPropertyDescriptor = __commonJS({
  "node_modules/es-abstract/2023/FromPropertyDescriptor.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var $TypeError = require_type();
    var isPropertyDescriptor = require_property_descriptor();
    var fromPropertyDescriptor = require_fromPropertyDescriptor();
    module.exports = function FromPropertyDescriptor(Desc) {
      if (typeof Desc !== "undefined" && !isPropertyDescriptor(Desc)) {
        throw new $TypeError("Assertion failed: `Desc` must be a Property Descriptor");
      }
      return fromPropertyDescriptor(Desc);
    };
  }
});

// node_modules/es-abstract/2023/IsDataDescriptor.js
var require_IsDataDescriptor = __commonJS({
  "node_modules/es-abstract/2023/IsDataDescriptor.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var $TypeError = require_type();
    var hasOwn = require_hasown();
    var isPropertyDescriptor = require_property_descriptor();
    module.exports = function IsDataDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return false;
      }
      if (!isPropertyDescriptor(Desc)) {
        throw new $TypeError("Assertion failed: `Desc` must be a Property Descriptor");
      }
      if (!hasOwn(Desc, "[[Value]]") && !hasOwn(Desc, "[[Writable]]")) {
        return false;
      }
      return true;
    };
  }
});

// node_modules/es-abstract/2023/SameValue.js
var require_SameValue = __commonJS({
  "node_modules/es-abstract/2023/SameValue.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var $isNaN = require_isNaN();
    module.exports = function SameValue(x, y) {
      if (x === y) {
        if (x === 0) {
          return 1 / x === 1 / y;
        }
        return true;
      }
      return $isNaN(x) && $isNaN(y);
    };
  }
});

// node_modules/es-abstract/2023/CreateMethodProperty.js
var require_CreateMethodProperty = __commonJS({
  "node_modules/es-abstract/2023/CreateMethodProperty.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var $TypeError = require_type();
    var DefineOwnProperty = require_DefineOwnProperty();
    var FromPropertyDescriptor = require_FromPropertyDescriptor();
    var IsDataDescriptor = require_IsDataDescriptor();
    var IsPropertyKey = require_IsPropertyKey();
    var SameValue = require_SameValue();
    var Type = require_Type2();
    module.exports = function CreateMethodProperty(O, P, V) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var newDesc = {
        "[[Configurable]]": true,
        "[[Enumerable]]": false,
        "[[Value]]": V,
        "[[Writable]]": true
      };
      return DefineOwnProperty(
        IsDataDescriptor,
        SameValue,
        FromPropertyDescriptor,
        O,
        P,
        newDesc
      );
    };
  }
});

// node_modules/es-abstract/helpers/forEach.js
var require_forEach = __commonJS({
  "node_modules/es-abstract/helpers/forEach.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    module.exports = function forEach(array, callback) {
      for (var i = 0; i < array.length; i += 1) {
        callback(array[i], i, array);
      }
    };
  }
});

// node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "node_modules/side-channel/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect = require_object_inspect();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key) {
      for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = {
          // eslint-disable-line no-param-reassign
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      return !!listGetNode(objects, key);
    };
    module.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        }
      };
      return channel;
    };
  }
});

// node_modules/internal-slot/index.js
var require_internal_slot = __commonJS({
  "node_modules/internal-slot/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var hasOwn = require_hasown();
    var channel = require_side_channel()();
    var $TypeError = require_type();
    var SLOT = {
      assert: function(O, slot) {
        if (!O || typeof O !== "object" && typeof O !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        channel.assert(O);
        if (!SLOT.has(O, slot)) {
          throw new $TypeError("`" + slot + "` is not present on `O`");
        }
      },
      get: function(O, slot) {
        if (!O || typeof O !== "object" && typeof O !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        var slots = channel.get(O);
        return slots && slots["$" + slot];
      },
      has: function(O, slot) {
        if (!O || typeof O !== "object" && typeof O !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        var slots = channel.get(O);
        return !!slots && hasOwn(slots, "$" + slot);
      },
      set: function(O, slot, V) {
        if (!O || typeof O !== "object" && typeof O !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        var slots = channel.get(O);
        if (!slots) {
          slots = {};
          channel.set(O, slots);
        }
        slots["$" + slot] = V;
      }
    };
    if (Object.freeze) {
      Object.freeze(SLOT);
    }
    module.exports = SLOT;
  }
});

// node_modules/es-abstract/2023/OrdinaryObjectCreate.js
var require_OrdinaryObjectCreate = __commonJS({
  "node_modules/es-abstract/2023/OrdinaryObjectCreate.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var GetIntrinsic = require_get_intrinsic();
    var $ObjectCreate = GetIntrinsic("%Object.create%", true);
    var $TypeError = require_type();
    var $SyntaxError = require_syntax();
    var IsArray = require_IsArray2();
    var Type = require_Type2();
    var forEach = require_forEach();
    var SLOT = require_internal_slot();
    var hasProto = require_has_proto()();
    module.exports = function OrdinaryObjectCreate(proto) {
      if (proto !== null && Type(proto) !== "Object") {
        throw new $TypeError("Assertion failed: `proto` must be null or an object");
      }
      var additionalInternalSlotsList = arguments.length < 2 ? [] : arguments[1];
      if (!IsArray(additionalInternalSlotsList)) {
        throw new $TypeError("Assertion failed: `additionalInternalSlotsList` must be an Array");
      }
      var O;
      if ($ObjectCreate) {
        O = $ObjectCreate(proto);
      } else if (hasProto) {
        O = { __proto__: proto };
      } else {
        if (proto === null) {
          throw new $SyntaxError("native Object.create support is required to create null objects");
        }
        var T = function T2() {
        };
        T.prototype = proto;
        O = new T();
      }
      if (additionalInternalSlotsList.length > 0) {
        forEach(additionalInternalSlotsList, function(slot) {
          SLOT.set(O, slot, void 0);
        });
      }
      return O;
    };
  }
});

// node_modules/es-abstract/2023/RegExpExec.js
var require_RegExpExec = __commonJS({
  "node_modules/es-abstract/2023/RegExpExec.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var $TypeError = require_type();
    var regexExec = require_callBound()("RegExp.prototype.exec");
    var Call = require_Call();
    var Get = require_Get();
    var IsCallable = require_IsCallable();
    var Type = require_Type2();
    module.exports = function RegExpExec(R, S) {
      if (Type(R) !== "Object") {
        throw new $TypeError("Assertion failed: `R` must be an Object");
      }
      if (typeof S !== "string") {
        throw new $TypeError("Assertion failed: `S` must be a String");
      }
      var exec = Get(R, "exec");
      if (IsCallable(exec)) {
        var result = Call(exec, R, [S]);
        if (typeof result === "object") {
          return result;
        }
        throw new $TypeError('"exec" method must return `null` or an Object');
      }
      return regexExec(R, S);
    };
  }
});

// node_modules/es-abstract/2023/Set.js
var require_Set = __commonJS({
  "node_modules/es-abstract/2023/Set.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var $TypeError = require_type();
    var IsPropertyKey = require_IsPropertyKey();
    var SameValue = require_SameValue();
    var Type = require_Type2();
    var noThrowOnStrictViolation = function() {
      try {
        delete [].length;
        return true;
      } catch (e2) {
        return false;
      }
    }();
    module.exports = function Set2(O, P, V, Throw) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: `O` must be an Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: `P` must be a Property Key");
      }
      if (typeof Throw !== "boolean") {
        throw new $TypeError("Assertion failed: `Throw` must be a Boolean");
      }
      if (Throw) {
        O[P] = V;
        if (noThrowOnStrictViolation && !SameValue(O[P], V)) {
          throw new $TypeError("Attempted to assign to readonly property.");
        }
        return true;
      }
      try {
        O[P] = V;
        return noThrowOnStrictViolation ? SameValue(O[P], V) : true;
      } catch (e2) {
        return false;
      }
    };
  }
});

// node_modules/es-abstract/helpers/isPrimitive.js
var require_isPrimitive = __commonJS({
  "node_modules/es-abstract/helpers/isPrimitive.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    module.exports = function isPrimitive(value) {
      return value === null || typeof value !== "function" && typeof value !== "object";
    };
  }
});

// node_modules/es-to-primitive/helpers/isPrimitive.js
var require_isPrimitive2 = __commonJS({
  "node_modules/es-to-primitive/helpers/isPrimitive.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    module.exports = function isPrimitive(value) {
      return value === null || typeof value !== "function" && typeof value !== "object";
    };
  }
});

// node_modules/is-date-object/index.js
var require_is_date_object = __commonJS({
  "node_modules/is-date-object/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var getDay = Date.prototype.getDay;
    var tryDateObject = function tryDateGetDayCall(value) {
      try {
        getDay.call(value);
        return true;
      } catch (e2) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var dateClass = "[object Date]";
    var hasToStringTag = require_shams2()();
    module.exports = function isDateObject(value) {
      if (typeof value !== "object" || value === null) {
        return false;
      }
      return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
    };
  }
});

// node_modules/is-symbol/index.js
var require_is_symbol = __commonJS({
  "node_modules/is-symbol/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var toStr = Object.prototype.toString;
    var hasSymbols = require_has_symbols()();
    if (hasSymbols) {
      symToStr = Symbol.prototype.toString;
      symStringRegex = /^Symbol\(.*\)$/;
      isSymbolObject = function isRealSymbolObject(value) {
        if (typeof value.valueOf() !== "symbol") {
          return false;
        }
        return symStringRegex.test(symToStr.call(value));
      };
      module.exports = function isSymbol(value) {
        if (typeof value === "symbol") {
          return true;
        }
        if (toStr.call(value) !== "[object Symbol]") {
          return false;
        }
        try {
          return isSymbolObject(value);
        } catch (e2) {
          return false;
        }
      };
    } else {
      module.exports = function isSymbol(value) {
        return false;
      };
    }
    var symToStr;
    var symStringRegex;
    var isSymbolObject;
  }
});

// node_modules/es-to-primitive/es2015.js
var require_es2015 = __commonJS({
  "node_modules/es-to-primitive/es2015.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var hasSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "symbol";
    var isPrimitive = require_isPrimitive2();
    var isCallable = require_is_callable();
    var isDate = require_is_date_object();
    var isSymbol = require_is_symbol();
    var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
      if (typeof O === "undefined" || O === null) {
        throw new TypeError("Cannot call method on " + O);
      }
      if (typeof hint !== "string" || hint !== "number" && hint !== "string") {
        throw new TypeError('hint must be "string" or "number"');
      }
      var methodNames = hint === "string" ? ["toString", "valueOf"] : ["valueOf", "toString"];
      var method, result, i;
      for (i = 0; i < methodNames.length; ++i) {
        method = O[methodNames[i]];
        if (isCallable(method)) {
          result = method.call(O);
          if (isPrimitive(result)) {
            return result;
          }
        }
      }
      throw new TypeError("No default value");
    };
    var GetMethod = function GetMethod2(O, P) {
      var func = O[P];
      if (func !== null && typeof func !== "undefined") {
        if (!isCallable(func)) {
          throw new TypeError(func + " returned for property " + P + " of object " + O + " is not a function");
        }
        return func;
      }
      return void 0;
    };
    module.exports = function ToPrimitive(input) {
      if (isPrimitive(input)) {
        return input;
      }
      var hint = "default";
      if (arguments.length > 1) {
        if (arguments[1] === String) {
          hint = "string";
        } else if (arguments[1] === Number) {
          hint = "number";
        }
      }
      var exoticToPrim;
      if (hasSymbols) {
        if (Symbol.toPrimitive) {
          exoticToPrim = GetMethod(input, Symbol.toPrimitive);
        } else if (isSymbol(input)) {
          exoticToPrim = Symbol.prototype.valueOf;
        }
      }
      if (typeof exoticToPrim !== "undefined") {
        var result = exoticToPrim.call(input, hint);
        if (isPrimitive(result)) {
          return result;
        }
        throw new TypeError("unable to convert exotic object to primitive");
      }
      if (hint === "default" && (isDate(input) || isSymbol(input))) {
        hint = "string";
      }
      return ordinaryToPrimitive(input, hint === "default" ? "number" : hint);
    };
  }
});

// node_modules/es-abstract/2023/ToPrimitive.js
var require_ToPrimitive = __commonJS({
  "node_modules/es-abstract/2023/ToPrimitive.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var toPrimitive = require_es2015();
    module.exports = function ToPrimitive(input) {
      if (arguments.length > 1) {
        return toPrimitive(input, arguments[1]);
      }
      return toPrimitive(input);
    };
  }
});

// node_modules/safe-regex-test/index.js
var require_safe_regex_test = __commonJS({
  "node_modules/safe-regex-test/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var callBound = require_callBound();
    var isRegex = require_is_regex();
    var $exec = callBound("RegExp.prototype.exec");
    var $TypeError = require_type();
    module.exports = function regexTester(regex) {
      if (!isRegex(regex)) {
        throw new $TypeError("`regex` must be a RegExp");
      }
      return function test(s) {
        return $exec(regex, s) !== null;
      };
    };
  }
});

// node_modules/string.prototype.trim/implementation.js
var require_implementation4 = __commonJS({
  "node_modules/string.prototype.trim/implementation.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var ToString = require_ToString();
    var callBound = require_callBound();
    var $replace = callBound("String.prototype.replace");
    var mvsIsWS = /^\s$/.test("᠎");
    var leftWhitespace = mvsIsWS ? /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+/ : /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+/;
    var rightWhitespace = mvsIsWS ? /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+$/ : /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+$/;
    module.exports = function trim() {
      var S = ToString(RequireObjectCoercible(this));
      return $replace($replace(S, leftWhitespace, ""), rightWhitespace, "");
    };
  }
});

// node_modules/string.prototype.trim/polyfill.js
var require_polyfill2 = __commonJS({
  "node_modules/string.prototype.trim/polyfill.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var implementation = require_implementation4();
    var zeroWidthSpace = "​";
    var mongolianVowelSeparator = "᠎";
    module.exports = function getPolyfill() {
      if (String.prototype.trim && zeroWidthSpace.trim() === zeroWidthSpace && mongolianVowelSeparator.trim() === mongolianVowelSeparator && ("_" + mongolianVowelSeparator).trim() === "_" + mongolianVowelSeparator && (mongolianVowelSeparator + "_").trim() === mongolianVowelSeparator + "_") {
        return String.prototype.trim;
      }
      return implementation;
    };
  }
});

// node_modules/string.prototype.trim/shim.js
var require_shim2 = __commonJS({
  "node_modules/string.prototype.trim/shim.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var define = require_define_properties();
    var getPolyfill = require_polyfill2();
    module.exports = function shimStringTrim() {
      var polyfill = getPolyfill();
      define(String.prototype, { trim: polyfill }, {
        trim: function testTrim() {
          return String.prototype.trim !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/string.prototype.trim/index.js
var require_string_prototype = __commonJS({
  "node_modules/string.prototype.trim/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var callBind = require_call_bind();
    var define = require_define_properties();
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var implementation = require_implementation4();
    var getPolyfill = require_polyfill2();
    var shim = require_shim2();
    var bound = callBind(getPolyfill());
    var boundMethod = function trim(receiver) {
      RequireObjectCoercible(receiver);
      return bound(receiver);
    };
    define(boundMethod, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = boundMethod;
  }
});

// node_modules/es-abstract/2023/StringToNumber.js
var require_StringToNumber = __commonJS({
  "node_modules/es-abstract/2023/StringToNumber.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var GetIntrinsic = require_get_intrinsic();
    var $Number = GetIntrinsic("%Number%");
    var $RegExp = GetIntrinsic("%RegExp%");
    var $TypeError = require_type();
    var $parseInteger = GetIntrinsic("%parseInt%");
    var callBound = require_callBound();
    var regexTester = require_safe_regex_test();
    var $strSlice = callBound("String.prototype.slice");
    var isBinary = regexTester(/^0b[01]+$/i);
    var isOctal = regexTester(/^0o[0-7]+$/i);
    var isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);
    var nonWS = ["", "​", "￾"].join("");
    var nonWSregex = new $RegExp("[" + nonWS + "]", "g");
    var hasNonWS = regexTester(nonWSregex);
    var $trim = require_string_prototype();
    module.exports = function StringToNumber(argument) {
      if (typeof argument !== "string") {
        throw new $TypeError("Assertion failed: `argument` is not a String");
      }
      if (isBinary(argument)) {
        return $Number($parseInteger($strSlice(argument, 2), 2));
      }
      if (isOctal(argument)) {
        return $Number($parseInteger($strSlice(argument, 2), 8));
      }
      if (hasNonWS(argument) || isInvalidHexLiteral(argument)) {
        return NaN;
      }
      var trimmed = $trim(argument);
      if (trimmed !== argument) {
        return StringToNumber(trimmed);
      }
      return $Number(argument);
    };
  }
});

// node_modules/es-abstract/2023/ToNumber.js
var require_ToNumber = __commonJS({
  "node_modules/es-abstract/2023/ToNumber.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = require_type();
    var $Number = GetIntrinsic("%Number%");
    var isPrimitive = require_isPrimitive();
    var ToPrimitive = require_ToPrimitive();
    var StringToNumber = require_StringToNumber();
    module.exports = function ToNumber(argument) {
      var value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
      if (typeof value === "symbol") {
        throw new $TypeError("Cannot convert a Symbol value to a number");
      }
      if (typeof value === "bigint") {
        throw new $TypeError("Conversion from 'BigInt' to 'number' is not allowed.");
      }
      if (typeof value === "string") {
        return StringToNumber(value);
      }
      return $Number(value);
    };
  }
});

// node_modules/es-abstract/2023/floor.js
var require_floor = __commonJS({
  "node_modules/es-abstract/2023/floor.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var $floor = Math.floor;
    module.exports = function floor(x) {
      if (typeof x === "bigint") {
        return x;
      }
      return $floor(x);
    };
  }
});

// node_modules/es-abstract/2023/truncate.js
var require_truncate = __commonJS({
  "node_modules/es-abstract/2023/truncate.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var floor = require_floor();
    var $TypeError = require_type();
    module.exports = function truncate(x) {
      if (typeof x !== "number" && typeof x !== "bigint") {
        throw new $TypeError("argument must be a Number or a BigInt");
      }
      var result = x < 0 ? -floor(-x) : floor(x);
      return result === 0 ? 0 : result;
    };
  }
});

// node_modules/es-abstract/2023/ToIntegerOrInfinity.js
var require_ToIntegerOrInfinity = __commonJS({
  "node_modules/es-abstract/2023/ToIntegerOrInfinity.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var ToNumber = require_ToNumber();
    var truncate = require_truncate();
    var $isNaN = require_isNaN();
    var $isFinite = require_isFinite();
    module.exports = function ToIntegerOrInfinity(value) {
      var number = ToNumber(value);
      if ($isNaN(number) || number === 0) {
        return 0;
      }
      if (!$isFinite(number)) {
        return number;
      }
      return truncate(number);
    };
  }
});

// node_modules/es-abstract/2023/ToLength.js
var require_ToLength = __commonJS({
  "node_modules/es-abstract/2023/ToLength.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var MAX_SAFE_INTEGER = require_maxSafeInteger();
    var ToIntegerOrInfinity = require_ToIntegerOrInfinity();
    module.exports = function ToLength(argument) {
      var len = ToIntegerOrInfinity(argument);
      if (len <= 0) {
        return 0;
      }
      if (len > MAX_SAFE_INTEGER) {
        return MAX_SAFE_INTEGER;
      }
      return len;
    };
  }
});

// node_modules/es-set-tostringtag/index.js
var require_es_set_tostringtag = __commonJS({
  "node_modules/es-set-tostringtag/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasToStringTag = require_shams2()();
    var hasOwn = require_hasown();
    var toStringTag = hasToStringTag ? Symbol.toStringTag : null;
    module.exports = function setToStringTag(object, value) {
      var overrideIfSet = arguments.length > 2 && arguments[2] && arguments[2].force;
      if (toStringTag && (overrideIfSet || !hasOwn(object, toStringTag))) {
        if ($defineProperty) {
          $defineProperty(object, toStringTag, {
            configurable: true,
            enumerable: false,
            value,
            writable: false
          });
        } else {
          object[toStringTag] = value;
        }
      }
    };
  }
});

// node_modules/es-abstract/2023/CreateRegExpStringIterator.js
var require_CreateRegExpStringIterator = __commonJS({
  "node_modules/es-abstract/2023/CreateRegExpStringIterator.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var GetIntrinsic = require_get_intrinsic();
    var hasSymbols = require_has_symbols()();
    var $TypeError = require_type();
    var IteratorPrototype = GetIntrinsic("%IteratorPrototype%", true);
    var AdvanceStringIndex = require_AdvanceStringIndex();
    var CreateIterResultObject = require_CreateIterResultObject();
    var CreateMethodProperty = require_CreateMethodProperty();
    var Get = require_Get();
    var OrdinaryObjectCreate = require_OrdinaryObjectCreate();
    var RegExpExec = require_RegExpExec();
    var Set2 = require_Set();
    var ToLength = require_ToLength();
    var ToString = require_ToString();
    var Type = require_Type2();
    var SLOT = require_internal_slot();
    var setToStringTag = require_es_set_tostringtag();
    var RegExpStringIterator = function RegExpStringIterator2(R, S, global2, fullUnicode) {
      if (typeof S !== "string") {
        throw new $TypeError("`S` must be a string");
      }
      if (typeof global2 !== "boolean") {
        throw new $TypeError("`global` must be a boolean");
      }
      if (typeof fullUnicode !== "boolean") {
        throw new $TypeError("`fullUnicode` must be a boolean");
      }
      SLOT.set(this, "[[IteratingRegExp]]", R);
      SLOT.set(this, "[[IteratedString]]", S);
      SLOT.set(this, "[[Global]]", global2);
      SLOT.set(this, "[[Unicode]]", fullUnicode);
      SLOT.set(this, "[[Done]]", false);
    };
    if (IteratorPrototype) {
      RegExpStringIterator.prototype = OrdinaryObjectCreate(IteratorPrototype);
    }
    var RegExpStringIteratorNext = function next() {
      var O = this;
      if (Type(O) !== "Object") {
        throw new $TypeError("receiver must be an object");
      }
      if (!(O instanceof RegExpStringIterator) || !SLOT.has(O, "[[IteratingRegExp]]") || !SLOT.has(O, "[[IteratedString]]") || !SLOT.has(O, "[[Global]]") || !SLOT.has(O, "[[Unicode]]") || !SLOT.has(O, "[[Done]]")) {
        throw new $TypeError('"this" value must be a RegExpStringIterator instance');
      }
      if (SLOT.get(O, "[[Done]]")) {
        return CreateIterResultObject(void 0, true);
      }
      var R = SLOT.get(O, "[[IteratingRegExp]]");
      var S = SLOT.get(O, "[[IteratedString]]");
      var global2 = SLOT.get(O, "[[Global]]");
      var fullUnicode = SLOT.get(O, "[[Unicode]]");
      var match2 = RegExpExec(R, S);
      if (match2 === null) {
        SLOT.set(O, "[[Done]]", true);
        return CreateIterResultObject(void 0, true);
      }
      if (global2) {
        var matchStr = ToString(Get(match2, "0"));
        if (matchStr === "") {
          var thisIndex = ToLength(Get(R, "lastIndex"));
          var nextIndex = AdvanceStringIndex(S, thisIndex, fullUnicode);
          Set2(R, "lastIndex", nextIndex, true);
        }
        return CreateIterResultObject(match2, false);
      }
      SLOT.set(O, "[[Done]]", true);
      return CreateIterResultObject(match2, false);
    };
    CreateMethodProperty(RegExpStringIterator.prototype, "next", RegExpStringIteratorNext);
    if (hasSymbols) {
      setToStringTag(RegExpStringIterator.prototype, "RegExp String Iterator");
      if (Symbol.iterator && typeof RegExpStringIterator.prototype[Symbol.iterator] !== "function") {
        iteratorFn = function SymbolIterator() {
          return this;
        };
        CreateMethodProperty(RegExpStringIterator.prototype, Symbol.iterator, iteratorFn);
      }
    }
    var iteratorFn;
    module.exports = function CreateRegExpStringIterator(R, S, global2, fullUnicode) {
      return new RegExpStringIterator(R, S, global2, fullUnicode);
    };
  }
});

// node_modules/es-abstract/GetIntrinsic.js
var require_GetIntrinsic = __commonJS({
  "node_modules/es-abstract/GetIntrinsic.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    module.exports = require_get_intrinsic();
  }
});

// node_modules/es-abstract/2023/ToPropertyDescriptor.js
var require_ToPropertyDescriptor = __commonJS({
  "node_modules/es-abstract/2023/ToPropertyDescriptor.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var hasOwn = require_hasown();
    var $TypeError = require_type();
    var Type = require_Type2();
    var ToBoolean = require_ToBoolean();
    var IsCallable = require_IsCallable();
    module.exports = function ToPropertyDescriptor(Obj) {
      if (Type(Obj) !== "Object") {
        throw new $TypeError("ToPropertyDescriptor requires an object");
      }
      var desc = {};
      if (hasOwn(Obj, "enumerable")) {
        desc["[[Enumerable]]"] = ToBoolean(Obj.enumerable);
      }
      if (hasOwn(Obj, "configurable")) {
        desc["[[Configurable]]"] = ToBoolean(Obj.configurable);
      }
      if (hasOwn(Obj, "value")) {
        desc["[[Value]]"] = Obj.value;
      }
      if (hasOwn(Obj, "writable")) {
        desc["[[Writable]]"] = ToBoolean(Obj.writable);
      }
      if (hasOwn(Obj, "get")) {
        var getter = Obj.get;
        if (typeof getter !== "undefined" && !IsCallable(getter)) {
          throw new $TypeError("getter must be a function");
        }
        desc["[[Get]]"] = getter;
      }
      if (hasOwn(Obj, "set")) {
        var setter = Obj.set;
        if (typeof setter !== "undefined" && !IsCallable(setter)) {
          throw new $TypeError("setter must be a function");
        }
        desc["[[Set]]"] = setter;
      }
      if ((hasOwn(desc, "[[Get]]") || hasOwn(desc, "[[Set]]")) && (hasOwn(desc, "[[Value]]") || hasOwn(desc, "[[Writable]]"))) {
        throw new $TypeError("Invalid property descriptor. Cannot both specify accessors and a value or writable attribute");
      }
      return desc;
    };
  }
});

// node_modules/es-abstract/2023/DefinePropertyOrThrow.js
var require_DefinePropertyOrThrow = __commonJS({
  "node_modules/es-abstract/2023/DefinePropertyOrThrow.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var $TypeError = require_type();
    var isPropertyDescriptor = require_property_descriptor();
    var DefineOwnProperty = require_DefineOwnProperty();
    var FromPropertyDescriptor = require_FromPropertyDescriptor();
    var IsDataDescriptor = require_IsDataDescriptor();
    var IsPropertyKey = require_IsPropertyKey();
    var SameValue = require_SameValue();
    var ToPropertyDescriptor = require_ToPropertyDescriptor();
    var Type = require_Type2();
    module.exports = function DefinePropertyOrThrow(O, P, desc) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var Desc = isPropertyDescriptor(desc) ? desc : ToPropertyDescriptor(desc);
      if (!isPropertyDescriptor(Desc)) {
        throw new $TypeError("Assertion failed: Desc is not a valid Property Descriptor");
      }
      return DefineOwnProperty(
        IsDataDescriptor,
        SameValue,
        FromPropertyDescriptor,
        O,
        P,
        Desc
      );
    };
  }
});

// node_modules/es-abstract/2023/IsConstructor.js
var require_IsConstructor = __commonJS({
  "node_modules/es-abstract/2023/IsConstructor.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var GetIntrinsic = require_GetIntrinsic();
    var $construct = GetIntrinsic("%Reflect.construct%", true);
    var DefinePropertyOrThrow = require_DefinePropertyOrThrow();
    try {
      DefinePropertyOrThrow({}, "", { "[[Get]]": function() {
      } });
    } catch (e2) {
      DefinePropertyOrThrow = null;
    }
    if (DefinePropertyOrThrow && $construct) {
      isConstructorMarker = {};
      badArrayLike = {};
      DefinePropertyOrThrow(badArrayLike, "length", {
        "[[Get]]": function() {
          throw isConstructorMarker;
        },
        "[[Enumerable]]": true
      });
      module.exports = function IsConstructor(argument) {
        try {
          $construct(argument, badArrayLike);
        } catch (err) {
          return err === isConstructorMarker;
        }
      };
    } else {
      module.exports = function IsConstructor(argument) {
        return typeof argument === "function" && !!argument.prototype;
      };
    }
    var isConstructorMarker;
    var badArrayLike;
  }
});

// node_modules/es-abstract/2023/SpeciesConstructor.js
var require_SpeciesConstructor = __commonJS({
  "node_modules/es-abstract/2023/SpeciesConstructor.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var GetIntrinsic = require_get_intrinsic();
    var $species = GetIntrinsic("%Symbol.species%", true);
    var $TypeError = require_type();
    var IsConstructor = require_IsConstructor();
    var Type = require_Type2();
    module.exports = function SpeciesConstructor(O, defaultConstructor) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      var C = O.constructor;
      if (typeof C === "undefined") {
        return defaultConstructor;
      }
      if (Type(C) !== "Object") {
        throw new $TypeError("O.constructor is not an Object");
      }
      var S = $species ? C[$species] : void 0;
      if (S == null) {
        return defaultConstructor;
      }
      if (IsConstructor(S)) {
        return S;
      }
      throw new $TypeError("no constructor found");
    };
  }
});

// node_modules/string.prototype.matchall/regexp-matchall.js
var require_regexp_matchall = __commonJS({
  "node_modules/string.prototype.matchall/regexp-matchall.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var CreateRegExpStringIterator = require_CreateRegExpStringIterator();
    var Get = require_Get();
    var Set2 = require_Set();
    var SpeciesConstructor = require_SpeciesConstructor();
    var ToLength = require_ToLength();
    var ToString = require_ToString();
    var Type = require_Type2();
    var flagsGetter = require_regexp_prototype();
    var setFunctionName = require_set_function_name();
    var callBound = require_callBound();
    var $indexOf = callBound("String.prototype.indexOf");
    var OrigRegExp = RegExp;
    var supportsConstructingWithFlags = "flags" in RegExp.prototype;
    var constructRegexWithFlags = function constructRegex(C, R) {
      var matcher;
      var flags = "flags" in R ? Get(R, "flags") : ToString(flagsGetter(R));
      if (supportsConstructingWithFlags && typeof flags === "string") {
        matcher = new C(R, flags);
      } else if (C === OrigRegExp) {
        matcher = new C(R.source, flags);
      } else {
        matcher = new C(R, flags);
      }
      return { flags, matcher };
    };
    var regexMatchAll = setFunctionName(function SymbolMatchAll(string) {
      var R = this;
      if (Type(R) !== "Object") {
        throw new TypeError('"this" value must be an Object');
      }
      var S = ToString(string);
      var C = SpeciesConstructor(R, OrigRegExp);
      var tmp = constructRegexWithFlags(C, R);
      var flags = tmp.flags;
      var matcher = tmp.matcher;
      var lastIndex = ToLength(Get(R, "lastIndex"));
      Set2(matcher, "lastIndex", lastIndex, true);
      var global2 = $indexOf(flags, "g") > -1;
      var fullUnicode = $indexOf(flags, "u") > -1;
      return CreateRegExpStringIterator(matcher, S, global2, fullUnicode);
    }, "[Symbol.matchAll]", true);
    module.exports = regexMatchAll;
  }
});

// node_modules/string.prototype.matchall/polyfill-regexp-matchall.js
var require_polyfill_regexp_matchall = __commonJS({
  "node_modules/string.prototype.matchall/polyfill-regexp-matchall.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var hasSymbols = require_has_symbols()();
    var regexpMatchAll = require_regexp_matchall();
    module.exports = function getRegExpMatchAllPolyfill() {
      if (!hasSymbols || typeof Symbol.matchAll !== "symbol" || typeof RegExp.prototype[Symbol.matchAll] !== "function") {
        return regexpMatchAll;
      }
      return RegExp.prototype[Symbol.matchAll];
    };
  }
});

// node_modules/string.prototype.matchall/implementation.js
var require_implementation5 = __commonJS({
  "node_modules/string.prototype.matchall/implementation.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var Call = require_Call();
    var Get = require_Get();
    var GetMethod = require_GetMethod();
    var IsRegExp = require_IsRegExp();
    var ToString = require_ToString();
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var callBound = require_callBound();
    var hasSymbols = require_has_symbols()();
    var flagsGetter = require_regexp_prototype();
    var $indexOf = callBound("String.prototype.indexOf");
    var regexpMatchAllPolyfill = require_polyfill_regexp_matchall();
    var getMatcher = function getMatcher2(regexp) {
      var matcherPolyfill = regexpMatchAllPolyfill();
      if (hasSymbols && typeof Symbol.matchAll === "symbol") {
        var matcher = GetMethod(regexp, Symbol.matchAll);
        if (matcher === RegExp.prototype[Symbol.matchAll] && matcher !== matcherPolyfill) {
          return matcherPolyfill;
        }
        return matcher;
      }
      if (IsRegExp(regexp)) {
        return matcherPolyfill;
      }
    };
    module.exports = function matchAll(regexp) {
      var O = RequireObjectCoercible(this);
      if (typeof regexp !== "undefined" && regexp !== null) {
        var isRegExp = IsRegExp(regexp);
        if (isRegExp) {
          var flags = "flags" in regexp ? Get(regexp, "flags") : flagsGetter(regexp);
          RequireObjectCoercible(flags);
          if ($indexOf(ToString(flags), "g") < 0) {
            throw new TypeError("matchAll requires a global regular expression");
          }
        }
        var matcher = getMatcher(regexp);
        if (typeof matcher !== "undefined") {
          return Call(matcher, regexp, [O]);
        }
      }
      var S = ToString(O);
      var rx = new RegExp(regexp, "g");
      return Call(getMatcher(rx), rx, [S]);
    };
  }
});

// node_modules/string.prototype.matchall/polyfill.js
var require_polyfill3 = __commonJS({
  "node_modules/string.prototype.matchall/polyfill.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var implementation = require_implementation5();
    module.exports = function getPolyfill() {
      if (String.prototype.matchAll) {
        try {
          "".matchAll(RegExp.prototype);
        } catch (e2) {
          return String.prototype.matchAll;
        }
      }
      return implementation;
    };
  }
});

// node_modules/string.prototype.matchall/shim.js
var require_shim3 = __commonJS({
  "node_modules/string.prototype.matchall/shim.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var define = require_define_properties();
    var hasSymbols = require_has_symbols()();
    var getPolyfill = require_polyfill3();
    var regexpMatchAllPolyfill = require_polyfill_regexp_matchall();
    var defineP = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    module.exports = function shimMatchAll() {
      var polyfill = getPolyfill();
      define(
        String.prototype,
        { matchAll: polyfill },
        { matchAll: function() {
          return String.prototype.matchAll !== polyfill;
        } }
      );
      if (hasSymbols) {
        var symbol = Symbol.matchAll || (Symbol["for"] ? Symbol["for"]("Symbol.matchAll") : Symbol("Symbol.matchAll"));
        define(
          Symbol,
          { matchAll: symbol },
          { matchAll: function() {
            return Symbol.matchAll !== symbol;
          } }
        );
        if (defineP && gOPD) {
          var desc = gOPD(Symbol, symbol);
          if (!desc || desc.configurable) {
            defineP(Symbol, symbol, {
              configurable: false,
              enumerable: false,
              value: symbol,
              writable: false
            });
          }
        }
        var regexpMatchAll = regexpMatchAllPolyfill();
        var func = {};
        func[symbol] = regexpMatchAll;
        var predicate = {};
        predicate[symbol] = function() {
          return RegExp.prototype[symbol] !== regexpMatchAll;
        };
        define(RegExp.prototype, func, predicate);
      }
      return polyfill;
    };
  }
});

// node_modules/string.prototype.matchall/index.js
var require_string_prototype2 = __commonJS({
  "node_modules/string.prototype.matchall/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var callBind = require_call_bind();
    var define = require_define_properties();
    var implementation = require_implementation5();
    var getPolyfill = require_polyfill3();
    var shim = require_shim3();
    var boundMatchAll = callBind(implementation);
    define(boundMatchAll, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = boundMatchAll;
  }
});

// node_modules/@sphereon/pex/dist/module/lib/validation/validatePDv1.js
var require_validatePDv1 = __commonJS({
  "node_modules/@sphereon/pex/dist/module/lib/validation/validatePDv1.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    module.exports = validate42;
    module.exports.default = validate42;
    var schema12 = { "$schema": "http://json-schema.org/draft-07/schema#", "title": "Presentation Definition", "definitions": { "schema": { "type": "object", "properties": { "uri": { "type": "string" }, "required": { "type": "boolean" } }, "required": ["uri"], "additionalProperties": false }, "issuance": { "type": "object", "properties": { "manifest": { "type": "string" } }, "additionalProperties": true }, "filter": { "type": "object", "properties": { "type": { "type": "string" }, "format": { "type": "string" }, "pattern": { "type": "string" }, "minimum": { "type": ["number", "string"] }, "minLength": { "type": "integer" }, "maxLength": { "type": "integer" }, "exclusiveMinimum": { "type": ["number", "string"] }, "exclusiveMaximum": { "type": ["number", "string"] }, "maximum": { "type": ["number", "string"] }, "const": { "type": ["number", "string"] }, "enum": { "type": "array", "items": { "type": ["number", "string"] } }, "not": { "type": "object", "minProperties": 1 } }, "required": ["type"], "additionalProperties": false }, "format": { "type": "object", "patternProperties": { "^jwt$|^jwt_vc$|^jwt_vp$": { "type": "object", "properties": { "alg": { "type": "array", "minItems": 1, "items": { "type": "string" } } }, "required": ["alg"], "additionalProperties": false }, "^ldp_vc$|^ldp_vp$|^ldp$": { "type": "object", "properties": { "proof_type": { "type": "array", "minItems": 1, "items": { "type": "string" } } }, "required": ["proof_type"], "additionalProperties": false }, "additionalProperties": false }, "additionalProperties": false }, "submission_requirements": { "type": "object", "oneOf": [{ "properties": { "name": { "type": "string" }, "purpose": { "type": "string" }, "rule": { "type": "string", "enum": ["all", "pick"] }, "count": { "type": "integer", "minimum": 1 }, "min": { "type": "integer", "minimum": 0 }, "max": { "type": "integer", "minimum": 0 }, "from": { "type": "string" } }, "required": ["rule", "from"], "additionalProperties": false }, { "properties": { "name": { "type": "string" }, "purpose": { "type": "string" }, "rule": { "type": "string", "enum": ["all", "pick"] }, "count": { "type": "integer", "minimum": 1 }, "min": { "type": "integer", "minimum": 0 }, "max": { "type": "integer", "minimum": 0 }, "from_nested": { "type": "array", "minItems": 1, "items": { "$ref": "#/definitions/submission_requirements" } } }, "required": ["rule", "from_nested"], "additionalProperties": false }] }, "input_descriptors": { "type": "object", "properties": { "id": { "type": "string" }, "name": { "type": "string" }, "purpose": { "type": "string" }, "group": { "type": "array", "items": { "type": "string" } }, "schema": { "type": "array", "items": { "$ref": "#/definitions/schema" } }, "issuance": { "type": "array", "items": { "$ref": "#/definitions/issuance" } }, "constraints": { "type": "object", "properties": { "limit_disclosure": { "type": "string", "enum": ["required", "preferred"] }, "statuses": { "type": "object", "properties": { "active": { "type": "object", "properties": { "directive": { "type": "string", "enum": ["required", "allowed", "disallowed"] } } }, "suspended": { "type": "object", "properties": { "directive": { "type": "string", "enum": ["required", "allowed", "disallowed"] } } }, "revoked": { "type": "object", "properties": { "directive": { "type": "string", "enum": ["required", "allowed", "disallowed"] } } } } }, "fields": { "type": "array", "items": { "$ref": "#/definitions/field" } }, "subject_is_issuer": { "type": "string", "enum": ["required", "preferred"] }, "is_holder": { "type": "array", "items": { "type": "object", "properties": { "field_id": { "type": "array", "items": { "type": "string" } }, "directive": { "type": "string", "enum": ["required", "preferred"] } }, "required": ["field_id", "directive"], "additionalProperties": false } }, "same_subject": { "type": "array", "items": { "type": "object", "properties": { "field_id": { "type": "array", "items": { "type": "string" } }, "directive": { "type": "string", "enum": ["required", "preferred"] } }, "required": ["field_id", "directive"], "additionalProperties": false } } }, "additionalProperties": false } }, "required": ["id", "schema"], "additionalProperties": false }, "field": { "type": "object", "oneOf": [{ "properties": { "id": { "type": "string" }, "path": { "type": "array", "items": { "type": "string" } }, "purpose": { "type": "string" }, "filter": { "$ref": "#/definitions/filter" } }, "required": ["path"], "additionalProperties": false }, { "properties": { "id": { "type": "string" }, "path": { "type": "array", "items": { "type": "string" } }, "purpose": { "type": "string" }, "filter": { "$ref": "#/definitions/filter" }, "predicate": { "type": "string", "enum": ["required", "preferred"] } }, "required": ["path", "filter", "predicate"], "additionalProperties": false }] } }, "type": "object", "properties": { "presentation_definition": { "type": "object", "properties": { "id": { "type": "string" }, "name": { "type": "string" }, "purpose": { "type": "string" }, "format": { "$ref": "#/definitions/format" }, "submission_requirements": { "type": "array", "items": { "$ref": "#/definitions/submission_requirements" } }, "input_descriptors": { "type": "array", "items": { "$ref": "#/definitions/input_descriptors" } } }, "required": ["id", "input_descriptors"], "additionalProperties": false } } };
    var schema13 = { "type": "object", "patternProperties": { "^jwt$|^jwt_vc$|^jwt_vp$": { "type": "object", "properties": { "alg": { "type": "array", "minItems": 1, "items": { "type": "string" } } }, "required": ["alg"], "additionalProperties": false }, "^ldp_vc$|^ldp_vp$|^ldp$": { "type": "object", "properties": { "proof_type": { "type": "array", "minItems": 1, "items": { "type": "string" } } }, "required": ["proof_type"], "additionalProperties": false }, "additionalProperties": false }, "additionalProperties": false };
    var pattern0 = new RegExp("^jwt$|^jwt_vc$|^jwt_vp$", "u");
    var pattern1 = new RegExp("^ldp_vc$|^ldp_vp$|^ldp$", "u");
    var pattern2 = new RegExp("additionalProperties", "u");
    function validate43(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        for (const key0 in data) {
          if (!(pattern0.test(key0) || pattern1.test(key0) || pattern2.test(key0))) {
            const err0 = { instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties", schema: false, parentSchema: schema13, data };
            if (vErrors === null) {
              vErrors = [err0];
            } else {
              vErrors.push(err0);
            }
            errors++;
          }
        }
        for (const key1 in data) {
          if (pattern0.test(key1)) {
            let data0 = data[key1];
            if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
              if (data0.alg === void 0) {
                const err1 = { instancePath: instancePath + "/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/patternProperties/%5Ejwt%24%7C%5Ejwt_vc%24%7C%5Ejwt_vp%24/required", keyword: "required", params: { missingProperty: "alg" }, message: "must have required property 'alg'", schema: schema13.patternProperties["^jwt$|^jwt_vc$|^jwt_vp$"].required, parentSchema: schema13.patternProperties["^jwt$|^jwt_vc$|^jwt_vp$"], data: data0 };
                if (vErrors === null) {
                  vErrors = [err1];
                } else {
                  vErrors.push(err1);
                }
                errors++;
              }
              for (const key2 in data0) {
                if (!(key2 === "alg")) {
                  const err2 = { instancePath: instancePath + "/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/patternProperties/%5Ejwt%24%7C%5Ejwt_vc%24%7C%5Ejwt_vp%24/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key2 }, message: "must NOT have additional properties", schema: false, parentSchema: schema13.patternProperties["^jwt$|^jwt_vc$|^jwt_vp$"], data: data0 };
                  if (vErrors === null) {
                    vErrors = [err2];
                  } else {
                    vErrors.push(err2);
                  }
                  errors++;
                }
              }
              if (data0.alg !== void 0) {
                let data1 = data0.alg;
                if (Array.isArray(data1)) {
                  if (data1.length < 1) {
                    const err3 = { instancePath: instancePath + "/" + key1.replace(/~/g, "~0").replace(/\//g, "~1") + "/alg", schemaPath: "#/patternProperties/%5Ejwt%24%7C%5Ejwt_vc%24%7C%5Ejwt_vp%24/properties/alg/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items", schema: 1, parentSchema: schema13.patternProperties["^jwt$|^jwt_vc$|^jwt_vp$"].properties.alg, data: data1 };
                    if (vErrors === null) {
                      vErrors = [err3];
                    } else {
                      vErrors.push(err3);
                    }
                    errors++;
                  }
                  const len0 = data1.length;
                  for (let i0 = 0; i0 < len0; i0++) {
                    let data2 = data1[i0];
                    if (typeof data2 !== "string") {
                      const err4 = { instancePath: instancePath + "/" + key1.replace(/~/g, "~0").replace(/\//g, "~1") + "/alg/" + i0, schemaPath: "#/patternProperties/%5Ejwt%24%7C%5Ejwt_vc%24%7C%5Ejwt_vp%24/properties/alg/items/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema13.patternProperties["^jwt$|^jwt_vc$|^jwt_vp$"].properties.alg.items.type, parentSchema: schema13.patternProperties["^jwt$|^jwt_vc$|^jwt_vp$"].properties.alg.items, data: data2 };
                      if (vErrors === null) {
                        vErrors = [err4];
                      } else {
                        vErrors.push(err4);
                      }
                      errors++;
                    }
                  }
                } else {
                  const err5 = { instancePath: instancePath + "/" + key1.replace(/~/g, "~0").replace(/\//g, "~1") + "/alg", schemaPath: "#/patternProperties/%5Ejwt%24%7C%5Ejwt_vc%24%7C%5Ejwt_vp%24/properties/alg/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema13.patternProperties["^jwt$|^jwt_vc$|^jwt_vp$"].properties.alg.type, parentSchema: schema13.patternProperties["^jwt$|^jwt_vc$|^jwt_vp$"].properties.alg, data: data1 };
                  if (vErrors === null) {
                    vErrors = [err5];
                  } else {
                    vErrors.push(err5);
                  }
                  errors++;
                }
              }
            } else {
              const err6 = { instancePath: instancePath + "/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/patternProperties/%5Ejwt%24%7C%5Ejwt_vc%24%7C%5Ejwt_vp%24/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema13.patternProperties["^jwt$|^jwt_vc$|^jwt_vp$"].type, parentSchema: schema13.patternProperties["^jwt$|^jwt_vc$|^jwt_vp$"], data: data0 };
              if (vErrors === null) {
                vErrors = [err6];
              } else {
                vErrors.push(err6);
              }
              errors++;
            }
          }
        }
        for (const key3 in data) {
          if (pattern1.test(key3)) {
            let data3 = data[key3];
            if (data3 && typeof data3 == "object" && !Array.isArray(data3)) {
              if (data3.proof_type === void 0) {
                const err7 = { instancePath: instancePath + "/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/patternProperties/%5Eldp_vc%24%7C%5Eldp_vp%24%7C%5Eldp%24/required", keyword: "required", params: { missingProperty: "proof_type" }, message: "must have required property 'proof_type'", schema: schema13.patternProperties["^ldp_vc$|^ldp_vp$|^ldp$"].required, parentSchema: schema13.patternProperties["^ldp_vc$|^ldp_vp$|^ldp$"], data: data3 };
                if (vErrors === null) {
                  vErrors = [err7];
                } else {
                  vErrors.push(err7);
                }
                errors++;
              }
              for (const key4 in data3) {
                if (!(key4 === "proof_type")) {
                  const err8 = { instancePath: instancePath + "/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/patternProperties/%5Eldp_vc%24%7C%5Eldp_vp%24%7C%5Eldp%24/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key4 }, message: "must NOT have additional properties", schema: false, parentSchema: schema13.patternProperties["^ldp_vc$|^ldp_vp$|^ldp$"], data: data3 };
                  if (vErrors === null) {
                    vErrors = [err8];
                  } else {
                    vErrors.push(err8);
                  }
                  errors++;
                }
              }
              if (data3.proof_type !== void 0) {
                let data4 = data3.proof_type;
                if (Array.isArray(data4)) {
                  if (data4.length < 1) {
                    const err9 = { instancePath: instancePath + "/" + key3.replace(/~/g, "~0").replace(/\//g, "~1") + "/proof_type", schemaPath: "#/patternProperties/%5Eldp_vc%24%7C%5Eldp_vp%24%7C%5Eldp%24/properties/proof_type/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items", schema: 1, parentSchema: schema13.patternProperties["^ldp_vc$|^ldp_vp$|^ldp$"].properties.proof_type, data: data4 };
                    if (vErrors === null) {
                      vErrors = [err9];
                    } else {
                      vErrors.push(err9);
                    }
                    errors++;
                  }
                  const len1 = data4.length;
                  for (let i1 = 0; i1 < len1; i1++) {
                    let data5 = data4[i1];
                    if (typeof data5 !== "string") {
                      const err10 = { instancePath: instancePath + "/" + key3.replace(/~/g, "~0").replace(/\//g, "~1") + "/proof_type/" + i1, schemaPath: "#/patternProperties/%5Eldp_vc%24%7C%5Eldp_vp%24%7C%5Eldp%24/properties/proof_type/items/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema13.patternProperties["^ldp_vc$|^ldp_vp$|^ldp$"].properties.proof_type.items.type, parentSchema: schema13.patternProperties["^ldp_vc$|^ldp_vp$|^ldp$"].properties.proof_type.items, data: data5 };
                      if (vErrors === null) {
                        vErrors = [err10];
                      } else {
                        vErrors.push(err10);
                      }
                      errors++;
                    }
                  }
                } else {
                  const err11 = { instancePath: instancePath + "/" + key3.replace(/~/g, "~0").replace(/\//g, "~1") + "/proof_type", schemaPath: "#/patternProperties/%5Eldp_vc%24%7C%5Eldp_vp%24%7C%5Eldp%24/properties/proof_type/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema13.patternProperties["^ldp_vc$|^ldp_vp$|^ldp$"].properties.proof_type.type, parentSchema: schema13.patternProperties["^ldp_vc$|^ldp_vp$|^ldp$"].properties.proof_type, data: data4 };
                  if (vErrors === null) {
                    vErrors = [err11];
                  } else {
                    vErrors.push(err11);
                  }
                  errors++;
                }
              }
            } else {
              const err12 = { instancePath: instancePath + "/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/patternProperties/%5Eldp_vc%24%7C%5Eldp_vp%24%7C%5Eldp%24/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema13.patternProperties["^ldp_vc$|^ldp_vp$|^ldp$"].type, parentSchema: schema13.patternProperties["^ldp_vc$|^ldp_vp$|^ldp$"], data: data3 };
              if (vErrors === null) {
                vErrors = [err12];
              } else {
                vErrors.push(err12);
              }
              errors++;
            }
          }
        }
        for (const key5 in data) {
          if (pattern2.test(key5)) {
            const err13 = { instancePath: instancePath + "/" + key5.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/patternProperties/additionalProperties/false schema", keyword: "false schema", params: {}, message: "boolean schema is false", schema: false, parentSchema: schema13.patternProperties.additionalProperties, data: data[key5] };
            if (vErrors === null) {
              vErrors = [err13];
            } else {
              vErrors.push(err13);
            }
            errors++;
          }
        }
      } else {
        const err14 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema13.type, parentSchema: schema13, data };
        if (vErrors === null) {
          vErrors = [err14];
        } else {
          vErrors.push(err14);
        }
        errors++;
      }
      validate43.errors = vErrors;
      return errors === 0;
    }
    var schema14 = { "type": "object", "oneOf": [{ "properties": { "name": { "type": "string" }, "purpose": { "type": "string" }, "rule": { "type": "string", "enum": ["all", "pick"] }, "count": { "type": "integer", "minimum": 1 }, "min": { "type": "integer", "minimum": 0 }, "max": { "type": "integer", "minimum": 0 }, "from": { "type": "string" } }, "required": ["rule", "from"], "additionalProperties": false }, { "properties": { "name": { "type": "string" }, "purpose": { "type": "string" }, "rule": { "type": "string", "enum": ["all", "pick"] }, "count": { "type": "integer", "minimum": 1 }, "min": { "type": "integer", "minimum": 0 }, "max": { "type": "integer", "minimum": 0 }, "from_nested": { "type": "array", "minItems": 1, "items": { "$ref": "#/definitions/submission_requirements" } } }, "required": ["rule", "from_nested"], "additionalProperties": false }] };
    var wrapper0 = { validate: validate45 };
    function validate45(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (!(data && typeof data == "object" && !Array.isArray(data))) {
        const err0 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema14.type, parentSchema: schema14, data };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors++;
      }
      const _errs1 = errors;
      let valid0 = false;
      let passing0 = null;
      const _errs2 = errors;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.rule === void 0) {
          const err1 = { instancePath, schemaPath: "#/oneOf/0/required", keyword: "required", params: { missingProperty: "rule" }, message: "must have required property 'rule'", schema: schema14.oneOf[0].required, parentSchema: schema14.oneOf[0], data };
          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }
          errors++;
        }
        if (data.from === void 0) {
          const err2 = { instancePath, schemaPath: "#/oneOf/0/required", keyword: "required", params: { missingProperty: "from" }, message: "must have required property 'from'", schema: schema14.oneOf[0].required, parentSchema: schema14.oneOf[0], data };
          if (vErrors === null) {
            vErrors = [err2];
          } else {
            vErrors.push(err2);
          }
          errors++;
        }
        for (const key0 in data) {
          if (!(key0 === "name" || key0 === "purpose" || key0 === "rule" || key0 === "count" || key0 === "min" || key0 === "max" || key0 === "from")) {
            const err3 = { instancePath, schemaPath: "#/oneOf/0/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties", schema: false, parentSchema: schema14.oneOf[0], data };
            if (vErrors === null) {
              vErrors = [err3];
            } else {
              vErrors.push(err3);
            }
            errors++;
          }
        }
        if (data.name !== void 0) {
          let data0 = data.name;
          if (typeof data0 !== "string") {
            const err4 = { instancePath: instancePath + "/name", schemaPath: "#/oneOf/0/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema14.oneOf[0].properties.name.type, parentSchema: schema14.oneOf[0].properties.name, data: data0 };
            if (vErrors === null) {
              vErrors = [err4];
            } else {
              vErrors.push(err4);
            }
            errors++;
          }
        }
        if (data.purpose !== void 0) {
          let data1 = data.purpose;
          if (typeof data1 !== "string") {
            const err5 = { instancePath: instancePath + "/purpose", schemaPath: "#/oneOf/0/properties/purpose/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema14.oneOf[0].properties.purpose.type, parentSchema: schema14.oneOf[0].properties.purpose, data: data1 };
            if (vErrors === null) {
              vErrors = [err5];
            } else {
              vErrors.push(err5);
            }
            errors++;
          }
        }
        if (data.rule !== void 0) {
          let data2 = data.rule;
          if (typeof data2 !== "string") {
            const err6 = { instancePath: instancePath + "/rule", schemaPath: "#/oneOf/0/properties/rule/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema14.oneOf[0].properties.rule.type, parentSchema: schema14.oneOf[0].properties.rule, data: data2 };
            if (vErrors === null) {
              vErrors = [err6];
            } else {
              vErrors.push(err6);
            }
            errors++;
          }
          if (!(data2 === "all" || data2 === "pick")) {
            const err7 = { instancePath: instancePath + "/rule", schemaPath: "#/oneOf/0/properties/rule/enum", keyword: "enum", params: { allowedValues: schema14.oneOf[0].properties.rule.enum }, message: "must be equal to one of the allowed values", schema: schema14.oneOf[0].properties.rule.enum, parentSchema: schema14.oneOf[0].properties.rule, data: data2 };
            if (vErrors === null) {
              vErrors = [err7];
            } else {
              vErrors.push(err7);
            }
            errors++;
          }
        }
        if (data.count !== void 0) {
          let data3 = data.count;
          if (!(typeof data3 == "number" && (!(data3 % 1) && !isNaN(data3)))) {
            const err8 = { instancePath: instancePath + "/count", schemaPath: "#/oneOf/0/properties/count/type", keyword: "type", params: { type: "integer" }, message: "must be integer", schema: schema14.oneOf[0].properties.count.type, parentSchema: schema14.oneOf[0].properties.count, data: data3 };
            if (vErrors === null) {
              vErrors = [err8];
            } else {
              vErrors.push(err8);
            }
            errors++;
          }
          if (typeof data3 == "number") {
            if (data3 < 1 || isNaN(data3)) {
              const err9 = { instancePath: instancePath + "/count", schemaPath: "#/oneOf/0/properties/count/minimum", keyword: "minimum", params: { comparison: ">=", limit: 1 }, message: "must be >= 1", schema: 1, parentSchema: schema14.oneOf[0].properties.count, data: data3 };
              if (vErrors === null) {
                vErrors = [err9];
              } else {
                vErrors.push(err9);
              }
              errors++;
            }
          }
        }
        if (data.min !== void 0) {
          let data4 = data.min;
          if (!(typeof data4 == "number" && (!(data4 % 1) && !isNaN(data4)))) {
            const err10 = { instancePath: instancePath + "/min", schemaPath: "#/oneOf/0/properties/min/type", keyword: "type", params: { type: "integer" }, message: "must be integer", schema: schema14.oneOf[0].properties.min.type, parentSchema: schema14.oneOf[0].properties.min, data: data4 };
            if (vErrors === null) {
              vErrors = [err10];
            } else {
              vErrors.push(err10);
            }
            errors++;
          }
          if (typeof data4 == "number") {
            if (data4 < 0 || isNaN(data4)) {
              const err11 = { instancePath: instancePath + "/min", schemaPath: "#/oneOf/0/properties/min/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0", schema: 0, parentSchema: schema14.oneOf[0].properties.min, data: data4 };
              if (vErrors === null) {
                vErrors = [err11];
              } else {
                vErrors.push(err11);
              }
              errors++;
            }
          }
        }
        if (data.max !== void 0) {
          let data5 = data.max;
          if (!(typeof data5 == "number" && (!(data5 % 1) && !isNaN(data5)))) {
            const err12 = { instancePath: instancePath + "/max", schemaPath: "#/oneOf/0/properties/max/type", keyword: "type", params: { type: "integer" }, message: "must be integer", schema: schema14.oneOf[0].properties.max.type, parentSchema: schema14.oneOf[0].properties.max, data: data5 };
            if (vErrors === null) {
              vErrors = [err12];
            } else {
              vErrors.push(err12);
            }
            errors++;
          }
          if (typeof data5 == "number") {
            if (data5 < 0 || isNaN(data5)) {
              const err13 = { instancePath: instancePath + "/max", schemaPath: "#/oneOf/0/properties/max/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0", schema: 0, parentSchema: schema14.oneOf[0].properties.max, data: data5 };
              if (vErrors === null) {
                vErrors = [err13];
              } else {
                vErrors.push(err13);
              }
              errors++;
            }
          }
        }
        if (data.from !== void 0) {
          let data6 = data.from;
          if (typeof data6 !== "string") {
            const err14 = { instancePath: instancePath + "/from", schemaPath: "#/oneOf/0/properties/from/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema14.oneOf[0].properties.from.type, parentSchema: schema14.oneOf[0].properties.from, data: data6 };
            if (vErrors === null) {
              vErrors = [err14];
            } else {
              vErrors.push(err14);
            }
            errors++;
          }
        }
      }
      var _valid0 = _errs2 === errors;
      if (_valid0) {
        valid0 = true;
        passing0 = 0;
      }
      const _errs18 = errors;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.rule === void 0) {
          const err15 = { instancePath, schemaPath: "#/oneOf/1/required", keyword: "required", params: { missingProperty: "rule" }, message: "must have required property 'rule'", schema: schema14.oneOf[1].required, parentSchema: schema14.oneOf[1], data };
          if (vErrors === null) {
            vErrors = [err15];
          } else {
            vErrors.push(err15);
          }
          errors++;
        }
        if (data.from_nested === void 0) {
          const err16 = { instancePath, schemaPath: "#/oneOf/1/required", keyword: "required", params: { missingProperty: "from_nested" }, message: "must have required property 'from_nested'", schema: schema14.oneOf[1].required, parentSchema: schema14.oneOf[1], data };
          if (vErrors === null) {
            vErrors = [err16];
          } else {
            vErrors.push(err16);
          }
          errors++;
        }
        for (const key1 in data) {
          if (!(key1 === "name" || key1 === "purpose" || key1 === "rule" || key1 === "count" || key1 === "min" || key1 === "max" || key1 === "from_nested")) {
            const err17 = { instancePath, schemaPath: "#/oneOf/1/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key1 }, message: "must NOT have additional properties", schema: false, parentSchema: schema14.oneOf[1], data };
            if (vErrors === null) {
              vErrors = [err17];
            } else {
              vErrors.push(err17);
            }
            errors++;
          }
        }
        if (data.name !== void 0) {
          let data7 = data.name;
          if (typeof data7 !== "string") {
            const err18 = { instancePath: instancePath + "/name", schemaPath: "#/oneOf/1/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema14.oneOf[1].properties.name.type, parentSchema: schema14.oneOf[1].properties.name, data: data7 };
            if (vErrors === null) {
              vErrors = [err18];
            } else {
              vErrors.push(err18);
            }
            errors++;
          }
        }
        if (data.purpose !== void 0) {
          let data8 = data.purpose;
          if (typeof data8 !== "string") {
            const err19 = { instancePath: instancePath + "/purpose", schemaPath: "#/oneOf/1/properties/purpose/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema14.oneOf[1].properties.purpose.type, parentSchema: schema14.oneOf[1].properties.purpose, data: data8 };
            if (vErrors === null) {
              vErrors = [err19];
            } else {
              vErrors.push(err19);
            }
            errors++;
          }
        }
        if (data.rule !== void 0) {
          let data9 = data.rule;
          if (typeof data9 !== "string") {
            const err20 = { instancePath: instancePath + "/rule", schemaPath: "#/oneOf/1/properties/rule/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema14.oneOf[1].properties.rule.type, parentSchema: schema14.oneOf[1].properties.rule, data: data9 };
            if (vErrors === null) {
              vErrors = [err20];
            } else {
              vErrors.push(err20);
            }
            errors++;
          }
          if (!(data9 === "all" || data9 === "pick")) {
            const err21 = { instancePath: instancePath + "/rule", schemaPath: "#/oneOf/1/properties/rule/enum", keyword: "enum", params: { allowedValues: schema14.oneOf[1].properties.rule.enum }, message: "must be equal to one of the allowed values", schema: schema14.oneOf[1].properties.rule.enum, parentSchema: schema14.oneOf[1].properties.rule, data: data9 };
            if (vErrors === null) {
              vErrors = [err21];
            } else {
              vErrors.push(err21);
            }
            errors++;
          }
        }
        if (data.count !== void 0) {
          let data10 = data.count;
          if (!(typeof data10 == "number" && (!(data10 % 1) && !isNaN(data10)))) {
            const err22 = { instancePath: instancePath + "/count", schemaPath: "#/oneOf/1/properties/count/type", keyword: "type", params: { type: "integer" }, message: "must be integer", schema: schema14.oneOf[1].properties.count.type, parentSchema: schema14.oneOf[1].properties.count, data: data10 };
            if (vErrors === null) {
              vErrors = [err22];
            } else {
              vErrors.push(err22);
            }
            errors++;
          }
          if (typeof data10 == "number") {
            if (data10 < 1 || isNaN(data10)) {
              const err23 = { instancePath: instancePath + "/count", schemaPath: "#/oneOf/1/properties/count/minimum", keyword: "minimum", params: { comparison: ">=", limit: 1 }, message: "must be >= 1", schema: 1, parentSchema: schema14.oneOf[1].properties.count, data: data10 };
              if (vErrors === null) {
                vErrors = [err23];
              } else {
                vErrors.push(err23);
              }
              errors++;
            }
          }
        }
        if (data.min !== void 0) {
          let data11 = data.min;
          if (!(typeof data11 == "number" && (!(data11 % 1) && !isNaN(data11)))) {
            const err24 = { instancePath: instancePath + "/min", schemaPath: "#/oneOf/1/properties/min/type", keyword: "type", params: { type: "integer" }, message: "must be integer", schema: schema14.oneOf[1].properties.min.type, parentSchema: schema14.oneOf[1].properties.min, data: data11 };
            if (vErrors === null) {
              vErrors = [err24];
            } else {
              vErrors.push(err24);
            }
            errors++;
          }
          if (typeof data11 == "number") {
            if (data11 < 0 || isNaN(data11)) {
              const err25 = { instancePath: instancePath + "/min", schemaPath: "#/oneOf/1/properties/min/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0", schema: 0, parentSchema: schema14.oneOf[1].properties.min, data: data11 };
              if (vErrors === null) {
                vErrors = [err25];
              } else {
                vErrors.push(err25);
              }
              errors++;
            }
          }
        }
        if (data.max !== void 0) {
          let data12 = data.max;
          if (!(typeof data12 == "number" && (!(data12 % 1) && !isNaN(data12)))) {
            const err26 = { instancePath: instancePath + "/max", schemaPath: "#/oneOf/1/properties/max/type", keyword: "type", params: { type: "integer" }, message: "must be integer", schema: schema14.oneOf[1].properties.max.type, parentSchema: schema14.oneOf[1].properties.max, data: data12 };
            if (vErrors === null) {
              vErrors = [err26];
            } else {
              vErrors.push(err26);
            }
            errors++;
          }
          if (typeof data12 == "number") {
            if (data12 < 0 || isNaN(data12)) {
              const err27 = { instancePath: instancePath + "/max", schemaPath: "#/oneOf/1/properties/max/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0", schema: 0, parentSchema: schema14.oneOf[1].properties.max, data: data12 };
              if (vErrors === null) {
                vErrors = [err27];
              } else {
                vErrors.push(err27);
              }
              errors++;
            }
          }
        }
        if (data.from_nested !== void 0) {
          let data13 = data.from_nested;
          if (Array.isArray(data13)) {
            if (data13.length < 1) {
              const err28 = { instancePath: instancePath + "/from_nested", schemaPath: "#/oneOf/1/properties/from_nested/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items", schema: 1, parentSchema: schema14.oneOf[1].properties.from_nested, data: data13 };
              if (vErrors === null) {
                vErrors = [err28];
              } else {
                vErrors.push(err28);
              }
              errors++;
            }
            const len0 = data13.length;
            for (let i0 = 0; i0 < len0; i0++) {
              if (!wrapper0.validate(data13[i0], { instancePath: instancePath + "/from_nested/" + i0, parentData: data13, parentDataProperty: i0, rootData })) {
                vErrors = vErrors === null ? wrapper0.validate.errors : vErrors.concat(wrapper0.validate.errors);
                errors = vErrors.length;
              }
            }
          } else {
            const err29 = { instancePath: instancePath + "/from_nested", schemaPath: "#/oneOf/1/properties/from_nested/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema14.oneOf[1].properties.from_nested.type, parentSchema: schema14.oneOf[1].properties.from_nested, data: data13 };
            if (vErrors === null) {
              vErrors = [err29];
            } else {
              vErrors.push(err29);
            }
            errors++;
          }
        }
      }
      var _valid0 = _errs18 === errors;
      if (_valid0 && valid0) {
        valid0 = false;
        passing0 = [passing0, 1];
      } else {
        if (_valid0) {
          valid0 = true;
          passing0 = 1;
        }
      }
      if (!valid0) {
        const err30 = { instancePath, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf", schema: schema14.oneOf, parentSchema: schema14, data };
        if (vErrors === null) {
          vErrors = [err30];
        } else {
          vErrors.push(err30);
        }
        errors++;
      } else {
        errors = _errs1;
        if (vErrors !== null) {
          if (_errs1) {
            vErrors.length = _errs1;
          } else {
            vErrors = null;
          }
        }
      }
      validate45.errors = vErrors;
      return errors === 0;
    }
    var schema15 = { "type": "object", "properties": { "id": { "type": "string" }, "name": { "type": "string" }, "purpose": { "type": "string" }, "group": { "type": "array", "items": { "type": "string" } }, "schema": { "type": "array", "items": { "$ref": "#/definitions/schema" } }, "issuance": { "type": "array", "items": { "$ref": "#/definitions/issuance" } }, "constraints": { "type": "object", "properties": { "limit_disclosure": { "type": "string", "enum": ["required", "preferred"] }, "statuses": { "type": "object", "properties": { "active": { "type": "object", "properties": { "directive": { "type": "string", "enum": ["required", "allowed", "disallowed"] } } }, "suspended": { "type": "object", "properties": { "directive": { "type": "string", "enum": ["required", "allowed", "disallowed"] } } }, "revoked": { "type": "object", "properties": { "directive": { "type": "string", "enum": ["required", "allowed", "disallowed"] } } } } }, "fields": { "type": "array", "items": { "$ref": "#/definitions/field" } }, "subject_is_issuer": { "type": "string", "enum": ["required", "preferred"] }, "is_holder": { "type": "array", "items": { "type": "object", "properties": { "field_id": { "type": "array", "items": { "type": "string" } }, "directive": { "type": "string", "enum": ["required", "preferred"] } }, "required": ["field_id", "directive"], "additionalProperties": false } }, "same_subject": { "type": "array", "items": { "type": "object", "properties": { "field_id": { "type": "array", "items": { "type": "string" } }, "directive": { "type": "string", "enum": ["required", "preferred"] } }, "required": ["field_id", "directive"], "additionalProperties": false } } }, "additionalProperties": false } }, "required": ["id", "schema"], "additionalProperties": false };
    var schema16 = { "type": "object", "properties": { "uri": { "type": "string" }, "required": { "type": "boolean" } }, "required": ["uri"], "additionalProperties": false };
    function validate48(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.uri === void 0) {
          const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "uri" }, message: "must have required property 'uri'", schema: schema16.required, parentSchema: schema16, data };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors++;
        }
        for (const key0 in data) {
          if (!(key0 === "uri" || key0 === "required")) {
            const err1 = { instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties", schema: false, parentSchema: schema16, data };
            if (vErrors === null) {
              vErrors = [err1];
            } else {
              vErrors.push(err1);
            }
            errors++;
          }
        }
        if (data.uri !== void 0) {
          let data0 = data.uri;
          if (typeof data0 !== "string") {
            const err2 = { instancePath: instancePath + "/uri", schemaPath: "#/properties/uri/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema16.properties.uri.type, parentSchema: schema16.properties.uri, data: data0 };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors++;
          }
        }
        if (data.required !== void 0) {
          let data1 = data.required;
          if (typeof data1 !== "boolean") {
            const err3 = { instancePath: instancePath + "/required", schemaPath: "#/properties/required/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean", schema: schema16.properties.required.type, parentSchema: schema16.properties.required, data: data1 };
            if (vErrors === null) {
              vErrors = [err3];
            } else {
              vErrors.push(err3);
            }
            errors++;
          }
        }
      } else {
        const err4 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema16.type, parentSchema: schema16, data };
        if (vErrors === null) {
          vErrors = [err4];
        } else {
          vErrors.push(err4);
        }
        errors++;
      }
      validate48.errors = vErrors;
      return errors === 0;
    }
    var schema17 = { "type": "object", "properties": { "manifest": { "type": "string" } }, "additionalProperties": true };
    function validate50(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.manifest !== void 0) {
          let data0 = data.manifest;
          if (typeof data0 !== "string") {
            const err0 = { instancePath: instancePath + "/manifest", schemaPath: "#/properties/manifest/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema17.properties.manifest.type, parentSchema: schema17.properties.manifest, data: data0 };
            if (vErrors === null) {
              vErrors = [err0];
            } else {
              vErrors.push(err0);
            }
            errors++;
          }
        }
      } else {
        const err1 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema17.type, parentSchema: schema17, data };
        if (vErrors === null) {
          vErrors = [err1];
        } else {
          vErrors.push(err1);
        }
        errors++;
      }
      validate50.errors = vErrors;
      return errors === 0;
    }
    var schema18 = { "type": "object", "oneOf": [{ "properties": { "id": { "type": "string" }, "path": { "type": "array", "items": { "type": "string" } }, "purpose": { "type": "string" }, "filter": { "$ref": "#/definitions/filter" } }, "required": ["path"], "additionalProperties": false }, { "properties": { "id": { "type": "string" }, "path": { "type": "array", "items": { "type": "string" } }, "purpose": { "type": "string" }, "filter": { "$ref": "#/definitions/filter" }, "predicate": { "type": "string", "enum": ["required", "preferred"] } }, "required": ["path", "filter", "predicate"], "additionalProperties": false }] };
    var schema19 = { "type": "object", "properties": { "type": { "type": "string" }, "format": { "type": "string" }, "pattern": { "type": "string" }, "minimum": { "type": ["number", "string"] }, "minLength": { "type": "integer" }, "maxLength": { "type": "integer" }, "exclusiveMinimum": { "type": ["number", "string"] }, "exclusiveMaximum": { "type": ["number", "string"] }, "maximum": { "type": ["number", "string"] }, "const": { "type": ["number", "string"] }, "enum": { "type": "array", "items": { "type": ["number", "string"] } }, "not": { "type": "object", "minProperties": 1 } }, "required": ["type"], "additionalProperties": false };
    var func4 = Object.prototype.hasOwnProperty;
    function validate53(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.type === void 0) {
          const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "type" }, message: "must have required property 'type'", schema: schema19.required, parentSchema: schema19, data };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors++;
        }
        for (const key0 in data) {
          if (!func4.call(schema19.properties, key0)) {
            const err1 = { instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties", schema: false, parentSchema: schema19, data };
            if (vErrors === null) {
              vErrors = [err1];
            } else {
              vErrors.push(err1);
            }
            errors++;
          }
        }
        if (data.type !== void 0) {
          let data0 = data.type;
          if (typeof data0 !== "string") {
            const err2 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema19.properties.type.type, parentSchema: schema19.properties.type, data: data0 };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors++;
          }
        }
        if (data.format !== void 0) {
          let data1 = data.format;
          if (typeof data1 !== "string") {
            const err3 = { instancePath: instancePath + "/format", schemaPath: "#/properties/format/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema19.properties.format.type, parentSchema: schema19.properties.format, data: data1 };
            if (vErrors === null) {
              vErrors = [err3];
            } else {
              vErrors.push(err3);
            }
            errors++;
          }
        }
        if (data.pattern !== void 0) {
          let data2 = data.pattern;
          if (typeof data2 !== "string") {
            const err4 = { instancePath: instancePath + "/pattern", schemaPath: "#/properties/pattern/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema19.properties.pattern.type, parentSchema: schema19.properties.pattern, data: data2 };
            if (vErrors === null) {
              vErrors = [err4];
            } else {
              vErrors.push(err4);
            }
            errors++;
          }
        }
        if (data.minimum !== void 0) {
          let data3 = data.minimum;
          if (!(typeof data3 == "number") && typeof data3 !== "string") {
            const err5 = { instancePath: instancePath + "/minimum", schemaPath: "#/properties/minimum/type", keyword: "type", params: { type: schema19.properties.minimum.type }, message: "must be number,string", schema: schema19.properties.minimum.type, parentSchema: schema19.properties.minimum, data: data3 };
            if (vErrors === null) {
              vErrors = [err5];
            } else {
              vErrors.push(err5);
            }
            errors++;
          }
        }
        if (data.minLength !== void 0) {
          let data4 = data.minLength;
          if (!(typeof data4 == "number" && (!(data4 % 1) && !isNaN(data4)))) {
            const err6 = { instancePath: instancePath + "/minLength", schemaPath: "#/properties/minLength/type", keyword: "type", params: { type: "integer" }, message: "must be integer", schema: schema19.properties.minLength.type, parentSchema: schema19.properties.minLength, data: data4 };
            if (vErrors === null) {
              vErrors = [err6];
            } else {
              vErrors.push(err6);
            }
            errors++;
          }
        }
        if (data.maxLength !== void 0) {
          let data5 = data.maxLength;
          if (!(typeof data5 == "number" && (!(data5 % 1) && !isNaN(data5)))) {
            const err7 = { instancePath: instancePath + "/maxLength", schemaPath: "#/properties/maxLength/type", keyword: "type", params: { type: "integer" }, message: "must be integer", schema: schema19.properties.maxLength.type, parentSchema: schema19.properties.maxLength, data: data5 };
            if (vErrors === null) {
              vErrors = [err7];
            } else {
              vErrors.push(err7);
            }
            errors++;
          }
        }
        if (data.exclusiveMinimum !== void 0) {
          let data6 = data.exclusiveMinimum;
          if (!(typeof data6 == "number") && typeof data6 !== "string") {
            const err8 = { instancePath: instancePath + "/exclusiveMinimum", schemaPath: "#/properties/exclusiveMinimum/type", keyword: "type", params: { type: schema19.properties.exclusiveMinimum.type }, message: "must be number,string", schema: schema19.properties.exclusiveMinimum.type, parentSchema: schema19.properties.exclusiveMinimum, data: data6 };
            if (vErrors === null) {
              vErrors = [err8];
            } else {
              vErrors.push(err8);
            }
            errors++;
          }
        }
        if (data.exclusiveMaximum !== void 0) {
          let data7 = data.exclusiveMaximum;
          if (!(typeof data7 == "number") && typeof data7 !== "string") {
            const err9 = { instancePath: instancePath + "/exclusiveMaximum", schemaPath: "#/properties/exclusiveMaximum/type", keyword: "type", params: { type: schema19.properties.exclusiveMaximum.type }, message: "must be number,string", schema: schema19.properties.exclusiveMaximum.type, parentSchema: schema19.properties.exclusiveMaximum, data: data7 };
            if (vErrors === null) {
              vErrors = [err9];
            } else {
              vErrors.push(err9);
            }
            errors++;
          }
        }
        if (data.maximum !== void 0) {
          let data8 = data.maximum;
          if (!(typeof data8 == "number") && typeof data8 !== "string") {
            const err10 = { instancePath: instancePath + "/maximum", schemaPath: "#/properties/maximum/type", keyword: "type", params: { type: schema19.properties.maximum.type }, message: "must be number,string", schema: schema19.properties.maximum.type, parentSchema: schema19.properties.maximum, data: data8 };
            if (vErrors === null) {
              vErrors = [err10];
            } else {
              vErrors.push(err10);
            }
            errors++;
          }
        }
        if (data.const !== void 0) {
          let data9 = data.const;
          if (!(typeof data9 == "number") && typeof data9 !== "string") {
            const err11 = { instancePath: instancePath + "/const", schemaPath: "#/properties/const/type", keyword: "type", params: { type: schema19.properties.const.type }, message: "must be number,string", schema: schema19.properties.const.type, parentSchema: schema19.properties.const, data: data9 };
            if (vErrors === null) {
              vErrors = [err11];
            } else {
              vErrors.push(err11);
            }
            errors++;
          }
        }
        if (data.enum !== void 0) {
          let data10 = data.enum;
          if (Array.isArray(data10)) {
            const len0 = data10.length;
            for (let i0 = 0; i0 < len0; i0++) {
              let data11 = data10[i0];
              if (!(typeof data11 == "number") && typeof data11 !== "string") {
                const err12 = { instancePath: instancePath + "/enum/" + i0, schemaPath: "#/properties/enum/items/type", keyword: "type", params: { type: schema19.properties.enum.items.type }, message: "must be number,string", schema: schema19.properties.enum.items.type, parentSchema: schema19.properties.enum.items, data: data11 };
                if (vErrors === null) {
                  vErrors = [err12];
                } else {
                  vErrors.push(err12);
                }
                errors++;
              }
            }
          } else {
            const err13 = { instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema19.properties.enum.type, parentSchema: schema19.properties.enum, data: data10 };
            if (vErrors === null) {
              vErrors = [err13];
            } else {
              vErrors.push(err13);
            }
            errors++;
          }
        }
        if (data.not !== void 0) {
          let data12 = data.not;
          if (data12 && typeof data12 == "object" && !Array.isArray(data12)) {
            if (Object.keys(data12).length < 1) {
              const err14 = { instancePath: instancePath + "/not", schemaPath: "#/properties/not/minProperties", keyword: "minProperties", params: { limit: 1 }, message: "must NOT have fewer than 1 properties", schema: 1, parentSchema: schema19.properties.not, data: data12 };
              if (vErrors === null) {
                vErrors = [err14];
              } else {
                vErrors.push(err14);
              }
              errors++;
            }
          } else {
            const err15 = { instancePath: instancePath + "/not", schemaPath: "#/properties/not/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema19.properties.not.type, parentSchema: schema19.properties.not, data: data12 };
            if (vErrors === null) {
              vErrors = [err15];
            } else {
              vErrors.push(err15);
            }
            errors++;
          }
        }
      } else {
        const err16 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema19.type, parentSchema: schema19, data };
        if (vErrors === null) {
          vErrors = [err16];
        } else {
          vErrors.push(err16);
        }
        errors++;
      }
      validate53.errors = vErrors;
      return errors === 0;
    }
    function validate52(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (!(data && typeof data == "object" && !Array.isArray(data))) {
        const err0 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema18.type, parentSchema: schema18, data };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors++;
      }
      const _errs1 = errors;
      let valid0 = false;
      let passing0 = null;
      const _errs2 = errors;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.path === void 0) {
          const err1 = { instancePath, schemaPath: "#/oneOf/0/required", keyword: "required", params: { missingProperty: "path" }, message: "must have required property 'path'", schema: schema18.oneOf[0].required, parentSchema: schema18.oneOf[0], data };
          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }
          errors++;
        }
        for (const key0 in data) {
          if (!(key0 === "id" || key0 === "path" || key0 === "purpose" || key0 === "filter")) {
            const err2 = { instancePath, schemaPath: "#/oneOf/0/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties", schema: false, parentSchema: schema18.oneOf[0], data };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors++;
          }
        }
        if (data.id !== void 0) {
          let data0 = data.id;
          if (typeof data0 !== "string") {
            const err3 = { instancePath: instancePath + "/id", schemaPath: "#/oneOf/0/properties/id/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema18.oneOf[0].properties.id.type, parentSchema: schema18.oneOf[0].properties.id, data: data0 };
            if (vErrors === null) {
              vErrors = [err3];
            } else {
              vErrors.push(err3);
            }
            errors++;
          }
        }
        if (data.path !== void 0) {
          let data1 = data.path;
          if (Array.isArray(data1)) {
            const len0 = data1.length;
            for (let i0 = 0; i0 < len0; i0++) {
              let data2 = data1[i0];
              if (typeof data2 !== "string") {
                const err4 = { instancePath: instancePath + "/path/" + i0, schemaPath: "#/oneOf/0/properties/path/items/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema18.oneOf[0].properties.path.items.type, parentSchema: schema18.oneOf[0].properties.path.items, data: data2 };
                if (vErrors === null) {
                  vErrors = [err4];
                } else {
                  vErrors.push(err4);
                }
                errors++;
              }
            }
          } else {
            const err5 = { instancePath: instancePath + "/path", schemaPath: "#/oneOf/0/properties/path/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema18.oneOf[0].properties.path.type, parentSchema: schema18.oneOf[0].properties.path, data: data1 };
            if (vErrors === null) {
              vErrors = [err5];
            } else {
              vErrors.push(err5);
            }
            errors++;
          }
        }
        if (data.purpose !== void 0) {
          let data3 = data.purpose;
          if (typeof data3 !== "string") {
            const err6 = { instancePath: instancePath + "/purpose", schemaPath: "#/oneOf/0/properties/purpose/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema18.oneOf[0].properties.purpose.type, parentSchema: schema18.oneOf[0].properties.purpose, data: data3 };
            if (vErrors === null) {
              vErrors = [err6];
            } else {
              vErrors.push(err6);
            }
            errors++;
          }
        }
        if (data.filter !== void 0) {
          if (!validate53(data.filter, { instancePath: instancePath + "/filter", parentData: data, parentDataProperty: "filter", rootData })) {
            vErrors = vErrors === null ? validate53.errors : vErrors.concat(validate53.errors);
            errors = vErrors.length;
          }
        }
      }
      var _valid0 = _errs2 === errors;
      if (_valid0) {
        valid0 = true;
        passing0 = 0;
      }
      const _errs13 = errors;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.path === void 0) {
          const err7 = { instancePath, schemaPath: "#/oneOf/1/required", keyword: "required", params: { missingProperty: "path" }, message: "must have required property 'path'", schema: schema18.oneOf[1].required, parentSchema: schema18.oneOf[1], data };
          if (vErrors === null) {
            vErrors = [err7];
          } else {
            vErrors.push(err7);
          }
          errors++;
        }
        if (data.filter === void 0) {
          const err8 = { instancePath, schemaPath: "#/oneOf/1/required", keyword: "required", params: { missingProperty: "filter" }, message: "must have required property 'filter'", schema: schema18.oneOf[1].required, parentSchema: schema18.oneOf[1], data };
          if (vErrors === null) {
            vErrors = [err8];
          } else {
            vErrors.push(err8);
          }
          errors++;
        }
        if (data.predicate === void 0) {
          const err9 = { instancePath, schemaPath: "#/oneOf/1/required", keyword: "required", params: { missingProperty: "predicate" }, message: "must have required property 'predicate'", schema: schema18.oneOf[1].required, parentSchema: schema18.oneOf[1], data };
          if (vErrors === null) {
            vErrors = [err9];
          } else {
            vErrors.push(err9);
          }
          errors++;
        }
        for (const key1 in data) {
          if (!(key1 === "id" || key1 === "path" || key1 === "purpose" || key1 === "filter" || key1 === "predicate")) {
            const err10 = { instancePath, schemaPath: "#/oneOf/1/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key1 }, message: "must NOT have additional properties", schema: false, parentSchema: schema18.oneOf[1], data };
            if (vErrors === null) {
              vErrors = [err10];
            } else {
              vErrors.push(err10);
            }
            errors++;
          }
        }
        if (data.id !== void 0) {
          let data5 = data.id;
          if (typeof data5 !== "string") {
            const err11 = { instancePath: instancePath + "/id", schemaPath: "#/oneOf/1/properties/id/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema18.oneOf[1].properties.id.type, parentSchema: schema18.oneOf[1].properties.id, data: data5 };
            if (vErrors === null) {
              vErrors = [err11];
            } else {
              vErrors.push(err11);
            }
            errors++;
          }
        }
        if (data.path !== void 0) {
          let data6 = data.path;
          if (Array.isArray(data6)) {
            const len1 = data6.length;
            for (let i1 = 0; i1 < len1; i1++) {
              let data7 = data6[i1];
              if (typeof data7 !== "string") {
                const err12 = { instancePath: instancePath + "/path/" + i1, schemaPath: "#/oneOf/1/properties/path/items/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema18.oneOf[1].properties.path.items.type, parentSchema: schema18.oneOf[1].properties.path.items, data: data7 };
                if (vErrors === null) {
                  vErrors = [err12];
                } else {
                  vErrors.push(err12);
                }
                errors++;
              }
            }
          } else {
            const err13 = { instancePath: instancePath + "/path", schemaPath: "#/oneOf/1/properties/path/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema18.oneOf[1].properties.path.type, parentSchema: schema18.oneOf[1].properties.path, data: data6 };
            if (vErrors === null) {
              vErrors = [err13];
            } else {
              vErrors.push(err13);
            }
            errors++;
          }
        }
        if (data.purpose !== void 0) {
          let data8 = data.purpose;
          if (typeof data8 !== "string") {
            const err14 = { instancePath: instancePath + "/purpose", schemaPath: "#/oneOf/1/properties/purpose/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema18.oneOf[1].properties.purpose.type, parentSchema: schema18.oneOf[1].properties.purpose, data: data8 };
            if (vErrors === null) {
              vErrors = [err14];
            } else {
              vErrors.push(err14);
            }
            errors++;
          }
        }
        if (data.filter !== void 0) {
          if (!validate53(data.filter, { instancePath: instancePath + "/filter", parentData: data, parentDataProperty: "filter", rootData })) {
            vErrors = vErrors === null ? validate53.errors : vErrors.concat(validate53.errors);
            errors = vErrors.length;
          }
        }
        if (data.predicate !== void 0) {
          let data10 = data.predicate;
          if (typeof data10 !== "string") {
            const err15 = { instancePath: instancePath + "/predicate", schemaPath: "#/oneOf/1/properties/predicate/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema18.oneOf[1].properties.predicate.type, parentSchema: schema18.oneOf[1].properties.predicate, data: data10 };
            if (vErrors === null) {
              vErrors = [err15];
            } else {
              vErrors.push(err15);
            }
            errors++;
          }
          if (!(data10 === "required" || data10 === "preferred")) {
            const err16 = { instancePath: instancePath + "/predicate", schemaPath: "#/oneOf/1/properties/predicate/enum", keyword: "enum", params: { allowedValues: schema18.oneOf[1].properties.predicate.enum }, message: "must be equal to one of the allowed values", schema: schema18.oneOf[1].properties.predicate.enum, parentSchema: schema18.oneOf[1].properties.predicate, data: data10 };
            if (vErrors === null) {
              vErrors = [err16];
            } else {
              vErrors.push(err16);
            }
            errors++;
          }
        }
      }
      var _valid0 = _errs13 === errors;
      if (_valid0 && valid0) {
        valid0 = false;
        passing0 = [passing0, 1];
      } else {
        if (_valid0) {
          valid0 = true;
          passing0 = 1;
        }
      }
      if (!valid0) {
        const err17 = { instancePath, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf", schema: schema18.oneOf, parentSchema: schema18, data };
        if (vErrors === null) {
          vErrors = [err17];
        } else {
          vErrors.push(err17);
        }
        errors++;
      } else {
        errors = _errs1;
        if (vErrors !== null) {
          if (_errs1) {
            vErrors.length = _errs1;
          } else {
            vErrors = null;
          }
        }
      }
      validate52.errors = vErrors;
      return errors === 0;
    }
    function validate47(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.id === void 0) {
          const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "id" }, message: "must have required property 'id'", schema: schema15.required, parentSchema: schema15, data };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors++;
        }
        if (data.schema === void 0) {
          const err1 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "schema" }, message: "must have required property 'schema'", schema: schema15.required, parentSchema: schema15, data };
          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }
          errors++;
        }
        for (const key0 in data) {
          if (!(key0 === "id" || key0 === "name" || key0 === "purpose" || key0 === "group" || key0 === "schema" || key0 === "issuance" || key0 === "constraints")) {
            const err2 = { instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties", schema: false, parentSchema: schema15, data };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors++;
          }
        }
        if (data.id !== void 0) {
          let data0 = data.id;
          if (typeof data0 !== "string") {
            const err3 = { instancePath: instancePath + "/id", schemaPath: "#/properties/id/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema15.properties.id.type, parentSchema: schema15.properties.id, data: data0 };
            if (vErrors === null) {
              vErrors = [err3];
            } else {
              vErrors.push(err3);
            }
            errors++;
          }
        }
        if (data.name !== void 0) {
          let data1 = data.name;
          if (typeof data1 !== "string") {
            const err4 = { instancePath: instancePath + "/name", schemaPath: "#/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema15.properties.name.type, parentSchema: schema15.properties.name, data: data1 };
            if (vErrors === null) {
              vErrors = [err4];
            } else {
              vErrors.push(err4);
            }
            errors++;
          }
        }
        if (data.purpose !== void 0) {
          let data2 = data.purpose;
          if (typeof data2 !== "string") {
            const err5 = { instancePath: instancePath + "/purpose", schemaPath: "#/properties/purpose/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema15.properties.purpose.type, parentSchema: schema15.properties.purpose, data: data2 };
            if (vErrors === null) {
              vErrors = [err5];
            } else {
              vErrors.push(err5);
            }
            errors++;
          }
        }
        if (data.group !== void 0) {
          let data3 = data.group;
          if (Array.isArray(data3)) {
            const len0 = data3.length;
            for (let i0 = 0; i0 < len0; i0++) {
              let data4 = data3[i0];
              if (typeof data4 !== "string") {
                const err6 = { instancePath: instancePath + "/group/" + i0, schemaPath: "#/properties/group/items/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema15.properties.group.items.type, parentSchema: schema15.properties.group.items, data: data4 };
                if (vErrors === null) {
                  vErrors = [err6];
                } else {
                  vErrors.push(err6);
                }
                errors++;
              }
            }
          } else {
            const err7 = { instancePath: instancePath + "/group", schemaPath: "#/properties/group/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema15.properties.group.type, parentSchema: schema15.properties.group, data: data3 };
            if (vErrors === null) {
              vErrors = [err7];
            } else {
              vErrors.push(err7);
            }
            errors++;
          }
        }
        if (data.schema !== void 0) {
          let data5 = data.schema;
          if (Array.isArray(data5)) {
            const len1 = data5.length;
            for (let i1 = 0; i1 < len1; i1++) {
              if (!validate48(data5[i1], { instancePath: instancePath + "/schema/" + i1, parentData: data5, parentDataProperty: i1, rootData })) {
                vErrors = vErrors === null ? validate48.errors : vErrors.concat(validate48.errors);
                errors = vErrors.length;
              }
            }
          } else {
            const err8 = { instancePath: instancePath + "/schema", schemaPath: "#/properties/schema/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema15.properties.schema.type, parentSchema: schema15.properties.schema, data: data5 };
            if (vErrors === null) {
              vErrors = [err8];
            } else {
              vErrors.push(err8);
            }
            errors++;
          }
        }
        if (data.issuance !== void 0) {
          let data7 = data.issuance;
          if (Array.isArray(data7)) {
            const len2 = data7.length;
            for (let i2 = 0; i2 < len2; i2++) {
              if (!validate50(data7[i2], { instancePath: instancePath + "/issuance/" + i2, parentData: data7, parentDataProperty: i2, rootData })) {
                vErrors = vErrors === null ? validate50.errors : vErrors.concat(validate50.errors);
                errors = vErrors.length;
              }
            }
          } else {
            const err9 = { instancePath: instancePath + "/issuance", schemaPath: "#/properties/issuance/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema15.properties.issuance.type, parentSchema: schema15.properties.issuance, data: data7 };
            if (vErrors === null) {
              vErrors = [err9];
            } else {
              vErrors.push(err9);
            }
            errors++;
          }
        }
        if (data.constraints !== void 0) {
          let data9 = data.constraints;
          if (data9 && typeof data9 == "object" && !Array.isArray(data9)) {
            for (const key1 in data9) {
              if (!(key1 === "limit_disclosure" || key1 === "statuses" || key1 === "fields" || key1 === "subject_is_issuer" || key1 === "is_holder" || key1 === "same_subject")) {
                const err10 = { instancePath: instancePath + "/constraints", schemaPath: "#/properties/constraints/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key1 }, message: "must NOT have additional properties", schema: false, parentSchema: schema15.properties.constraints, data: data9 };
                if (vErrors === null) {
                  vErrors = [err10];
                } else {
                  vErrors.push(err10);
                }
                errors++;
              }
            }
            if (data9.limit_disclosure !== void 0) {
              let data10 = data9.limit_disclosure;
              if (typeof data10 !== "string") {
                const err11 = { instancePath: instancePath + "/constraints/limit_disclosure", schemaPath: "#/properties/constraints/properties/limit_disclosure/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema15.properties.constraints.properties.limit_disclosure.type, parentSchema: schema15.properties.constraints.properties.limit_disclosure, data: data10 };
                if (vErrors === null) {
                  vErrors = [err11];
                } else {
                  vErrors.push(err11);
                }
                errors++;
              }
              if (!(data10 === "required" || data10 === "preferred")) {
                const err12 = { instancePath: instancePath + "/constraints/limit_disclosure", schemaPath: "#/properties/constraints/properties/limit_disclosure/enum", keyword: "enum", params: { allowedValues: schema15.properties.constraints.properties.limit_disclosure.enum }, message: "must be equal to one of the allowed values", schema: schema15.properties.constraints.properties.limit_disclosure.enum, parentSchema: schema15.properties.constraints.properties.limit_disclosure, data: data10 };
                if (vErrors === null) {
                  vErrors = [err12];
                } else {
                  vErrors.push(err12);
                }
                errors++;
              }
            }
            if (data9.statuses !== void 0) {
              let data11 = data9.statuses;
              if (data11 && typeof data11 == "object" && !Array.isArray(data11)) {
                if (data11.active !== void 0) {
                  let data12 = data11.active;
                  if (data12 && typeof data12 == "object" && !Array.isArray(data12)) {
                    if (data12.directive !== void 0) {
                      let data13 = data12.directive;
                      if (typeof data13 !== "string") {
                        const err13 = { instancePath: instancePath + "/constraints/statuses/active/directive", schemaPath: "#/properties/constraints/properties/statuses/properties/active/properties/directive/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema15.properties.constraints.properties.statuses.properties.active.properties.directive.type, parentSchema: schema15.properties.constraints.properties.statuses.properties.active.properties.directive, data: data13 };
                        if (vErrors === null) {
                          vErrors = [err13];
                        } else {
                          vErrors.push(err13);
                        }
                        errors++;
                      }
                      if (!(data13 === "required" || data13 === "allowed" || data13 === "disallowed")) {
                        const err14 = { instancePath: instancePath + "/constraints/statuses/active/directive", schemaPath: "#/properties/constraints/properties/statuses/properties/active/properties/directive/enum", keyword: "enum", params: { allowedValues: schema15.properties.constraints.properties.statuses.properties.active.properties.directive.enum }, message: "must be equal to one of the allowed values", schema: schema15.properties.constraints.properties.statuses.properties.active.properties.directive.enum, parentSchema: schema15.properties.constraints.properties.statuses.properties.active.properties.directive, data: data13 };
                        if (vErrors === null) {
                          vErrors = [err14];
                        } else {
                          vErrors.push(err14);
                        }
                        errors++;
                      }
                    }
                  } else {
                    const err15 = { instancePath: instancePath + "/constraints/statuses/active", schemaPath: "#/properties/constraints/properties/statuses/properties/active/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema15.properties.constraints.properties.statuses.properties.active.type, parentSchema: schema15.properties.constraints.properties.statuses.properties.active, data: data12 };
                    if (vErrors === null) {
                      vErrors = [err15];
                    } else {
                      vErrors.push(err15);
                    }
                    errors++;
                  }
                }
                if (data11.suspended !== void 0) {
                  let data14 = data11.suspended;
                  if (data14 && typeof data14 == "object" && !Array.isArray(data14)) {
                    if (data14.directive !== void 0) {
                      let data15 = data14.directive;
                      if (typeof data15 !== "string") {
                        const err16 = { instancePath: instancePath + "/constraints/statuses/suspended/directive", schemaPath: "#/properties/constraints/properties/statuses/properties/suspended/properties/directive/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema15.properties.constraints.properties.statuses.properties.suspended.properties.directive.type, parentSchema: schema15.properties.constraints.properties.statuses.properties.suspended.properties.directive, data: data15 };
                        if (vErrors === null) {
                          vErrors = [err16];
                        } else {
                          vErrors.push(err16);
                        }
                        errors++;
                      }
                      if (!(data15 === "required" || data15 === "allowed" || data15 === "disallowed")) {
                        const err17 = { instancePath: instancePath + "/constraints/statuses/suspended/directive", schemaPath: "#/properties/constraints/properties/statuses/properties/suspended/properties/directive/enum", keyword: "enum", params: { allowedValues: schema15.properties.constraints.properties.statuses.properties.suspended.properties.directive.enum }, message: "must be equal to one of the allowed values", schema: schema15.properties.constraints.properties.statuses.properties.suspended.properties.directive.enum, parentSchema: schema15.properties.constraints.properties.statuses.properties.suspended.properties.directive, data: data15 };
                        if (vErrors === null) {
                          vErrors = [err17];
                        } else {
                          vErrors.push(err17);
                        }
                        errors++;
                      }
                    }
                  } else {
                    const err18 = { instancePath: instancePath + "/constraints/statuses/suspended", schemaPath: "#/properties/constraints/properties/statuses/properties/suspended/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema15.properties.constraints.properties.statuses.properties.suspended.type, parentSchema: schema15.properties.constraints.properties.statuses.properties.suspended, data: data14 };
                    if (vErrors === null) {
                      vErrors = [err18];
                    } else {
                      vErrors.push(err18);
                    }
                    errors++;
                  }
                }
                if (data11.revoked !== void 0) {
                  let data16 = data11.revoked;
                  if (data16 && typeof data16 == "object" && !Array.isArray(data16)) {
                    if (data16.directive !== void 0) {
                      let data17 = data16.directive;
                      if (typeof data17 !== "string") {
                        const err19 = { instancePath: instancePath + "/constraints/statuses/revoked/directive", schemaPath: "#/properties/constraints/properties/statuses/properties/revoked/properties/directive/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema15.properties.constraints.properties.statuses.properties.revoked.properties.directive.type, parentSchema: schema15.properties.constraints.properties.statuses.properties.revoked.properties.directive, data: data17 };
                        if (vErrors === null) {
                          vErrors = [err19];
                        } else {
                          vErrors.push(err19);
                        }
                        errors++;
                      }
                      if (!(data17 === "required" || data17 === "allowed" || data17 === "disallowed")) {
                        const err20 = { instancePath: instancePath + "/constraints/statuses/revoked/directive", schemaPath: "#/properties/constraints/properties/statuses/properties/revoked/properties/directive/enum", keyword: "enum", params: { allowedValues: schema15.properties.constraints.properties.statuses.properties.revoked.properties.directive.enum }, message: "must be equal to one of the allowed values", schema: schema15.properties.constraints.properties.statuses.properties.revoked.properties.directive.enum, parentSchema: schema15.properties.constraints.properties.statuses.properties.revoked.properties.directive, data: data17 };
                        if (vErrors === null) {
                          vErrors = [err20];
                        } else {
                          vErrors.push(err20);
                        }
                        errors++;
                      }
                    }
                  } else {
                    const err21 = { instancePath: instancePath + "/constraints/statuses/revoked", schemaPath: "#/properties/constraints/properties/statuses/properties/revoked/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema15.properties.constraints.properties.statuses.properties.revoked.type, parentSchema: schema15.properties.constraints.properties.statuses.properties.revoked, data: data16 };
                    if (vErrors === null) {
                      vErrors = [err21];
                    } else {
                      vErrors.push(err21);
                    }
                    errors++;
                  }
                }
              } else {
                const err22 = { instancePath: instancePath + "/constraints/statuses", schemaPath: "#/properties/constraints/properties/statuses/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema15.properties.constraints.properties.statuses.type, parentSchema: schema15.properties.constraints.properties.statuses, data: data11 };
                if (vErrors === null) {
                  vErrors = [err22];
                } else {
                  vErrors.push(err22);
                }
                errors++;
              }
            }
            if (data9.fields !== void 0) {
              let data18 = data9.fields;
              if (Array.isArray(data18)) {
                const len3 = data18.length;
                for (let i3 = 0; i3 < len3; i3++) {
                  if (!validate52(data18[i3], { instancePath: instancePath + "/constraints/fields/" + i3, parentData: data18, parentDataProperty: i3, rootData })) {
                    vErrors = vErrors === null ? validate52.errors : vErrors.concat(validate52.errors);
                    errors = vErrors.length;
                  }
                }
              } else {
                const err23 = { instancePath: instancePath + "/constraints/fields", schemaPath: "#/properties/constraints/properties/fields/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema15.properties.constraints.properties.fields.type, parentSchema: schema15.properties.constraints.properties.fields, data: data18 };
                if (vErrors === null) {
                  vErrors = [err23];
                } else {
                  vErrors.push(err23);
                }
                errors++;
              }
            }
            if (data9.subject_is_issuer !== void 0) {
              let data20 = data9.subject_is_issuer;
              if (typeof data20 !== "string") {
                const err24 = { instancePath: instancePath + "/constraints/subject_is_issuer", schemaPath: "#/properties/constraints/properties/subject_is_issuer/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema15.properties.constraints.properties.subject_is_issuer.type, parentSchema: schema15.properties.constraints.properties.subject_is_issuer, data: data20 };
                if (vErrors === null) {
                  vErrors = [err24];
                } else {
                  vErrors.push(err24);
                }
                errors++;
              }
              if (!(data20 === "required" || data20 === "preferred")) {
                const err25 = { instancePath: instancePath + "/constraints/subject_is_issuer", schemaPath: "#/properties/constraints/properties/subject_is_issuer/enum", keyword: "enum", params: { allowedValues: schema15.properties.constraints.properties.subject_is_issuer.enum }, message: "must be equal to one of the allowed values", schema: schema15.properties.constraints.properties.subject_is_issuer.enum, parentSchema: schema15.properties.constraints.properties.subject_is_issuer, data: data20 };
                if (vErrors === null) {
                  vErrors = [err25];
                } else {
                  vErrors.push(err25);
                }
                errors++;
              }
            }
            if (data9.is_holder !== void 0) {
              let data21 = data9.is_holder;
              if (Array.isArray(data21)) {
                const len4 = data21.length;
                for (let i4 = 0; i4 < len4; i4++) {
                  let data22 = data21[i4];
                  if (data22 && typeof data22 == "object" && !Array.isArray(data22)) {
                    if (data22.field_id === void 0) {
                      const err26 = { instancePath: instancePath + "/constraints/is_holder/" + i4, schemaPath: "#/properties/constraints/properties/is_holder/items/required", keyword: "required", params: { missingProperty: "field_id" }, message: "must have required property 'field_id'", schema: schema15.properties.constraints.properties.is_holder.items.required, parentSchema: schema15.properties.constraints.properties.is_holder.items, data: data22 };
                      if (vErrors === null) {
                        vErrors = [err26];
                      } else {
                        vErrors.push(err26);
                      }
                      errors++;
                    }
                    if (data22.directive === void 0) {
                      const err27 = { instancePath: instancePath + "/constraints/is_holder/" + i4, schemaPath: "#/properties/constraints/properties/is_holder/items/required", keyword: "required", params: { missingProperty: "directive" }, message: "must have required property 'directive'", schema: schema15.properties.constraints.properties.is_holder.items.required, parentSchema: schema15.properties.constraints.properties.is_holder.items, data: data22 };
                      if (vErrors === null) {
                        vErrors = [err27];
                      } else {
                        vErrors.push(err27);
                      }
                      errors++;
                    }
                    for (const key2 in data22) {
                      if (!(key2 === "field_id" || key2 === "directive")) {
                        const err28 = { instancePath: instancePath + "/constraints/is_holder/" + i4, schemaPath: "#/properties/constraints/properties/is_holder/items/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key2 }, message: "must NOT have additional properties", schema: false, parentSchema: schema15.properties.constraints.properties.is_holder.items, data: data22 };
                        if (vErrors === null) {
                          vErrors = [err28];
                        } else {
                          vErrors.push(err28);
                        }
                        errors++;
                      }
                    }
                    if (data22.field_id !== void 0) {
                      let data23 = data22.field_id;
                      if (Array.isArray(data23)) {
                        const len5 = data23.length;
                        for (let i5 = 0; i5 < len5; i5++) {
                          let data24 = data23[i5];
                          if (typeof data24 !== "string") {
                            const err29 = { instancePath: instancePath + "/constraints/is_holder/" + i4 + "/field_id/" + i5, schemaPath: "#/properties/constraints/properties/is_holder/items/properties/field_id/items/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema15.properties.constraints.properties.is_holder.items.properties.field_id.items.type, parentSchema: schema15.properties.constraints.properties.is_holder.items.properties.field_id.items, data: data24 };
                            if (vErrors === null) {
                              vErrors = [err29];
                            } else {
                              vErrors.push(err29);
                            }
                            errors++;
                          }
                        }
                      } else {
                        const err30 = { instancePath: instancePath + "/constraints/is_holder/" + i4 + "/field_id", schemaPath: "#/properties/constraints/properties/is_holder/items/properties/field_id/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema15.properties.constraints.properties.is_holder.items.properties.field_id.type, parentSchema: schema15.properties.constraints.properties.is_holder.items.properties.field_id, data: data23 };
                        if (vErrors === null) {
                          vErrors = [err30];
                        } else {
                          vErrors.push(err30);
                        }
                        errors++;
                      }
                    }
                    if (data22.directive !== void 0) {
                      let data25 = data22.directive;
                      if (typeof data25 !== "string") {
                        const err31 = { instancePath: instancePath + "/constraints/is_holder/" + i4 + "/directive", schemaPath: "#/properties/constraints/properties/is_holder/items/properties/directive/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema15.properties.constraints.properties.is_holder.items.properties.directive.type, parentSchema: schema15.properties.constraints.properties.is_holder.items.properties.directive, data: data25 };
                        if (vErrors === null) {
                          vErrors = [err31];
                        } else {
                          vErrors.push(err31);
                        }
                        errors++;
                      }
                      if (!(data25 === "required" || data25 === "preferred")) {
                        const err32 = { instancePath: instancePath + "/constraints/is_holder/" + i4 + "/directive", schemaPath: "#/properties/constraints/properties/is_holder/items/properties/directive/enum", keyword: "enum", params: { allowedValues: schema15.properties.constraints.properties.is_holder.items.properties.directive.enum }, message: "must be equal to one of the allowed values", schema: schema15.properties.constraints.properties.is_holder.items.properties.directive.enum, parentSchema: schema15.properties.constraints.properties.is_holder.items.properties.directive, data: data25 };
                        if (vErrors === null) {
                          vErrors = [err32];
                        } else {
                          vErrors.push(err32);
                        }
                        errors++;
                      }
                    }
                  } else {
                    const err33 = { instancePath: instancePath + "/constraints/is_holder/" + i4, schemaPath: "#/properties/constraints/properties/is_holder/items/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema15.properties.constraints.properties.is_holder.items.type, parentSchema: schema15.properties.constraints.properties.is_holder.items, data: data22 };
                    if (vErrors === null) {
                      vErrors = [err33];
                    } else {
                      vErrors.push(err33);
                    }
                    errors++;
                  }
                }
              } else {
                const err34 = { instancePath: instancePath + "/constraints/is_holder", schemaPath: "#/properties/constraints/properties/is_holder/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema15.properties.constraints.properties.is_holder.type, parentSchema: schema15.properties.constraints.properties.is_holder, data: data21 };
                if (vErrors === null) {
                  vErrors = [err34];
                } else {
                  vErrors.push(err34);
                }
                errors++;
              }
            }
            if (data9.same_subject !== void 0) {
              let data26 = data9.same_subject;
              if (Array.isArray(data26)) {
                const len6 = data26.length;
                for (let i6 = 0; i6 < len6; i6++) {
                  let data27 = data26[i6];
                  if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                    if (data27.field_id === void 0) {
                      const err35 = { instancePath: instancePath + "/constraints/same_subject/" + i6, schemaPath: "#/properties/constraints/properties/same_subject/items/required", keyword: "required", params: { missingProperty: "field_id" }, message: "must have required property 'field_id'", schema: schema15.properties.constraints.properties.same_subject.items.required, parentSchema: schema15.properties.constraints.properties.same_subject.items, data: data27 };
                      if (vErrors === null) {
                        vErrors = [err35];
                      } else {
                        vErrors.push(err35);
                      }
                      errors++;
                    }
                    if (data27.directive === void 0) {
                      const err36 = { instancePath: instancePath + "/constraints/same_subject/" + i6, schemaPath: "#/properties/constraints/properties/same_subject/items/required", keyword: "required", params: { missingProperty: "directive" }, message: "must have required property 'directive'", schema: schema15.properties.constraints.properties.same_subject.items.required, parentSchema: schema15.properties.constraints.properties.same_subject.items, data: data27 };
                      if (vErrors === null) {
                        vErrors = [err36];
                      } else {
                        vErrors.push(err36);
                      }
                      errors++;
                    }
                    for (const key3 in data27) {
                      if (!(key3 === "field_id" || key3 === "directive")) {
                        const err37 = { instancePath: instancePath + "/constraints/same_subject/" + i6, schemaPath: "#/properties/constraints/properties/same_subject/items/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key3 }, message: "must NOT have additional properties", schema: false, parentSchema: schema15.properties.constraints.properties.same_subject.items, data: data27 };
                        if (vErrors === null) {
                          vErrors = [err37];
                        } else {
                          vErrors.push(err37);
                        }
                        errors++;
                      }
                    }
                    if (data27.field_id !== void 0) {
                      let data28 = data27.field_id;
                      if (Array.isArray(data28)) {
                        const len7 = data28.length;
                        for (let i7 = 0; i7 < len7; i7++) {
                          let data29 = data28[i7];
                          if (typeof data29 !== "string") {
                            const err38 = { instancePath: instancePath + "/constraints/same_subject/" + i6 + "/field_id/" + i7, schemaPath: "#/properties/constraints/properties/same_subject/items/properties/field_id/items/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema15.properties.constraints.properties.same_subject.items.properties.field_id.items.type, parentSchema: schema15.properties.constraints.properties.same_subject.items.properties.field_id.items, data: data29 };
                            if (vErrors === null) {
                              vErrors = [err38];
                            } else {
                              vErrors.push(err38);
                            }
                            errors++;
                          }
                        }
                      } else {
                        const err39 = { instancePath: instancePath + "/constraints/same_subject/" + i6 + "/field_id", schemaPath: "#/properties/constraints/properties/same_subject/items/properties/field_id/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema15.properties.constraints.properties.same_subject.items.properties.field_id.type, parentSchema: schema15.properties.constraints.properties.same_subject.items.properties.field_id, data: data28 };
                        if (vErrors === null) {
                          vErrors = [err39];
                        } else {
                          vErrors.push(err39);
                        }
                        errors++;
                      }
                    }
                    if (data27.directive !== void 0) {
                      let data30 = data27.directive;
                      if (typeof data30 !== "string") {
                        const err40 = { instancePath: instancePath + "/constraints/same_subject/" + i6 + "/directive", schemaPath: "#/properties/constraints/properties/same_subject/items/properties/directive/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema15.properties.constraints.properties.same_subject.items.properties.directive.type, parentSchema: schema15.properties.constraints.properties.same_subject.items.properties.directive, data: data30 };
                        if (vErrors === null) {
                          vErrors = [err40];
                        } else {
                          vErrors.push(err40);
                        }
                        errors++;
                      }
                      if (!(data30 === "required" || data30 === "preferred")) {
                        const err41 = { instancePath: instancePath + "/constraints/same_subject/" + i6 + "/directive", schemaPath: "#/properties/constraints/properties/same_subject/items/properties/directive/enum", keyword: "enum", params: { allowedValues: schema15.properties.constraints.properties.same_subject.items.properties.directive.enum }, message: "must be equal to one of the allowed values", schema: schema15.properties.constraints.properties.same_subject.items.properties.directive.enum, parentSchema: schema15.properties.constraints.properties.same_subject.items.properties.directive, data: data30 };
                        if (vErrors === null) {
                          vErrors = [err41];
                        } else {
                          vErrors.push(err41);
                        }
                        errors++;
                      }
                    }
                  } else {
                    const err42 = { instancePath: instancePath + "/constraints/same_subject/" + i6, schemaPath: "#/properties/constraints/properties/same_subject/items/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema15.properties.constraints.properties.same_subject.items.type, parentSchema: schema15.properties.constraints.properties.same_subject.items, data: data27 };
                    if (vErrors === null) {
                      vErrors = [err42];
                    } else {
                      vErrors.push(err42);
                    }
                    errors++;
                  }
                }
              } else {
                const err43 = { instancePath: instancePath + "/constraints/same_subject", schemaPath: "#/properties/constraints/properties/same_subject/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema15.properties.constraints.properties.same_subject.type, parentSchema: schema15.properties.constraints.properties.same_subject, data: data26 };
                if (vErrors === null) {
                  vErrors = [err43];
                } else {
                  vErrors.push(err43);
                }
                errors++;
              }
            }
          } else {
            const err44 = { instancePath: instancePath + "/constraints", schemaPath: "#/properties/constraints/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema15.properties.constraints.type, parentSchema: schema15.properties.constraints, data: data9 };
            if (vErrors === null) {
              vErrors = [err44];
            } else {
              vErrors.push(err44);
            }
            errors++;
          }
        }
      } else {
        const err45 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema15.type, parentSchema: schema15, data };
        if (vErrors === null) {
          vErrors = [err45];
        } else {
          vErrors.push(err45);
        }
        errors++;
      }
      validate47.errors = vErrors;
      return errors === 0;
    }
    function validate42(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.presentation_definition !== void 0) {
          let data0 = data.presentation_definition;
          if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
            if (data0.id === void 0) {
              const err0 = { instancePath: instancePath + "/presentation_definition", schemaPath: "#/properties/presentation_definition/required", keyword: "required", params: { missingProperty: "id" }, message: "must have required property 'id'", schema: schema12.properties.presentation_definition.required, parentSchema: schema12.properties.presentation_definition, data: data0 };
              if (vErrors === null) {
                vErrors = [err0];
              } else {
                vErrors.push(err0);
              }
              errors++;
            }
            if (data0.input_descriptors === void 0) {
              const err1 = { instancePath: instancePath + "/presentation_definition", schemaPath: "#/properties/presentation_definition/required", keyword: "required", params: { missingProperty: "input_descriptors" }, message: "must have required property 'input_descriptors'", schema: schema12.properties.presentation_definition.required, parentSchema: schema12.properties.presentation_definition, data: data0 };
              if (vErrors === null) {
                vErrors = [err1];
              } else {
                vErrors.push(err1);
              }
              errors++;
            }
            for (const key0 in data0) {
              if (!(key0 === "id" || key0 === "name" || key0 === "purpose" || key0 === "format" || key0 === "submission_requirements" || key0 === "input_descriptors")) {
                const err2 = { instancePath: instancePath + "/presentation_definition", schemaPath: "#/properties/presentation_definition/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties", schema: false, parentSchema: schema12.properties.presentation_definition, data: data0 };
                if (vErrors === null) {
                  vErrors = [err2];
                } else {
                  vErrors.push(err2);
                }
                errors++;
              }
            }
            if (data0.id !== void 0) {
              let data1 = data0.id;
              if (typeof data1 !== "string") {
                const err3 = { instancePath: instancePath + "/presentation_definition/id", schemaPath: "#/properties/presentation_definition/properties/id/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema12.properties.presentation_definition.properties.id.type, parentSchema: schema12.properties.presentation_definition.properties.id, data: data1 };
                if (vErrors === null) {
                  vErrors = [err3];
                } else {
                  vErrors.push(err3);
                }
                errors++;
              }
            }
            if (data0.name !== void 0) {
              let data2 = data0.name;
              if (typeof data2 !== "string") {
                const err4 = { instancePath: instancePath + "/presentation_definition/name", schemaPath: "#/properties/presentation_definition/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema12.properties.presentation_definition.properties.name.type, parentSchema: schema12.properties.presentation_definition.properties.name, data: data2 };
                if (vErrors === null) {
                  vErrors = [err4];
                } else {
                  vErrors.push(err4);
                }
                errors++;
              }
            }
            if (data0.purpose !== void 0) {
              let data3 = data0.purpose;
              if (typeof data3 !== "string") {
                const err5 = { instancePath: instancePath + "/presentation_definition/purpose", schemaPath: "#/properties/presentation_definition/properties/purpose/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema12.properties.presentation_definition.properties.purpose.type, parentSchema: schema12.properties.presentation_definition.properties.purpose, data: data3 };
                if (vErrors === null) {
                  vErrors = [err5];
                } else {
                  vErrors.push(err5);
                }
                errors++;
              }
            }
            if (data0.format !== void 0) {
              if (!validate43(data0.format, { instancePath: instancePath + "/presentation_definition/format", parentData: data0, parentDataProperty: "format", rootData })) {
                vErrors = vErrors === null ? validate43.errors : vErrors.concat(validate43.errors);
                errors = vErrors.length;
              }
            }
            if (data0.submission_requirements !== void 0) {
              let data5 = data0.submission_requirements;
              if (Array.isArray(data5)) {
                const len0 = data5.length;
                for (let i0 = 0; i0 < len0; i0++) {
                  if (!validate45(data5[i0], { instancePath: instancePath + "/presentation_definition/submission_requirements/" + i0, parentData: data5, parentDataProperty: i0, rootData })) {
                    vErrors = vErrors === null ? validate45.errors : vErrors.concat(validate45.errors);
                    errors = vErrors.length;
                  }
                }
              } else {
                const err6 = { instancePath: instancePath + "/presentation_definition/submission_requirements", schemaPath: "#/properties/presentation_definition/properties/submission_requirements/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema12.properties.presentation_definition.properties.submission_requirements.type, parentSchema: schema12.properties.presentation_definition.properties.submission_requirements, data: data5 };
                if (vErrors === null) {
                  vErrors = [err6];
                } else {
                  vErrors.push(err6);
                }
                errors++;
              }
            }
            if (data0.input_descriptors !== void 0) {
              let data7 = data0.input_descriptors;
              if (Array.isArray(data7)) {
                const len1 = data7.length;
                for (let i1 = 0; i1 < len1; i1++) {
                  if (!validate47(data7[i1], { instancePath: instancePath + "/presentation_definition/input_descriptors/" + i1, parentData: data7, parentDataProperty: i1, rootData })) {
                    vErrors = vErrors === null ? validate47.errors : vErrors.concat(validate47.errors);
                    errors = vErrors.length;
                  }
                }
              } else {
                const err7 = { instancePath: instancePath + "/presentation_definition/input_descriptors", schemaPath: "#/properties/presentation_definition/properties/input_descriptors/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema12.properties.presentation_definition.properties.input_descriptors.type, parentSchema: schema12.properties.presentation_definition.properties.input_descriptors, data: data7 };
                if (vErrors === null) {
                  vErrors = [err7];
                } else {
                  vErrors.push(err7);
                }
                errors++;
              }
            }
          } else {
            const err8 = { instancePath: instancePath + "/presentation_definition", schemaPath: "#/properties/presentation_definition/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema12.properties.presentation_definition.type, parentSchema: schema12.properties.presentation_definition, data: data0 };
            if (vErrors === null) {
              vErrors = [err8];
            } else {
              vErrors.push(err8);
            }
            errors++;
          }
        }
      } else {
        const err9 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema12.type, parentSchema: schema12, data };
        if (vErrors === null) {
          vErrors = [err9];
        } else {
          vErrors.push(err9);
        }
        errors++;
      }
      validate42.errors = vErrors;
      return errors === 0;
    }
  }
});

// node_modules/@sphereon/pex/dist/module/lib/validation/validatePDv2.js
var require_validatePDv2 = __commonJS({
  "node_modules/@sphereon/pex/dist/module/lib/validation/validatePDv2.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    module.exports = validate42;
    module.exports.default = validate42;
    var schema12 = { "$schema": "http://json-schema.org/draft-07/schema#", "title": "Presentation Definition", "definitions": { "issuance": { "type": "object", "properties": { "manifest": { "type": "string" } }, "additionalProperties": true }, "format": { "type": "object", "patternProperties": { "^jwt$|^jwt_vc$|^jwt_vp$|^mso_mdoc$": { "type": "object", "properties": { "alg": { "type": "array", "minItems": 1, "items": { "type": "string" } } }, "required": ["alg"], "additionalProperties": false }, "^ldp_vc$|^ldp_vp$|^ldp$": { "type": "object", "properties": { "proof_type": { "type": "array", "minItems": 1, "items": { "type": "string" } } }, "required": ["proof_type"], "additionalProperties": false }, "additionalProperties": false }, "additionalProperties": false }, "submission_requirements": { "type": "object", "oneOf": [{ "properties": { "name": { "type": "string" }, "purpose": { "type": "string" }, "rule": { "type": "string", "enum": ["all", "pick"] }, "count": { "type": "integer", "minimum": 1 }, "min": { "type": "integer", "minimum": 0 }, "max": { "type": "integer", "minimum": 0 }, "from": { "type": "string" } }, "required": ["rule", "from"], "additionalProperties": false }, { "properties": { "name": { "type": "string" }, "purpose": { "type": "string" }, "rule": { "type": "string", "enum": ["all", "pick"] }, "count": { "type": "integer", "minimum": 1 }, "min": { "type": "integer", "minimum": 0 }, "max": { "type": "integer", "minimum": 0 }, "from_nested": { "type": "array", "minItems": 1, "items": { "$ref": "#/definitions/submission_requirements" } } }, "required": ["rule", "from_nested"], "additionalProperties": false }] }, "input_descriptors": { "type": "object", "properties": { "id": { "type": "string" }, "name": { "type": "string" }, "purpose": { "type": "string" }, "issuance": { "type": "array", "items": { "$ref": "#/definitions/issuance" } }, "group": { "type": "array", "items": { "type": "string" } }, "format": { "$ref": "#/definitions/format" }, "constraints": { "type": "object", "properties": { "limit_disclosure": { "type": "string", "enum": ["required", "preferred"] }, "statuses": { "type": "object", "properties": { "active": { "type": "object", "properties": { "directive": { "type": "string", "enum": ["required", "allowed", "disallowed"] } } }, "suspended": { "type": "object", "properties": { "directive": { "type": "string", "enum": ["required", "allowed", "disallowed"] } } }, "revoked": { "type": "object", "properties": { "directive": { "type": "string", "enum": ["required", "allowed", "disallowed"] } } } } }, "fields": { "type": "array", "items": { "$ref": "#/definitions/field" } }, "subject_is_issuer": { "type": "string", "enum": ["required", "preferred"] }, "is_holder": { "type": "array", "items": { "type": "object", "properties": { "field_id": { "type": "array", "items": { "type": "string" } }, "directive": { "type": "string", "enum": ["required", "preferred"] } }, "required": ["field_id", "directive"], "additionalProperties": false } }, "same_subject": { "type": "array", "items": { "type": "object", "properties": { "field_id": { "type": "array", "items": { "type": "string" } }, "directive": { "type": "string", "enum": ["required", "preferred"] } }, "required": ["field_id", "directive"], "additionalProperties": false } } }, "additionalProperties": false } }, "required": ["id"], "additionalProperties": false }, "field": { "type": "object", "oneOf": [{ "properties": { "id": { "type": "string" }, "path": { "type": "array", "items": { "type": "string" } }, "purpose": { "type": "string" }, "intent_to_retain": { "type": "boolean" }, "filter": { "$ref": "http://json-schema.org/schema#" }, "name": { "type": "string" } }, "required": ["path"], "additionalProperties": false }, { "properties": { "id": { "type": "string" }, "path": { "type": "array", "items": { "type": "string" } }, "purpose": { "type": "string" }, "intent_to_retain": { "type": "boolean" }, "filter": { "$ref": "http://json-schema.org/schema#" }, "predicate": { "type": "string", "enum": ["required", "preferred"] }, "name": { "type": "string" } }, "required": ["path", "filter", "predicate"], "additionalProperties": false }] } }, "type": "object", "properties": { "presentation_definition": { "type": "object", "properties": { "id": { "type": "string" }, "name": { "type": "string" }, "purpose": { "type": "string" }, "format": { "$ref": "#/definitions/format" }, "frame": { "type": "object", "additionalProperties": true }, "submission_requirements": { "type": "array", "items": { "$ref": "#/definitions/submission_requirements" } }, "input_descriptors": { "type": "array", "items": { "$ref": "#/definitions/input_descriptors" } } }, "required": ["id", "input_descriptors"], "additionalProperties": false } } };
    var schema13 = { "type": "object", "patternProperties": { "^jwt$|^jwt_vc$|^jwt_vp$|^mso_mdoc$": { "type": "object", "properties": { "alg": { "type": "array", "minItems": 1, "items": { "type": "string" } } }, "required": ["alg"], "additionalProperties": false }, "^ldp_vc$|^ldp_vp$|^ldp$": { "type": "object", "properties": { "proof_type": { "type": "array", "minItems": 1, "items": { "type": "string" } } }, "required": ["proof_type"], "additionalProperties": false }, "additionalProperties": false }, "additionalProperties": false };
    var pattern0 = new RegExp("^jwt$|^jwt_vc$|^jwt_vp$|^mso_mdoc$", "u");
    var pattern1 = new RegExp("^ldp_vc$|^ldp_vp$|^ldp$", "u");
    var pattern2 = new RegExp("additionalProperties", "u");
    function validate43(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        for (const key0 in data) {
          if (!(pattern0.test(key0) || pattern1.test(key0) || pattern2.test(key0))) {
            const err0 = { instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties", schema: false, parentSchema: schema13, data };
            if (vErrors === null) {
              vErrors = [err0];
            } else {
              vErrors.push(err0);
            }
            errors++;
          }
        }
        for (const key1 in data) {
          if (pattern0.test(key1)) {
            let data0 = data[key1];
            if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
              if (data0.alg === void 0) {
                const err1 = { instancePath: instancePath + "/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/patternProperties/%5Ejwt%24%7C%5Ejwt_vc%24%7C%5Ejwt_vp%24%7C%5Emso_mdoc%24/required", keyword: "required", params: { missingProperty: "alg" }, message: "must have required property 'alg'", schema: schema13.patternProperties["^jwt$|^jwt_vc$|^jwt_vp$|^mso_mdoc$"].required, parentSchema: schema13.patternProperties["^jwt$|^jwt_vc$|^jwt_vp$|^mso_mdoc$"], data: data0 };
                if (vErrors === null) {
                  vErrors = [err1];
                } else {
                  vErrors.push(err1);
                }
                errors++;
              }
              for (const key2 in data0) {
                if (!(key2 === "alg")) {
                  const err2 = { instancePath: instancePath + "/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/patternProperties/%5Ejwt%24%7C%5Ejwt_vc%24%7C%5Ejwt_vp%24%7C%5Emso_mdoc%24/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key2 }, message: "must NOT have additional properties", schema: false, parentSchema: schema13.patternProperties["^jwt$|^jwt_vc$|^jwt_vp$|^mso_mdoc$"], data: data0 };
                  if (vErrors === null) {
                    vErrors = [err2];
                  } else {
                    vErrors.push(err2);
                  }
                  errors++;
                }
              }
              if (data0.alg !== void 0) {
                let data1 = data0.alg;
                if (Array.isArray(data1)) {
                  if (data1.length < 1) {
                    const err3 = { instancePath: instancePath + "/" + key1.replace(/~/g, "~0").replace(/\//g, "~1") + "/alg", schemaPath: "#/patternProperties/%5Ejwt%24%7C%5Ejwt_vc%24%7C%5Ejwt_vp%24%7C%5Emso_mdoc%24/properties/alg/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items", schema: 1, parentSchema: schema13.patternProperties["^jwt$|^jwt_vc$|^jwt_vp$|^mso_mdoc$"].properties.alg, data: data1 };
                    if (vErrors === null) {
                      vErrors = [err3];
                    } else {
                      vErrors.push(err3);
                    }
                    errors++;
                  }
                  const len0 = data1.length;
                  for (let i0 = 0; i0 < len0; i0++) {
                    let data2 = data1[i0];
                    if (typeof data2 !== "string") {
                      const err4 = { instancePath: instancePath + "/" + key1.replace(/~/g, "~0").replace(/\//g, "~1") + "/alg/" + i0, schemaPath: "#/patternProperties/%5Ejwt%24%7C%5Ejwt_vc%24%7C%5Ejwt_vp%24%7C%5Emso_mdoc%24/properties/alg/items/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema13.patternProperties["^jwt$|^jwt_vc$|^jwt_vp$|^mso_mdoc$"].properties.alg.items.type, parentSchema: schema13.patternProperties["^jwt$|^jwt_vc$|^jwt_vp$|^mso_mdoc$"].properties.alg.items, data: data2 };
                      if (vErrors === null) {
                        vErrors = [err4];
                      } else {
                        vErrors.push(err4);
                      }
                      errors++;
                    }
                  }
                } else {
                  const err5 = { instancePath: instancePath + "/" + key1.replace(/~/g, "~0").replace(/\//g, "~1") + "/alg", schemaPath: "#/patternProperties/%5Ejwt%24%7C%5Ejwt_vc%24%7C%5Ejwt_vp%24%7C%5Emso_mdoc%24/properties/alg/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema13.patternProperties["^jwt$|^jwt_vc$|^jwt_vp$|^mso_mdoc$"].properties.alg.type, parentSchema: schema13.patternProperties["^jwt$|^jwt_vc$|^jwt_vp$|^mso_mdoc$"].properties.alg, data: data1 };
                  if (vErrors === null) {
                    vErrors = [err5];
                  } else {
                    vErrors.push(err5);
                  }
                  errors++;
                }
              }
            } else {
              const err6 = { instancePath: instancePath + "/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/patternProperties/%5Ejwt%24%7C%5Ejwt_vc%24%7C%5Ejwt_vp%24%7C%5Emso_mdoc%24/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema13.patternProperties["^jwt$|^jwt_vc$|^jwt_vp$|^mso_mdoc$"].type, parentSchema: schema13.patternProperties["^jwt$|^jwt_vc$|^jwt_vp$|^mso_mdoc$"], data: data0 };
              if (vErrors === null) {
                vErrors = [err6];
              } else {
                vErrors.push(err6);
              }
              errors++;
            }
          }
        }
        for (const key3 in data) {
          if (pattern1.test(key3)) {
            let data3 = data[key3];
            if (data3 && typeof data3 == "object" && !Array.isArray(data3)) {
              if (data3.proof_type === void 0) {
                const err7 = { instancePath: instancePath + "/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/patternProperties/%5Eldp_vc%24%7C%5Eldp_vp%24%7C%5Eldp%24/required", keyword: "required", params: { missingProperty: "proof_type" }, message: "must have required property 'proof_type'", schema: schema13.patternProperties["^ldp_vc$|^ldp_vp$|^ldp$"].required, parentSchema: schema13.patternProperties["^ldp_vc$|^ldp_vp$|^ldp$"], data: data3 };
                if (vErrors === null) {
                  vErrors = [err7];
                } else {
                  vErrors.push(err7);
                }
                errors++;
              }
              for (const key4 in data3) {
                if (!(key4 === "proof_type")) {
                  const err8 = { instancePath: instancePath + "/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/patternProperties/%5Eldp_vc%24%7C%5Eldp_vp%24%7C%5Eldp%24/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key4 }, message: "must NOT have additional properties", schema: false, parentSchema: schema13.patternProperties["^ldp_vc$|^ldp_vp$|^ldp$"], data: data3 };
                  if (vErrors === null) {
                    vErrors = [err8];
                  } else {
                    vErrors.push(err8);
                  }
                  errors++;
                }
              }
              if (data3.proof_type !== void 0) {
                let data4 = data3.proof_type;
                if (Array.isArray(data4)) {
                  if (data4.length < 1) {
                    const err9 = { instancePath: instancePath + "/" + key3.replace(/~/g, "~0").replace(/\//g, "~1") + "/proof_type", schemaPath: "#/patternProperties/%5Eldp_vc%24%7C%5Eldp_vp%24%7C%5Eldp%24/properties/proof_type/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items", schema: 1, parentSchema: schema13.patternProperties["^ldp_vc$|^ldp_vp$|^ldp$"].properties.proof_type, data: data4 };
                    if (vErrors === null) {
                      vErrors = [err9];
                    } else {
                      vErrors.push(err9);
                    }
                    errors++;
                  }
                  const len1 = data4.length;
                  for (let i1 = 0; i1 < len1; i1++) {
                    let data5 = data4[i1];
                    if (typeof data5 !== "string") {
                      const err10 = { instancePath: instancePath + "/" + key3.replace(/~/g, "~0").replace(/\//g, "~1") + "/proof_type/" + i1, schemaPath: "#/patternProperties/%5Eldp_vc%24%7C%5Eldp_vp%24%7C%5Eldp%24/properties/proof_type/items/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema13.patternProperties["^ldp_vc$|^ldp_vp$|^ldp$"].properties.proof_type.items.type, parentSchema: schema13.patternProperties["^ldp_vc$|^ldp_vp$|^ldp$"].properties.proof_type.items, data: data5 };
                      if (vErrors === null) {
                        vErrors = [err10];
                      } else {
                        vErrors.push(err10);
                      }
                      errors++;
                    }
                  }
                } else {
                  const err11 = { instancePath: instancePath + "/" + key3.replace(/~/g, "~0").replace(/\//g, "~1") + "/proof_type", schemaPath: "#/patternProperties/%5Eldp_vc%24%7C%5Eldp_vp%24%7C%5Eldp%24/properties/proof_type/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema13.patternProperties["^ldp_vc$|^ldp_vp$|^ldp$"].properties.proof_type.type, parentSchema: schema13.patternProperties["^ldp_vc$|^ldp_vp$|^ldp$"].properties.proof_type, data: data4 };
                  if (vErrors === null) {
                    vErrors = [err11];
                  } else {
                    vErrors.push(err11);
                  }
                  errors++;
                }
              }
            } else {
              const err12 = { instancePath: instancePath + "/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/patternProperties/%5Eldp_vc%24%7C%5Eldp_vp%24%7C%5Eldp%24/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema13.patternProperties["^ldp_vc$|^ldp_vp$|^ldp$"].type, parentSchema: schema13.patternProperties["^ldp_vc$|^ldp_vp$|^ldp$"], data: data3 };
              if (vErrors === null) {
                vErrors = [err12];
              } else {
                vErrors.push(err12);
              }
              errors++;
            }
          }
        }
        for (const key5 in data) {
          if (pattern2.test(key5)) {
            const err13 = { instancePath: instancePath + "/" + key5.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/patternProperties/additionalProperties/false schema", keyword: "false schema", params: {}, message: "boolean schema is false", schema: false, parentSchema: schema13.patternProperties.additionalProperties, data: data[key5] };
            if (vErrors === null) {
              vErrors = [err13];
            } else {
              vErrors.push(err13);
            }
            errors++;
          }
        }
      } else {
        const err14 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema13.type, parentSchema: schema13, data };
        if (vErrors === null) {
          vErrors = [err14];
        } else {
          vErrors.push(err14);
        }
        errors++;
      }
      validate43.errors = vErrors;
      return errors === 0;
    }
    var schema14 = { "type": "object", "oneOf": [{ "properties": { "name": { "type": "string" }, "purpose": { "type": "string" }, "rule": { "type": "string", "enum": ["all", "pick"] }, "count": { "type": "integer", "minimum": 1 }, "min": { "type": "integer", "minimum": 0 }, "max": { "type": "integer", "minimum": 0 }, "from": { "type": "string" } }, "required": ["rule", "from"], "additionalProperties": false }, { "properties": { "name": { "type": "string" }, "purpose": { "type": "string" }, "rule": { "type": "string", "enum": ["all", "pick"] }, "count": { "type": "integer", "minimum": 1 }, "min": { "type": "integer", "minimum": 0 }, "max": { "type": "integer", "minimum": 0 }, "from_nested": { "type": "array", "minItems": 1, "items": { "$ref": "#/definitions/submission_requirements" } } }, "required": ["rule", "from_nested"], "additionalProperties": false }] };
    var wrapper0 = { validate: validate45 };
    function validate45(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (!(data && typeof data == "object" && !Array.isArray(data))) {
        const err0 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema14.type, parentSchema: schema14, data };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors++;
      }
      const _errs1 = errors;
      let valid0 = false;
      let passing0 = null;
      const _errs2 = errors;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.rule === void 0) {
          const err1 = { instancePath, schemaPath: "#/oneOf/0/required", keyword: "required", params: { missingProperty: "rule" }, message: "must have required property 'rule'", schema: schema14.oneOf[0].required, parentSchema: schema14.oneOf[0], data };
          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }
          errors++;
        }
        if (data.from === void 0) {
          const err2 = { instancePath, schemaPath: "#/oneOf/0/required", keyword: "required", params: { missingProperty: "from" }, message: "must have required property 'from'", schema: schema14.oneOf[0].required, parentSchema: schema14.oneOf[0], data };
          if (vErrors === null) {
            vErrors = [err2];
          } else {
            vErrors.push(err2);
          }
          errors++;
        }
        for (const key0 in data) {
          if (!(key0 === "name" || key0 === "purpose" || key0 === "rule" || key0 === "count" || key0 === "min" || key0 === "max" || key0 === "from")) {
            const err3 = { instancePath, schemaPath: "#/oneOf/0/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties", schema: false, parentSchema: schema14.oneOf[0], data };
            if (vErrors === null) {
              vErrors = [err3];
            } else {
              vErrors.push(err3);
            }
            errors++;
          }
        }
        if (data.name !== void 0) {
          let data0 = data.name;
          if (typeof data0 !== "string") {
            const err4 = { instancePath: instancePath + "/name", schemaPath: "#/oneOf/0/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema14.oneOf[0].properties.name.type, parentSchema: schema14.oneOf[0].properties.name, data: data0 };
            if (vErrors === null) {
              vErrors = [err4];
            } else {
              vErrors.push(err4);
            }
            errors++;
          }
        }
        if (data.purpose !== void 0) {
          let data1 = data.purpose;
          if (typeof data1 !== "string") {
            const err5 = { instancePath: instancePath + "/purpose", schemaPath: "#/oneOf/0/properties/purpose/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema14.oneOf[0].properties.purpose.type, parentSchema: schema14.oneOf[0].properties.purpose, data: data1 };
            if (vErrors === null) {
              vErrors = [err5];
            } else {
              vErrors.push(err5);
            }
            errors++;
          }
        }
        if (data.rule !== void 0) {
          let data2 = data.rule;
          if (typeof data2 !== "string") {
            const err6 = { instancePath: instancePath + "/rule", schemaPath: "#/oneOf/0/properties/rule/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema14.oneOf[0].properties.rule.type, parentSchema: schema14.oneOf[0].properties.rule, data: data2 };
            if (vErrors === null) {
              vErrors = [err6];
            } else {
              vErrors.push(err6);
            }
            errors++;
          }
          if (!(data2 === "all" || data2 === "pick")) {
            const err7 = { instancePath: instancePath + "/rule", schemaPath: "#/oneOf/0/properties/rule/enum", keyword: "enum", params: { allowedValues: schema14.oneOf[0].properties.rule.enum }, message: "must be equal to one of the allowed values", schema: schema14.oneOf[0].properties.rule.enum, parentSchema: schema14.oneOf[0].properties.rule, data: data2 };
            if (vErrors === null) {
              vErrors = [err7];
            } else {
              vErrors.push(err7);
            }
            errors++;
          }
        }
        if (data.count !== void 0) {
          let data3 = data.count;
          if (!(typeof data3 == "number" && (!(data3 % 1) && !isNaN(data3)))) {
            const err8 = { instancePath: instancePath + "/count", schemaPath: "#/oneOf/0/properties/count/type", keyword: "type", params: { type: "integer" }, message: "must be integer", schema: schema14.oneOf[0].properties.count.type, parentSchema: schema14.oneOf[0].properties.count, data: data3 };
            if (vErrors === null) {
              vErrors = [err8];
            } else {
              vErrors.push(err8);
            }
            errors++;
          }
          if (typeof data3 == "number") {
            if (data3 < 1 || isNaN(data3)) {
              const err9 = { instancePath: instancePath + "/count", schemaPath: "#/oneOf/0/properties/count/minimum", keyword: "minimum", params: { comparison: ">=", limit: 1 }, message: "must be >= 1", schema: 1, parentSchema: schema14.oneOf[0].properties.count, data: data3 };
              if (vErrors === null) {
                vErrors = [err9];
              } else {
                vErrors.push(err9);
              }
              errors++;
            }
          }
        }
        if (data.min !== void 0) {
          let data4 = data.min;
          if (!(typeof data4 == "number" && (!(data4 % 1) && !isNaN(data4)))) {
            const err10 = { instancePath: instancePath + "/min", schemaPath: "#/oneOf/0/properties/min/type", keyword: "type", params: { type: "integer" }, message: "must be integer", schema: schema14.oneOf[0].properties.min.type, parentSchema: schema14.oneOf[0].properties.min, data: data4 };
            if (vErrors === null) {
              vErrors = [err10];
            } else {
              vErrors.push(err10);
            }
            errors++;
          }
          if (typeof data4 == "number") {
            if (data4 < 0 || isNaN(data4)) {
              const err11 = { instancePath: instancePath + "/min", schemaPath: "#/oneOf/0/properties/min/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0", schema: 0, parentSchema: schema14.oneOf[0].properties.min, data: data4 };
              if (vErrors === null) {
                vErrors = [err11];
              } else {
                vErrors.push(err11);
              }
              errors++;
            }
          }
        }
        if (data.max !== void 0) {
          let data5 = data.max;
          if (!(typeof data5 == "number" && (!(data5 % 1) && !isNaN(data5)))) {
            const err12 = { instancePath: instancePath + "/max", schemaPath: "#/oneOf/0/properties/max/type", keyword: "type", params: { type: "integer" }, message: "must be integer", schema: schema14.oneOf[0].properties.max.type, parentSchema: schema14.oneOf[0].properties.max, data: data5 };
            if (vErrors === null) {
              vErrors = [err12];
            } else {
              vErrors.push(err12);
            }
            errors++;
          }
          if (typeof data5 == "number") {
            if (data5 < 0 || isNaN(data5)) {
              const err13 = { instancePath: instancePath + "/max", schemaPath: "#/oneOf/0/properties/max/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0", schema: 0, parentSchema: schema14.oneOf[0].properties.max, data: data5 };
              if (vErrors === null) {
                vErrors = [err13];
              } else {
                vErrors.push(err13);
              }
              errors++;
            }
          }
        }
        if (data.from !== void 0) {
          let data6 = data.from;
          if (typeof data6 !== "string") {
            const err14 = { instancePath: instancePath + "/from", schemaPath: "#/oneOf/0/properties/from/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema14.oneOf[0].properties.from.type, parentSchema: schema14.oneOf[0].properties.from, data: data6 };
            if (vErrors === null) {
              vErrors = [err14];
            } else {
              vErrors.push(err14);
            }
            errors++;
          }
        }
      }
      var _valid0 = _errs2 === errors;
      if (_valid0) {
        valid0 = true;
        passing0 = 0;
      }
      const _errs18 = errors;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.rule === void 0) {
          const err15 = { instancePath, schemaPath: "#/oneOf/1/required", keyword: "required", params: { missingProperty: "rule" }, message: "must have required property 'rule'", schema: schema14.oneOf[1].required, parentSchema: schema14.oneOf[1], data };
          if (vErrors === null) {
            vErrors = [err15];
          } else {
            vErrors.push(err15);
          }
          errors++;
        }
        if (data.from_nested === void 0) {
          const err16 = { instancePath, schemaPath: "#/oneOf/1/required", keyword: "required", params: { missingProperty: "from_nested" }, message: "must have required property 'from_nested'", schema: schema14.oneOf[1].required, parentSchema: schema14.oneOf[1], data };
          if (vErrors === null) {
            vErrors = [err16];
          } else {
            vErrors.push(err16);
          }
          errors++;
        }
        for (const key1 in data) {
          if (!(key1 === "name" || key1 === "purpose" || key1 === "rule" || key1 === "count" || key1 === "min" || key1 === "max" || key1 === "from_nested")) {
            const err17 = { instancePath, schemaPath: "#/oneOf/1/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key1 }, message: "must NOT have additional properties", schema: false, parentSchema: schema14.oneOf[1], data };
            if (vErrors === null) {
              vErrors = [err17];
            } else {
              vErrors.push(err17);
            }
            errors++;
          }
        }
        if (data.name !== void 0) {
          let data7 = data.name;
          if (typeof data7 !== "string") {
            const err18 = { instancePath: instancePath + "/name", schemaPath: "#/oneOf/1/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema14.oneOf[1].properties.name.type, parentSchema: schema14.oneOf[1].properties.name, data: data7 };
            if (vErrors === null) {
              vErrors = [err18];
            } else {
              vErrors.push(err18);
            }
            errors++;
          }
        }
        if (data.purpose !== void 0) {
          let data8 = data.purpose;
          if (typeof data8 !== "string") {
            const err19 = { instancePath: instancePath + "/purpose", schemaPath: "#/oneOf/1/properties/purpose/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema14.oneOf[1].properties.purpose.type, parentSchema: schema14.oneOf[1].properties.purpose, data: data8 };
            if (vErrors === null) {
              vErrors = [err19];
            } else {
              vErrors.push(err19);
            }
            errors++;
          }
        }
        if (data.rule !== void 0) {
          let data9 = data.rule;
          if (typeof data9 !== "string") {
            const err20 = { instancePath: instancePath + "/rule", schemaPath: "#/oneOf/1/properties/rule/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema14.oneOf[1].properties.rule.type, parentSchema: schema14.oneOf[1].properties.rule, data: data9 };
            if (vErrors === null) {
              vErrors = [err20];
            } else {
              vErrors.push(err20);
            }
            errors++;
          }
          if (!(data9 === "all" || data9 === "pick")) {
            const err21 = { instancePath: instancePath + "/rule", schemaPath: "#/oneOf/1/properties/rule/enum", keyword: "enum", params: { allowedValues: schema14.oneOf[1].properties.rule.enum }, message: "must be equal to one of the allowed values", schema: schema14.oneOf[1].properties.rule.enum, parentSchema: schema14.oneOf[1].properties.rule, data: data9 };
            if (vErrors === null) {
              vErrors = [err21];
            } else {
              vErrors.push(err21);
            }
            errors++;
          }
        }
        if (data.count !== void 0) {
          let data10 = data.count;
          if (!(typeof data10 == "number" && (!(data10 % 1) && !isNaN(data10)))) {
            const err22 = { instancePath: instancePath + "/count", schemaPath: "#/oneOf/1/properties/count/type", keyword: "type", params: { type: "integer" }, message: "must be integer", schema: schema14.oneOf[1].properties.count.type, parentSchema: schema14.oneOf[1].properties.count, data: data10 };
            if (vErrors === null) {
              vErrors = [err22];
            } else {
              vErrors.push(err22);
            }
            errors++;
          }
          if (typeof data10 == "number") {
            if (data10 < 1 || isNaN(data10)) {
              const err23 = { instancePath: instancePath + "/count", schemaPath: "#/oneOf/1/properties/count/minimum", keyword: "minimum", params: { comparison: ">=", limit: 1 }, message: "must be >= 1", schema: 1, parentSchema: schema14.oneOf[1].properties.count, data: data10 };
              if (vErrors === null) {
                vErrors = [err23];
              } else {
                vErrors.push(err23);
              }
              errors++;
            }
          }
        }
        if (data.min !== void 0) {
          let data11 = data.min;
          if (!(typeof data11 == "number" && (!(data11 % 1) && !isNaN(data11)))) {
            const err24 = { instancePath: instancePath + "/min", schemaPath: "#/oneOf/1/properties/min/type", keyword: "type", params: { type: "integer" }, message: "must be integer", schema: schema14.oneOf[1].properties.min.type, parentSchema: schema14.oneOf[1].properties.min, data: data11 };
            if (vErrors === null) {
              vErrors = [err24];
            } else {
              vErrors.push(err24);
            }
            errors++;
          }
          if (typeof data11 == "number") {
            if (data11 < 0 || isNaN(data11)) {
              const err25 = { instancePath: instancePath + "/min", schemaPath: "#/oneOf/1/properties/min/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0", schema: 0, parentSchema: schema14.oneOf[1].properties.min, data: data11 };
              if (vErrors === null) {
                vErrors = [err25];
              } else {
                vErrors.push(err25);
              }
              errors++;
            }
          }
        }
        if (data.max !== void 0) {
          let data12 = data.max;
          if (!(typeof data12 == "number" && (!(data12 % 1) && !isNaN(data12)))) {
            const err26 = { instancePath: instancePath + "/max", schemaPath: "#/oneOf/1/properties/max/type", keyword: "type", params: { type: "integer" }, message: "must be integer", schema: schema14.oneOf[1].properties.max.type, parentSchema: schema14.oneOf[1].properties.max, data: data12 };
            if (vErrors === null) {
              vErrors = [err26];
            } else {
              vErrors.push(err26);
            }
            errors++;
          }
          if (typeof data12 == "number") {
            if (data12 < 0 || isNaN(data12)) {
              const err27 = { instancePath: instancePath + "/max", schemaPath: "#/oneOf/1/properties/max/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0", schema: 0, parentSchema: schema14.oneOf[1].properties.max, data: data12 };
              if (vErrors === null) {
                vErrors = [err27];
              } else {
                vErrors.push(err27);
              }
              errors++;
            }
          }
        }
        if (data.from_nested !== void 0) {
          let data13 = data.from_nested;
          if (Array.isArray(data13)) {
            if (data13.length < 1) {
              const err28 = { instancePath: instancePath + "/from_nested", schemaPath: "#/oneOf/1/properties/from_nested/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items", schema: 1, parentSchema: schema14.oneOf[1].properties.from_nested, data: data13 };
              if (vErrors === null) {
                vErrors = [err28];
              } else {
                vErrors.push(err28);
              }
              errors++;
            }
            const len0 = data13.length;
            for (let i0 = 0; i0 < len0; i0++) {
              if (!wrapper0.validate(data13[i0], { instancePath: instancePath + "/from_nested/" + i0, parentData: data13, parentDataProperty: i0, rootData })) {
                vErrors = vErrors === null ? wrapper0.validate.errors : vErrors.concat(wrapper0.validate.errors);
                errors = vErrors.length;
              }
            }
          } else {
            const err29 = { instancePath: instancePath + "/from_nested", schemaPath: "#/oneOf/1/properties/from_nested/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema14.oneOf[1].properties.from_nested.type, parentSchema: schema14.oneOf[1].properties.from_nested, data: data13 };
            if (vErrors === null) {
              vErrors = [err29];
            } else {
              vErrors.push(err29);
            }
            errors++;
          }
        }
      }
      var _valid0 = _errs18 === errors;
      if (_valid0 && valid0) {
        valid0 = false;
        passing0 = [passing0, 1];
      } else {
        if (_valid0) {
          valid0 = true;
          passing0 = 1;
        }
      }
      if (!valid0) {
        const err30 = { instancePath, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf", schema: schema14.oneOf, parentSchema: schema14, data };
        if (vErrors === null) {
          vErrors = [err30];
        } else {
          vErrors.push(err30);
        }
        errors++;
      } else {
        errors = _errs1;
        if (vErrors !== null) {
          if (_errs1) {
            vErrors.length = _errs1;
          } else {
            vErrors = null;
          }
        }
      }
      validate45.errors = vErrors;
      return errors === 0;
    }
    var schema15 = { "type": "object", "properties": { "id": { "type": "string" }, "name": { "type": "string" }, "purpose": { "type": "string" }, "issuance": { "type": "array", "items": { "$ref": "#/definitions/issuance" } }, "group": { "type": "array", "items": { "type": "string" } }, "format": { "$ref": "#/definitions/format" }, "constraints": { "type": "object", "properties": { "limit_disclosure": { "type": "string", "enum": ["required", "preferred"] }, "statuses": { "type": "object", "properties": { "active": { "type": "object", "properties": { "directive": { "type": "string", "enum": ["required", "allowed", "disallowed"] } } }, "suspended": { "type": "object", "properties": { "directive": { "type": "string", "enum": ["required", "allowed", "disallowed"] } } }, "revoked": { "type": "object", "properties": { "directive": { "type": "string", "enum": ["required", "allowed", "disallowed"] } } } } }, "fields": { "type": "array", "items": { "$ref": "#/definitions/field" } }, "subject_is_issuer": { "type": "string", "enum": ["required", "preferred"] }, "is_holder": { "type": "array", "items": { "type": "object", "properties": { "field_id": { "type": "array", "items": { "type": "string" } }, "directive": { "type": "string", "enum": ["required", "preferred"] } }, "required": ["field_id", "directive"], "additionalProperties": false } }, "same_subject": { "type": "array", "items": { "type": "object", "properties": { "field_id": { "type": "array", "items": { "type": "string" } }, "directive": { "type": "string", "enum": ["required", "preferred"] } }, "required": ["field_id", "directive"], "additionalProperties": false } } }, "additionalProperties": false } }, "required": ["id"], "additionalProperties": false };
    var schema16 = { "type": "object", "properties": { "manifest": { "type": "string" } }, "additionalProperties": true };
    function validate48(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.manifest !== void 0) {
          let data0 = data.manifest;
          if (typeof data0 !== "string") {
            const err0 = { instancePath: instancePath + "/manifest", schemaPath: "#/properties/manifest/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema16.properties.manifest.type, parentSchema: schema16.properties.manifest, data: data0 };
            if (vErrors === null) {
              vErrors = [err0];
            } else {
              vErrors.push(err0);
            }
            errors++;
          }
        }
      } else {
        const err1 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema16.type, parentSchema: schema16, data };
        if (vErrors === null) {
          vErrors = [err1];
        } else {
          vErrors.push(err1);
        }
        errors++;
      }
      validate48.errors = vErrors;
      return errors === 0;
    }
    var schema17 = { "type": "object", "oneOf": [{ "properties": { "id": { "type": "string" }, "path": { "type": "array", "items": { "type": "string" } }, "purpose": { "type": "string" }, "intent_to_retain": { "type": "boolean" }, "filter": { "$ref": "http://json-schema.org/schema#" }, "name": { "type": "string" } }, "required": ["path"], "additionalProperties": false }, { "properties": { "id": { "type": "string" }, "path": { "type": "array", "items": { "type": "string" } }, "purpose": { "type": "string" }, "intent_to_retain": { "type": "boolean" }, "filter": { "$ref": "http://json-schema.org/schema#" }, "predicate": { "type": "string", "enum": ["required", "preferred"] }, "name": { "type": "string" } }, "required": ["path", "filter", "predicate"], "additionalProperties": false }] };
    var schema6 = { "$schema": "http://json-schema.org/draft-07/schema#", "$id": "http://json-schema.org/draft-07/schema#", "title": "Core schema meta-schema", "definitions": { "schemaArray": { "type": "array", "minItems": 1, "items": { "$ref": "#" } }, "nonNegativeInteger": { "type": "integer", "minimum": 0 }, "nonNegativeIntegerDefault0": { "allOf": [{ "$ref": "#/definitions/nonNegativeInteger" }, { "default": 0 }] }, "simpleTypes": { "enum": ["array", "boolean", "integer", "null", "number", "object", "string"] }, "stringArray": { "type": "array", "items": { "type": "string" }, "uniqueItems": true, "default": [] } }, "type": ["object", "boolean"], "properties": { "$id": { "type": "string", "format": "uri-reference" }, "$schema": { "type": "string", "format": "uri" }, "$ref": { "type": "string", "format": "uri-reference" }, "$comment": { "type": "string" }, "title": { "type": "string" }, "description": { "type": "string" }, "default": true, "readOnly": { "type": "boolean", "default": false }, "examples": { "type": "array", "items": true }, "multipleOf": { "type": "number", "exclusiveMinimum": 0 }, "maximum": { "type": "number" }, "exclusiveMaximum": { "type": "number" }, "minimum": { "type": "number" }, "exclusiveMinimum": { "type": "number" }, "maxLength": { "$ref": "#/definitions/nonNegativeInteger" }, "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "pattern": { "type": "string", "format": "regex" }, "additionalItems": { "$ref": "#" }, "items": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/schemaArray" }], "default": true }, "maxItems": { "$ref": "#/definitions/nonNegativeInteger" }, "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "uniqueItems": { "type": "boolean", "default": false }, "contains": { "$ref": "#" }, "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" }, "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "required": { "$ref": "#/definitions/stringArray" }, "additionalProperties": { "$ref": "#" }, "definitions": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "properties": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "patternProperties": { "type": "object", "additionalProperties": { "$ref": "#" }, "propertyNames": { "format": "regex" }, "default": {} }, "dependencies": { "type": "object", "additionalProperties": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/stringArray" }] } }, "propertyNames": { "$ref": "#" }, "const": true, "enum": { "type": "array", "items": true, "minItems": 1, "uniqueItems": true }, "type": { "anyOf": [{ "$ref": "#/definitions/simpleTypes" }, { "type": "array", "items": { "$ref": "#/definitions/simpleTypes" }, "minItems": 1, "uniqueItems": true }] }, "format": { "type": "string" }, "contentMediaType": { "type": "string" }, "contentEncoding": { "type": "string" }, "if": { "$ref": "#" }, "then": { "$ref": "#" }, "else": { "$ref": "#" }, "allOf": { "$ref": "#/definitions/schemaArray" }, "anyOf": { "$ref": "#/definitions/schemaArray" }, "oneOf": { "$ref": "#/definitions/schemaArray" }, "not": { "$ref": "#" } }, "default": true };
    var schema7 = { "type": "integer", "minimum": 0 };
    function validate22(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (!(typeof data == "number" && (!(data % 1) && !isNaN(data)))) {
        const err0 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "integer" }, message: "must be integer", schema: schema7.type, parentSchema: schema7, data };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors++;
      }
      if (typeof data == "number") {
        if (data < 0 || isNaN(data)) {
          const err1 = { instancePath, schemaPath: "#/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0", schema: 0, parentSchema: schema7, data };
          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }
          errors++;
        }
      }
      validate22.errors = vErrors;
      return errors === 0;
    }
    function validate24(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (!validate22(data, { instancePath, parentData, parentDataProperty, rootData })) {
        vErrors = vErrors === null ? validate22.errors : vErrors.concat(validate22.errors);
        errors = vErrors.length;
      }
      validate24.errors = vErrors;
      return errors === 0;
    }
    var schema9 = { "type": "array", "minItems": 1, "items": { "$ref": "#" } };
    var root1 = { validate: validate21 };
    function validate27(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (Array.isArray(data)) {
        if (data.length < 1) {
          const err0 = { instancePath, schemaPath: "#/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items", schema: 1, parentSchema: schema9, data };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors++;
        }
        const len0 = data.length;
        for (let i0 = 0; i0 < len0; i0++) {
          if (!root1.validate(data[i0], { instancePath: instancePath + "/" + i0, parentData: data, parentDataProperty: i0, rootData })) {
            vErrors = vErrors === null ? root1.validate.errors : vErrors.concat(root1.validate.errors);
            errors = vErrors.length;
          }
        }
      } else {
        const err1 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema9.type, parentSchema: schema9, data };
        if (vErrors === null) {
          vErrors = [err1];
        } else {
          vErrors.push(err1);
        }
        errors++;
      }
      validate27.errors = vErrors;
      return errors === 0;
    }
    var schema10 = { "type": "array", "items": { "type": "string" }, "uniqueItems": true, "default": [] };
    function validate33(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (Array.isArray(data)) {
        const len0 = data.length;
        for (let i0 = 0; i0 < len0; i0++) {
          let data0 = data[i0];
          if (typeof data0 !== "string") {
            const err0 = { instancePath: instancePath + "/" + i0, schemaPath: "#/items/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema10.items.type, parentSchema: schema10.items, data: data0 };
            if (vErrors === null) {
              vErrors = [err0];
            } else {
              vErrors.push(err0);
            }
            errors++;
          }
        }
        let i1 = data.length;
        let j0;
        if (i1 > 1) {
          const indices0 = {};
          for (; i1--; ) {
            let item0 = data[i1];
            if (typeof item0 !== "string") {
              continue;
            }
            if (typeof indices0[item0] == "number") {
              j0 = indices0[item0];
              const err1 = { instancePath, schemaPath: "#/uniqueItems", keyword: "uniqueItems", params: { i: i1, j: j0 }, message: "must NOT have duplicate items (items ## " + j0 + " and " + i1 + " are identical)", schema: true, parentSchema: schema10, data };
              if (vErrors === null) {
                vErrors = [err1];
              } else {
                vErrors.push(err1);
              }
              errors++;
              break;
            }
            indices0[item0] = i1;
          }
        }
      } else {
        const err2 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema10.type, parentSchema: schema10, data };
        if (vErrors === null) {
          vErrors = [err2];
        } else {
          vErrors.push(err2);
        }
        errors++;
      }
      validate33.errors = vErrors;
      return errors === 0;
    }
    var schema11 = { "enum": ["array", "boolean", "integer", "null", "number", "object", "string"] };
    function validate36(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (!(data === "array" || data === "boolean" || data === "integer" || data === "null" || data === "number" || data === "object" || data === "string")) {
        const err0 = { instancePath, schemaPath: "#/enum", keyword: "enum", params: { allowedValues: schema11.enum }, message: "must be equal to one of the allowed values", schema: schema11.enum, parentSchema: schema11, data };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors++;
      }
      validate36.errors = vErrors;
      return errors === 0;
    }
    var func0 = require_equal().default;
    function validate21(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      ;
      let vErrors = null;
      let errors = 0;
      if (!(data && typeof data == "object" && !Array.isArray(data)) && typeof data !== "boolean") {
        const err0 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: schema6.type }, message: "must be object,boolean", schema: schema6.type, parentSchema: schema6, data };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors++;
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.$id !== void 0) {
          let data0 = data.$id;
          if (!(typeof data0 === "string")) {
            const err1 = { instancePath: instancePath + "/$id", schemaPath: "#/properties/%24id/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema6.properties.$id.type, parentSchema: schema6.properties.$id, data: data0 };
            if (vErrors === null) {
              vErrors = [err1];
            } else {
              vErrors.push(err1);
            }
            errors++;
          }
        }
        if (data.$schema !== void 0) {
          let data1 = data.$schema;
          if (!(typeof data1 === "string")) {
            const err2 = { instancePath: instancePath + "/$schema", schemaPath: "#/properties/%24schema/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema6.properties.$schema.type, parentSchema: schema6.properties.$schema, data: data1 };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors++;
          }
        }
        if (data.$ref !== void 0) {
          let data2 = data.$ref;
          if (!(typeof data2 === "string")) {
            const err3 = { instancePath: instancePath + "/$ref", schemaPath: "#/properties/%24ref/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema6.properties.$ref.type, parentSchema: schema6.properties.$ref, data: data2 };
            if (vErrors === null) {
              vErrors = [err3];
            } else {
              vErrors.push(err3);
            }
            errors++;
          }
        }
        if (data.$comment !== void 0) {
          let data3 = data.$comment;
          if (typeof data3 !== "string") {
            const err4 = { instancePath: instancePath + "/$comment", schemaPath: "#/properties/%24comment/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema6.properties.$comment.type, parentSchema: schema6.properties.$comment, data: data3 };
            if (vErrors === null) {
              vErrors = [err4];
            } else {
              vErrors.push(err4);
            }
            errors++;
          }
        }
        if (data.title !== void 0) {
          let data4 = data.title;
          if (typeof data4 !== "string") {
            const err5 = { instancePath: instancePath + "/title", schemaPath: "#/properties/title/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema6.properties.title.type, parentSchema: schema6.properties.title, data: data4 };
            if (vErrors === null) {
              vErrors = [err5];
            } else {
              vErrors.push(err5);
            }
            errors++;
          }
        }
        if (data.description !== void 0) {
          let data5 = data.description;
          if (typeof data5 !== "string") {
            const err6 = { instancePath: instancePath + "/description", schemaPath: "#/properties/description/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema6.properties.description.type, parentSchema: schema6.properties.description, data: data5 };
            if (vErrors === null) {
              vErrors = [err6];
            } else {
              vErrors.push(err6);
            }
            errors++;
          }
        }
        if (data.readOnly !== void 0) {
          let data6 = data.readOnly;
          if (typeof data6 !== "boolean") {
            const err7 = { instancePath: instancePath + "/readOnly", schemaPath: "#/properties/readOnly/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean", schema: schema6.properties.readOnly.type, parentSchema: schema6.properties.readOnly, data: data6 };
            if (vErrors === null) {
              vErrors = [err7];
            } else {
              vErrors.push(err7);
            }
            errors++;
          }
        }
        if (data.examples !== void 0) {
          let data7 = data.examples;
          if (!Array.isArray(data7)) {
            const err8 = { instancePath: instancePath + "/examples", schemaPath: "#/properties/examples/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema6.properties.examples.type, parentSchema: schema6.properties.examples, data: data7 };
            if (vErrors === null) {
              vErrors = [err8];
            } else {
              vErrors.push(err8);
            }
            errors++;
          }
        }
        if (data.multipleOf !== void 0) {
          let data8 = data.multipleOf;
          if (typeof data8 == "number") {
            if (data8 <= 0 || isNaN(data8)) {
              const err9 = { instancePath: instancePath + "/multipleOf", schemaPath: "#/properties/multipleOf/exclusiveMinimum", keyword: "exclusiveMinimum", params: { comparison: ">", limit: 0 }, message: "must be > 0", schema: 0, parentSchema: schema6.properties.multipleOf, data: data8 };
              if (vErrors === null) {
                vErrors = [err9];
              } else {
                vErrors.push(err9);
              }
              errors++;
            }
          } else {
            const err10 = { instancePath: instancePath + "/multipleOf", schemaPath: "#/properties/multipleOf/type", keyword: "type", params: { type: "number" }, message: "must be number", schema: schema6.properties.multipleOf.type, parentSchema: schema6.properties.multipleOf, data: data8 };
            if (vErrors === null) {
              vErrors = [err10];
            } else {
              vErrors.push(err10);
            }
            errors++;
          }
        }
        if (data.maximum !== void 0) {
          let data9 = data.maximum;
          if (!(typeof data9 == "number")) {
            const err11 = { instancePath: instancePath + "/maximum", schemaPath: "#/properties/maximum/type", keyword: "type", params: { type: "number" }, message: "must be number", schema: schema6.properties.maximum.type, parentSchema: schema6.properties.maximum, data: data9 };
            if (vErrors === null) {
              vErrors = [err11];
            } else {
              vErrors.push(err11);
            }
            errors++;
          }
        }
        if (data.exclusiveMaximum !== void 0) {
          let data10 = data.exclusiveMaximum;
          if (!(typeof data10 == "number")) {
            const err12 = { instancePath: instancePath + "/exclusiveMaximum", schemaPath: "#/properties/exclusiveMaximum/type", keyword: "type", params: { type: "number" }, message: "must be number", schema: schema6.properties.exclusiveMaximum.type, parentSchema: schema6.properties.exclusiveMaximum, data: data10 };
            if (vErrors === null) {
              vErrors = [err12];
            } else {
              vErrors.push(err12);
            }
            errors++;
          }
        }
        if (data.minimum !== void 0) {
          let data11 = data.minimum;
          if (!(typeof data11 == "number")) {
            const err13 = { instancePath: instancePath + "/minimum", schemaPath: "#/properties/minimum/type", keyword: "type", params: { type: "number" }, message: "must be number", schema: schema6.properties.minimum.type, parentSchema: schema6.properties.minimum, data: data11 };
            if (vErrors === null) {
              vErrors = [err13];
            } else {
              vErrors.push(err13);
            }
            errors++;
          }
        }
        if (data.exclusiveMinimum !== void 0) {
          let data12 = data.exclusiveMinimum;
          if (!(typeof data12 == "number")) {
            const err14 = { instancePath: instancePath + "/exclusiveMinimum", schemaPath: "#/properties/exclusiveMinimum/type", keyword: "type", params: { type: "number" }, message: "must be number", schema: schema6.properties.exclusiveMinimum.type, parentSchema: schema6.properties.exclusiveMinimum, data: data12 };
            if (vErrors === null) {
              vErrors = [err14];
            } else {
              vErrors.push(err14);
            }
            errors++;
          }
        }
        if (data.maxLength !== void 0) {
          if (!validate22(data.maxLength, { instancePath: instancePath + "/maxLength", parentData: data, parentDataProperty: "maxLength", rootData })) {
            vErrors = vErrors === null ? validate22.errors : vErrors.concat(validate22.errors);
            errors = vErrors.length;
          }
        }
        if (data.minLength !== void 0) {
          if (!validate24(data.minLength, { instancePath: instancePath + "/minLength", parentData: data, parentDataProperty: "minLength", rootData })) {
            vErrors = vErrors === null ? validate24.errors : vErrors.concat(validate24.errors);
            errors = vErrors.length;
          }
        }
        if (data.pattern !== void 0) {
          let data15 = data.pattern;
          if (!(typeof data15 === "string")) {
            const err15 = { instancePath: instancePath + "/pattern", schemaPath: "#/properties/pattern/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema6.properties.pattern.type, parentSchema: schema6.properties.pattern, data: data15 };
            if (vErrors === null) {
              vErrors = [err15];
            } else {
              vErrors.push(err15);
            }
            errors++;
          }
        }
        if (data.additionalItems !== void 0) {
          if (!validate21(data.additionalItems, { instancePath: instancePath + "/additionalItems", parentData: data, parentDataProperty: "additionalItems", rootData })) {
            vErrors = vErrors === null ? validate21.errors : vErrors.concat(validate21.errors);
            errors = vErrors.length;
          }
        }
        if (data.items !== void 0) {
          let data17 = data.items;
          const _errs33 = errors;
          let valid1 = false;
          const _errs34 = errors;
          if (!validate21(data17, { instancePath: instancePath + "/items", parentData: data, parentDataProperty: "items", rootData })) {
            vErrors = vErrors === null ? validate21.errors : vErrors.concat(validate21.errors);
            errors = vErrors.length;
          }
          var _valid0 = _errs34 === errors;
          valid1 = valid1 || _valid0;
          if (!valid1) {
            const _errs35 = errors;
            if (!validate27(data17, { instancePath: instancePath + "/items", parentData: data, parentDataProperty: "items", rootData })) {
              vErrors = vErrors === null ? validate27.errors : vErrors.concat(validate27.errors);
              errors = vErrors.length;
            }
            var _valid0 = _errs35 === errors;
            valid1 = valid1 || _valid0;
          }
          if (!valid1) {
            const err16 = { instancePath: instancePath + "/items", schemaPath: "#/properties/items/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf", schema: schema6.properties.items.anyOf, parentSchema: schema6.properties.items, data: data17 };
            if (vErrors === null) {
              vErrors = [err16];
            } else {
              vErrors.push(err16);
            }
            errors++;
          } else {
            errors = _errs33;
            if (vErrors !== null) {
              if (_errs33) {
                vErrors.length = _errs33;
              } else {
                vErrors = null;
              }
            }
          }
        }
        if (data.maxItems !== void 0) {
          if (!validate22(data.maxItems, { instancePath: instancePath + "/maxItems", parentData: data, parentDataProperty: "maxItems", rootData })) {
            vErrors = vErrors === null ? validate22.errors : vErrors.concat(validate22.errors);
            errors = vErrors.length;
          }
        }
        if (data.minItems !== void 0) {
          if (!validate24(data.minItems, { instancePath: instancePath + "/minItems", parentData: data, parentDataProperty: "minItems", rootData })) {
            vErrors = vErrors === null ? validate24.errors : vErrors.concat(validate24.errors);
            errors = vErrors.length;
          }
        }
        if (data.uniqueItems !== void 0) {
          let data20 = data.uniqueItems;
          if (typeof data20 !== "boolean") {
            const err17 = { instancePath: instancePath + "/uniqueItems", schemaPath: "#/properties/uniqueItems/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean", schema: schema6.properties.uniqueItems.type, parentSchema: schema6.properties.uniqueItems, data: data20 };
            if (vErrors === null) {
              vErrors = [err17];
            } else {
              vErrors.push(err17);
            }
            errors++;
          }
        }
        if (data.contains !== void 0) {
          if (!validate21(data.contains, { instancePath: instancePath + "/contains", parentData: data, parentDataProperty: "contains", rootData })) {
            vErrors = vErrors === null ? validate21.errors : vErrors.concat(validate21.errors);
            errors = vErrors.length;
          }
        }
        if (data.maxProperties !== void 0) {
          if (!validate22(data.maxProperties, { instancePath: instancePath + "/maxProperties", parentData: data, parentDataProperty: "maxProperties", rootData })) {
            vErrors = vErrors === null ? validate22.errors : vErrors.concat(validate22.errors);
            errors = vErrors.length;
          }
        }
        if (data.minProperties !== void 0) {
          if (!validate24(data.minProperties, { instancePath: instancePath + "/minProperties", parentData: data, parentDataProperty: "minProperties", rootData })) {
            vErrors = vErrors === null ? validate24.errors : vErrors.concat(validate24.errors);
            errors = vErrors.length;
          }
        }
        if (data.required !== void 0) {
          if (!validate33(data.required, { instancePath: instancePath + "/required", parentData: data, parentDataProperty: "required", rootData })) {
            vErrors = vErrors === null ? validate33.errors : vErrors.concat(validate33.errors);
            errors = vErrors.length;
          }
        }
        if (data.additionalProperties !== void 0) {
          if (!validate21(data.additionalProperties, { instancePath: instancePath + "/additionalProperties", parentData: data, parentDataProperty: "additionalProperties", rootData })) {
            vErrors = vErrors === null ? validate21.errors : vErrors.concat(validate21.errors);
            errors = vErrors.length;
          }
        }
        if (data.definitions !== void 0) {
          let data26 = data.definitions;
          if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
            for (const key0 in data26) {
              if (!validate21(data26[key0], { instancePath: instancePath + "/definitions/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data26, parentDataProperty: key0, rootData })) {
                vErrors = vErrors === null ? validate21.errors : vErrors.concat(validate21.errors);
                errors = vErrors.length;
              }
            }
          } else {
            const err18 = { instancePath: instancePath + "/definitions", schemaPath: "#/properties/definitions/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema6.properties.definitions.type, parentSchema: schema6.properties.definitions, data: data26 };
            if (vErrors === null) {
              vErrors = [err18];
            } else {
              vErrors.push(err18);
            }
            errors++;
          }
        }
        if (data.properties !== void 0) {
          let data28 = data.properties;
          if (data28 && typeof data28 == "object" && !Array.isArray(data28)) {
            for (const key1 in data28) {
              if (!validate21(data28[key1], { instancePath: instancePath + "/properties/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data28, parentDataProperty: key1, rootData })) {
                vErrors = vErrors === null ? validate21.errors : vErrors.concat(validate21.errors);
                errors = vErrors.length;
              }
            }
          } else {
            const err19 = { instancePath: instancePath + "/properties", schemaPath: "#/properties/properties/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema6.properties.properties.type, parentSchema: schema6.properties.properties, data: data28 };
            if (vErrors === null) {
              vErrors = [err19];
            } else {
              vErrors.push(err19);
            }
            errors++;
          }
        }
        if (data.patternProperties !== void 0) {
          let data30 = data.patternProperties;
          if (data30 && typeof data30 == "object" && !Array.isArray(data30)) {
            for (const key2 in data30) {
              const _errs55 = errors;
              var valid4 = _errs55 === errors;
              if (!valid4) {
                const err20 = { instancePath: instancePath + "/patternProperties", schemaPath: "#/properties/patternProperties/propertyNames", keyword: "propertyNames", params: { propertyName: key2 }, message: "property name must be valid", schema: schema6.properties.patternProperties.propertyNames, parentSchema: schema6.properties.patternProperties, data: data30 };
                if (vErrors === null) {
                  vErrors = [err20];
                } else {
                  vErrors.push(err20);
                }
                errors++;
              }
            }
            for (const key3 in data30) {
              if (!validate21(data30[key3], { instancePath: instancePath + "/patternProperties/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data30, parentDataProperty: key3, rootData })) {
                vErrors = vErrors === null ? validate21.errors : vErrors.concat(validate21.errors);
                errors = vErrors.length;
              }
            }
          } else {
            const err21 = { instancePath: instancePath + "/patternProperties", schemaPath: "#/properties/patternProperties/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema6.properties.patternProperties.type, parentSchema: schema6.properties.patternProperties, data: data30 };
            if (vErrors === null) {
              vErrors = [err21];
            } else {
              vErrors.push(err21);
            }
            errors++;
          }
        }
        if (data.dependencies !== void 0) {
          let data32 = data.dependencies;
          if (data32 && typeof data32 == "object" && !Array.isArray(data32)) {
            for (const key4 in data32) {
              let data33 = data32[key4];
              const _errs62 = errors;
              let valid7 = false;
              const _errs63 = errors;
              if (!validate21(data33, { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data32, parentDataProperty: key4, rootData })) {
                vErrors = vErrors === null ? validate21.errors : vErrors.concat(validate21.errors);
                errors = vErrors.length;
              }
              var _valid1 = _errs63 === errors;
              valid7 = valid7 || _valid1;
              if (!valid7) {
                const _errs64 = errors;
                if (!validate33(data33, { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data32, parentDataProperty: key4, rootData })) {
                  vErrors = vErrors === null ? validate33.errors : vErrors.concat(validate33.errors);
                  errors = vErrors.length;
                }
                var _valid1 = _errs64 === errors;
                valid7 = valid7 || _valid1;
              }
              if (!valid7) {
                const err22 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/dependencies/additionalProperties/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf", schema: schema6.properties.dependencies.additionalProperties.anyOf, parentSchema: schema6.properties.dependencies.additionalProperties, data: data33 };
                if (vErrors === null) {
                  vErrors = [err22];
                } else {
                  vErrors.push(err22);
                }
                errors++;
              } else {
                errors = _errs62;
                if (vErrors !== null) {
                  if (_errs62) {
                    vErrors.length = _errs62;
                  } else {
                    vErrors = null;
                  }
                }
              }
            }
          } else {
            const err23 = { instancePath: instancePath + "/dependencies", schemaPath: "#/properties/dependencies/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema6.properties.dependencies.type, parentSchema: schema6.properties.dependencies, data: data32 };
            if (vErrors === null) {
              vErrors = [err23];
            } else {
              vErrors.push(err23);
            }
            errors++;
          }
        }
        if (data.propertyNames !== void 0) {
          if (!validate21(data.propertyNames, { instancePath: instancePath + "/propertyNames", parentData: data, parentDataProperty: "propertyNames", rootData })) {
            vErrors = vErrors === null ? validate21.errors : vErrors.concat(validate21.errors);
            errors = vErrors.length;
          }
        }
        if (data.enum !== void 0) {
          let data35 = data.enum;
          if (Array.isArray(data35)) {
            if (data35.length < 1) {
              const err24 = { instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items", schema: 1, parentSchema: schema6.properties.enum, data: data35 };
              if (vErrors === null) {
                vErrors = [err24];
              } else {
                vErrors.push(err24);
              }
              errors++;
            }
            let i0 = data35.length;
            let j0;
            if (i0 > 1) {
              outer0:
                for (; i0--; ) {
                  for (j0 = i0; j0--; ) {
                    if (func0(data35[i0], data35[j0])) {
                      const err25 = { instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/uniqueItems", keyword: "uniqueItems", params: { i: i0, j: j0 }, message: "must NOT have duplicate items (items ## " + j0 + " and " + i0 + " are identical)", schema: true, parentSchema: schema6.properties.enum, data: data35 };
                      if (vErrors === null) {
                        vErrors = [err25];
                      } else {
                        vErrors.push(err25);
                      }
                      errors++;
                      break outer0;
                    }
                  }
                }
            }
          } else {
            const err26 = { instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema6.properties.enum.type, parentSchema: schema6.properties.enum, data: data35 };
            if (vErrors === null) {
              vErrors = [err26];
            } else {
              vErrors.push(err26);
            }
            errors++;
          }
        }
        if (data.type !== void 0) {
          let data36 = data.type;
          const _errs69 = errors;
          let valid9 = false;
          const _errs70 = errors;
          if (!validate36(data36, { instancePath: instancePath + "/type", parentData: data, parentDataProperty: "type", rootData })) {
            vErrors = vErrors === null ? validate36.errors : vErrors.concat(validate36.errors);
            errors = vErrors.length;
          }
          var _valid2 = _errs70 === errors;
          valid9 = valid9 || _valid2;
          if (!valid9) {
            const _errs71 = errors;
            if (Array.isArray(data36)) {
              if (data36.length < 1) {
                const err27 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf/1/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items", schema: 1, parentSchema: schema6.properties.type.anyOf[1], data: data36 };
                if (vErrors === null) {
                  vErrors = [err27];
                } else {
                  vErrors.push(err27);
                }
                errors++;
              }
              const len0 = data36.length;
              for (let i1 = 0; i1 < len0; i1++) {
                if (!validate36(data36[i1], { instancePath: instancePath + "/type/" + i1, parentData: data36, parentDataProperty: i1, rootData })) {
                  vErrors = vErrors === null ? validate36.errors : vErrors.concat(validate36.errors);
                  errors = vErrors.length;
                }
              }
              let i2 = data36.length;
              let j1;
              if (i2 > 1) {
                outer1:
                  for (; i2--; ) {
                    for (j1 = i2; j1--; ) {
                      if (func0(data36[i2], data36[j1])) {
                        const err28 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf/1/uniqueItems", keyword: "uniqueItems", params: { i: i2, j: j1 }, message: "must NOT have duplicate items (items ## " + j1 + " and " + i2 + " are identical)", schema: true, parentSchema: schema6.properties.type.anyOf[1], data: data36 };
                        if (vErrors === null) {
                          vErrors = [err28];
                        } else {
                          vErrors.push(err28);
                        }
                        errors++;
                        break outer1;
                      }
                    }
                  }
              }
            } else {
              const err29 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf/1/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema6.properties.type.anyOf[1].type, parentSchema: schema6.properties.type.anyOf[1], data: data36 };
              if (vErrors === null) {
                vErrors = [err29];
              } else {
                vErrors.push(err29);
              }
              errors++;
            }
            var _valid2 = _errs71 === errors;
            valid9 = valid9 || _valid2;
          }
          if (!valid9) {
            const err30 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf", schema: schema6.properties.type.anyOf, parentSchema: schema6.properties.type, data: data36 };
            if (vErrors === null) {
              vErrors = [err30];
            } else {
              vErrors.push(err30);
            }
            errors++;
          } else {
            errors = _errs69;
            if (vErrors !== null) {
              if (_errs69) {
                vErrors.length = _errs69;
              } else {
                vErrors = null;
              }
            }
          }
        }
        if (data.format !== void 0) {
          let data38 = data.format;
          if (typeof data38 !== "string") {
            const err31 = { instancePath: instancePath + "/format", schemaPath: "#/properties/format/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema6.properties.format.type, parentSchema: schema6.properties.format, data: data38 };
            if (vErrors === null) {
              vErrors = [err31];
            } else {
              vErrors.push(err31);
            }
            errors++;
          }
        }
        if (data.contentMediaType !== void 0) {
          let data39 = data.contentMediaType;
          if (typeof data39 !== "string") {
            const err32 = { instancePath: instancePath + "/contentMediaType", schemaPath: "#/properties/contentMediaType/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema6.properties.contentMediaType.type, parentSchema: schema6.properties.contentMediaType, data: data39 };
            if (vErrors === null) {
              vErrors = [err32];
            } else {
              vErrors.push(err32);
            }
            errors++;
          }
        }
        if (data.contentEncoding !== void 0) {
          let data40 = data.contentEncoding;
          if (typeof data40 !== "string") {
            const err33 = { instancePath: instancePath + "/contentEncoding", schemaPath: "#/properties/contentEncoding/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema6.properties.contentEncoding.type, parentSchema: schema6.properties.contentEncoding, data: data40 };
            if (vErrors === null) {
              vErrors = [err33];
            } else {
              vErrors.push(err33);
            }
            errors++;
          }
        }
        if (data.if !== void 0) {
          if (!validate21(data.if, { instancePath: instancePath + "/if", parentData: data, parentDataProperty: "if", rootData })) {
            vErrors = vErrors === null ? validate21.errors : vErrors.concat(validate21.errors);
            errors = vErrors.length;
          }
        }
        if (data.then !== void 0) {
          if (!validate21(data.then, { instancePath: instancePath + "/then", parentData: data, parentDataProperty: "then", rootData })) {
            vErrors = vErrors === null ? validate21.errors : vErrors.concat(validate21.errors);
            errors = vErrors.length;
          }
        }
        if (data.else !== void 0) {
          if (!validate21(data.else, { instancePath: instancePath + "/else", parentData: data, parentDataProperty: "else", rootData })) {
            vErrors = vErrors === null ? validate21.errors : vErrors.concat(validate21.errors);
            errors = vErrors.length;
          }
        }
        if (data.allOf !== void 0) {
          if (!validate27(data.allOf, { instancePath: instancePath + "/allOf", parentData: data, parentDataProperty: "allOf", rootData })) {
            vErrors = vErrors === null ? validate27.errors : vErrors.concat(validate27.errors);
            errors = vErrors.length;
          }
        }
        if (data.anyOf !== void 0) {
          if (!validate27(data.anyOf, { instancePath: instancePath + "/anyOf", parentData: data, parentDataProperty: "anyOf", rootData })) {
            vErrors = vErrors === null ? validate27.errors : vErrors.concat(validate27.errors);
            errors = vErrors.length;
          }
        }
        if (data.oneOf !== void 0) {
          if (!validate27(data.oneOf, { instancePath: instancePath + "/oneOf", parentData: data, parentDataProperty: "oneOf", rootData })) {
            vErrors = vErrors === null ? validate27.errors : vErrors.concat(validate27.errors);
            errors = vErrors.length;
          }
        }
        if (data.not !== void 0) {
          if (!validate21(data.not, { instancePath: instancePath + "/not", parentData: data, parentDataProperty: "not", rootData })) {
            vErrors = vErrors === null ? validate21.errors : vErrors.concat(validate21.errors);
            errors = vErrors.length;
          }
        }
      }
      validate21.errors = vErrors;
      return errors === 0;
    }
    function validate51(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (!(data && typeof data == "object" && !Array.isArray(data))) {
        const err0 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema17.type, parentSchema: schema17, data };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors++;
      }
      const _errs1 = errors;
      let valid0 = false;
      let passing0 = null;
      const _errs2 = errors;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.path === void 0) {
          const err1 = { instancePath, schemaPath: "#/oneOf/0/required", keyword: "required", params: { missingProperty: "path" }, message: "must have required property 'path'", schema: schema17.oneOf[0].required, parentSchema: schema17.oneOf[0], data };
          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }
          errors++;
        }
        for (const key0 in data) {
          if (!(key0 === "id" || key0 === "path" || key0 === "purpose" || key0 === "intent_to_retain" || key0 === "filter" || key0 === "name")) {
            const err2 = { instancePath, schemaPath: "#/oneOf/0/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties", schema: false, parentSchema: schema17.oneOf[0], data };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors++;
          }
        }
        if (data.id !== void 0) {
          let data0 = data.id;
          if (typeof data0 !== "string") {
            const err3 = { instancePath: instancePath + "/id", schemaPath: "#/oneOf/0/properties/id/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema17.oneOf[0].properties.id.type, parentSchema: schema17.oneOf[0].properties.id, data: data0 };
            if (vErrors === null) {
              vErrors = [err3];
            } else {
              vErrors.push(err3);
            }
            errors++;
          }
        }
        if (data.path !== void 0) {
          let data1 = data.path;
          if (Array.isArray(data1)) {
            const len0 = data1.length;
            for (let i0 = 0; i0 < len0; i0++) {
              let data2 = data1[i0];
              if (typeof data2 !== "string") {
                const err4 = { instancePath: instancePath + "/path/" + i0, schemaPath: "#/oneOf/0/properties/path/items/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema17.oneOf[0].properties.path.items.type, parentSchema: schema17.oneOf[0].properties.path.items, data: data2 };
                if (vErrors === null) {
                  vErrors = [err4];
                } else {
                  vErrors.push(err4);
                }
                errors++;
              }
            }
          } else {
            const err5 = { instancePath: instancePath + "/path", schemaPath: "#/oneOf/0/properties/path/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema17.oneOf[0].properties.path.type, parentSchema: schema17.oneOf[0].properties.path, data: data1 };
            if (vErrors === null) {
              vErrors = [err5];
            } else {
              vErrors.push(err5);
            }
            errors++;
          }
        }
        if (data.purpose !== void 0) {
          let data3 = data.purpose;
          if (typeof data3 !== "string") {
            const err6 = { instancePath: instancePath + "/purpose", schemaPath: "#/oneOf/0/properties/purpose/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema17.oneOf[0].properties.purpose.type, parentSchema: schema17.oneOf[0].properties.purpose, data: data3 };
            if (vErrors === null) {
              vErrors = [err6];
            } else {
              vErrors.push(err6);
            }
            errors++;
          }
        }
        if (data.intent_to_retain !== void 0) {
          let data4 = data.intent_to_retain;
          if (typeof data4 !== "boolean") {
            const err7 = { instancePath: instancePath + "/intent_to_retain", schemaPath: "#/oneOf/0/properties/intent_to_retain/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean", schema: schema17.oneOf[0].properties.intent_to_retain.type, parentSchema: schema17.oneOf[0].properties.intent_to_retain, data: data4 };
            if (vErrors === null) {
              vErrors = [err7];
            } else {
              vErrors.push(err7);
            }
            errors++;
          }
        }
        if (data.filter !== void 0) {
          if (!validate21(data.filter, { instancePath: instancePath + "/filter", parentData: data, parentDataProperty: "filter", rootData })) {
            vErrors = vErrors === null ? validate21.errors : vErrors.concat(validate21.errors);
            errors = vErrors.length;
          }
        }
        if (data.name !== void 0) {
          let data6 = data.name;
          if (typeof data6 !== "string") {
            const err8 = { instancePath: instancePath + "/name", schemaPath: "#/oneOf/0/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema17.oneOf[0].properties.name.type, parentSchema: schema17.oneOf[0].properties.name, data: data6 };
            if (vErrors === null) {
              vErrors = [err8];
            } else {
              vErrors.push(err8);
            }
            errors++;
          }
        }
      }
      var _valid0 = _errs2 === errors;
      if (_valid0) {
        valid0 = true;
        passing0 = 0;
      }
      const _errs17 = errors;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.path === void 0) {
          const err9 = { instancePath, schemaPath: "#/oneOf/1/required", keyword: "required", params: { missingProperty: "path" }, message: "must have required property 'path'", schema: schema17.oneOf[1].required, parentSchema: schema17.oneOf[1], data };
          if (vErrors === null) {
            vErrors = [err9];
          } else {
            vErrors.push(err9);
          }
          errors++;
        }
        if (data.filter === void 0) {
          const err10 = { instancePath, schemaPath: "#/oneOf/1/required", keyword: "required", params: { missingProperty: "filter" }, message: "must have required property 'filter'", schema: schema17.oneOf[1].required, parentSchema: schema17.oneOf[1], data };
          if (vErrors === null) {
            vErrors = [err10];
          } else {
            vErrors.push(err10);
          }
          errors++;
        }
        if (data.predicate === void 0) {
          const err11 = { instancePath, schemaPath: "#/oneOf/1/required", keyword: "required", params: { missingProperty: "predicate" }, message: "must have required property 'predicate'", schema: schema17.oneOf[1].required, parentSchema: schema17.oneOf[1], data };
          if (vErrors === null) {
            vErrors = [err11];
          } else {
            vErrors.push(err11);
          }
          errors++;
        }
        for (const key1 in data) {
          if (!(key1 === "id" || key1 === "path" || key1 === "purpose" || key1 === "intent_to_retain" || key1 === "filter" || key1 === "predicate" || key1 === "name")) {
            const err12 = { instancePath, schemaPath: "#/oneOf/1/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key1 }, message: "must NOT have additional properties", schema: false, parentSchema: schema17.oneOf[1], data };
            if (vErrors === null) {
              vErrors = [err12];
            } else {
              vErrors.push(err12);
            }
            errors++;
          }
        }
        if (data.id !== void 0) {
          let data7 = data.id;
          if (typeof data7 !== "string") {
            const err13 = { instancePath: instancePath + "/id", schemaPath: "#/oneOf/1/properties/id/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema17.oneOf[1].properties.id.type, parentSchema: schema17.oneOf[1].properties.id, data: data7 };
            if (vErrors === null) {
              vErrors = [err13];
            } else {
              vErrors.push(err13);
            }
            errors++;
          }
        }
        if (data.path !== void 0) {
          let data8 = data.path;
          if (Array.isArray(data8)) {
            const len1 = data8.length;
            for (let i1 = 0; i1 < len1; i1++) {
              let data9 = data8[i1];
              if (typeof data9 !== "string") {
                const err14 = { instancePath: instancePath + "/path/" + i1, schemaPath: "#/oneOf/1/properties/path/items/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema17.oneOf[1].properties.path.items.type, parentSchema: schema17.oneOf[1].properties.path.items, data: data9 };
                if (vErrors === null) {
                  vErrors = [err14];
                } else {
                  vErrors.push(err14);
                }
                errors++;
              }
            }
          } else {
            const err15 = { instancePath: instancePath + "/path", schemaPath: "#/oneOf/1/properties/path/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema17.oneOf[1].properties.path.type, parentSchema: schema17.oneOf[1].properties.path, data: data8 };
            if (vErrors === null) {
              vErrors = [err15];
            } else {
              vErrors.push(err15);
            }
            errors++;
          }
        }
        if (data.purpose !== void 0) {
          let data10 = data.purpose;
          if (typeof data10 !== "string") {
            const err16 = { instancePath: instancePath + "/purpose", schemaPath: "#/oneOf/1/properties/purpose/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema17.oneOf[1].properties.purpose.type, parentSchema: schema17.oneOf[1].properties.purpose, data: data10 };
            if (vErrors === null) {
              vErrors = [err16];
            } else {
              vErrors.push(err16);
            }
            errors++;
          }
        }
        if (data.intent_to_retain !== void 0) {
          let data11 = data.intent_to_retain;
          if (typeof data11 !== "boolean") {
            const err17 = { instancePath: instancePath + "/intent_to_retain", schemaPath: "#/oneOf/1/properties/intent_to_retain/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean", schema: schema17.oneOf[1].properties.intent_to_retain.type, parentSchema: schema17.oneOf[1].properties.intent_to_retain, data: data11 };
            if (vErrors === null) {
              vErrors = [err17];
            } else {
              vErrors.push(err17);
            }
            errors++;
          }
        }
        if (data.filter !== void 0) {
          if (!validate21(data.filter, { instancePath: instancePath + "/filter", parentData: data, parentDataProperty: "filter", rootData })) {
            vErrors = vErrors === null ? validate21.errors : vErrors.concat(validate21.errors);
            errors = vErrors.length;
          }
        }
        if (data.predicate !== void 0) {
          let data13 = data.predicate;
          if (typeof data13 !== "string") {
            const err18 = { instancePath: instancePath + "/predicate", schemaPath: "#/oneOf/1/properties/predicate/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema17.oneOf[1].properties.predicate.type, parentSchema: schema17.oneOf[1].properties.predicate, data: data13 };
            if (vErrors === null) {
              vErrors = [err18];
            } else {
              vErrors.push(err18);
            }
            errors++;
          }
          if (!(data13 === "required" || data13 === "preferred")) {
            const err19 = { instancePath: instancePath + "/predicate", schemaPath: "#/oneOf/1/properties/predicate/enum", keyword: "enum", params: { allowedValues: schema17.oneOf[1].properties.predicate.enum }, message: "must be equal to one of the allowed values", schema: schema17.oneOf[1].properties.predicate.enum, parentSchema: schema17.oneOf[1].properties.predicate, data: data13 };
            if (vErrors === null) {
              vErrors = [err19];
            } else {
              vErrors.push(err19);
            }
            errors++;
          }
        }
        if (data.name !== void 0) {
          let data14 = data.name;
          if (typeof data14 !== "string") {
            const err20 = { instancePath: instancePath + "/name", schemaPath: "#/oneOf/1/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema17.oneOf[1].properties.name.type, parentSchema: schema17.oneOf[1].properties.name, data: data14 };
            if (vErrors === null) {
              vErrors = [err20];
            } else {
              vErrors.push(err20);
            }
            errors++;
          }
        }
      }
      var _valid0 = _errs17 === errors;
      if (_valid0 && valid0) {
        valid0 = false;
        passing0 = [passing0, 1];
      } else {
        if (_valid0) {
          valid0 = true;
          passing0 = 1;
        }
      }
      if (!valid0) {
        const err21 = { instancePath, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf", schema: schema17.oneOf, parentSchema: schema17, data };
        if (vErrors === null) {
          vErrors = [err21];
        } else {
          vErrors.push(err21);
        }
        errors++;
      } else {
        errors = _errs1;
        if (vErrors !== null) {
          if (_errs1) {
            vErrors.length = _errs1;
          } else {
            vErrors = null;
          }
        }
      }
      validate51.errors = vErrors;
      return errors === 0;
    }
    function validate47(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.id === void 0) {
          const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "id" }, message: "must have required property 'id'", schema: schema15.required, parentSchema: schema15, data };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors++;
        }
        for (const key0 in data) {
          if (!(key0 === "id" || key0 === "name" || key0 === "purpose" || key0 === "issuance" || key0 === "group" || key0 === "format" || key0 === "constraints")) {
            const err1 = { instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties", schema: false, parentSchema: schema15, data };
            if (vErrors === null) {
              vErrors = [err1];
            } else {
              vErrors.push(err1);
            }
            errors++;
          }
        }
        if (data.id !== void 0) {
          let data0 = data.id;
          if (typeof data0 !== "string") {
            const err2 = { instancePath: instancePath + "/id", schemaPath: "#/properties/id/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema15.properties.id.type, parentSchema: schema15.properties.id, data: data0 };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors++;
          }
        }
        if (data.name !== void 0) {
          let data1 = data.name;
          if (typeof data1 !== "string") {
            const err3 = { instancePath: instancePath + "/name", schemaPath: "#/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema15.properties.name.type, parentSchema: schema15.properties.name, data: data1 };
            if (vErrors === null) {
              vErrors = [err3];
            } else {
              vErrors.push(err3);
            }
            errors++;
          }
        }
        if (data.purpose !== void 0) {
          let data2 = data.purpose;
          if (typeof data2 !== "string") {
            const err4 = { instancePath: instancePath + "/purpose", schemaPath: "#/properties/purpose/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema15.properties.purpose.type, parentSchema: schema15.properties.purpose, data: data2 };
            if (vErrors === null) {
              vErrors = [err4];
            } else {
              vErrors.push(err4);
            }
            errors++;
          }
        }
        if (data.issuance !== void 0) {
          let data3 = data.issuance;
          if (Array.isArray(data3)) {
            const len0 = data3.length;
            for (let i0 = 0; i0 < len0; i0++) {
              if (!validate48(data3[i0], { instancePath: instancePath + "/issuance/" + i0, parentData: data3, parentDataProperty: i0, rootData })) {
                vErrors = vErrors === null ? validate48.errors : vErrors.concat(validate48.errors);
                errors = vErrors.length;
              }
            }
          } else {
            const err5 = { instancePath: instancePath + "/issuance", schemaPath: "#/properties/issuance/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema15.properties.issuance.type, parentSchema: schema15.properties.issuance, data: data3 };
            if (vErrors === null) {
              vErrors = [err5];
            } else {
              vErrors.push(err5);
            }
            errors++;
          }
        }
        if (data.group !== void 0) {
          let data5 = data.group;
          if (Array.isArray(data5)) {
            const len1 = data5.length;
            for (let i1 = 0; i1 < len1; i1++) {
              let data6 = data5[i1];
              if (typeof data6 !== "string") {
                const err6 = { instancePath: instancePath + "/group/" + i1, schemaPath: "#/properties/group/items/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema15.properties.group.items.type, parentSchema: schema15.properties.group.items, data: data6 };
                if (vErrors === null) {
                  vErrors = [err6];
                } else {
                  vErrors.push(err6);
                }
                errors++;
              }
            }
          } else {
            const err7 = { instancePath: instancePath + "/group", schemaPath: "#/properties/group/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema15.properties.group.type, parentSchema: schema15.properties.group, data: data5 };
            if (vErrors === null) {
              vErrors = [err7];
            } else {
              vErrors.push(err7);
            }
            errors++;
          }
        }
        if (data.format !== void 0) {
          if (!validate43(data.format, { instancePath: instancePath + "/format", parentData: data, parentDataProperty: "format", rootData })) {
            vErrors = vErrors === null ? validate43.errors : vErrors.concat(validate43.errors);
            errors = vErrors.length;
          }
        }
        if (data.constraints !== void 0) {
          let data8 = data.constraints;
          if (data8 && typeof data8 == "object" && !Array.isArray(data8)) {
            for (const key1 in data8) {
              if (!(key1 === "limit_disclosure" || key1 === "statuses" || key1 === "fields" || key1 === "subject_is_issuer" || key1 === "is_holder" || key1 === "same_subject")) {
                const err8 = { instancePath: instancePath + "/constraints", schemaPath: "#/properties/constraints/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key1 }, message: "must NOT have additional properties", schema: false, parentSchema: schema15.properties.constraints, data: data8 };
                if (vErrors === null) {
                  vErrors = [err8];
                } else {
                  vErrors.push(err8);
                }
                errors++;
              }
            }
            if (data8.limit_disclosure !== void 0) {
              let data9 = data8.limit_disclosure;
              if (typeof data9 !== "string") {
                const err9 = { instancePath: instancePath + "/constraints/limit_disclosure", schemaPath: "#/properties/constraints/properties/limit_disclosure/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema15.properties.constraints.properties.limit_disclosure.type, parentSchema: schema15.properties.constraints.properties.limit_disclosure, data: data9 };
                if (vErrors === null) {
                  vErrors = [err9];
                } else {
                  vErrors.push(err9);
                }
                errors++;
              }
              if (!(data9 === "required" || data9 === "preferred")) {
                const err10 = { instancePath: instancePath + "/constraints/limit_disclosure", schemaPath: "#/properties/constraints/properties/limit_disclosure/enum", keyword: "enum", params: { allowedValues: schema15.properties.constraints.properties.limit_disclosure.enum }, message: "must be equal to one of the allowed values", schema: schema15.properties.constraints.properties.limit_disclosure.enum, parentSchema: schema15.properties.constraints.properties.limit_disclosure, data: data9 };
                if (vErrors === null) {
                  vErrors = [err10];
                } else {
                  vErrors.push(err10);
                }
                errors++;
              }
            }
            if (data8.statuses !== void 0) {
              let data10 = data8.statuses;
              if (data10 && typeof data10 == "object" && !Array.isArray(data10)) {
                if (data10.active !== void 0) {
                  let data11 = data10.active;
                  if (data11 && typeof data11 == "object" && !Array.isArray(data11)) {
                    if (data11.directive !== void 0) {
                      let data12 = data11.directive;
                      if (typeof data12 !== "string") {
                        const err11 = { instancePath: instancePath + "/constraints/statuses/active/directive", schemaPath: "#/properties/constraints/properties/statuses/properties/active/properties/directive/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema15.properties.constraints.properties.statuses.properties.active.properties.directive.type, parentSchema: schema15.properties.constraints.properties.statuses.properties.active.properties.directive, data: data12 };
                        if (vErrors === null) {
                          vErrors = [err11];
                        } else {
                          vErrors.push(err11);
                        }
                        errors++;
                      }
                      if (!(data12 === "required" || data12 === "allowed" || data12 === "disallowed")) {
                        const err12 = { instancePath: instancePath + "/constraints/statuses/active/directive", schemaPath: "#/properties/constraints/properties/statuses/properties/active/properties/directive/enum", keyword: "enum", params: { allowedValues: schema15.properties.constraints.properties.statuses.properties.active.properties.directive.enum }, message: "must be equal to one of the allowed values", schema: schema15.properties.constraints.properties.statuses.properties.active.properties.directive.enum, parentSchema: schema15.properties.constraints.properties.statuses.properties.active.properties.directive, data: data12 };
                        if (vErrors === null) {
                          vErrors = [err12];
                        } else {
                          vErrors.push(err12);
                        }
                        errors++;
                      }
                    }
                  } else {
                    const err13 = { instancePath: instancePath + "/constraints/statuses/active", schemaPath: "#/properties/constraints/properties/statuses/properties/active/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema15.properties.constraints.properties.statuses.properties.active.type, parentSchema: schema15.properties.constraints.properties.statuses.properties.active, data: data11 };
                    if (vErrors === null) {
                      vErrors = [err13];
                    } else {
                      vErrors.push(err13);
                    }
                    errors++;
                  }
                }
                if (data10.suspended !== void 0) {
                  let data13 = data10.suspended;
                  if (data13 && typeof data13 == "object" && !Array.isArray(data13)) {
                    if (data13.directive !== void 0) {
                      let data14 = data13.directive;
                      if (typeof data14 !== "string") {
                        const err14 = { instancePath: instancePath + "/constraints/statuses/suspended/directive", schemaPath: "#/properties/constraints/properties/statuses/properties/suspended/properties/directive/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema15.properties.constraints.properties.statuses.properties.suspended.properties.directive.type, parentSchema: schema15.properties.constraints.properties.statuses.properties.suspended.properties.directive, data: data14 };
                        if (vErrors === null) {
                          vErrors = [err14];
                        } else {
                          vErrors.push(err14);
                        }
                        errors++;
                      }
                      if (!(data14 === "required" || data14 === "allowed" || data14 === "disallowed")) {
                        const err15 = { instancePath: instancePath + "/constraints/statuses/suspended/directive", schemaPath: "#/properties/constraints/properties/statuses/properties/suspended/properties/directive/enum", keyword: "enum", params: { allowedValues: schema15.properties.constraints.properties.statuses.properties.suspended.properties.directive.enum }, message: "must be equal to one of the allowed values", schema: schema15.properties.constraints.properties.statuses.properties.suspended.properties.directive.enum, parentSchema: schema15.properties.constraints.properties.statuses.properties.suspended.properties.directive, data: data14 };
                        if (vErrors === null) {
                          vErrors = [err15];
                        } else {
                          vErrors.push(err15);
                        }
                        errors++;
                      }
                    }
                  } else {
                    const err16 = { instancePath: instancePath + "/constraints/statuses/suspended", schemaPath: "#/properties/constraints/properties/statuses/properties/suspended/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema15.properties.constraints.properties.statuses.properties.suspended.type, parentSchema: schema15.properties.constraints.properties.statuses.properties.suspended, data: data13 };
                    if (vErrors === null) {
                      vErrors = [err16];
                    } else {
                      vErrors.push(err16);
                    }
                    errors++;
                  }
                }
                if (data10.revoked !== void 0) {
                  let data15 = data10.revoked;
                  if (data15 && typeof data15 == "object" && !Array.isArray(data15)) {
                    if (data15.directive !== void 0) {
                      let data16 = data15.directive;
                      if (typeof data16 !== "string") {
                        const err17 = { instancePath: instancePath + "/constraints/statuses/revoked/directive", schemaPath: "#/properties/constraints/properties/statuses/properties/revoked/properties/directive/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema15.properties.constraints.properties.statuses.properties.revoked.properties.directive.type, parentSchema: schema15.properties.constraints.properties.statuses.properties.revoked.properties.directive, data: data16 };
                        if (vErrors === null) {
                          vErrors = [err17];
                        } else {
                          vErrors.push(err17);
                        }
                        errors++;
                      }
                      if (!(data16 === "required" || data16 === "allowed" || data16 === "disallowed")) {
                        const err18 = { instancePath: instancePath + "/constraints/statuses/revoked/directive", schemaPath: "#/properties/constraints/properties/statuses/properties/revoked/properties/directive/enum", keyword: "enum", params: { allowedValues: schema15.properties.constraints.properties.statuses.properties.revoked.properties.directive.enum }, message: "must be equal to one of the allowed values", schema: schema15.properties.constraints.properties.statuses.properties.revoked.properties.directive.enum, parentSchema: schema15.properties.constraints.properties.statuses.properties.revoked.properties.directive, data: data16 };
                        if (vErrors === null) {
                          vErrors = [err18];
                        } else {
                          vErrors.push(err18);
                        }
                        errors++;
                      }
                    }
                  } else {
                    const err19 = { instancePath: instancePath + "/constraints/statuses/revoked", schemaPath: "#/properties/constraints/properties/statuses/properties/revoked/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema15.properties.constraints.properties.statuses.properties.revoked.type, parentSchema: schema15.properties.constraints.properties.statuses.properties.revoked, data: data15 };
                    if (vErrors === null) {
                      vErrors = [err19];
                    } else {
                      vErrors.push(err19);
                    }
                    errors++;
                  }
                }
              } else {
                const err20 = { instancePath: instancePath + "/constraints/statuses", schemaPath: "#/properties/constraints/properties/statuses/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema15.properties.constraints.properties.statuses.type, parentSchema: schema15.properties.constraints.properties.statuses, data: data10 };
                if (vErrors === null) {
                  vErrors = [err20];
                } else {
                  vErrors.push(err20);
                }
                errors++;
              }
            }
            if (data8.fields !== void 0) {
              let data17 = data8.fields;
              if (Array.isArray(data17)) {
                const len2 = data17.length;
                for (let i2 = 0; i2 < len2; i2++) {
                  if (!validate51(data17[i2], { instancePath: instancePath + "/constraints/fields/" + i2, parentData: data17, parentDataProperty: i2, rootData })) {
                    vErrors = vErrors === null ? validate51.errors : vErrors.concat(validate51.errors);
                    errors = vErrors.length;
                  }
                }
              } else {
                const err21 = { instancePath: instancePath + "/constraints/fields", schemaPath: "#/properties/constraints/properties/fields/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema15.properties.constraints.properties.fields.type, parentSchema: schema15.properties.constraints.properties.fields, data: data17 };
                if (vErrors === null) {
                  vErrors = [err21];
                } else {
                  vErrors.push(err21);
                }
                errors++;
              }
            }
            if (data8.subject_is_issuer !== void 0) {
              let data19 = data8.subject_is_issuer;
              if (typeof data19 !== "string") {
                const err22 = { instancePath: instancePath + "/constraints/subject_is_issuer", schemaPath: "#/properties/constraints/properties/subject_is_issuer/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema15.properties.constraints.properties.subject_is_issuer.type, parentSchema: schema15.properties.constraints.properties.subject_is_issuer, data: data19 };
                if (vErrors === null) {
                  vErrors = [err22];
                } else {
                  vErrors.push(err22);
                }
                errors++;
              }
              if (!(data19 === "required" || data19 === "preferred")) {
                const err23 = { instancePath: instancePath + "/constraints/subject_is_issuer", schemaPath: "#/properties/constraints/properties/subject_is_issuer/enum", keyword: "enum", params: { allowedValues: schema15.properties.constraints.properties.subject_is_issuer.enum }, message: "must be equal to one of the allowed values", schema: schema15.properties.constraints.properties.subject_is_issuer.enum, parentSchema: schema15.properties.constraints.properties.subject_is_issuer, data: data19 };
                if (vErrors === null) {
                  vErrors = [err23];
                } else {
                  vErrors.push(err23);
                }
                errors++;
              }
            }
            if (data8.is_holder !== void 0) {
              let data20 = data8.is_holder;
              if (Array.isArray(data20)) {
                const len3 = data20.length;
                for (let i3 = 0; i3 < len3; i3++) {
                  let data21 = data20[i3];
                  if (data21 && typeof data21 == "object" && !Array.isArray(data21)) {
                    if (data21.field_id === void 0) {
                      const err24 = { instancePath: instancePath + "/constraints/is_holder/" + i3, schemaPath: "#/properties/constraints/properties/is_holder/items/required", keyword: "required", params: { missingProperty: "field_id" }, message: "must have required property 'field_id'", schema: schema15.properties.constraints.properties.is_holder.items.required, parentSchema: schema15.properties.constraints.properties.is_holder.items, data: data21 };
                      if (vErrors === null) {
                        vErrors = [err24];
                      } else {
                        vErrors.push(err24);
                      }
                      errors++;
                    }
                    if (data21.directive === void 0) {
                      const err25 = { instancePath: instancePath + "/constraints/is_holder/" + i3, schemaPath: "#/properties/constraints/properties/is_holder/items/required", keyword: "required", params: { missingProperty: "directive" }, message: "must have required property 'directive'", schema: schema15.properties.constraints.properties.is_holder.items.required, parentSchema: schema15.properties.constraints.properties.is_holder.items, data: data21 };
                      if (vErrors === null) {
                        vErrors = [err25];
                      } else {
                        vErrors.push(err25);
                      }
                      errors++;
                    }
                    for (const key2 in data21) {
                      if (!(key2 === "field_id" || key2 === "directive")) {
                        const err26 = { instancePath: instancePath + "/constraints/is_holder/" + i3, schemaPath: "#/properties/constraints/properties/is_holder/items/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key2 }, message: "must NOT have additional properties", schema: false, parentSchema: schema15.properties.constraints.properties.is_holder.items, data: data21 };
                        if (vErrors === null) {
                          vErrors = [err26];
                        } else {
                          vErrors.push(err26);
                        }
                        errors++;
                      }
                    }
                    if (data21.field_id !== void 0) {
                      let data22 = data21.field_id;
                      if (Array.isArray(data22)) {
                        const len4 = data22.length;
                        for (let i4 = 0; i4 < len4; i4++) {
                          let data23 = data22[i4];
                          if (typeof data23 !== "string") {
                            const err27 = { instancePath: instancePath + "/constraints/is_holder/" + i3 + "/field_id/" + i4, schemaPath: "#/properties/constraints/properties/is_holder/items/properties/field_id/items/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema15.properties.constraints.properties.is_holder.items.properties.field_id.items.type, parentSchema: schema15.properties.constraints.properties.is_holder.items.properties.field_id.items, data: data23 };
                            if (vErrors === null) {
                              vErrors = [err27];
                            } else {
                              vErrors.push(err27);
                            }
                            errors++;
                          }
                        }
                      } else {
                        const err28 = { instancePath: instancePath + "/constraints/is_holder/" + i3 + "/field_id", schemaPath: "#/properties/constraints/properties/is_holder/items/properties/field_id/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema15.properties.constraints.properties.is_holder.items.properties.field_id.type, parentSchema: schema15.properties.constraints.properties.is_holder.items.properties.field_id, data: data22 };
                        if (vErrors === null) {
                          vErrors = [err28];
                        } else {
                          vErrors.push(err28);
                        }
                        errors++;
                      }
                    }
                    if (data21.directive !== void 0) {
                      let data24 = data21.directive;
                      if (typeof data24 !== "string") {
                        const err29 = { instancePath: instancePath + "/constraints/is_holder/" + i3 + "/directive", schemaPath: "#/properties/constraints/properties/is_holder/items/properties/directive/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema15.properties.constraints.properties.is_holder.items.properties.directive.type, parentSchema: schema15.properties.constraints.properties.is_holder.items.properties.directive, data: data24 };
                        if (vErrors === null) {
                          vErrors = [err29];
                        } else {
                          vErrors.push(err29);
                        }
                        errors++;
                      }
                      if (!(data24 === "required" || data24 === "preferred")) {
                        const err30 = { instancePath: instancePath + "/constraints/is_holder/" + i3 + "/directive", schemaPath: "#/properties/constraints/properties/is_holder/items/properties/directive/enum", keyword: "enum", params: { allowedValues: schema15.properties.constraints.properties.is_holder.items.properties.directive.enum }, message: "must be equal to one of the allowed values", schema: schema15.properties.constraints.properties.is_holder.items.properties.directive.enum, parentSchema: schema15.properties.constraints.properties.is_holder.items.properties.directive, data: data24 };
                        if (vErrors === null) {
                          vErrors = [err30];
                        } else {
                          vErrors.push(err30);
                        }
                        errors++;
                      }
                    }
                  } else {
                    const err31 = { instancePath: instancePath + "/constraints/is_holder/" + i3, schemaPath: "#/properties/constraints/properties/is_holder/items/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema15.properties.constraints.properties.is_holder.items.type, parentSchema: schema15.properties.constraints.properties.is_holder.items, data: data21 };
                    if (vErrors === null) {
                      vErrors = [err31];
                    } else {
                      vErrors.push(err31);
                    }
                    errors++;
                  }
                }
              } else {
                const err32 = { instancePath: instancePath + "/constraints/is_holder", schemaPath: "#/properties/constraints/properties/is_holder/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema15.properties.constraints.properties.is_holder.type, parentSchema: schema15.properties.constraints.properties.is_holder, data: data20 };
                if (vErrors === null) {
                  vErrors = [err32];
                } else {
                  vErrors.push(err32);
                }
                errors++;
              }
            }
            if (data8.same_subject !== void 0) {
              let data25 = data8.same_subject;
              if (Array.isArray(data25)) {
                const len5 = data25.length;
                for (let i5 = 0; i5 < len5; i5++) {
                  let data26 = data25[i5];
                  if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                    if (data26.field_id === void 0) {
                      const err33 = { instancePath: instancePath + "/constraints/same_subject/" + i5, schemaPath: "#/properties/constraints/properties/same_subject/items/required", keyword: "required", params: { missingProperty: "field_id" }, message: "must have required property 'field_id'", schema: schema15.properties.constraints.properties.same_subject.items.required, parentSchema: schema15.properties.constraints.properties.same_subject.items, data: data26 };
                      if (vErrors === null) {
                        vErrors = [err33];
                      } else {
                        vErrors.push(err33);
                      }
                      errors++;
                    }
                    if (data26.directive === void 0) {
                      const err34 = { instancePath: instancePath + "/constraints/same_subject/" + i5, schemaPath: "#/properties/constraints/properties/same_subject/items/required", keyword: "required", params: { missingProperty: "directive" }, message: "must have required property 'directive'", schema: schema15.properties.constraints.properties.same_subject.items.required, parentSchema: schema15.properties.constraints.properties.same_subject.items, data: data26 };
                      if (vErrors === null) {
                        vErrors = [err34];
                      } else {
                        vErrors.push(err34);
                      }
                      errors++;
                    }
                    for (const key3 in data26) {
                      if (!(key3 === "field_id" || key3 === "directive")) {
                        const err35 = { instancePath: instancePath + "/constraints/same_subject/" + i5, schemaPath: "#/properties/constraints/properties/same_subject/items/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key3 }, message: "must NOT have additional properties", schema: false, parentSchema: schema15.properties.constraints.properties.same_subject.items, data: data26 };
                        if (vErrors === null) {
                          vErrors = [err35];
                        } else {
                          vErrors.push(err35);
                        }
                        errors++;
                      }
                    }
                    if (data26.field_id !== void 0) {
                      let data27 = data26.field_id;
                      if (Array.isArray(data27)) {
                        const len6 = data27.length;
                        for (let i6 = 0; i6 < len6; i6++) {
                          let data28 = data27[i6];
                          if (typeof data28 !== "string") {
                            const err36 = { instancePath: instancePath + "/constraints/same_subject/" + i5 + "/field_id/" + i6, schemaPath: "#/properties/constraints/properties/same_subject/items/properties/field_id/items/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema15.properties.constraints.properties.same_subject.items.properties.field_id.items.type, parentSchema: schema15.properties.constraints.properties.same_subject.items.properties.field_id.items, data: data28 };
                            if (vErrors === null) {
                              vErrors = [err36];
                            } else {
                              vErrors.push(err36);
                            }
                            errors++;
                          }
                        }
                      } else {
                        const err37 = { instancePath: instancePath + "/constraints/same_subject/" + i5 + "/field_id", schemaPath: "#/properties/constraints/properties/same_subject/items/properties/field_id/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema15.properties.constraints.properties.same_subject.items.properties.field_id.type, parentSchema: schema15.properties.constraints.properties.same_subject.items.properties.field_id, data: data27 };
                        if (vErrors === null) {
                          vErrors = [err37];
                        } else {
                          vErrors.push(err37);
                        }
                        errors++;
                      }
                    }
                    if (data26.directive !== void 0) {
                      let data29 = data26.directive;
                      if (typeof data29 !== "string") {
                        const err38 = { instancePath: instancePath + "/constraints/same_subject/" + i5 + "/directive", schemaPath: "#/properties/constraints/properties/same_subject/items/properties/directive/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema15.properties.constraints.properties.same_subject.items.properties.directive.type, parentSchema: schema15.properties.constraints.properties.same_subject.items.properties.directive, data: data29 };
                        if (vErrors === null) {
                          vErrors = [err38];
                        } else {
                          vErrors.push(err38);
                        }
                        errors++;
                      }
                      if (!(data29 === "required" || data29 === "preferred")) {
                        const err39 = { instancePath: instancePath + "/constraints/same_subject/" + i5 + "/directive", schemaPath: "#/properties/constraints/properties/same_subject/items/properties/directive/enum", keyword: "enum", params: { allowedValues: schema15.properties.constraints.properties.same_subject.items.properties.directive.enum }, message: "must be equal to one of the allowed values", schema: schema15.properties.constraints.properties.same_subject.items.properties.directive.enum, parentSchema: schema15.properties.constraints.properties.same_subject.items.properties.directive, data: data29 };
                        if (vErrors === null) {
                          vErrors = [err39];
                        } else {
                          vErrors.push(err39);
                        }
                        errors++;
                      }
                    }
                  } else {
                    const err40 = { instancePath: instancePath + "/constraints/same_subject/" + i5, schemaPath: "#/properties/constraints/properties/same_subject/items/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema15.properties.constraints.properties.same_subject.items.type, parentSchema: schema15.properties.constraints.properties.same_subject.items, data: data26 };
                    if (vErrors === null) {
                      vErrors = [err40];
                    } else {
                      vErrors.push(err40);
                    }
                    errors++;
                  }
                }
              } else {
                const err41 = { instancePath: instancePath + "/constraints/same_subject", schemaPath: "#/properties/constraints/properties/same_subject/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema15.properties.constraints.properties.same_subject.type, parentSchema: schema15.properties.constraints.properties.same_subject, data: data25 };
                if (vErrors === null) {
                  vErrors = [err41];
                } else {
                  vErrors.push(err41);
                }
                errors++;
              }
            }
          } else {
            const err42 = { instancePath: instancePath + "/constraints", schemaPath: "#/properties/constraints/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema15.properties.constraints.type, parentSchema: schema15.properties.constraints, data: data8 };
            if (vErrors === null) {
              vErrors = [err42];
            } else {
              vErrors.push(err42);
            }
            errors++;
          }
        }
      } else {
        const err43 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema15.type, parentSchema: schema15, data };
        if (vErrors === null) {
          vErrors = [err43];
        } else {
          vErrors.push(err43);
        }
        errors++;
      }
      validate47.errors = vErrors;
      return errors === 0;
    }
    function validate42(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.presentation_definition !== void 0) {
          let data0 = data.presentation_definition;
          if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
            if (data0.id === void 0) {
              const err0 = { instancePath: instancePath + "/presentation_definition", schemaPath: "#/properties/presentation_definition/required", keyword: "required", params: { missingProperty: "id" }, message: "must have required property 'id'", schema: schema12.properties.presentation_definition.required, parentSchema: schema12.properties.presentation_definition, data: data0 };
              if (vErrors === null) {
                vErrors = [err0];
              } else {
                vErrors.push(err0);
              }
              errors++;
            }
            if (data0.input_descriptors === void 0) {
              const err1 = { instancePath: instancePath + "/presentation_definition", schemaPath: "#/properties/presentation_definition/required", keyword: "required", params: { missingProperty: "input_descriptors" }, message: "must have required property 'input_descriptors'", schema: schema12.properties.presentation_definition.required, parentSchema: schema12.properties.presentation_definition, data: data0 };
              if (vErrors === null) {
                vErrors = [err1];
              } else {
                vErrors.push(err1);
              }
              errors++;
            }
            for (const key0 in data0) {
              if (!(key0 === "id" || key0 === "name" || key0 === "purpose" || key0 === "format" || key0 === "frame" || key0 === "submission_requirements" || key0 === "input_descriptors")) {
                const err2 = { instancePath: instancePath + "/presentation_definition", schemaPath: "#/properties/presentation_definition/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties", schema: false, parentSchema: schema12.properties.presentation_definition, data: data0 };
                if (vErrors === null) {
                  vErrors = [err2];
                } else {
                  vErrors.push(err2);
                }
                errors++;
              }
            }
            if (data0.id !== void 0) {
              let data1 = data0.id;
              if (typeof data1 !== "string") {
                const err3 = { instancePath: instancePath + "/presentation_definition/id", schemaPath: "#/properties/presentation_definition/properties/id/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema12.properties.presentation_definition.properties.id.type, parentSchema: schema12.properties.presentation_definition.properties.id, data: data1 };
                if (vErrors === null) {
                  vErrors = [err3];
                } else {
                  vErrors.push(err3);
                }
                errors++;
              }
            }
            if (data0.name !== void 0) {
              let data2 = data0.name;
              if (typeof data2 !== "string") {
                const err4 = { instancePath: instancePath + "/presentation_definition/name", schemaPath: "#/properties/presentation_definition/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema12.properties.presentation_definition.properties.name.type, parentSchema: schema12.properties.presentation_definition.properties.name, data: data2 };
                if (vErrors === null) {
                  vErrors = [err4];
                } else {
                  vErrors.push(err4);
                }
                errors++;
              }
            }
            if (data0.purpose !== void 0) {
              let data3 = data0.purpose;
              if (typeof data3 !== "string") {
                const err5 = { instancePath: instancePath + "/presentation_definition/purpose", schemaPath: "#/properties/presentation_definition/properties/purpose/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema12.properties.presentation_definition.properties.purpose.type, parentSchema: schema12.properties.presentation_definition.properties.purpose, data: data3 };
                if (vErrors === null) {
                  vErrors = [err5];
                } else {
                  vErrors.push(err5);
                }
                errors++;
              }
            }
            if (data0.format !== void 0) {
              if (!validate43(data0.format, { instancePath: instancePath + "/presentation_definition/format", parentData: data0, parentDataProperty: "format", rootData })) {
                vErrors = vErrors === null ? validate43.errors : vErrors.concat(validate43.errors);
                errors = vErrors.length;
              }
            }
            if (data0.frame !== void 0) {
              let data5 = data0.frame;
              if (data5 && typeof data5 == "object" && !Array.isArray(data5)) {
              } else {
                const err6 = { instancePath: instancePath + "/presentation_definition/frame", schemaPath: "#/properties/presentation_definition/properties/frame/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema12.properties.presentation_definition.properties.frame.type, parentSchema: schema12.properties.presentation_definition.properties.frame, data: data5 };
                if (vErrors === null) {
                  vErrors = [err6];
                } else {
                  vErrors.push(err6);
                }
                errors++;
              }
            }
            if (data0.submission_requirements !== void 0) {
              let data6 = data0.submission_requirements;
              if (Array.isArray(data6)) {
                const len0 = data6.length;
                for (let i0 = 0; i0 < len0; i0++) {
                  if (!validate45(data6[i0], { instancePath: instancePath + "/presentation_definition/submission_requirements/" + i0, parentData: data6, parentDataProperty: i0, rootData })) {
                    vErrors = vErrors === null ? validate45.errors : vErrors.concat(validate45.errors);
                    errors = vErrors.length;
                  }
                }
              } else {
                const err7 = { instancePath: instancePath + "/presentation_definition/submission_requirements", schemaPath: "#/properties/presentation_definition/properties/submission_requirements/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema12.properties.presentation_definition.properties.submission_requirements.type, parentSchema: schema12.properties.presentation_definition.properties.submission_requirements, data: data6 };
                if (vErrors === null) {
                  vErrors = [err7];
                } else {
                  vErrors.push(err7);
                }
                errors++;
              }
            }
            if (data0.input_descriptors !== void 0) {
              let data8 = data0.input_descriptors;
              if (Array.isArray(data8)) {
                const len1 = data8.length;
                for (let i1 = 0; i1 < len1; i1++) {
                  if (!validate47(data8[i1], { instancePath: instancePath + "/presentation_definition/input_descriptors/" + i1, parentData: data8, parentDataProperty: i1, rootData })) {
                    vErrors = vErrors === null ? validate47.errors : vErrors.concat(validate47.errors);
                    errors = vErrors.length;
                  }
                }
              } else {
                const err8 = { instancePath: instancePath + "/presentation_definition/input_descriptors", schemaPath: "#/properties/presentation_definition/properties/input_descriptors/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema12.properties.presentation_definition.properties.input_descriptors.type, parentSchema: schema12.properties.presentation_definition.properties.input_descriptors, data: data8 };
                if (vErrors === null) {
                  vErrors = [err8];
                } else {
                  vErrors.push(err8);
                }
                errors++;
              }
            }
          } else {
            const err9 = { instancePath: instancePath + "/presentation_definition", schemaPath: "#/properties/presentation_definition/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema12.properties.presentation_definition.type, parentSchema: schema12.properties.presentation_definition, data: data0 };
            if (vErrors === null) {
              vErrors = [err9];
            } else {
              vErrors.push(err9);
            }
            errors++;
          }
        }
      } else {
        const err10 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema12.type, parentSchema: schema12, data };
        if (vErrors === null) {
          vErrors = [err10];
        } else {
          vErrors.push(err10);
        }
        errors++;
      }
      validate42.errors = vErrors;
      return errors === 0;
    }
  }
});

// node_modules/ajv-formats/dist/formats.js
var require_formats = __commonJS({
  "node_modules/ajv-formats/dist/formats.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
    function fmtDef(validate2, compare) {
      return { validate: validate2, compare };
    }
    exports.fullFormats = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: fmtDef(date, compareDate),
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: fmtDef(time, compareTime),
      "date-time": fmtDef(date_time, compareDateTime),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte,
      // signed 32 bit integer
      int32: { type: "number", validate: validateInt32 },
      // signed 64 bit integer
      int64: { type: "number", validate: validateInt64 },
      // C-type float
      float: { type: "number", validate: validateNumber },
      // C-type double
      double: { type: "number", validate: validateNumber },
      // hint to the UI to hide input strings
      password: true,
      // unchecked string payload
      binary: true
    };
    exports.fastFormats = {
      ...exports.fullFormats,
      date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
      time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareTime),
      "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    };
    exports.formatNames = Object.keys(exports.fullFormats);
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function date(str) {
      const matches = DATE.exec(str);
      if (!matches)
        return false;
      const year = +matches[1];
      const month = +matches[2];
      const day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function compareDate(d1, d2) {
      if (!(d1 && d2))
        return void 0;
      if (d1 > d2)
        return 1;
      if (d1 < d2)
        return -1;
      return 0;
    }
    var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
    function time(str, withTimeZone) {
      const matches = TIME.exec(str);
      if (!matches)
        return false;
      const hour = +matches[1];
      const minute = +matches[2];
      const second = +matches[3];
      const timeZone = matches[5];
      return (hour <= 23 && minute <= 59 && second <= 59 || hour === 23 && minute === 59 && second === 60) && (!withTimeZone || timeZone !== "");
    }
    function compareTime(t1, t2) {
      if (!(t1 && t2))
        return void 0;
      const a1 = TIME.exec(t1);
      const a2 = TIME.exec(t2);
      if (!(a1 && a2))
        return void 0;
      t1 = a1[1] + a1[2] + a1[3] + (a1[4] || "");
      t2 = a2[1] + a2[2] + a2[3] + (a2[4] || "");
      if (t1 > t2)
        return 1;
      if (t1 < t2)
        return -1;
      return 0;
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function date_time(str) {
      const dateTime = str.split(DATE_TIME_SEPARATOR);
      return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true);
    }
    function compareDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
      const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
      const res = compareDate(d1, d2);
      if (res === void 0)
        return void 0;
      return res || compareTime(t1, t2);
    }
    var NOT_URI_FRAGMENT = /\/|:/;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function byte(str) {
      BYTE.lastIndex = 0;
      return BYTE.test(str);
    }
    var MIN_INT32 = -(2 ** 31);
    var MAX_INT32 = 2 ** 31 - 1;
    function validateInt32(value) {
      return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
    }
    function validateInt64(value) {
      return Number.isInteger(value);
    }
    function validateNumber() {
      return true;
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return false;
      try {
        new RegExp(str);
        return true;
      } catch (e2) {
        return false;
      }
    }
  }
});

// node_modules/ajv-formats/dist/limit.js
var require_limit = __commonJS({
  "node_modules/ajv-formats/dist/limit.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatLimitDefinition = void 0;
    var ajv_1 = require_ajv();
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => codegen_1.str`should be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => codegen_1._`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    exports.formatLimitDefinition = {
      keyword: Object.keys(KWDs),
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, keyword, it } = cxt;
        const { opts, self } = it;
        if (!opts.validateFormats)
          return;
        const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, "format");
        if (fCxt.$data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          });
          const fmt = gen.const("fmt", codegen_1._`${fmts}[${fCxt.schemaCode}]`);
          cxt.fail$data(codegen_1.or(codegen_1._`typeof ${fmt} != "object"`, codegen_1._`${fmt} instanceof RegExp`, codegen_1._`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        function validateFormat() {
          const format = fCxt.schema;
          const fmtDef = self.formats[format];
          if (!fmtDef || fmtDef === true)
            return;
          if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
            throw new Error(`"${keyword}": format "${format}" does not define "compare" function`);
          }
          const fmt = gen.scopeValue("formats", {
            key: format,
            ref: fmtDef,
            code: opts.code.formats ? codegen_1._`${opts.code.formats}${codegen_1.getProperty(format)}` : void 0
          });
          cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
          return codegen_1._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    var formatLimitPlugin = (ajv) => {
      ajv.addKeyword(exports.formatLimitDefinition);
      return ajv;
    };
    exports.default = formatLimitPlugin;
  }
});

// node_modules/ajv-formats/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/ajv-formats/dist/index.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var formats_1 = require_formats();
    var limit_1 = require_limit();
    var codegen_1 = require_codegen();
    var fullName = new codegen_1.Name("fullFormats");
    var fastName = new codegen_1.Name("fastFormats");
    var formatsPlugin = (ajv, opts = { keywords: true }) => {
      if (Array.isArray(opts)) {
        addFormats2(ajv, opts, formats_1.fullFormats, fullName);
        return ajv;
      }
      const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
      const list = opts.formats || formats_1.formatNames;
      addFormats2(ajv, list, formats, exportName);
      if (opts.keywords)
        limit_1.default(ajv);
      return ajv;
    };
    formatsPlugin.get = (name, mode = "full") => {
      const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
      const f = formats[name];
      if (!f)
        throw new Error(`Unknown format "${name}"`);
      return f;
    };
    function addFormats2(ajv, list, fs, exportName) {
      var _a;
      var _b;
      (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = codegen_1._`require("ajv-formats/dist/formats").${exportName}`;
      for (const f of list)
        ajv.addFormat(f, fs[f]);
    }
    module.exports = exports = formatsPlugin;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = formatsPlugin;
  }
});

// node_modules/@sphereon/pex-models/dist/model/callback.js
var require_callback = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/callback.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/challenge.js
var require_challenge = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/challenge.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/constraintsV1.js
var require_constraintsV1 = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/constraintsV1.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/constraintsV2.js
var require_constraintsV2 = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/constraintsV2.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/descriptor.js
var require_descriptor = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/descriptor.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/diObject.js
var require_diObject = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/diObject.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/directives.js
var require_directives = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/directives.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Directives = void 0;
    exports.Directives = {
      Required: "required",
      Allowed: "allowed",
      Disallowed: "disallowed"
    };
  }
});

// node_modules/@sphereon/pex-models/dist/model/exchangeStatus.js
var require_exchangeStatus = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/exchangeStatus.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExchangeStatus = void 0;
    exports.ExchangeStatus = {
      Created: "CREATED",
      Submitted: "SUBMITTED",
      HolderDeclined: "HOLDER_DECLINED",
      Expired: "EXPIRED",
      Accepted: "ACCEPTED",
      VerifierDeclined: "VERIFIER_DECLINED"
    };
  }
});

// node_modules/@sphereon/pex-models/dist/model/fieldV1.js
var require_fieldV1 = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/fieldV1.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/fieldV2.js
var require_fieldV2 = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/fieldV2.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/filterV1.js
var require_filterV1 = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/filterV1.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/filterV2.js
var require_filterV2 = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/filterV2.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/filterV2AllOf.js
var require_filterV2AllOf = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/filterV2AllOf.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/filterV2Base.js
var require_filterV2Base = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/filterV2Base.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/filterV2BaseItems.js
var require_filterV2BaseItems = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/filterV2BaseItems.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/format.js
var require_format3 = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/format.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/holderSubject.js
var require_holderSubject = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/holderSubject.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/inputDescriptorV1.js
var require_inputDescriptorV1 = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/inputDescriptorV1.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/inputDescriptorV2.js
var require_inputDescriptorV2 = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/inputDescriptorV2.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/issuance.js
var require_issuance = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/issuance.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/issue.js
var require_issue = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/issue.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/jwtObject.js
var require_jwtObject = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/jwtObject.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/ldpObject.js
var require_ldpObject = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/ldpObject.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/oneOfNumberString.js
var require_oneOfNumberString = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/oneOfNumberString.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/optionality.js
var require_optionality = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/optionality.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Optionality = void 0;
    exports.Optionality = {
      Required: "required",
      Preferred: "preferred"
    };
  }
});

// node_modules/@sphereon/pex-models/dist/model/pdStatus.js
var require_pdStatus = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/pdStatus.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/presentationDefinitionV1.js
var require_presentationDefinitionV1 = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/presentationDefinitionV1.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/presentationDefinitionV2.js
var require_presentationDefinitionV2 = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/presentationDefinitionV2.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/presentationDefinitionWrapper.js
var require_presentationDefinitionWrapper = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/presentationDefinitionWrapper.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/presentationStatus.js
var require_presentationStatus = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/presentationStatus.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/presentationStatusWrapper.js
var require_presentationStatusWrapper = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/presentationStatusWrapper.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/presentationSubmission.js
var require_presentationSubmission = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/presentationSubmission.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/presentationWrapper.js
var require_presentationWrapper = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/presentationWrapper.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/resource.js
var require_resource = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/resource.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/rules.js
var require_rules2 = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/rules.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Rules = void 0;
    exports.Rules = {
      All: "all",
      Pick: "pick"
    };
  }
});

// node_modules/@sphereon/pex-models/dist/model/schema.js
var require_schema = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/schema.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/sdJwtObject.js
var require_sdJwtObject = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/sdJwtObject.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/status.js
var require_status = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/status.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Status = void 0;
    exports.Status = {
      Success: "SUCCESS",
      Warn: "WARN",
      Error: "ERROR"
    };
  }
});

// node_modules/@sphereon/pex-models/dist/model/statusResponse.js
var require_statusResponse = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/statusResponse.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/statuses.js
var require_statuses = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/statuses.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/submissionRequirement.js
var require_submissionRequirement = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/submissionRequirement.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/thread.js
var require_thread = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/thread.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sphereon/pex-models/dist/model/models.js
var require_models = __commonJS({
  "node_modules/@sphereon/pex-models/dist/model/models.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_callback(), exports);
    __exportStar(require_challenge(), exports);
    __exportStar(require_constraintsV1(), exports);
    __exportStar(require_constraintsV2(), exports);
    __exportStar(require_descriptor(), exports);
    __exportStar(require_diObject(), exports);
    __exportStar(require_directives(), exports);
    __exportStar(require_exchangeStatus(), exports);
    __exportStar(require_fieldV1(), exports);
    __exportStar(require_fieldV2(), exports);
    __exportStar(require_filterV1(), exports);
    __exportStar(require_filterV2(), exports);
    __exportStar(require_filterV2AllOf(), exports);
    __exportStar(require_filterV2Base(), exports);
    __exportStar(require_filterV2BaseItems(), exports);
    __exportStar(require_format3(), exports);
    __exportStar(require_holderSubject(), exports);
    __exportStar(require_inputDescriptorV1(), exports);
    __exportStar(require_inputDescriptorV2(), exports);
    __exportStar(require_issuance(), exports);
    __exportStar(require_issue(), exports);
    __exportStar(require_jwtObject(), exports);
    __exportStar(require_ldpObject(), exports);
    __exportStar(require_oneOfNumberString(), exports);
    __exportStar(require_optionality(), exports);
    __exportStar(require_pdStatus(), exports);
    __exportStar(require_presentationDefinitionV1(), exports);
    __exportStar(require_presentationDefinitionV2(), exports);
    __exportStar(require_presentationDefinitionWrapper(), exports);
    __exportStar(require_presentationStatus(), exports);
    __exportStar(require_presentationStatusWrapper(), exports);
    __exportStar(require_presentationSubmission(), exports);
    __exportStar(require_presentationWrapper(), exports);
    __exportStar(require_resource(), exports);
    __exportStar(require_rules2(), exports);
    __exportStar(require_schema(), exports);
    __exportStar(require_sdJwtObject(), exports);
    __exportStar(require_status(), exports);
    __exportStar(require_statusResponse(), exports);
    __exportStar(require_statuses(), exports);
    __exportStar(require_submissionRequirement(), exports);
    __exportStar(require_thread(), exports);
  }
});

// node_modules/@sphereon/pex-models/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/@sphereon/pex-models/dist/index.js"(exports) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_models(), exports);
  }
});

// node_modules/@sphereon/pex/dist/module/lib/validation/validateFilterv1.js
var require_validateFilterv1 = __commonJS({
  "node_modules/@sphereon/pex/dist/module/lib/validation/validateFilterv1.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    module.exports = validate42;
    module.exports.default = validate42;
    var schema13 = { "additionalProperties": false, "properties": { "const": { "$ref": "#/definitions/OneOfNumberString" }, "enum": { "items": { "$ref": "#/definitions/OneOfNumberString" }, "type": "array" }, "exclusiveMaximum": { "$ref": "#/definitions/OneOfNumberString" }, "exclusiveMinimum": { "$ref": "#/definitions/OneOfNumberString" }, "format": { "type": "string" }, "maxLength": { "type": "number" }, "maximum": { "$ref": "#/definitions/OneOfNumberString" }, "minLength": { "type": "number" }, "minimum": { "$ref": "#/definitions/OneOfNumberString" }, "not": { "type": "object" }, "pattern": { "type": "string" }, "type": { "type": "string" } }, "required": ["type"], "type": "object" };
    var func4 = Object.prototype.hasOwnProperty;
    var schema14 = { "type": ["number", "string"] };
    function validate44(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (!(typeof data == "number") && typeof data !== "string") {
        const err0 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: schema14.type }, message: "must be number,string", schema: schema14.type, parentSchema: schema14, data };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors++;
      }
      validate44.errors = vErrors;
      return errors === 0;
    }
    function validate43(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.type === void 0) {
          const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "type" }, message: "must have required property 'type'", schema: schema13.required, parentSchema: schema13, data };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors++;
        }
        for (const key0 in data) {
          if (!func4.call(schema13.properties, key0)) {
            const err1 = { instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties", schema: false, parentSchema: schema13, data };
            if (vErrors === null) {
              vErrors = [err1];
            } else {
              vErrors.push(err1);
            }
            errors++;
          }
        }
        if (data.const !== void 0) {
          if (!validate44(data.const, { instancePath: instancePath + "/const", parentData: data, parentDataProperty: "const", rootData })) {
            vErrors = vErrors === null ? validate44.errors : vErrors.concat(validate44.errors);
            errors = vErrors.length;
          }
        }
        if (data.enum !== void 0) {
          let data1 = data.enum;
          if (Array.isArray(data1)) {
            const len0 = data1.length;
            for (let i0 = 0; i0 < len0; i0++) {
              if (!validate44(data1[i0], { instancePath: instancePath + "/enum/" + i0, parentData: data1, parentDataProperty: i0, rootData })) {
                vErrors = vErrors === null ? validate44.errors : vErrors.concat(validate44.errors);
                errors = vErrors.length;
              }
            }
          } else {
            const err2 = { instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema13.properties.enum.type, parentSchema: schema13.properties.enum, data: data1 };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors++;
          }
        }
        if (data.exclusiveMaximum !== void 0) {
          if (!validate44(data.exclusiveMaximum, { instancePath: instancePath + "/exclusiveMaximum", parentData: data, parentDataProperty: "exclusiveMaximum", rootData })) {
            vErrors = vErrors === null ? validate44.errors : vErrors.concat(validate44.errors);
            errors = vErrors.length;
          }
        }
        if (data.exclusiveMinimum !== void 0) {
          if (!validate44(data.exclusiveMinimum, { instancePath: instancePath + "/exclusiveMinimum", parentData: data, parentDataProperty: "exclusiveMinimum", rootData })) {
            vErrors = vErrors === null ? validate44.errors : vErrors.concat(validate44.errors);
            errors = vErrors.length;
          }
        }
        if (data.format !== void 0) {
          let data5 = data.format;
          if (typeof data5 !== "string") {
            const err3 = { instancePath: instancePath + "/format", schemaPath: "#/properties/format/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema13.properties.format.type, parentSchema: schema13.properties.format, data: data5 };
            if (vErrors === null) {
              vErrors = [err3];
            } else {
              vErrors.push(err3);
            }
            errors++;
          }
        }
        if (data.maxLength !== void 0) {
          let data6 = data.maxLength;
          if (!(typeof data6 == "number")) {
            const err4 = { instancePath: instancePath + "/maxLength", schemaPath: "#/properties/maxLength/type", keyword: "type", params: { type: "number" }, message: "must be number", schema: schema13.properties.maxLength.type, parentSchema: schema13.properties.maxLength, data: data6 };
            if (vErrors === null) {
              vErrors = [err4];
            } else {
              vErrors.push(err4);
            }
            errors++;
          }
        }
        if (data.maximum !== void 0) {
          if (!validate44(data.maximum, { instancePath: instancePath + "/maximum", parentData: data, parentDataProperty: "maximum", rootData })) {
            vErrors = vErrors === null ? validate44.errors : vErrors.concat(validate44.errors);
            errors = vErrors.length;
          }
        }
        if (data.minLength !== void 0) {
          let data8 = data.minLength;
          if (!(typeof data8 == "number")) {
            const err5 = { instancePath: instancePath + "/minLength", schemaPath: "#/properties/minLength/type", keyword: "type", params: { type: "number" }, message: "must be number", schema: schema13.properties.minLength.type, parentSchema: schema13.properties.minLength, data: data8 };
            if (vErrors === null) {
              vErrors = [err5];
            } else {
              vErrors.push(err5);
            }
            errors++;
          }
        }
        if (data.minimum !== void 0) {
          if (!validate44(data.minimum, { instancePath: instancePath + "/minimum", parentData: data, parentDataProperty: "minimum", rootData })) {
            vErrors = vErrors === null ? validate44.errors : vErrors.concat(validate44.errors);
            errors = vErrors.length;
          }
        }
        if (data.not !== void 0) {
          let data10 = data.not;
          if (!(data10 && typeof data10 == "object" && !Array.isArray(data10))) {
            const err6 = { instancePath: instancePath + "/not", schemaPath: "#/properties/not/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema13.properties.not.type, parentSchema: schema13.properties.not, data: data10 };
            if (vErrors === null) {
              vErrors = [err6];
            } else {
              vErrors.push(err6);
            }
            errors++;
          }
        }
        if (data.pattern !== void 0) {
          let data11 = data.pattern;
          if (typeof data11 !== "string") {
            const err7 = { instancePath: instancePath + "/pattern", schemaPath: "#/properties/pattern/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema13.properties.pattern.type, parentSchema: schema13.properties.pattern, data: data11 };
            if (vErrors === null) {
              vErrors = [err7];
            } else {
              vErrors.push(err7);
            }
            errors++;
          }
        }
        if (data.type !== void 0) {
          let data12 = data.type;
          if (typeof data12 !== "string") {
            const err8 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema13.properties.type.type, parentSchema: schema13.properties.type, data: data12 };
            if (vErrors === null) {
              vErrors = [err8];
            } else {
              vErrors.push(err8);
            }
            errors++;
          }
        }
      } else {
        const err9 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema13.type, parentSchema: schema13, data };
        if (vErrors === null) {
          vErrors = [err9];
        } else {
          vErrors.push(err9);
        }
        errors++;
      }
      validate43.errors = vErrors;
      return errors === 0;
    }
    function validate42(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (!validate43(data, { instancePath, parentData, parentDataProperty, rootData })) {
        vErrors = vErrors === null ? validate43.errors : vErrors.concat(validate43.errors);
        errors = vErrors.length;
      }
      validate42.errors = vErrors;
      return errors === 0;
    }
  }
});

// node_modules/@sphereon/pex/dist/module/lib/validation/validateFilterv2.js
var require_validateFilterv2 = __commonJS({
  "node_modules/@sphereon/pex/dist/module/lib/validation/validateFilterv2.js"(exports, module) {
    "use strict";
    var import_dist68 = __toESM(require_dist());
    module.exports = validate42;
    module.exports.default = validate42;
    var schema13 = { "additionalProperties": false, "properties": { "const": { "$ref": "#/definitions/OneOfNumberString" }, "enum": { "items": { "$ref": "#/definitions/OneOfNumberString" }, "type": "array" }, "exclusiveMaximum": { "$ref": "#/definitions/OneOfNumberString" }, "exclusiveMinimum": { "$ref": "#/definitions/OneOfNumberString" }, "format": { "type": "string" }, "formatExclusiveMaximum": { "type": "string" }, "formatExclusiveMinimum": { "type": "string" }, "formatMaximum": { "type": "string" }, "formatMinimum": { "type": "string" }, "maxLength": { "type": "number" }, "maximum": { "$ref": "#/definitions/OneOfNumberString" }, "minLength": { "type": "number" }, "minimum": { "$ref": "#/definitions/OneOfNumberString" }, "not": { "type": "object" }, "pattern": { "type": "string" }, "type": { "type": "string" } }, "required": ["type"], "type": "object" };
    var func4 = Object.prototype.hasOwnProperty;
    var schema14 = { "type": ["number", "string"] };
    function validate44(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (!(typeof data == "number") && typeof data !== "string") {
        const err0 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: schema14.type }, message: "must be number,string", schema: schema14.type, parentSchema: schema14, data };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors++;
      }
      validate44.errors = vErrors;
      return errors === 0;
    }
    function validate43(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.type === void 0) {
          const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "type" }, message: "must have required property 'type'", schema: schema13.required, parentSchema: schema13, data };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors++;
        }
        for (const key0 in data) {
          if (!func4.call(schema13.properties, key0)) {
            const err1 = { instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties", schema: false, parentSchema: schema13, data };
            if (vErrors === null) {
              vErrors = [err1];
            } else {
              vErrors.push(err1);
            }
            errors++;
          }
        }
        if (data.const !== void 0) {
          if (!validate44(data.const, { instancePath: instancePath + "/const", parentData: data, parentDataProperty: "const", rootData })) {
            vErrors = vErrors === null ? validate44.errors : vErrors.concat(validate44.errors);
            errors = vErrors.length;
          }
        }
        if (data.enum !== void 0) {
          let data1 = data.enum;
          if (Array.isArray(data1)) {
            const len0 = data1.length;
            for (let i0 = 0; i0 < len0; i0++) {
              if (!validate44(data1[i0], { instancePath: instancePath + "/enum/" + i0, parentData: data1, parentDataProperty: i0, rootData })) {
                vErrors = vErrors === null ? validate44.errors : vErrors.concat(validate44.errors);
                errors = vErrors.length;
              }
            }
          } else {
            const err2 = { instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/type", keyword: "type", params: { type: "array" }, message: "must be array", schema: schema13.properties.enum.type, parentSchema: schema13.properties.enum, data: data1 };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors++;
          }
        }
        if (data.exclusiveMaximum !== void 0) {
          if (!validate44(data.exclusiveMaximum, { instancePath: instancePath + "/exclusiveMaximum", parentData: data, parentDataProperty: "exclusiveMaximum", rootData })) {
            vErrors = vErrors === null ? validate44.errors : vErrors.concat(validate44.errors);
            errors = vErrors.length;
          }
        }
        if (data.exclusiveMinimum !== void 0) {
          if (!validate44(data.exclusiveMinimum, { instancePath: instancePath + "/exclusiveMinimum", parentData: data, parentDataProperty: "exclusiveMinimum", rootData })) {
            vErrors = vErrors === null ? validate44.errors : vErrors.concat(validate44.errors);
            errors = vErrors.length;
          }
        }
        if (data.format !== void 0) {
          let data5 = data.format;
          if (typeof data5 !== "string") {
            const err3 = { instancePath: instancePath + "/format", schemaPath: "#/properties/format/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema13.properties.format.type, parentSchema: schema13.properties.format, data: data5 };
            if (vErrors === null) {
              vErrors = [err3];
            } else {
              vErrors.push(err3);
            }
            errors++;
          }
        }
        if (data.formatExclusiveMaximum !== void 0) {
          let data6 = data.formatExclusiveMaximum;
          if (typeof data6 !== "string") {
            const err4 = { instancePath: instancePath + "/formatExclusiveMaximum", schemaPath: "#/properties/formatExclusiveMaximum/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema13.properties.formatExclusiveMaximum.type, parentSchema: schema13.properties.formatExclusiveMaximum, data: data6 };
            if (vErrors === null) {
              vErrors = [err4];
            } else {
              vErrors.push(err4);
            }
            errors++;
          }
        }
        if (data.formatExclusiveMinimum !== void 0) {
          let data7 = data.formatExclusiveMinimum;
          if (typeof data7 !== "string") {
            const err5 = { instancePath: instancePath + "/formatExclusiveMinimum", schemaPath: "#/properties/formatExclusiveMinimum/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema13.properties.formatExclusiveMinimum.type, parentSchema: schema13.properties.formatExclusiveMinimum, data: data7 };
            if (vErrors === null) {
              vErrors = [err5];
            } else {
              vErrors.push(err5);
            }
            errors++;
          }
        }
        if (data.formatMaximum !== void 0) {
          let data8 = data.formatMaximum;
          if (typeof data8 !== "string") {
            const err6 = { instancePath: instancePath + "/formatMaximum", schemaPath: "#/properties/formatMaximum/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema13.properties.formatMaximum.type, parentSchema: schema13.properties.formatMaximum, data: data8 };
            if (vErrors === null) {
              vErrors = [err6];
            } else {
              vErrors.push(err6);
            }
            errors++;
          }
        }
        if (data.formatMinimum !== void 0) {
          let data9 = data.formatMinimum;
          if (typeof data9 !== "string") {
            const err7 = { instancePath: instancePath + "/formatMinimum", schemaPath: "#/properties/formatMinimum/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema13.properties.formatMinimum.type, parentSchema: schema13.properties.formatMinimum, data: data9 };
            if (vErrors === null) {
              vErrors = [err7];
            } else {
              vErrors.push(err7);
            }
            errors++;
          }
        }
        if (data.maxLength !== void 0) {
          let data10 = data.maxLength;
          if (!(typeof data10 == "number")) {
            const err8 = { instancePath: instancePath + "/maxLength", schemaPath: "#/properties/maxLength/type", keyword: "type", params: { type: "number" }, message: "must be number", schema: schema13.properties.maxLength.type, parentSchema: schema13.properties.maxLength, data: data10 };
            if (vErrors === null) {
              vErrors = [err8];
            } else {
              vErrors.push(err8);
            }
            errors++;
          }
        }
        if (data.maximum !== void 0) {
          if (!validate44(data.maximum, { instancePath: instancePath + "/maximum", parentData: data, parentDataProperty: "maximum", rootData })) {
            vErrors = vErrors === null ? validate44.errors : vErrors.concat(validate44.errors);
            errors = vErrors.length;
          }
        }
        if (data.minLength !== void 0) {
          let data12 = data.minLength;
          if (!(typeof data12 == "number")) {
            const err9 = { instancePath: instancePath + "/minLength", schemaPath: "#/properties/minLength/type", keyword: "type", params: { type: "number" }, message: "must be number", schema: schema13.properties.minLength.type, parentSchema: schema13.properties.minLength, data: data12 };
            if (vErrors === null) {
              vErrors = [err9];
            } else {
              vErrors.push(err9);
            }
            errors++;
          }
        }
        if (data.minimum !== void 0) {
          if (!validate44(data.minimum, { instancePath: instancePath + "/minimum", parentData: data, parentDataProperty: "minimum", rootData })) {
            vErrors = vErrors === null ? validate44.errors : vErrors.concat(validate44.errors);
            errors = vErrors.length;
          }
        }
        if (data.not !== void 0) {
          let data14 = data.not;
          if (!(data14 && typeof data14 == "object" && !Array.isArray(data14))) {
            const err10 = { instancePath: instancePath + "/not", schemaPath: "#/properties/not/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema13.properties.not.type, parentSchema: schema13.properties.not, data: data14 };
            if (vErrors === null) {
              vErrors = [err10];
            } else {
              vErrors.push(err10);
            }
            errors++;
          }
        }
        if (data.pattern !== void 0) {
          let data15 = data.pattern;
          if (typeof data15 !== "string") {
            const err11 = { instancePath: instancePath + "/pattern", schemaPath: "#/properties/pattern/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema13.properties.pattern.type, parentSchema: schema13.properties.pattern, data: data15 };
            if (vErrors === null) {
              vErrors = [err11];
            } else {
              vErrors.push(err11);
            }
            errors++;
          }
        }
        if (data.type !== void 0) {
          let data16 = data.type;
          if (typeof data16 !== "string") {
            const err12 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string", schema: schema13.properties.type.type, parentSchema: schema13.properties.type, data: data16 };
            if (vErrors === null) {
              vErrors = [err12];
            } else {
              vErrors.push(err12);
            }
            errors++;
          }
        }
      } else {
        const err13 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object", schema: schema13.type, parentSchema: schema13, data };
        if (vErrors === null) {
          vErrors = [err13];
        } else {
          vErrors.push(err13);
        }
        errors++;
      }
      validate43.errors = vErrors;
      return errors === 0;
    }
    function validate42(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (!validate43(data, { instancePath, parentData, parentDataProperty, rootData })) {
        vErrors = vErrors === null ? validate43.errors : vErrors.concat(validate43.errors);
        errors = vErrors.length;
      }
      validate42.errors = vErrors;
      return errors === 0;
    }
  }
});

// node_modules/@sphereon/pex/dist/module/lib/PEX.js
var import_dist63 = __toESM(require_dist());

// node_modules/@sphereon/pex/dist/module/lib/ConstraintUtils.js
var import_dist = __toESM(require_dist());
var Status = {
  INFO: "info",
  WARN: "warn",
  ERROR: "error"
};
var Checked = class {
  constructor(tag, status, message) {
    __publicField(this, "tag");
    __publicField(this, "status");
    __publicField(this, "message");
    this.tag = tag;
    this.status = status;
    this.message = message;
  }
};
var hasErrors = (checked) => {
  function isError(chk) {
    return chk.status === Status.ERROR;
  }
  return checked.filter((chk) => isError(chk)).length > 0;
};

// node_modules/@sphereon/pex/dist/module/lib/evaluation/index.js
var import_dist42 = __toESM(require_dist());

// node_modules/@sphereon/pex/dist/module/lib/evaluation/core/index.js
var import_dist6 = __toESM(require_dist());

// node_modules/@sphereon/pex/dist/module/lib/evaluation/core/evaluationResults.js
var import_dist2 = __toESM(require_dist());

// node_modules/@sphereon/pex/dist/module/lib/evaluation/core/handlerCheckResult.js
var import_dist3 = __toESM(require_dist());

// node_modules/@sphereon/pex/dist/module/lib/evaluation/core/selectResults.js
var import_dist4 = __toESM(require_dist());

// node_modules/@sphereon/pex/dist/module/lib/evaluation/core/submissionRequirementMatch.js
var import_dist5 = __toESM(require_dist());

// node_modules/@sphereon/pex/dist/module/lib/evaluation/evaluationClient.js
var import_dist40 = __toESM(require_dist());
var import_ssi_types3 = __toESM(require_dist2());

// node_modules/@sphereon/pex/dist/module/lib/types/Messages.js
var import_dist8 = __toESM(require_dist());
var PexMessages;
(function(PexMessages2) {
  PexMessages2["INPUT_CANDIDATE_DOESNT_CONTAIN_PROPERTY"] = "Input candidate does not contain property";
  PexMessages2["INPUT_CANDIDATE_FAILED_FILTER_EVALUATION"] = "Input candidate failed filter evaluation";
  PexMessages2["INPUT_CANDIDATE_IS_ELIGIBLE_FOR_PRESENTATION_SUBMISSION"] = "The input candidate is eligible for submission";
  PexMessages2["INPUT_CANDIDATE_IS_NOT_ELIGIBLE_FOR_PRESENTATION_SUBMISSION"] = "The input candidate is not eligible for submission";
  PexMessages2["INPUT_DESCRIPTOR_CONTEXT_CONTAINS_HASHLINK_VERIFICATION_NOT_SUPPORTED"] = "Input descriptor contains hashlink. This version doesn't support hashlink verification.";
  PexMessages2["LIMIT_DISCLOSURE_APPLIED"] = "added variable in the limit_disclosure to the verifiableCredential";
  PexMessages2["LIMIT_DISCLOSURE_NOT_SUPPORTED"] = "Limit disclosure not supported";
  PexMessages2["SUBJECT_IS_NOT_ISSUER"] = "subject is not issuer";
  PexMessages2["SUBJECT_IS_ISSUER"] = "subject is issuer";
  PexMessages2["FORMAT_RESTRICTION_PASSED"] = "the Credential format of the candidate inputs matches the required formats";
  PexMessages2["FORMAT_RESTRICTION_DIDNT_PASS"] = "the Credential format of the candidate inputs didn't match the required formats";
  PexMessages2["URI_EVALUATION_PASSED"] = "@context URI(s) for the schema of the candidate input is equal to one of the input_descriptors object uri values.";
  PexMessages2["URI_EVALUATION_DIDNT_PASS"] = "@context URI for the of the candidate input MUST be equal to one of the input_descriptors object uri values exactly.";
  PexMessages2["UNKNOWN_EXCEPTION"] = "unknown exception occurred: ";
  PexMessages2["VERIFIABLE_CREDENTIAL_MANDATORY_FIELD_NOT_PRESENT"] = "mandatory field not present in the verifiableCredential";
})(PexMessages || (PexMessages = {}));
var Messages_default = PexMessages;

// node_modules/@sphereon/pex/dist/module/lib/utils/index.js
var import_dist24 = __toESM(require_dist());

// node_modules/@sphereon/pex/dist/module/lib/utils/jsonPathUtils.js
var import_dist17 = __toESM(require_dist());

// node_modules/@astronautlabs/jsonpath/dist.esm/index.js
var import_dist16 = __toESM(require_dist());

// node_modules/@astronautlabs/jsonpath/dist.esm/jsonpath.js
var import_dist15 = __toESM(require_dist());

// node_modules/@astronautlabs/jsonpath/dist.esm/handlers.js
var import_dist11 = __toESM(require_dist());

// node_modules/@astronautlabs/jsonpath/dist.esm/esprima.js
var import_dist9 = __toESM(require_dist());
var Token;
var TokenName;
var FnExprTokens;
var PropertyKind;
var Messages;
var Regex;
var SyntaxTreeDelegate;
var source;
var strict;
var index;
var lineNumber;
var lineStart;
var length;
var delegate;
var lookahead;
var state;
var extra;
Token = {
  BooleanLiteral: 1,
  EOF: 2,
  Identifier: 3,
  Keyword: 4,
  NullLiteral: 5,
  NumericLiteral: 6,
  Punctuator: 7,
  StringLiteral: 8,
  RegularExpression: 9
};
TokenName = {};
TokenName[Token.BooleanLiteral] = "Boolean";
TokenName[Token.EOF] = "<end>";
TokenName[Token.Identifier] = "Identifier";
TokenName[Token.Keyword] = "Keyword";
TokenName[Token.NullLiteral] = "Null";
TokenName[Token.NumericLiteral] = "Numeric";
TokenName[Token.Punctuator] = "Punctuator";
TokenName[Token.StringLiteral] = "String";
TokenName[Token.RegularExpression] = "RegularExpression";
FnExprTokens = [
  "(",
  "{",
  "[",
  "in",
  "typeof",
  "instanceof",
  "new",
  "return",
  "case",
  "delete",
  "throw",
  "void",
  // assignment operators
  "=",
  "+=",
  "-=",
  "*=",
  "/=",
  "%=",
  "<<=",
  ">>=",
  ">>>=",
  "&=",
  "|=",
  "^=",
  ",",
  // binary/unary operators
  "+",
  "-",
  "*",
  "/",
  "%",
  "++",
  "--",
  "<<",
  ">>",
  ">>>",
  "&",
  "|",
  "^",
  "!",
  "~",
  "&&",
  "||",
  "?",
  ":",
  "===",
  "==",
  ">=",
  "<=",
  "<",
  ">",
  "!=",
  "!=="
];
var Syntax = {
  AssignmentExpression: "AssignmentExpression",
  ArrayExpression: "ArrayExpression",
  BlockStatement: "BlockStatement",
  BinaryExpression: "BinaryExpression",
  BreakStatement: "BreakStatement",
  CallExpression: "CallExpression",
  CatchClause: "CatchClause",
  ConditionalExpression: "ConditionalExpression",
  ContinueStatement: "ContinueStatement",
  DoWhileStatement: "DoWhileStatement",
  DebuggerStatement: "DebuggerStatement",
  EmptyStatement: "EmptyStatement",
  ExpressionStatement: "ExpressionStatement",
  ForStatement: "ForStatement",
  ForInStatement: "ForInStatement",
  FunctionDeclaration: "FunctionDeclaration",
  FunctionExpression: "FunctionExpression",
  Identifier: "Identifier",
  IfStatement: "IfStatement",
  Literal: "Literal",
  LabeledStatement: "LabeledStatement",
  LogicalExpression: "LogicalExpression",
  MemberExpression: "MemberExpression",
  NewExpression: "NewExpression",
  ObjectExpression: "ObjectExpression",
  Program: "Program",
  Property: "Property",
  ReturnStatement: "ReturnStatement",
  SequenceExpression: "SequenceExpression",
  SwitchStatement: "SwitchStatement",
  SwitchCase: "SwitchCase",
  ThisExpression: "ThisExpression",
  ThrowStatement: "ThrowStatement",
  TryStatement: "TryStatement",
  UnaryExpression: "UnaryExpression",
  UpdateExpression: "UpdateExpression",
  VariableDeclaration: "VariableDeclaration",
  VariableDeclarator: "VariableDeclarator",
  WhileStatement: "WhileStatement",
  WithStatement: "WithStatement"
};
PropertyKind = {
  Data: 1,
  Get: 2,
  Set: 4
};
Messages = {
  UnexpectedToken: "Unexpected token %0",
  UnexpectedNumber: "Unexpected number",
  UnexpectedString: "Unexpected string",
  UnexpectedIdentifier: "Unexpected identifier",
  UnexpectedReserved: "Unexpected reserved word",
  UnexpectedEOS: "Unexpected end of input",
  NewlineAfterThrow: "Illegal newline after throw",
  InvalidRegExp: "Invalid regular expression",
  UnterminatedRegExp: "Invalid regular expression: missing /",
  InvalidLHSInAssignment: "Invalid left-hand side in assignment",
  InvalidLHSInForIn: "Invalid left-hand side in for-in",
  MultipleDefaultsInSwitch: "More than one default clause in switch statement",
  NoCatchOrFinally: "Missing catch or finally after try",
  UnknownLabel: "Undefined label '%0'",
  Redeclaration: "%0 '%1' has already been declared",
  IllegalContinue: "Illegal continue statement",
  IllegalBreak: "Illegal break statement",
  IllegalReturn: "Illegal return statement",
  StrictModeWith: "Strict mode code may not include a with statement",
  StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
  StrictVarName: "Variable name may not be eval or arguments in strict mode",
  StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
  StrictParamDupe: "Strict mode function may not have duplicate parameter names",
  StrictFunctionName: "Function name may not be eval or arguments in strict mode",
  StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
  StrictDelete: "Delete of an unqualified identifier in strict mode.",
  StrictDuplicateProperty: "Duplicate data property in object literal not allowed in strict mode",
  AccessorDataProperty: "Object literal may not have data and accessor property with the same name",
  AccessorGetSet: "Object literal may not have multiple get/set accessors with the same name",
  StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
  StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
  StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
  StrictReservedWord: "Use of future reserved word in strict mode"
};
Regex = {
  NonAsciiIdentifierStart: new RegExp("[ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԧԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠࢢ-ࢬऄ-हऽॐक़-ॡॱ-ॷॹ-ॿঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-ళవ-హఽౘౙౠౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൠൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛰᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤜᥐ-ᥭᥰ-ᥴᦀ-ᦫᧁ-ᧇᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⸯ々-〇〡-〩〱-〵〸-〼ぁ-ゖゝ-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿌ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚗꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞎꞐ-ꞓꞠ-Ɦꟸ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꪀ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꯀ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ]"),
  NonAsciiIdentifierPart: new RegExp("[ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮ̀-ʹͶͷͺ-ͽΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁ҃-҇Ҋ-ԧԱ-Ֆՙա-և֑-ׇֽֿׁׂׅׄא-תװ-ײؐ-ؚؠ-٩ٮ-ۓە-ۜ۟-۪ۨ-ۼۿܐ-݊ݍ-ޱ߀-ߵߺࠀ-࠭ࡀ-࡛ࢠࢢ-ࢬࣤ-ࣾऀ-ॣ०-९ॱ-ॷॹ-ॿঁ-ঃঅ-ঌএঐও-নপ-রলশ-হ়-ৄেৈো-ৎৗড়ঢ়য়-ৣ০-ৱਁ-ਃਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹ਼ਾ-ੂੇੈੋ-੍ੑਖ਼-ੜਫ਼੦-ੵઁ-ઃઅ-ઍએ-ઑઓ-નપ-રલળવ-હ઼-ૅે-ૉો-્ૐૠ-ૣ૦-૯ଁ-ଃଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହ଼-ୄେୈୋ-୍ୖୗଡ଼ଢ଼ୟ-ୣ୦-୯ୱஂஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹா-ூெ-ைொ-்ௐௗ௦-௯ఁ-ఃఅ-ఌఎ-ఐఒ-నప-ళవ-హఽ-ౄె-ైొ-్ౕౖౘౙౠ-ౣ౦-౯ಂಃಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹ಼-ೄೆ-ೈೊ-್ೕೖೞೠ-ೣ೦-೯ೱೲംഃഅ-ഌഎ-ഐഒ-ഺഽ-ൄെ-ൈൊ-ൎൗൠ-ൣ൦-൯ൺ-ൿංඃඅ-ඖක-නඳ-රලව-ෆ්ා-ුූෘ-ෟෲෳก-ฺเ-๎๐-๙ກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ູົ-ຽເ-ໄໆ່-ໍ໐-໙ໜ-ໟༀ༘༙༠-༩༹༵༷༾-ཇཉ-ཬཱ-྄྆-ྗྙ-ྼ࿆က-၉ၐ-ႝႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚ፝-፟ᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛰᜀ-ᜌᜎ-᜔ᜠ-᜴ᝀ-ᝓᝠ-ᝬᝮ-ᝰᝲᝳក-៓ៗៜ៝០-៩᠋-᠍᠐-᠙ᠠ-ᡷᢀ-ᢪᢰ-ᣵᤀ-ᤜᤠ-ᤫᤰ-᤻᥆-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉ᧐-᧙ᨀ-ᨛᨠ-ᩞ᩠-᩿᩼-᪉᪐-᪙ᪧᬀ-ᭋ᭐-᭙᭫-᭳ᮀ-᯳ᰀ-᰷᱀-᱉ᱍ-ᱽ᳐-᳔᳒-ᳶᴀ-ᷦ᷼-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼ‌‍‿⁀⁔ⁱⁿₐ-ₜ⃐-⃥⃜⃡-⃰ℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯ⵿-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⷠ-ⷿⸯ々-〇〡-〯〱-〵〸-〼ぁ-ゖ゙゚ゝ-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿌ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘫꙀ-꙯ꙴ-꙽ꙿ-ꚗꚟ-꛱ꜗ-ꜟꜢ-ꞈꞋ-ꞎꞐ-ꞓꞠ-Ɦꟸ-ꠧꡀ-ꡳꢀ-꣄꣐-꣙꣠-ꣷꣻ꤀-꤭ꤰ-꥓ꥠ-ꥼꦀ-꧀ꧏ-꧙ꨀ-ꨶꩀ-ꩍ꩐-꩙ꩠ-ꩶꩺꩻꪀ-ꫂꫛ-ꫝꫠ-ꫯꫲ-꫶ꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꯀ-ꯪ꯬꯭꯰-꯹가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻ︀-️︠-︦︳︴﹍-﹏ﹰ-ﹴﹶ-ﻼ０-９Ａ-Ｚ＿ａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ]")
};
function assert(condition, message) {
  if (!condition) {
    throw new Error("ASSERT: " + message);
  }
}
function isDecimalDigit(ch) {
  return ch >= 48 && ch <= 57;
}
function isHexDigit(ch) {
  return "0123456789abcdefABCDEF".indexOf(ch) >= 0;
}
function isOctalDigit(ch) {
  return "01234567".indexOf(ch) >= 0;
}
function isWhiteSpace(ch) {
  return ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(ch) >= 0;
}
function isLineTerminator(ch) {
  return ch === 10 || ch === 13 || ch === 8232 || ch === 8233;
}
function isIdentifierStart(ch) {
  return ch == 64 || // @ (for jsonpath)
  ch === 36 || ch === 95 || // $ (dollar) and _ (underscore)
  ch >= 65 && ch <= 90 || // A..Z
  ch >= 97 && ch <= 122 || // a..z
  ch === 92 || // \ (backslash)
  ch >= 128 && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch));
}
function isIdentifierPart(ch) {
  return ch === 36 || ch === 95 || // $ (dollar) and _ (underscore)
  ch >= 65 && ch <= 90 || // A..Z
  ch >= 97 && ch <= 122 || // a..z
  ch >= 48 && ch <= 57 || // 0..9
  ch === 92 || // \ (backslash)
  ch >= 128 && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch));
}
function isFutureReservedWord(id) {
  switch (id) {
    case "class":
    case "enum":
    case "export":
    case "extends":
    case "import":
    case "super":
      return true;
    default:
      return false;
  }
}
function isStrictModeReservedWord(id) {
  switch (id) {
    case "implements":
    case "interface":
    case "package":
    case "private":
    case "protected":
    case "public":
    case "static":
    case "yield":
    case "let":
      return true;
    default:
      return false;
  }
}
function isRestrictedWord(id) {
  return id === "eval" || id === "arguments";
}
function isKeyword(id) {
  if (strict && isStrictModeReservedWord(id)) {
    return true;
  }
  switch (id.length) {
    case 2:
      return id === "if" || id === "in" || id === "do";
    case 3:
      return id === "var" || id === "for" || id === "new" || id === "try" || id === "let";
    case 4:
      return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
    case 5:
      return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
    case 6:
      return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
    case 7:
      return id === "default" || id === "finally" || id === "extends";
    case 8:
      return id === "function" || id === "continue" || id === "debugger";
    case 10:
      return id === "instanceof";
    default:
      return false;
  }
}
function addComment(type, value, start, end, loc) {
  var comment, attacher;
  assert(typeof start === "number", "Comment must have valid position");
  if (state.lastCommentStart >= start) {
    return;
  }
  state.lastCommentStart = start;
  comment = {
    type,
    value
  };
  if (extra.range) {
    comment.range = [start, end];
  }
  if (extra.loc) {
    comment.loc = loc;
  }
  extra.comments.push(comment);
  if (extra.attachComment) {
    extra.leadingComments.push(comment);
    extra.trailingComments.push(comment);
  }
}
function skipSingleLineComment(offset) {
  var start, loc, ch, comment;
  start = index - offset;
  loc = {
    start: {
      line: lineNumber,
      column: index - lineStart - offset
    }
  };
  while (index < length) {
    ch = source.charCodeAt(index);
    ++index;
    if (isLineTerminator(ch)) {
      if (extra.comments) {
        comment = source.slice(start + offset, index - 1);
        loc.end = {
          line: lineNumber,
          column: index - lineStart - 1
        };
        addComment("Line", comment, start, index - 1, loc);
      }
      if (ch === 13 && source.charCodeAt(index) === 10) {
        ++index;
      }
      ++lineNumber;
      lineStart = index;
      return;
    }
  }
  if (extra.comments) {
    comment = source.slice(start + offset, index);
    loc.end = {
      line: lineNumber,
      column: index - lineStart
    };
    addComment("Line", comment, start, index, loc);
  }
}
function skipMultiLineComment() {
  var start, loc, ch, comment;
  if (extra.comments) {
    start = index - 2;
    loc = {
      start: {
        line: lineNumber,
        column: index - lineStart - 2
      }
    };
  }
  while (index < length) {
    ch = source.charCodeAt(index);
    if (isLineTerminator(ch)) {
      if (ch === 13 && source.charCodeAt(index + 1) === 10) {
        ++index;
      }
      ++lineNumber;
      ++index;
      lineStart = index;
      if (index >= length) {
        throwError({}, Messages.UnexpectedToken, "ILLEGAL");
      }
    } else if (ch === 42) {
      if (source.charCodeAt(index + 1) === 47) {
        ++index;
        ++index;
        if (extra.comments) {
          comment = source.slice(start + 2, index - 2);
          loc.end = {
            line: lineNumber,
            column: index - lineStart
          };
          addComment("Block", comment, start, index, loc);
        }
        return;
      }
      ++index;
    } else {
      ++index;
    }
  }
  throwError({}, Messages.UnexpectedToken, "ILLEGAL");
}
function skipComment() {
  var ch, start;
  start = index === 0;
  while (index < length) {
    ch = source.charCodeAt(index);
    if (isWhiteSpace(ch)) {
      ++index;
    } else if (isLineTerminator(ch)) {
      ++index;
      if (ch === 13 && source.charCodeAt(index) === 10) {
        ++index;
      }
      ++lineNumber;
      lineStart = index;
      start = true;
    } else if (ch === 47) {
      ch = source.charCodeAt(index + 1);
      if (ch === 47) {
        ++index;
        ++index;
        skipSingleLineComment(2);
        start = true;
      } else if (ch === 42) {
        ++index;
        ++index;
        skipMultiLineComment();
      } else {
        break;
      }
    } else if (start && ch === 45) {
      if (source.charCodeAt(index + 1) === 45 && source.charCodeAt(index + 2) === 62) {
        index += 3;
        skipSingleLineComment(3);
      } else {
        break;
      }
    } else if (ch === 60) {
      if (source.slice(index + 1, index + 4) === "!--") {
        ++index;
        ++index;
        ++index;
        ++index;
        skipSingleLineComment(4);
      } else {
        break;
      }
    } else {
      break;
    }
  }
}
function scanHexEscape(prefix) {
  var i, len, ch, code = 0;
  len = prefix === "u" ? 4 : 2;
  for (i = 0; i < len; ++i) {
    if (index < length && isHexDigit(source[index])) {
      ch = source[index++];
      code = code * 16 + "0123456789abcdef".indexOf(ch.toLowerCase());
    } else {
      return "";
    }
  }
  return String.fromCharCode(code);
}
function getEscapedIdentifier() {
  var ch, id;
  ch = source.charCodeAt(index++);
  id = String.fromCharCode(ch);
  if (ch === 92) {
    if (source.charCodeAt(index) !== 117) {
      throwError({}, Messages.UnexpectedToken, "ILLEGAL");
    }
    ++index;
    ch = scanHexEscape("u");
    if (!ch || ch === "\\" || !isIdentifierStart(ch.charCodeAt(0))) {
      throwError({}, Messages.UnexpectedToken, "ILLEGAL");
    }
    id = ch;
  }
  while (index < length) {
    ch = source.charCodeAt(index);
    if (!isIdentifierPart(ch)) {
      break;
    }
    ++index;
    id += String.fromCharCode(ch);
    if (ch === 92) {
      id = id.substr(0, id.length - 1);
      if (source.charCodeAt(index) !== 117) {
        throwError({}, Messages.UnexpectedToken, "ILLEGAL");
      }
      ++index;
      ch = scanHexEscape("u");
      if (!ch || ch === "\\" || !isIdentifierPart(ch.charCodeAt(0))) {
        throwError({}, Messages.UnexpectedToken, "ILLEGAL");
      }
      id += ch;
    }
  }
  return id;
}
function getIdentifier() {
  var start, ch;
  start = index++;
  while (index < length) {
    ch = source.charCodeAt(index);
    if (ch === 92) {
      index = start;
      return getEscapedIdentifier();
    }
    if (isIdentifierPart(ch)) {
      ++index;
    } else {
      break;
    }
  }
  return source.slice(start, index);
}
function scanIdentifier() {
  var start, id, type;
  start = index;
  id = source.charCodeAt(index) === 92 ? getEscapedIdentifier() : getIdentifier();
  if (id.length === 1) {
    type = Token.Identifier;
  } else if (isKeyword(id)) {
    type = Token.Keyword;
  } else if (id === "null") {
    type = Token.NullLiteral;
  } else if (id === "true" || id === "false") {
    type = Token.BooleanLiteral;
  } else {
    type = Token.Identifier;
  }
  return {
    type,
    value: id,
    lineNumber,
    lineStart,
    start,
    end: index
  };
}
function scanPunctuator() {
  var start = index, code = source.charCodeAt(index), code2, ch1 = source[index], ch2, ch3, ch4;
  switch (code) {
    case 46:
    case 40:
    case 41:
    case 59:
    case 44:
    case 123:
    case 125:
    case 91:
    case 93:
    case 58:
    case 63:
    case 126:
      ++index;
      if (extra.tokenize) {
        if (code === 40) {
          extra.openParenToken = extra.tokens.length;
        } else if (code === 123) {
          extra.openCurlyToken = extra.tokens.length;
        }
      }
      return {
        type: Token.Punctuator,
        value: String.fromCharCode(code),
        lineNumber,
        lineStart,
        start,
        end: index
      };
    default:
      code2 = source.charCodeAt(index + 1);
      if (code2 === 61) {
        switch (code) {
          case 43:
          case 45:
          case 47:
          case 60:
          case 62:
          case 94:
          case 124:
          case 37:
          case 38:
          case 42:
            index += 2;
            return {
              type: Token.Punctuator,
              value: String.fromCharCode(code) + String.fromCharCode(code2),
              lineNumber,
              lineStart,
              start,
              end: index
            };
          case 33:
          case 61:
            index += 2;
            if (source.charCodeAt(index) === 61) {
              ++index;
            }
            return {
              type: Token.Punctuator,
              value: source.slice(start, index),
              lineNumber,
              lineStart,
              start,
              end: index
            };
        }
      }
  }
  ch4 = source.substr(index, 4);
  if (ch4 === ">>>=") {
    index += 4;
    return {
      type: Token.Punctuator,
      value: ch4,
      lineNumber,
      lineStart,
      start,
      end: index
    };
  }
  ch3 = ch4.substr(0, 3);
  if (ch3 === ">>>" || ch3 === "<<=" || ch3 === ">>=") {
    index += 3;
    return {
      type: Token.Punctuator,
      value: ch3,
      lineNumber,
      lineStart,
      start,
      end: index
    };
  }
  ch2 = ch3.substr(0, 2);
  if (ch1 === ch2[1] && "+-<>&|".indexOf(ch1) >= 0 || ch2 === "=>") {
    index += 2;
    return {
      type: Token.Punctuator,
      value: ch2,
      lineNumber,
      lineStart,
      start,
      end: index
    };
  }
  if ("<>=!+-*%&|^/".indexOf(ch1) >= 0) {
    ++index;
    return {
      type: Token.Punctuator,
      value: ch1,
      lineNumber,
      lineStart,
      start,
      end: index
    };
  }
  throwError({}, Messages.UnexpectedToken, "ILLEGAL");
}
function scanHexLiteral(start) {
  var number = "";
  while (index < length) {
    if (!isHexDigit(source[index])) {
      break;
    }
    number += source[index++];
  }
  if (number.length === 0) {
    throwError({}, Messages.UnexpectedToken, "ILLEGAL");
  }
  if (isIdentifierStart(source.charCodeAt(index))) {
    throwError({}, Messages.UnexpectedToken, "ILLEGAL");
  }
  return {
    type: Token.NumericLiteral,
    value: parseInt("0x" + number, 16),
    lineNumber,
    lineStart,
    start,
    end: index
  };
}
function scanOctalLiteral(start) {
  var number = "0" + source[index++];
  while (index < length) {
    if (!isOctalDigit(source[index])) {
      break;
    }
    number += source[index++];
  }
  if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
    throwError({}, Messages.UnexpectedToken, "ILLEGAL");
  }
  return {
    type: Token.NumericLiteral,
    value: parseInt(number, 8),
    octal: true,
    lineNumber,
    lineStart,
    start,
    end: index
  };
}
function scanNumericLiteral() {
  var number, start, ch;
  ch = source[index];
  assert(isDecimalDigit(ch.charCodeAt(0)) || ch === ".", "Numeric literal must start with a decimal digit or a decimal point");
  start = index;
  number = "";
  if (ch !== ".") {
    number = source[index++];
    ch = source[index];
    if (number === "0") {
      if (ch === "x" || ch === "X") {
        ++index;
        return scanHexLiteral(start);
      }
      if (isOctalDigit(ch)) {
        return scanOctalLiteral(start);
      }
      if (ch && isDecimalDigit(ch.charCodeAt(0))) {
        throwError({}, Messages.UnexpectedToken, "ILLEGAL");
      }
    }
    while (isDecimalDigit(source.charCodeAt(index))) {
      number += source[index++];
    }
    ch = source[index];
  }
  if (ch === ".") {
    number += source[index++];
    while (isDecimalDigit(source.charCodeAt(index))) {
      number += source[index++];
    }
    ch = source[index];
  }
  if (ch === "e" || ch === "E") {
    number += source[index++];
    ch = source[index];
    if (ch === "+" || ch === "-") {
      number += source[index++];
    }
    if (isDecimalDigit(source.charCodeAt(index))) {
      while (isDecimalDigit(source.charCodeAt(index))) {
        number += source[index++];
      }
    } else {
      throwError({}, Messages.UnexpectedToken, "ILLEGAL");
    }
  }
  if (isIdentifierStart(source.charCodeAt(index))) {
    throwError({}, Messages.UnexpectedToken, "ILLEGAL");
  }
  return {
    type: Token.NumericLiteral,
    value: parseFloat(number),
    lineNumber,
    lineStart,
    start,
    end: index
  };
}
function scanStringLiteral() {
  var str = "", quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;
  startLineNumber = lineNumber;
  startLineStart = lineStart;
  quote = source[index];
  assert(quote === "'" || quote === '"', "String literal must starts with a quote");
  start = index;
  ++index;
  while (index < length) {
    ch = source[index++];
    if (ch === quote) {
      quote = "";
      break;
    } else if (ch === "\\") {
      ch = source[index++];
      if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
        switch (ch) {
          case "u":
          case "x":
            restore = index;
            unescaped = scanHexEscape(ch);
            if (unescaped) {
              str += unescaped;
            } else {
              index = restore;
              str += ch;
            }
            break;
          case "n":
            str += "\n";
            break;
          case "r":
            str += "\r";
            break;
          case "t":
            str += "	";
            break;
          case "b":
            str += "\b";
            break;
          case "f":
            str += "\f";
            break;
          case "v":
            str += "\v";
            break;
          default:
            if (isOctalDigit(ch)) {
              code = "01234567".indexOf(ch);
              if (code !== 0) {
                octal = true;
              }
              if (index < length && isOctalDigit(source[index])) {
                octal = true;
                code = code * 8 + "01234567".indexOf(source[index++]);
                if ("0123".indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {
                  code = code * 8 + "01234567".indexOf(source[index++]);
                }
              }
              str += String.fromCharCode(code);
            } else {
              str += ch;
            }
            break;
        }
      } else {
        ++lineNumber;
        if (ch === "\r" && source[index] === "\n") {
          ++index;
        }
        lineStart = index;
      }
    } else if (isLineTerminator(ch.charCodeAt(0))) {
      break;
    } else {
      str += ch;
    }
  }
  if (quote !== "") {
    throwError({}, Messages.UnexpectedToken, "ILLEGAL");
  }
  return {
    type: Token.StringLiteral,
    value: str,
    octal,
    startLineNumber,
    startLineStart,
    lineNumber,
    lineStart,
    start,
    end: index
  };
}
function testRegExp(pattern, flags) {
  var value;
  try {
    value = new RegExp(pattern, flags);
  } catch (e2) {
    throwError({}, Messages.InvalidRegExp);
  }
  return value;
}
function scanRegExpBody() {
  var ch, str, classMarker, terminated, body;
  ch = source[index];
  assert(ch === "/", "Regular expression literal must start with a slash");
  str = source[index++];
  classMarker = false;
  terminated = false;
  while (index < length) {
    ch = source[index++];
    str += ch;
    if (ch === "\\") {
      ch = source[index++];
      if (isLineTerminator(ch.charCodeAt(0))) {
        throwError({}, Messages.UnterminatedRegExp);
      }
      str += ch;
    } else if (isLineTerminator(ch.charCodeAt(0))) {
      throwError({}, Messages.UnterminatedRegExp);
    } else if (classMarker) {
      if (ch === "]") {
        classMarker = false;
      }
    } else {
      if (ch === "/") {
        terminated = true;
        break;
      } else if (ch === "[") {
        classMarker = true;
      }
    }
  }
  if (!terminated) {
    throwError({}, Messages.UnterminatedRegExp);
  }
  body = str.substr(1, str.length - 2);
  return {
    value: body,
    literal: str
  };
}
function scanRegExpFlags() {
  var ch, str, flags, restore;
  str = "";
  flags = "";
  while (index < length) {
    ch = source[index];
    if (!isIdentifierPart(ch.charCodeAt(0))) {
      break;
    }
    ++index;
    if (ch === "\\" && index < length) {
      ch = source[index];
      if (ch === "u") {
        ++index;
        restore = index;
        ch = scanHexEscape("u");
        if (ch) {
          flags += ch;
          for (str += "\\u"; restore < index; ++restore) {
            str += source[restore];
          }
        } else {
          index = restore;
          flags += "u";
          str += "\\u";
        }
        throwErrorTolerant({}, Messages.UnexpectedToken, "ILLEGAL");
      } else {
        str += "\\";
        throwErrorTolerant({}, Messages.UnexpectedToken, "ILLEGAL");
      }
    } else {
      flags += ch;
      str += ch;
    }
  }
  return {
    value: flags,
    literal: str
  };
}
function scanRegExp() {
  var start, body, flags, pattern, value;
  lookahead = null;
  skipComment();
  start = index;
  body = scanRegExpBody();
  flags = scanRegExpFlags();
  value = testRegExp(body.value, flags.value);
  if (extra.tokenize) {
    return {
      type: Token.RegularExpression,
      value,
      lineNumber,
      lineStart,
      start,
      end: index
    };
  }
  return {
    literal: body.literal + flags.literal,
    value,
    start,
    end: index
  };
}
function collectRegex() {
  var pos, loc, regex, token;
  skipComment();
  pos = index;
  loc = {
    start: {
      line: lineNumber,
      column: index - lineStart
    }
  };
  regex = scanRegExp();
  loc.end = {
    line: lineNumber,
    column: index - lineStart
  };
  if (!extra.tokenize) {
    if (extra.tokens.length > 0) {
      token = extra.tokens[extra.tokens.length - 1];
      if (token.range[0] === pos && token.type === "Punctuator") {
        if (token.value === "/" || token.value === "/=") {
          extra.tokens.pop();
        }
      }
    }
    extra.tokens.push({
      type: "RegularExpression",
      value: regex.literal,
      range: [pos, index],
      loc
    });
  }
  return regex;
}
function isIdentifierName(token) {
  return token.type === Token.Identifier || token.type === Token.Keyword || token.type === Token.BooleanLiteral || token.type === Token.NullLiteral;
}
function advanceSlash() {
  var prevToken, checkToken;
  prevToken = extra.tokens[extra.tokens.length - 1];
  if (!prevToken) {
    return collectRegex();
  }
  if (prevToken.type === "Punctuator") {
    if (prevToken.value === "]") {
      return scanPunctuator();
    }
    if (prevToken.value === ")") {
      checkToken = extra.tokens[extra.openParenToken - 1];
      if (checkToken && checkToken.type === "Keyword" && (checkToken.value === "if" || checkToken.value === "while" || checkToken.value === "for" || checkToken.value === "with")) {
        return collectRegex();
      }
      return scanPunctuator();
    }
    if (prevToken.value === "}") {
      if (extra.tokens[extra.openCurlyToken - 3] && extra.tokens[extra.openCurlyToken - 3].type === "Keyword") {
        checkToken = extra.tokens[extra.openCurlyToken - 4];
        if (!checkToken) {
          return scanPunctuator();
        }
      } else if (extra.tokens[extra.openCurlyToken - 4] && extra.tokens[extra.openCurlyToken - 4].type === "Keyword") {
        checkToken = extra.tokens[extra.openCurlyToken - 5];
        if (!checkToken) {
          return collectRegex();
        }
      } else {
        return scanPunctuator();
      }
      if (FnExprTokens.indexOf(checkToken.value) >= 0) {
        return scanPunctuator();
      }
      return collectRegex();
    }
    return collectRegex();
  }
  if (prevToken.type === "Keyword") {
    return collectRegex();
  }
  return scanPunctuator();
}
function advance() {
  var ch;
  skipComment();
  if (index >= length) {
    return {
      type: Token.EOF,
      lineNumber,
      lineStart,
      start: index,
      end: index
    };
  }
  ch = source.charCodeAt(index);
  if (isIdentifierStart(ch)) {
    return scanIdentifier();
  }
  if (ch === 40 || ch === 41 || ch === 59) {
    return scanPunctuator();
  }
  if (ch === 39 || ch === 34) {
    return scanStringLiteral();
  }
  if (ch === 46) {
    if (isDecimalDigit(source.charCodeAt(index + 1))) {
      return scanNumericLiteral();
    }
    return scanPunctuator();
  }
  if (isDecimalDigit(ch)) {
    return scanNumericLiteral();
  }
  if (extra.tokenize && ch === 47) {
    return advanceSlash();
  }
  return scanPunctuator();
}
function collectToken() {
  var loc, token, range, value;
  skipComment();
  loc = {
    start: {
      line: lineNumber,
      column: index - lineStart
    }
  };
  token = advance();
  loc.end = {
    line: lineNumber,
    column: index - lineStart
  };
  if (token.type !== Token.EOF) {
    value = source.slice(token.start, token.end);
    extra.tokens.push({
      type: TokenName[token.type],
      value,
      range: [token.start, token.end],
      loc
    });
  }
  return token;
}
function lex() {
  var token;
  token = lookahead;
  index = token.end;
  lineNumber = token.lineNumber;
  lineStart = token.lineStart;
  lookahead = typeof extra.tokens !== "undefined" ? collectToken() : advance();
  index = token.end;
  lineNumber = token.lineNumber;
  lineStart = token.lineStart;
  return token;
}
function peek() {
  var pos, line, start;
  pos = index;
  line = lineNumber;
  start = lineStart;
  lookahead = typeof extra.tokens !== "undefined" ? collectToken() : advance();
  index = pos;
  lineNumber = line;
  lineStart = start;
}
function Position(line, column) {
  this.line = line;
  this.column = column;
}
function SourceLocation(startLine, startColumn, line, column) {
  this.start = new Position(startLine, startColumn);
  this.end = new Position(line, column);
}
SyntaxTreeDelegate = {
  name: "SyntaxTree",
  processComment: function(node) {
    var lastChild, trailingComments;
    if (node.type === Syntax.Program) {
      if (node.body.length > 0) {
        return;
      }
    }
    if (extra.trailingComments.length > 0) {
      if (extra.trailingComments[0].range[0] >= node.range[1]) {
        trailingComments = extra.trailingComments;
        extra.trailingComments = [];
      } else {
        extra.trailingComments.length = 0;
      }
    } else {
      if (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments && extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments[0].range[0] >= node.range[1]) {
        trailingComments = extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
        delete extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
      }
    }
    while (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].range[0] >= node.range[0]) {
      lastChild = extra.bottomRightStack.pop();
    }
    if (lastChild) {
      if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {
        node.leadingComments = lastChild.leadingComments;
        delete lastChild.leadingComments;
      }
    } else if (extra.leadingComments.length > 0 && extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {
      node.leadingComments = extra.leadingComments;
      extra.leadingComments = [];
    }
    if (trailingComments) {
      node.trailingComments = trailingComments;
    }
    extra.bottomRightStack.push(node);
  },
  markEnd: function(node, startToken) {
    if (extra.range) {
      node.range = [startToken.start, index];
    }
    if (extra.loc) {
      node.loc = new SourceLocation(startToken.startLineNumber === void 0 ? startToken.lineNumber : startToken.startLineNumber, startToken.start - (startToken.startLineStart === void 0 ? startToken.lineStart : startToken.startLineStart), lineNumber, index - lineStart);
      this.postProcess(node);
    }
    if (extra.attachComment) {
      this.processComment(node);
    }
    return node;
  },
  postProcess: function(node) {
    if (extra.source) {
      node.loc.source = extra.source;
    }
    return node;
  },
  createArrayExpression: function(elements) {
    return {
      type: Syntax.ArrayExpression,
      elements
    };
  },
  createAssignmentExpression: function(operator, left, right) {
    return {
      type: Syntax.AssignmentExpression,
      operator,
      left,
      right
    };
  },
  createBinaryExpression: function(operator, left, right) {
    var type = operator === "||" || operator === "&&" ? Syntax.LogicalExpression : Syntax.BinaryExpression;
    return {
      type,
      operator,
      left,
      right
    };
  },
  createBlockStatement: function(body) {
    return {
      type: Syntax.BlockStatement,
      body
    };
  },
  createBreakStatement: function(label) {
    return {
      type: Syntax.BreakStatement,
      label
    };
  },
  createCallExpression: function(callee, args) {
    return {
      type: Syntax.CallExpression,
      callee,
      "arguments": args
    };
  },
  createCatchClause: function(param, body) {
    return {
      type: Syntax.CatchClause,
      param,
      body
    };
  },
  createConditionalExpression: function(test, consequent, alternate) {
    return {
      type: Syntax.ConditionalExpression,
      test,
      consequent,
      alternate
    };
  },
  createContinueStatement: function(label) {
    return {
      type: Syntax.ContinueStatement,
      label
    };
  },
  createDebuggerStatement: function() {
    return {
      type: Syntax.DebuggerStatement
    };
  },
  createDoWhileStatement: function(body, test) {
    return {
      type: Syntax.DoWhileStatement,
      body,
      test
    };
  },
  createEmptyStatement: function() {
    return {
      type: Syntax.EmptyStatement
    };
  },
  createExpressionStatement: function(expression) {
    return {
      type: Syntax.ExpressionStatement,
      expression
    };
  },
  createForStatement: function(init, test, update, body) {
    return {
      type: Syntax.ForStatement,
      init,
      test,
      update,
      body
    };
  },
  createForInStatement: function(left, right, body) {
    return {
      type: Syntax.ForInStatement,
      left,
      right,
      body,
      each: false
    };
  },
  createFunctionDeclaration: function(id, params, defaults, body) {
    return {
      type: Syntax.FunctionDeclaration,
      id,
      params,
      defaults,
      body,
      rest: null,
      generator: false,
      expression: false
    };
  },
  createFunctionExpression: function(id, params, defaults, body) {
    return {
      type: Syntax.FunctionExpression,
      id,
      params,
      defaults,
      body,
      rest: null,
      generator: false,
      expression: false
    };
  },
  createIdentifier: function(name) {
    return {
      type: Syntax.Identifier,
      name
    };
  },
  createIfStatement: function(test, consequent, alternate) {
    return {
      type: Syntax.IfStatement,
      test,
      consequent,
      alternate
    };
  },
  createLabeledStatement: function(label, body) {
    return {
      type: Syntax.LabeledStatement,
      label,
      body
    };
  },
  createLiteral: function(token) {
    return {
      type: Syntax.Literal,
      value: token.value,
      raw: source.slice(token.start, token.end)
    };
  },
  createMemberExpression: function(accessor, object, property) {
    return {
      type: Syntax.MemberExpression,
      computed: accessor === "[",
      object,
      property
    };
  },
  createNewExpression: function(callee, args) {
    return {
      type: Syntax.NewExpression,
      callee,
      "arguments": args
    };
  },
  createObjectExpression: function(properties) {
    return {
      type: Syntax.ObjectExpression,
      properties
    };
  },
  createPostfixExpression: function(operator, argument) {
    return {
      type: Syntax.UpdateExpression,
      operator,
      argument,
      prefix: false
    };
  },
  createProgram: function(body) {
    return {
      type: Syntax.Program,
      body
    };
  },
  createProperty: function(kind, key, value) {
    return {
      type: Syntax.Property,
      key,
      value,
      kind
    };
  },
  createReturnStatement: function(argument) {
    return {
      type: Syntax.ReturnStatement,
      argument
    };
  },
  createSequenceExpression: function(expressions) {
    return {
      type: Syntax.SequenceExpression,
      expressions
    };
  },
  createSwitchCase: function(test, consequent) {
    return {
      type: Syntax.SwitchCase,
      test,
      consequent
    };
  },
  createSwitchStatement: function(discriminant, cases) {
    return {
      type: Syntax.SwitchStatement,
      discriminant,
      cases
    };
  },
  createThisExpression: function() {
    return {
      type: Syntax.ThisExpression
    };
  },
  createThrowStatement: function(argument) {
    return {
      type: Syntax.ThrowStatement,
      argument
    };
  },
  createTryStatement: function(block, guardedHandlers, handlers, finalizer) {
    return {
      type: Syntax.TryStatement,
      block,
      guardedHandlers,
      handlers,
      finalizer
    };
  },
  createUnaryExpression: function(operator, argument) {
    if (operator === "++" || operator === "--") {
      return {
        type: Syntax.UpdateExpression,
        operator,
        argument,
        prefix: true
      };
    }
    return {
      type: Syntax.UnaryExpression,
      operator,
      argument,
      prefix: true
    };
  },
  createVariableDeclaration: function(declarations, kind) {
    return {
      type: Syntax.VariableDeclaration,
      declarations,
      kind
    };
  },
  createVariableDeclarator: function(id, init) {
    return {
      type: Syntax.VariableDeclarator,
      id,
      init
    };
  },
  createWhileStatement: function(test, body) {
    return {
      type: Syntax.WhileStatement,
      test,
      body
    };
  },
  createWithStatement: function(object, body) {
    return {
      type: Syntax.WithStatement,
      object,
      body
    };
  }
};
function peekLineTerminator() {
  var pos, line, start, found;
  pos = index;
  line = lineNumber;
  start = lineStart;
  skipComment();
  found = lineNumber !== line;
  index = pos;
  lineNumber = line;
  lineStart = start;
  return found;
}
function throwError(token, messageFormat) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  var error, msg = messageFormat.replace(/%(\d)/g, function(whole, index2) {
    assert(index2 < args.length, "Message reference must be in range");
    return args[index2];
  });
  if (typeof token.lineNumber === "number") {
    error = new Error("Line " + token.lineNumber + ": " + msg);
    error.index = token.start;
    error.lineNumber = token.lineNumber;
    error.column = token.start - lineStart + 1;
  } else {
    error = new Error("Line " + lineNumber + ": " + msg);
    error.index = index;
    error.lineNumber = lineNumber;
    error.column = index - lineStart + 1;
  }
  error.description = msg;
  throw error;
}
function throwErrorTolerant() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  try {
    throwError.apply(null, args);
  } catch (e2) {
    if (extra.errors) {
      extra.errors.push(e2);
    } else {
      throw e2;
    }
  }
}
function throwUnexpected(token) {
  if (token.type === Token.EOF) {
    throwError(token, Messages.UnexpectedEOS);
  }
  if (token.type === Token.NumericLiteral) {
    throwError(token, Messages.UnexpectedNumber);
  }
  if (token.type === Token.StringLiteral) {
    throwError(token, Messages.UnexpectedString);
  }
  if (token.type === Token.Identifier) {
    throwError(token, Messages.UnexpectedIdentifier);
  }
  if (token.type === Token.Keyword) {
    if (isFutureReservedWord(token.value)) {
      throwError(token, Messages.UnexpectedReserved);
    } else if (strict && isStrictModeReservedWord(token.value)) {
      throwErrorTolerant(token, Messages.StrictReservedWord);
      return;
    }
    throwError(token, Messages.UnexpectedToken, token.value);
  }
  throwError(token, Messages.UnexpectedToken, token.value);
}
function expect(value) {
  var token = lex();
  if (token.type !== Token.Punctuator || token.value !== value) {
    throwUnexpected(token);
  }
}
function expectKeyword(keyword) {
  var token = lex();
  if (token.type !== Token.Keyword || token.value !== keyword) {
    throwUnexpected(token);
  }
}
function match(value) {
  return lookahead.type === Token.Punctuator && lookahead.value === value;
}
function matchKeyword(keyword) {
  return lookahead.type === Token.Keyword && lookahead.value === keyword;
}
function matchAssign() {
  var op;
  if (lookahead.type !== Token.Punctuator) {
    return false;
  }
  op = lookahead.value;
  return op === "=" || op === "*=" || op === "/=" || op === "%=" || op === "+=" || op === "-=" || op === "<<=" || op === ">>=" || op === ">>>=" || op === "&=" || op === "^=" || op === "|=";
}
function consumeSemicolon() {
  var line;
  if (source.charCodeAt(index) === 59 || match(";")) {
    lex();
    return;
  }
  line = lineNumber;
  skipComment();
  if (lineNumber !== line) {
    return;
  }
  if (lookahead.type !== Token.EOF && !match("}")) {
    throwUnexpected(lookahead);
  }
}
function isLeftHandSide(expr) {
  return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
}
function parseArrayInitialiser() {
  var elements = [], startToken;
  startToken = lookahead;
  expect("[");
  while (!match("]")) {
    if (match(",")) {
      lex();
      elements.push(null);
    } else {
      elements.push(parseAssignmentExpression());
      if (!match("]")) {
        expect(",");
      }
    }
  }
  lex();
  return delegate.markEnd(delegate.createArrayExpression(elements), startToken);
}
function parsePropertyFunction(param, first) {
  var previousStrict, body, startToken;
  previousStrict = strict;
  startToken = lookahead;
  body = parseFunctionSourceElements();
  if (first && strict && isRestrictedWord(param[0].name)) {
    throwErrorTolerant(first, Messages.StrictParamName);
  }
  strict = previousStrict;
  return delegate.markEnd(delegate.createFunctionExpression(null, param, [], body), startToken);
}
function parseObjectPropertyKey() {
  var token, startToken;
  startToken = lookahead;
  token = lex();
  if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
    if (strict && token.octal) {
      throwErrorTolerant(token, Messages.StrictOctalLiteral);
    }
    return delegate.markEnd(delegate.createLiteral(token), startToken);
  }
  return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
}
function parseObjectProperty() {
  var token, key, id, value, param, startToken;
  token = lookahead;
  startToken = lookahead;
  if (token.type === Token.Identifier) {
    id = parseObjectPropertyKey();
    if (token.value === "get" && !match(":")) {
      key = parseObjectPropertyKey();
      expect("(");
      expect(")");
      value = parsePropertyFunction([]);
      return delegate.markEnd(delegate.createProperty("get", key, value), startToken);
    }
    if (token.value === "set" && !match(":")) {
      key = parseObjectPropertyKey();
      expect("(");
      token = lookahead;
      if (token.type !== Token.Identifier) {
        expect(")");
        throwErrorTolerant(token, Messages.UnexpectedToken, token.value);
        value = parsePropertyFunction([]);
      } else {
        param = [parseVariableIdentifier()];
        expect(")");
        value = parsePropertyFunction(param, token);
      }
      return delegate.markEnd(delegate.createProperty("set", key, value), startToken);
    }
    expect(":");
    value = parseAssignmentExpression();
    return delegate.markEnd(delegate.createProperty("init", id, value), startToken);
  }
  if (token.type === Token.EOF || token.type === Token.Punctuator) {
    throwUnexpected(token);
  } else {
    key = parseObjectPropertyKey();
    expect(":");
    value = parseAssignmentExpression();
    return delegate.markEnd(delegate.createProperty("init", key, value), startToken);
  }
}
function parseObjectInitialiser() {
  var properties = [], property, name, key, kind, map = {}, toString = String, startToken;
  startToken = lookahead;
  expect("{");
  while (!match("}")) {
    property = parseObjectProperty();
    if (property.key.type === Syntax.Identifier) {
      name = property.key.name;
    } else {
      name = toString(property.key.value);
    }
    kind = property.kind === "init" ? PropertyKind.Data : property.kind === "get" ? PropertyKind.Get : PropertyKind.Set;
    key = "$" + name;
    if (Object.prototype.hasOwnProperty.call(map, key)) {
      if (map[key] === PropertyKind.Data) {
        if (strict && kind === PropertyKind.Data) {
          throwErrorTolerant({}, Messages.StrictDuplicateProperty);
        } else if (kind !== PropertyKind.Data) {
          throwErrorTolerant({}, Messages.AccessorDataProperty);
        }
      } else {
        if (kind === PropertyKind.Data) {
          throwErrorTolerant({}, Messages.AccessorDataProperty);
        } else if (map[key] & kind) {
          throwErrorTolerant({}, Messages.AccessorGetSet);
        }
      }
      map[key] |= kind;
    } else {
      map[key] = kind;
    }
    properties.push(property);
    if (!match("}")) {
      expect(",");
    }
  }
  expect("}");
  return delegate.markEnd(delegate.createObjectExpression(properties), startToken);
}
function parseGroupExpression() {
  var expr;
  expect("(");
  expr = parseExpression();
  expect(")");
  return expr;
}
function parsePrimaryExpression() {
  var type, token, expr, startToken;
  if (match("(")) {
    return parseGroupExpression();
  }
  if (match("[")) {
    return parseArrayInitialiser();
  }
  if (match("{")) {
    return parseObjectInitialiser();
  }
  type = lookahead.type;
  startToken = lookahead;
  if (type === Token.Identifier) {
    expr = delegate.createIdentifier(lex().value);
  } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
    if (strict && lookahead.octal) {
      throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
    }
    expr = delegate.createLiteral(lex());
  } else if (type === Token.Keyword) {
    if (matchKeyword("function")) {
      return parseFunctionExpression();
    }
    if (matchKeyword("this")) {
      lex();
      expr = delegate.createThisExpression();
    } else {
      throwUnexpected(lex());
    }
  } else if (type === Token.BooleanLiteral) {
    token = lex();
    token.value = token.value === "true";
    expr = delegate.createLiteral(token);
  } else if (type === Token.NullLiteral) {
    token = lex();
    token.value = null;
    expr = delegate.createLiteral(token);
  } else if (match("/") || match("/=")) {
    if (typeof extra.tokens !== "undefined") {
      expr = delegate.createLiteral(collectRegex());
    } else {
      expr = delegate.createLiteral(scanRegExp());
    }
    peek();
  } else {
    throwUnexpected(lex());
  }
  return delegate.markEnd(expr, startToken);
}
function parseArguments() {
  var args = [];
  expect("(");
  if (!match(")")) {
    while (index < length) {
      args.push(parseAssignmentExpression());
      if (match(")")) {
        break;
      }
      expect(",");
    }
  }
  expect(")");
  return args;
}
function parseNonComputedProperty() {
  var token, startToken;
  startToken = lookahead;
  token = lex();
  if (!isIdentifierName(token)) {
    throwUnexpected(token);
  }
  return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
}
function parseNonComputedMember() {
  expect(".");
  return parseNonComputedProperty();
}
function parseComputedMember() {
  var expr;
  expect("[");
  expr = parseExpression();
  expect("]");
  return expr;
}
function parseNewExpression() {
  var callee, args, startToken;
  startToken = lookahead;
  expectKeyword("new");
  callee = parseLeftHandSideExpression();
  args = match("(") ? parseArguments() : [];
  return delegate.markEnd(delegate.createNewExpression(callee, args), startToken);
}
function parseLeftHandSideExpressionAllowCall() {
  var previousAllowIn, expr, args, property, startToken;
  startToken = lookahead;
  previousAllowIn = state.allowIn;
  state.allowIn = true;
  expr = matchKeyword("new") ? parseNewExpression() : parsePrimaryExpression();
  state.allowIn = previousAllowIn;
  for (; ; ) {
    if (match(".")) {
      property = parseNonComputedMember();
      expr = delegate.createMemberExpression(".", expr, property);
    } else if (match("(")) {
      args = parseArguments();
      expr = delegate.createCallExpression(expr, args);
    } else if (match("[")) {
      property = parseComputedMember();
      expr = delegate.createMemberExpression("[", expr, property);
    } else {
      break;
    }
    delegate.markEnd(expr, startToken);
  }
  return expr;
}
function parseLeftHandSideExpression() {
  var previousAllowIn, expr, property, startToken;
  startToken = lookahead;
  previousAllowIn = state.allowIn;
  expr = matchKeyword("new") ? parseNewExpression() : parsePrimaryExpression();
  state.allowIn = previousAllowIn;
  while (match(".") || match("[")) {
    if (match("[")) {
      property = parseComputedMember();
      expr = delegate.createMemberExpression("[", expr, property);
    } else {
      property = parseNonComputedMember();
      expr = delegate.createMemberExpression(".", expr, property);
    }
    delegate.markEnd(expr, startToken);
  }
  return expr;
}
function parsePostfixExpression() {
  var expr, token, startToken = lookahead;
  expr = parseLeftHandSideExpressionAllowCall();
  if (lookahead.type === Token.Punctuator) {
    if ((match("++") || match("--")) && !peekLineTerminator()) {
      if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
        throwErrorTolerant({}, Messages.StrictLHSPostfix);
      }
      if (!isLeftHandSide(expr)) {
        throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
      }
      token = lex();
      expr = delegate.markEnd(delegate.createPostfixExpression(token.value, expr), startToken);
    }
  }
  return expr;
}
function parseUnaryExpression() {
  var token, expr, startToken;
  if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
    expr = parsePostfixExpression();
  } else if (match("++") || match("--")) {
    startToken = lookahead;
    token = lex();
    expr = parseUnaryExpression();
    if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
      throwErrorTolerant({}, Messages.StrictLHSPrefix);
    }
    if (!isLeftHandSide(expr)) {
      throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
    }
    expr = delegate.createUnaryExpression(token.value, expr);
    expr = delegate.markEnd(expr, startToken);
  } else if (match("+") || match("-") || match("~") || match("!")) {
    startToken = lookahead;
    token = lex();
    expr = parseUnaryExpression();
    expr = delegate.createUnaryExpression(token.value, expr);
    expr = delegate.markEnd(expr, startToken);
  } else if (matchKeyword("delete") || matchKeyword("void") || matchKeyword("typeof")) {
    startToken = lookahead;
    token = lex();
    expr = parseUnaryExpression();
    expr = delegate.createUnaryExpression(token.value, expr);
    expr = delegate.markEnd(expr, startToken);
    if (strict && expr.operator === "delete" && expr.argument.type === Syntax.Identifier) {
      throwErrorTolerant({}, Messages.StrictDelete);
    }
  } else {
    expr = parsePostfixExpression();
  }
  return expr;
}
function binaryPrecedence(token, allowIn) {
  var prec = 0;
  if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
    return 0;
  }
  switch (token.value) {
    case "||":
      prec = 1;
      break;
    case "&&":
      prec = 2;
      break;
    case "|":
      prec = 3;
      break;
    case "^":
      prec = 4;
      break;
    case "&":
      prec = 5;
      break;
    case "==":
    case "!=":
    case "===":
    case "!==":
      prec = 6;
      break;
    case "<":
    case ">":
    case "<=":
    case ">=":
    case "instanceof":
      prec = 7;
      break;
    case "in":
      prec = allowIn ? 7 : 0;
      break;
    case "<<":
    case ">>":
    case ">>>":
      prec = 8;
      break;
    case "+":
    case "-":
      prec = 9;
      break;
    case "*":
    case "/":
    case "%":
      prec = 11;
      break;
    default:
      break;
  }
  return prec;
}
function parseBinaryExpression() {
  var marker, markers, expr, token, prec, stack, right, operator, left, i;
  marker = lookahead;
  left = parseUnaryExpression();
  token = lookahead;
  prec = binaryPrecedence(token, state.allowIn);
  if (prec === 0) {
    return left;
  }
  token.prec = prec;
  lex();
  markers = [marker, lookahead];
  right = parseUnaryExpression();
  stack = [left, token, right];
  while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {
    while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {
      right = stack.pop();
      operator = stack.pop().value;
      left = stack.pop();
      expr = delegate.createBinaryExpression(operator, left, right);
      markers.pop();
      marker = markers[markers.length - 1];
      delegate.markEnd(expr, marker);
      stack.push(expr);
    }
    token = lex();
    token.prec = prec;
    stack.push(token);
    markers.push(lookahead);
    expr = parseUnaryExpression();
    stack.push(expr);
  }
  i = stack.length - 1;
  expr = stack[i];
  markers.pop();
  while (i > 1) {
    expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
    i -= 2;
    marker = markers.pop();
    delegate.markEnd(expr, marker);
  }
  return expr;
}
function parseConditionalExpression() {
  var expr, previousAllowIn, consequent, alternate, startToken;
  startToken = lookahead;
  expr = parseBinaryExpression();
  if (match("?")) {
    lex();
    previousAllowIn = state.allowIn;
    state.allowIn = true;
    consequent = parseAssignmentExpression();
    state.allowIn = previousAllowIn;
    expect(":");
    alternate = parseAssignmentExpression();
    expr = delegate.createConditionalExpression(expr, consequent, alternate);
    delegate.markEnd(expr, startToken);
  }
  return expr;
}
function parseAssignmentExpression() {
  var token, left, right, node, startToken;
  token = lookahead;
  startToken = lookahead;
  node = left = parseConditionalExpression();
  if (matchAssign()) {
    if (!isLeftHandSide(left)) {
      throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
    }
    if (strict && left.type === Syntax.Identifier && isRestrictedWord(left.name)) {
      throwErrorTolerant(token, Messages.StrictLHSAssignment);
    }
    token = lex();
    right = parseAssignmentExpression();
    node = delegate.markEnd(delegate.createAssignmentExpression(token.value, left, right), startToken);
  }
  return node;
}
function parseExpression() {
  var expr, startToken = lookahead;
  expr = parseAssignmentExpression();
  if (match(",")) {
    expr = delegate.createSequenceExpression([expr]);
    while (index < length) {
      if (!match(",")) {
        break;
      }
      lex();
      expr.expressions.push(parseAssignmentExpression());
    }
    delegate.markEnd(expr, startToken);
  }
  return expr;
}
function parseStatementList() {
  var list = [], statement;
  while (index < length) {
    if (match("}")) {
      break;
    }
    statement = parseSourceElement();
    if (typeof statement === "undefined") {
      break;
    }
    list.push(statement);
  }
  return list;
}
function parseBlock() {
  var block, startToken;
  startToken = lookahead;
  expect("{");
  block = parseStatementList();
  expect("}");
  return delegate.markEnd(delegate.createBlockStatement(block), startToken);
}
function parseVariableIdentifier() {
  var token, startToken;
  startToken = lookahead;
  token = lex();
  if (token.type !== Token.Identifier) {
    throwUnexpected(token);
  }
  return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
}
function parseVariableDeclaration(kind) {
  var init = null, id, startToken;
  startToken = lookahead;
  id = parseVariableIdentifier();
  if (strict && isRestrictedWord(id.name)) {
    throwErrorTolerant({}, Messages.StrictVarName);
  }
  if (kind === "const") {
    expect("=");
    init = parseAssignmentExpression();
  } else if (match("=")) {
    lex();
    init = parseAssignmentExpression();
  }
  return delegate.markEnd(delegate.createVariableDeclarator(id, init), startToken);
}
function parseVariableDeclarationList(kind) {
  var list = [];
  do {
    list.push(parseVariableDeclaration(kind));
    if (!match(",")) {
      break;
    }
    lex();
  } while (index < length);
  return list;
}
function parseVariableStatement() {
  var declarations;
  expectKeyword("var");
  declarations = parseVariableDeclarationList();
  consumeSemicolon();
  return delegate.createVariableDeclaration(declarations, "var");
}
function parseConstLetDeclaration(kind) {
  var declarations, startToken;
  startToken = lookahead;
  expectKeyword(kind);
  declarations = parseVariableDeclarationList(kind);
  consumeSemicolon();
  return delegate.markEnd(delegate.createVariableDeclaration(declarations, kind), startToken);
}
function parseEmptyStatement() {
  expect(";");
  return delegate.createEmptyStatement();
}
function parseExpressionStatement() {
  var expr = parseExpression();
  consumeSemicolon();
  return delegate.createExpressionStatement(expr);
}
function parseIfStatement() {
  var test, consequent, alternate;
  expectKeyword("if");
  expect("(");
  test = parseExpression();
  expect(")");
  consequent = parseStatement();
  if (matchKeyword("else")) {
    lex();
    alternate = parseStatement();
  } else {
    alternate = null;
  }
  return delegate.createIfStatement(test, consequent, alternate);
}
function parseDoWhileStatement() {
  var body, test, oldInIteration;
  expectKeyword("do");
  oldInIteration = state.inIteration;
  state.inIteration = true;
  body = parseStatement();
  state.inIteration = oldInIteration;
  expectKeyword("while");
  expect("(");
  test = parseExpression();
  expect(")");
  if (match(";")) {
    lex();
  }
  return delegate.createDoWhileStatement(body, test);
}
function parseWhileStatement() {
  var test, body, oldInIteration;
  expectKeyword("while");
  expect("(");
  test = parseExpression();
  expect(")");
  oldInIteration = state.inIteration;
  state.inIteration = true;
  body = parseStatement();
  state.inIteration = oldInIteration;
  return delegate.createWhileStatement(test, body);
}
function parseForVariableDeclaration() {
  var token, declarations, startToken;
  startToken = lookahead;
  token = lex();
  declarations = parseVariableDeclarationList();
  return delegate.markEnd(delegate.createVariableDeclaration(declarations, token.value), startToken);
}
function parseForStatement() {
  var init, test, update, left, right, body, oldInIteration;
  init = test = update = null;
  expectKeyword("for");
  expect("(");
  if (match(";")) {
    lex();
  } else {
    if (matchKeyword("var") || matchKeyword("let")) {
      state.allowIn = false;
      init = parseForVariableDeclaration();
      state.allowIn = true;
      if (init.declarations.length === 1 && matchKeyword("in")) {
        lex();
        left = init;
        right = parseExpression();
        init = null;
      }
    } else {
      state.allowIn = false;
      init = parseExpression();
      state.allowIn = true;
      if (matchKeyword("in")) {
        if (!isLeftHandSide(init)) {
          throwErrorTolerant({}, Messages.InvalidLHSInForIn);
        }
        lex();
        left = init;
        right = parseExpression();
        init = null;
      }
    }
    if (typeof left === "undefined") {
      expect(";");
    }
  }
  if (typeof left === "undefined") {
    if (!match(";")) {
      test = parseExpression();
    }
    expect(";");
    if (!match(")")) {
      update = parseExpression();
    }
  }
  expect(")");
  oldInIteration = state.inIteration;
  state.inIteration = true;
  body = parseStatement();
  state.inIteration = oldInIteration;
  return typeof left === "undefined" ? delegate.createForStatement(init, test, update, body) : delegate.createForInStatement(left, right, body);
}
function parseContinueStatement() {
  var label = null, key;
  expectKeyword("continue");
  if (source.charCodeAt(index) === 59) {
    lex();
    if (!state.inIteration) {
      throwError({}, Messages.IllegalContinue);
    }
    return delegate.createContinueStatement(null);
  }
  if (peekLineTerminator()) {
    if (!state.inIteration) {
      throwError({}, Messages.IllegalContinue);
    }
    return delegate.createContinueStatement(null);
  }
  if (lookahead.type === Token.Identifier) {
    label = parseVariableIdentifier();
    key = "$" + label.name;
    if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
      throwError({}, Messages.UnknownLabel, label.name);
    }
  }
  consumeSemicolon();
  if (label === null && !state.inIteration) {
    throwError({}, Messages.IllegalContinue);
  }
  return delegate.createContinueStatement(label);
}
function parseBreakStatement() {
  var label = null, key;
  expectKeyword("break");
  if (source.charCodeAt(index) === 59) {
    lex();
    if (!(state.inIteration || state.inSwitch)) {
      throwError({}, Messages.IllegalBreak);
    }
    return delegate.createBreakStatement(null);
  }
  if (peekLineTerminator()) {
    if (!(state.inIteration || state.inSwitch)) {
      throwError({}, Messages.IllegalBreak);
    }
    return delegate.createBreakStatement(null);
  }
  if (lookahead.type === Token.Identifier) {
    label = parseVariableIdentifier();
    key = "$" + label.name;
    if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
      throwError({}, Messages.UnknownLabel, label.name);
    }
  }
  consumeSemicolon();
  if (label === null && !(state.inIteration || state.inSwitch)) {
    throwError({}, Messages.IllegalBreak);
  }
  return delegate.createBreakStatement(label);
}
function parseReturnStatement() {
  var argument = null;
  expectKeyword("return");
  if (!state.inFunctionBody) {
    throwErrorTolerant({}, Messages.IllegalReturn);
  }
  if (source.charCodeAt(index) === 32) {
    if (isIdentifierStart(source.charCodeAt(index + 1))) {
      argument = parseExpression();
      consumeSemicolon();
      return delegate.createReturnStatement(argument);
    }
  }
  if (peekLineTerminator()) {
    return delegate.createReturnStatement(null);
  }
  if (!match(";")) {
    if (!match("}") && lookahead.type !== Token.EOF) {
      argument = parseExpression();
    }
  }
  consumeSemicolon();
  return delegate.createReturnStatement(argument);
}
function parseWithStatement() {
  var object, body;
  if (strict) {
    skipComment();
    throwErrorTolerant({}, Messages.StrictModeWith);
  }
  expectKeyword("with");
  expect("(");
  object = parseExpression();
  expect(")");
  body = parseStatement();
  return delegate.createWithStatement(object, body);
}
function parseSwitchCase() {
  var test, consequent = [], statement, startToken;
  startToken = lookahead;
  if (matchKeyword("default")) {
    lex();
    test = null;
  } else {
    expectKeyword("case");
    test = parseExpression();
  }
  expect(":");
  while (index < length) {
    if (match("}") || matchKeyword("default") || matchKeyword("case")) {
      break;
    }
    statement = parseStatement();
    consequent.push(statement);
  }
  return delegate.markEnd(delegate.createSwitchCase(test, consequent), startToken);
}
function parseSwitchStatement() {
  var discriminant, cases, clause, oldInSwitch, defaultFound;
  expectKeyword("switch");
  expect("(");
  discriminant = parseExpression();
  expect(")");
  expect("{");
  cases = [];
  if (match("}")) {
    lex();
    return delegate.createSwitchStatement(discriminant, cases);
  }
  oldInSwitch = state.inSwitch;
  state.inSwitch = true;
  defaultFound = false;
  while (index < length) {
    if (match("}")) {
      break;
    }
    clause = parseSwitchCase();
    if (clause.test === null) {
      if (defaultFound) {
        throwError({}, Messages.MultipleDefaultsInSwitch);
      }
      defaultFound = true;
    }
    cases.push(clause);
  }
  state.inSwitch = oldInSwitch;
  expect("}");
  return delegate.createSwitchStatement(discriminant, cases);
}
function parseThrowStatement() {
  var argument;
  expectKeyword("throw");
  if (peekLineTerminator()) {
    throwError({}, Messages.NewlineAfterThrow);
  }
  argument = parseExpression();
  consumeSemicolon();
  return delegate.createThrowStatement(argument);
}
function parseCatchClause() {
  var param, body, startToken;
  startToken = lookahead;
  expectKeyword("catch");
  expect("(");
  if (match(")")) {
    throwUnexpected(lookahead);
  }
  param = parseVariableIdentifier();
  if (strict && isRestrictedWord(param.name)) {
    throwErrorTolerant({}, Messages.StrictCatchVariable);
  }
  expect(")");
  body = parseBlock();
  return delegate.markEnd(delegate.createCatchClause(param, body), startToken);
}
function parseTryStatement() {
  var block, handlers = [], finalizer = null;
  expectKeyword("try");
  block = parseBlock();
  if (matchKeyword("catch")) {
    handlers.push(parseCatchClause());
  }
  if (matchKeyword("finally")) {
    lex();
    finalizer = parseBlock();
  }
  if (handlers.length === 0 && !finalizer) {
    throwError({}, Messages.NoCatchOrFinally);
  }
  return delegate.createTryStatement(block, [], handlers, finalizer);
}
function parseDebuggerStatement() {
  expectKeyword("debugger");
  consumeSemicolon();
  return delegate.createDebuggerStatement();
}
function parseStatement() {
  var type = lookahead.type, expr, labeledBody, key, startToken;
  if (type === Token.EOF) {
    throwUnexpected(lookahead);
  }
  if (type === Token.Punctuator && lookahead.value === "{") {
    return parseBlock();
  }
  startToken = lookahead;
  if (type === Token.Punctuator) {
    switch (lookahead.value) {
      case ";":
        return delegate.markEnd(parseEmptyStatement(), startToken);
      case "(":
        return delegate.markEnd(parseExpressionStatement(), startToken);
      default:
        break;
    }
  }
  if (type === Token.Keyword) {
    switch (lookahead.value) {
      case "break":
        return delegate.markEnd(parseBreakStatement(), startToken);
      case "continue":
        return delegate.markEnd(parseContinueStatement(), startToken);
      case "debugger":
        return delegate.markEnd(parseDebuggerStatement(), startToken);
      case "do":
        return delegate.markEnd(parseDoWhileStatement(), startToken);
      case "for":
        return delegate.markEnd(parseForStatement(), startToken);
      case "function":
        return delegate.markEnd(parseFunctionDeclaration(), startToken);
      case "if":
        return delegate.markEnd(parseIfStatement(), startToken);
      case "return":
        return delegate.markEnd(parseReturnStatement(), startToken);
      case "switch":
        return delegate.markEnd(parseSwitchStatement(), startToken);
      case "throw":
        return delegate.markEnd(parseThrowStatement(), startToken);
      case "try":
        return delegate.markEnd(parseTryStatement(), startToken);
      case "var":
        return delegate.markEnd(parseVariableStatement(), startToken);
      case "while":
        return delegate.markEnd(parseWhileStatement(), startToken);
      case "with":
        return delegate.markEnd(parseWithStatement(), startToken);
      default:
        break;
    }
  }
  expr = parseExpression();
  if (expr.type === Syntax.Identifier && match(":")) {
    lex();
    key = "$" + expr.name;
    if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
      throwError({}, Messages.Redeclaration, "Label", expr.name);
    }
    state.labelSet[key] = true;
    labeledBody = parseStatement();
    delete state.labelSet[key];
    return delegate.markEnd(delegate.createLabeledStatement(expr, labeledBody), startToken);
  }
  consumeSemicolon();
  return delegate.markEnd(delegate.createExpressionStatement(expr), startToken);
}
function parseFunctionSourceElements() {
  var sourceElement, sourceElements = [], token, directive, firstRestricted, oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, startToken;
  startToken = lookahead;
  expect("{");
  while (index < length) {
    if (lookahead.type !== Token.StringLiteral) {
      break;
    }
    token = lookahead;
    sourceElement = parseSourceElement();
    sourceElements.push(sourceElement);
    if (sourceElement.expression.type !== Syntax.Literal) {
      break;
    }
    directive = source.slice(token.start + 1, token.end - 1);
    if (directive === "use strict") {
      strict = true;
      if (firstRestricted) {
        throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
      }
    } else {
      if (!firstRestricted && token.octal) {
        firstRestricted = token;
      }
    }
  }
  oldLabelSet = state.labelSet;
  oldInIteration = state.inIteration;
  oldInSwitch = state.inSwitch;
  oldInFunctionBody = state.inFunctionBody;
  state.labelSet = {};
  state.inIteration = false;
  state.inSwitch = false;
  state.inFunctionBody = true;
  while (index < length) {
    if (match("}")) {
      break;
    }
    sourceElement = parseSourceElement();
    if (typeof sourceElement === "undefined") {
      break;
    }
    sourceElements.push(sourceElement);
  }
  expect("}");
  state.labelSet = oldLabelSet;
  state.inIteration = oldInIteration;
  state.inSwitch = oldInSwitch;
  state.inFunctionBody = oldInFunctionBody;
  return delegate.markEnd(delegate.createBlockStatement(sourceElements), startToken);
}
function parseParams(firstRestricted) {
  var param, params = [], token, stricted, paramSet, key, message;
  expect("(");
  if (!match(")")) {
    paramSet = {};
    while (index < length) {
      token = lookahead;
      param = parseVariableIdentifier();
      key = "$" + token.value;
      if (strict) {
        if (isRestrictedWord(token.value)) {
          stricted = token;
          message = Messages.StrictParamName;
        }
        if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
          stricted = token;
          message = Messages.StrictParamDupe;
        }
      } else if (!firstRestricted) {
        if (isRestrictedWord(token.value)) {
          firstRestricted = token;
          message = Messages.StrictParamName;
        } else if (isStrictModeReservedWord(token.value)) {
          firstRestricted = token;
          message = Messages.StrictReservedWord;
        } else if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
          firstRestricted = token;
          message = Messages.StrictParamDupe;
        }
      }
      params.push(param);
      paramSet[key] = true;
      if (match(")")) {
        break;
      }
      expect(",");
    }
  }
  expect(")");
  return {
    params,
    stricted,
    firstRestricted,
    message
  };
}
function parseFunctionDeclaration() {
  var id, params = [], body, token, stricted, tmp, firstRestricted, message, previousStrict, startToken;
  startToken = lookahead;
  expectKeyword("function");
  token = lookahead;
  id = parseVariableIdentifier();
  if (strict) {
    if (isRestrictedWord(token.value)) {
      throwErrorTolerant(token, Messages.StrictFunctionName);
    }
  } else {
    if (isRestrictedWord(token.value)) {
      firstRestricted = token;
      message = Messages.StrictFunctionName;
    } else if (isStrictModeReservedWord(token.value)) {
      firstRestricted = token;
      message = Messages.StrictReservedWord;
    }
  }
  tmp = parseParams(firstRestricted);
  params = tmp.params;
  stricted = tmp.stricted;
  firstRestricted = tmp.firstRestricted;
  if (tmp.message) {
    message = tmp.message;
  }
  previousStrict = strict;
  body = parseFunctionSourceElements();
  if (strict && firstRestricted) {
    throwError(firstRestricted, message);
  }
  if (strict && stricted) {
    throwErrorTolerant(stricted, message);
  }
  strict = previousStrict;
  return delegate.markEnd(delegate.createFunctionDeclaration(id, params, [], body), startToken);
}
function parseFunctionExpression() {
  var token, id = null, stricted, firstRestricted, message, tmp, params = [], body, previousStrict, startToken;
  startToken = lookahead;
  expectKeyword("function");
  if (!match("(")) {
    token = lookahead;
    id = parseVariableIdentifier();
    if (strict) {
      if (isRestrictedWord(token.value)) {
        throwErrorTolerant(token, Messages.StrictFunctionName);
      }
    } else {
      if (isRestrictedWord(token.value)) {
        firstRestricted = token;
        message = Messages.StrictFunctionName;
      } else if (isStrictModeReservedWord(token.value)) {
        firstRestricted = token;
        message = Messages.StrictReservedWord;
      }
    }
  }
  tmp = parseParams(firstRestricted);
  params = tmp.params;
  stricted = tmp.stricted;
  firstRestricted = tmp.firstRestricted;
  if (tmp.message) {
    message = tmp.message;
  }
  previousStrict = strict;
  body = parseFunctionSourceElements();
  if (strict && firstRestricted) {
    throwError(firstRestricted, message);
  }
  if (strict && stricted) {
    throwErrorTolerant(stricted, message);
  }
  strict = previousStrict;
  return delegate.markEnd(delegate.createFunctionExpression(id, params, [], body), startToken);
}
function parseSourceElement() {
  if (lookahead.type === Token.Keyword) {
    switch (lookahead.value) {
      case "const":
      case "let":
        return parseConstLetDeclaration(lookahead.value);
      case "function":
        return parseFunctionDeclaration();
      default:
        return parseStatement();
    }
  }
  if (lookahead.type !== Token.EOF) {
    return parseStatement();
  }
}
function parseSourceElements() {
  var sourceElement, sourceElements = [], token, directive, firstRestricted;
  while (index < length) {
    token = lookahead;
    if (token.type !== Token.StringLiteral) {
      break;
    }
    sourceElement = parseSourceElement();
    sourceElements.push(sourceElement);
    if (sourceElement.expression.type !== Syntax.Literal) {
      break;
    }
    directive = source.slice(token.start + 1, token.end - 1);
    if (directive === "use strict") {
      strict = true;
      if (firstRestricted) {
        throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
      }
    } else {
      if (!firstRestricted && token.octal) {
        firstRestricted = token;
      }
    }
  }
  while (index < length) {
    sourceElement = parseSourceElement();
    if (typeof sourceElement === "undefined") {
      break;
    }
    sourceElements.push(sourceElement);
  }
  return sourceElements;
}
function parseProgram() {
  var body, startToken;
  skipComment();
  peek();
  startToken = lookahead;
  strict = false;
  body = parseSourceElements();
  return delegate.markEnd(delegate.createProgram(body), startToken);
}
function filterTokenLocation() {
  var i, entry, token, tokens = [];
  for (i = 0; i < extra.tokens.length; ++i) {
    entry = extra.tokens[i];
    token = {
      type: entry.type,
      value: entry.value
    };
    if (extra.range) {
      token.range = entry.range;
    }
    if (extra.loc) {
      token.loc = entry.loc;
    }
    tokens.push(token);
  }
  extra.tokens = tokens;
}
function parse(code, options) {
  var program, toString;
  toString = String;
  if (typeof code !== "string" && !(code instanceof String)) {
    code = toString(code);
  }
  delegate = SyntaxTreeDelegate;
  source = code;
  index = 0;
  lineNumber = source.length > 0 ? 1 : 0;
  lineStart = 0;
  length = source.length;
  lookahead = null;
  state = {
    allowIn: true,
    labelSet: {},
    inFunctionBody: false,
    inIteration: false,
    inSwitch: false,
    lastCommentStart: -1
  };
  extra = {};
  if (typeof options !== "undefined") {
    extra.range = typeof options.range === "boolean" && options.range;
    extra.loc = typeof options.loc === "boolean" && options.loc;
    extra.attachComment = typeof options.attachComment === "boolean" && options.attachComment;
    if (extra.loc && options.source !== null && options.source !== void 0) {
      extra.source = toString(options.source);
    }
    if (typeof options.tokens === "boolean" && options.tokens) {
      extra.tokens = [];
    }
    if (typeof options.comment === "boolean" && options.comment) {
      extra.comments = [];
    }
    if (typeof options.tolerant === "boolean" && options.tolerant) {
      extra.errors = [];
    }
    if (extra.attachComment) {
      extra.range = true;
      extra.comments = [];
      extra.bottomRightStack = [];
      extra.trailingComments = [];
      extra.leadingComments = [];
    }
  }
  try {
    program = parseProgram();
    if (typeof extra.comments !== "undefined") {
      program.comments = extra.comments;
    }
    if (typeof extra.tokens !== "undefined") {
      filterTokenLocation();
      program.tokens = extra.tokens;
    }
    if (typeof extra.errors !== "undefined") {
      program.errors = extra.errors;
    }
  } catch (e2) {
    throw e2;
  } finally {
    extra = {};
  }
  return program;
}

// node_modules/@astronautlabs/jsonpath/dist.esm/slice.js
var import_dist10 = __toESM(require_dist());
function slice(arr, start, end, step) {
  function integer(val) {
    return String(val).match(/^[0-9]+$/) ? parseInt(val) : Number.isFinite(val) ? parseInt(val, 10) : 0;
  }
  if (typeof start == "string")
    throw new Error("start cannot be a string");
  if (typeof end == "string")
    throw new Error("end cannot be a string");
  if (typeof step == "string")
    throw new Error("step cannot be a string");
  var len = arr.length;
  if (step === 0)
    throw new Error("step cannot be zero");
  step = step ? integer(step) : 1;
  start = start < 0 ? len + start : start;
  end = end < 0 ? len + end : end;
  start = integer(start === 0 ? 0 : !start ? step > 0 ? 0 : len - 1 : start);
  end = integer(end === 0 ? 0 : !end ? step > 0 ? len : -1 : end);
  start = step > 0 ? Math.max(0, start) : Math.min(len, start);
  end = step > 0 ? Math.min(end, len) : Math.max(-1, end);
  if (step > 0 && end <= start)
    return [];
  if (step < 0 && start <= end)
    return [];
  var result = [];
  for (var i = start; i != end; i += step) {
    if (step < 0 && i <= end || step > 0 && i >= end)
      break;
    result.push(arr[i]);
  }
  return result;
}

// node_modules/@astronautlabs/jsonpath/dist.esm/handlers.js
var import_static_eval = __toESM(require_static_eval());
function traverser(recurse) {
  return function(partial, ref, passable, count) {
    var value = partial.value;
    var path = partial.path;
    var results = [];
    var descend = (function(value2, path2) {
      if (is_array(value2)) {
        value2.forEach(function(element, index2) {
          if (results.length >= count) {
            return;
          }
          if (passable(index2, element, ref)) {
            results.push({ path: path2.concat(index2), value: element });
          }
        });
        value2.forEach(function(element, index2) {
          if (results.length >= count) {
            return;
          }
          if (recurse) {
            descend(element, path2.concat(index2));
          }
        });
      } else if (is_object(value2)) {
        Object.keys(value2).forEach(function(k) {
          if (results.length >= count) {
            return;
          }
          if (passable(k, value2[k], ref)) {
            results.push({ path: path2.concat(k), value: value2[k] });
          }
        });
        Object.keys(value2).forEach(function(k) {
          if (results.length >= count) {
            return;
          }
          if (recurse) {
            descend(value2[k], path2.concat(k));
          }
        });
      }
    }).bind(this);
    descend(value, path);
    return results;
  };
}
function evaluate(ast, vars) {
  try {
    return (0, import_static_eval.default)(ast, vars);
  } catch (e2) {
  }
}
function _descend(passable) {
  return function(component, partial, count) {
    return this.descend(partial, component.expression.value, passable, count);
  };
}
function _traverse(passable) {
  return function(component, partial, count) {
    return this.traverse(partial, component.expression.value, passable, count);
  };
}
function unique(results) {
  results = results.filter(function(d) {
    return d;
  });
  return uniq(results, function(r2) {
    return r2.path.map(function(c) {
      return String(c).replace("-", "--");
    }).join("-");
  });
}
function _parse_nullable_int(val) {
  var sval = String(val);
  return sval.match(/^-?[0-9]+$/) ? parseInt(sval) : null;
}
function is_array(val) {
  return Array.isArray(val);
}
function is_object(val) {
  return val && !(val instanceof Array) && val instanceof Object;
}
function eval_recurse(partial, src, template) {
  var ast = parse(src).body[0].expression;
  var value = evaluate(ast, { "@": partial.value });
  var path = template.replace(/\{\{\s*value\s*\}\}/g, value);
  var results = JSONPath.nodes(partial.value, path);
  results.forEach(function(r2) {
    r2.path = partial.path.concat(r2.path.slice(1));
  });
  return results;
}
var Handlers = (
  /** @class */
  function() {
    function Handlers2() {
      this._fns = {
        "member-child-identifier": function(component, partial) {
          var key = component.expression.value;
          var value = partial.value;
          if (value instanceof Object && key in value) {
            return [{ value: value[key], path: partial.path.concat(key) }];
          }
        },
        "member-descendant-identifier": _traverse(function(key, value, ref) {
          return key == ref;
        }),
        "subscript-child-numeric_literal": _descend(function(key, value, ref) {
          return key === ref;
        }),
        "member-child-numeric_literal": _descend(function(key, value, ref) {
          return String(key) === String(ref);
        }),
        "subscript-descendant-numeric_literal": _traverse(function(key, value, ref) {
          return key === ref;
        }),
        "member-child-wildcard": _descend(function() {
          return true;
        }),
        "member-descendant-wildcard": _traverse(function() {
          return true;
        }),
        "subscript-descendant-wildcard": _traverse(function() {
          return true;
        }),
        "subscript-child-wildcard": _descend(function() {
          return true;
        }),
        "subscript-child-slice": function(component, partial) {
          if (is_array(partial.value)) {
            var args = component.expression.value.split(":").map(_parse_nullable_int);
            var values = partial.value.map(function(v, i) {
              return { value: v, path: partial.path.concat(i) };
            });
            return slice.apply(null, [values].concat(args));
          }
        },
        "subscript-child-union": function(component, partial) {
          var results = [];
          component.expression.value.forEach(function(component2) {
            var _component = { operation: "subscript", scope: "child", expression: component2.expression };
            var handler = this.resolve(_component);
            var _results = handler(_component, partial);
            if (_results) {
              results = results.concat(_results);
            }
          }, this);
          return unique(results);
        },
        "subscript-descendant-union": function(component, partial, count) {
          var self = this;
          var results = [];
          var nodes = JSONPath.nodes(partial, "$..*").slice(1);
          nodes.forEach(function(node) {
            if (results.length >= count)
              return;
            component.expression.value.forEach(function(component2) {
              var _component = { operation: "subscript", scope: "child", expression: component2.expression };
              var handler = self.resolve(_component);
              var _results = handler(_component, node);
              results = results.concat(_results);
            });
          });
          return unique(results);
        },
        "subscript-child-filter_expression": function(component, partial, count) {
          var src = component.expression.value.slice(2, -1);
          var ast = parse(src).body[0].expression;
          var passable = function(key, value) {
            return evaluate(ast, { "@": value });
          };
          return this.descend(partial, null, passable, count);
        },
        "subscript-descendant-filter_expression": function(component, partial, count) {
          var src = component.expression.value.slice(2, -1);
          var ast = parse(src).body[0].expression;
          var passable = function(key, value) {
            return evaluate(ast, { "@": value });
          };
          return this.traverse(partial, null, passable, count);
        },
        "subscript-child-script_expression": function(component, partial) {
          var exp = component.expression.value.slice(1, -1);
          return eval_recurse(partial, exp, "$[{{value}}]");
        },
        "member-child-script_expression": function(component, partial) {
          var exp = component.expression.value.slice(1, -1);
          return eval_recurse(partial, exp, "$.{{value}}");
        },
        "member-descendant-script_expression": function(component, partial) {
          var exp = component.expression.value.slice(1, -1);
          return eval_recurse(partial, exp, "$..value");
        }
      };
      this.initialize();
    }
    Handlers2.prototype.initialize = function() {
      this.traverse = traverser(true);
      this.descend = traverser();
      this._fns["subscript-child-string_literal"] = this._fns["member-child-identifier"];
      this._fns["member-descendant-numeric_literal"] = this._fns["subscript-descendant-string_literal"] = this._fns["member-descendant-identifier"];
    };
    Handlers2.prototype.resolve = function(component) {
      var key = [component.operation, component.scope, component.expression.type].join("-");
      var method = this._fns[key];
      if (!method)
        throw new Error("couldn't resolve key: " + key);
      return method.bind(this);
    };
    Handlers2.prototype.register = function(key, handler) {
      if (!(handler instanceof Function)) {
        throw new Error("handler must be a function");
      }
      this._fns[key] = handler;
    };
    return Handlers2;
  }()
);
function uniq(array, iteratee) {
  var result = [];
  var seen = [];
  for (var i = 0, length2 = array === null || array === void 0 ? void 0 : array.length; i < length2; i++) {
    var value = array[i], computed = iteratee ? iteratee(value, i) : value;
    if (!seen.includes(computed)) {
      seen.push(computed);
      result.push(value);
    }
  }
  return result;
}

// node_modules/@astronautlabs/jsonpath/dist.esm/tokens.js
var import_dist12 = __toESM(require_dist());
var TOKENS = {
  identifier: "[a-zA-Z_]+[a-zA-Z0-9_]*",
  integer: "-?(?:0|[1-9][0-9]*)",
  qq_string: '"(?:\\\\["bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4}|[^"\\\\])*"',
  q_string: "'(?:\\\\['bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4}|[^'\\\\])*'"
};

// node_modules/@astronautlabs/jsonpath/dist.esm/parser.js
var import_dist13 = __toESM(require_dist());
var gparser = __toESM(require_parser());
function Parser2() {
  var parser = new gparser.Parser();
  var _parseError = parser.parseError;
  parser.yy.parseError = function() {
    if (parser.yy.ast) {
      parser.yy.ast.initialize();
    }
    _parseError.apply(parser, arguments);
  };
  return parser;
}

// node_modules/@astronautlabs/jsonpath/dist.esm/assert.js
var import_dist14 = __toESM(require_dist());
var assert2 = (
  /** @class */
  function() {
    function assert3() {
    }
    assert3.ok = function(predicate, message) {
      if (!predicate)
        throw new Error(message);
    };
    assert3.equal = function(value, expected, message) {
      if (value !== expected)
        throw new Error(message);
    };
    return assert3;
  }()
);

// node_modules/@astronautlabs/jsonpath/dist.esm/jsonpath.js
var JSONPath = (
  /** @class */
  function() {
    function JSONPath2() {
    }
    JSONPath2.parse = function(string) {
      assert2.ok(typeof string === "string", "we need a path");
      return new Parser2().parse(string);
    };
    JSONPath2.parent = function(obj, string) {
      assert2.ok(obj instanceof Object, "obj needs to be an object");
      assert2.ok(string, "we need a path");
      var node = this.nodes(obj, string)[0];
      var key = node.path.pop();
      return this.value(obj, node.path);
    };
    JSONPath2.apply = function(obj, string, fn) {
      assert2.ok(obj instanceof Object, "obj needs to be an object");
      assert2.ok(string, "we need a path");
      assert2.equal(typeof fn, "function", "fn needs to be function");
      var nodes = this.nodes(obj, string).sort(function(a, b) {
        return b.path.length - a.path.length;
      });
      nodes.forEach(function(node) {
        var key = node.path.pop();
        var parent = this.value(obj, this.stringify(node.path));
        var val = node.value = fn.call(obj, parent[key]);
        parent[key] = val;
      }, this);
      return nodes;
    };
    JSONPath2.value = function(obj, path, value) {
      assert2.ok(obj instanceof Object, "obj needs to be an object");
      assert2.ok(path, "we need a path");
      if (value !== void 0) {
        var node = this.nodes(obj, path).shift();
        if (!node)
          return this._vivify(obj, path, value);
        var key = node.path.slice(-1).shift();
        var parent = this.parent(obj, this.stringify(node.path));
        parent[key] = value;
      }
      return this.query(obj, this.stringify(path), 1).shift();
    };
    JSONPath2._vivify = function(obj, string, value) {
      var self = this;
      assert2.ok(obj instanceof Object, "obj needs to be an object");
      assert2.ok(string, "we need a path");
      var path = new Parser2().parse(string).map(function(component) {
        return component.expression.value;
      });
      var setValue = function(path2, value2) {
        var key = path2.pop();
        var node = self.value(obj, path2);
        if (!node) {
          setValue(path2.concat(), typeof key === "string" ? {} : []);
          node = self.value(obj, path2);
        }
        node[key] = value2;
      };
      setValue(path, value);
      return this.query(obj, string)[0];
    };
    JSONPath2.query = function(obj, string, count) {
      assert2.ok(obj instanceof Object, "obj needs to be an object");
      assert2.ok(typeof string === "string", "we need a path");
      var results = this.nodes(obj, string, count).map(function(r2) {
        return r2.value;
      });
      return results;
    };
    JSONPath2.paths = function(obj, string, count) {
      assert2.ok(obj instanceof Object, "obj needs to be an object");
      assert2.ok(string, "we need a path");
      var results = this.nodes(obj, string, count).map(function(r2) {
        return r2.path;
      });
      return results;
    };
    JSONPath2.nodes = function(obj, string, count) {
      assert2.ok(obj instanceof Object, "obj needs to be an object");
      assert2.ok(string, "we need a path");
      if (count === 0)
        return [];
      var path = new Parser2().parse(string);
      var handlers = new Handlers();
      var partials = [{ path: ["$"], value: obj }];
      var matches = [];
      if (path.length && path[0].expression.type == "root")
        path.shift();
      if (!path.length)
        return partials;
      path.forEach(function(component, index2) {
        if (matches.length >= count)
          return;
        var handler = handlers.resolve(component);
        var _partials = [];
        partials.forEach(function(p) {
          if (matches.length >= count)
            return;
          var results = handler(component, p, count);
          if (index2 == path.length - 1) {
            matches = matches.concat(results || []);
          } else {
            _partials = _partials.concat(results || []);
          }
        });
        partials = _partials;
      });
      return count ? matches.slice(0, count) : matches;
    };
    JSONPath2.stringify = function(path) {
      assert2.ok(path, "we need a path");
      var string = "$";
      var templates = {
        "descendant-member": "..{{value}}",
        "child-member": ".{{value}}",
        "descendant-subscript": "..[{{value}}]",
        "child-subscript": "[{{value}}]"
      };
      path = this._normalize(path);
      path.forEach(function(component) {
        if (component.expression.type == "root")
          return;
        var key = [component.scope, component.operation].join("-");
        var template = templates[key];
        var value;
        if (component.expression.type == "string_literal") {
          value = JSON.stringify(component.expression.value);
        } else {
          value = component.expression.value;
        }
        if (!template)
          throw new Error("couldn't find template " + key);
        string += template.replace(/{{value}}/, value);
      });
      return string;
    };
    JSONPath2._normalize = function(path) {
      assert2.ok(path, "we need a path");
      if (typeof path == "string") {
        return new Parser2().parse(path);
      } else if (Array.isArray(path) && typeof path[0] == "string") {
        var _path = [{ expression: { type: "root", value: "$" } }];
        path.forEach(function(component, index2) {
          if (component == "$" && index2 === 0)
            return;
          if (typeof component == "string" && component.match("^" + TOKENS.identifier + "$")) {
            _path.push({
              operation: "member",
              scope: "child",
              expression: { value: component, type: "identifier" }
            });
          } else {
            var type = typeof component == "number" ? "numeric_literal" : "string_literal";
            _path.push({
              operation: "subscript",
              scope: "child",
              expression: { value: component, type }
            });
          }
        });
        return _path;
      } else if (Array.isArray(path) && typeof path[0] == "object") {
        return path;
      }
      throw new Error("couldn't understand path " + path);
    };
    return JSONPath2;
  }()
);

// node_modules/@sphereon/pex/dist/module/lib/utils/jsonPathUtils.js
var _JsonPathUtils = class _JsonPathUtils {
  /**
     * @param obj: any object can be found in verifiablePresentation.verifiableCredential[i]
     * @param paths: paths that can be found in Field object
     * @return a result object containing value of the correct path in the verifiableCredential and the correct path
     * @example(success result): if you call this method with 1. verifiableCredential:
     *   {
          '@context': [''],
          age: 19,
          credentialSchema: [ { id: '' } ],
          id: '2dc74354-e965-4883-be5e-bfec48bf60c7',
          issuer: '',
          type: 'VerifiableCredential'
        }
     and 2 paths: [ '$.age', '$.details.age ]
     you will get result: [ { value: 19, path: [ '$', 'age' ] } ]
  
     @example(fail result): if you call this method with 1. verifiableCredential:
     {
          '@context': [ '' ],
          credentialSchema: [ { id: '' } ],
          id: '2dc74354-e965-4883-be5e-bfec48bf60c7',
          issuer: '',
          type: 'VerifiableCredential'
        }
     and 2. paths: [ '$.age' ],
     you will get result: result: []
     @example (array example):
     vc: {
          '@context': [''],
          "details": {
          "information":[
            {
              "age": 19
            }]
        },
          credentialSchema: [ { id: '' } ],
          id: '2dc74354-e965-4883-be5e-bfec48bf60c7',
          issuer: '',
          type: 'VerifiableCredential'
        }
     result: [ { value: 19, path: [ '$', 'details', 'information', 0, 'age' ] } ]
     */
  static extractInputField(obj, paths) {
    let result = [];
    if (paths) {
      for (const path of paths) {
        result = JSONPath.nodes(obj, path);
        if (result.length) {
          break;
        }
      }
    }
    return result;
  }
  static changePropertyNameRecursively(pd, currentPropertyName, newPropertyName) {
    const existingPaths = _JsonPathUtils.extractInputField(pd, ["$.." + currentPropertyName]);
    for (const existingPath of existingPaths) {
      this.copyResultPathToDestinationDefinition(existingPath.path, pd, newPropertyName);
    }
  }
  static copyResultPathToDestinationDefinition(pathDetails, pd, newPropertyName) {
    let objectCursor = pd;
    for (let i = 1; i < pathDetails.length; i++) {
      if (i + 1 < pathDetails.length) {
        objectCursor = objectCursor[pathDetails[i]];
      }
      if (pathDetails.length == i + 1) {
        objectCursor[newPropertyName] = objectCursor[pathDetails[i]];
        delete objectCursor[pathDetails[i]];
        break;
      }
    }
  }
  static changeSpecialPathsRecursively(pd) {
    const paths = _JsonPathUtils.extractInputField(pd, ["$..path"]);
    for (const path of paths) {
      this.modifyPathsWithSpecialCharacter(path.path, pd);
    }
  }
  static modifyPathsWithSpecialCharacter(pathDetails, pd) {
    let objectCursor = pd;
    for (let i = 1; i < pathDetails.length; i++) {
      if (i + 1 < pathDetails.length) {
        objectCursor = objectCursor[pathDetails[i]];
      }
      if (pathDetails.length == i + 1) {
        const paths = objectCursor[pathDetails[i]];
        const editedPaths = [];
        for (let j = 0; j < paths.length; j++) {
          editedPaths.push(this.modifyPathWithSpecialCharacter(paths[j]));
        }
        objectCursor[pathDetails[i]] = editedPaths;
        break;
      }
    }
  }
  static modifyPathWithSpecialCharacter(path) {
    const matches = this.matchAll(path, this.REGEX_PATH);
    path = this.modifyPathRecursive(matches, path);
    return path;
  }
  static modifyPathRecursive(matches, path) {
    let next = matches.next();
    let indexChanged = false;
    while (next && !next.done && !indexChanged) {
      const atIdx = next.value.index;
      if (atIdx && atIdx == 1) {
        path = path.charAt(0) + "['" + next.value[0] + "']" + path.substring(atIdx + next.value[0].length);
        indexChanged = true;
        this.modifyPathRecursive(matches, path);
      } else if (atIdx && atIdx > 1 && path.substring(atIdx - 2, atIdx) !== "['" && path.substring(atIdx - 2, atIdx) !== '["') {
        if (path.substring(atIdx - 2, atIdx) === "..") {
          path = path.substring(0, atIdx - 2) + "..['" + next.value[0] + "']" + path.substring(atIdx + next.value[0].length);
          indexChanged = true;
          const matches2 = this.matchAll(path, this.REGEX_PATH);
          this.modifyPathRecursive(matches2, path);
        } else if (path.charAt(atIdx - 1) === ".") {
          path = path.substring(0, atIdx - 1) + "['" + next.value[0] + "']" + path.substring(atIdx + next.value[0].length);
          indexChanged = true;
          this.modifyPathRecursive(matches, path);
        }
      }
      next = matches.next();
    }
    return path;
  }
};
__publicField(_JsonPathUtils, "matchAll", require_string_prototype2());
__publicField(_JsonPathUtils, "REGEX_PATH", /@\w+/g);
var JsonPathUtils = _JsonPathUtils;

// node_modules/@sphereon/pex/dist/module/lib/utils/ObjectUtils.js
var import_dist18 = __toESM(require_dist());
var ObjectUtils = class _ObjectUtils {
  static asArray(value) {
    return Array.isArray(value) ? value : [value];
  }
  static isObject(value) {
    return Object.prototype.toString.call(value) === "[object Object]";
  }
  static isUrlAbsolute(url) {
    const isAbsoluteRegex = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^\s]*$/;
    _ObjectUtils.isString(url) && isAbsoluteRegex.test(url);
  }
  static isString(value) {
    return typeof value === "string" || Object.prototype.toString.call(value) === "[object String]";
  }
  /**
   * Receives an object array and for the field in question, returns the unique values
   */
  static getDistinctFieldInObject(data, fieldName) {
    const fieldValues = data.map((item) => item[fieldName]);
    return Array.from(new Set(fieldValues));
  }
};

// node_modules/@sphereon/pex/dist/module/lib/utils/ObjectValidationUtils.js
var import_dist19 = __toESM(require_dist());
var ObjectValidationUtils = class {
  static optionalNonEmptyString(value) {
    return value == null || value.length > 0;
  }
  static nonEmptyString(value) {
    return value != null && value.length > 0;
  }
  static isValidDIDURI(uri) {
    const pchar = "[a-zA-Z-\\._~]|%[0-9a-fA-F]{2}|[!$&'()*+,;=:@]";
    const format = "^did:([a-z0-9]+)(:([a-zA-Z0-9\\.\\-_]|%[0-9a-fA-F]{2})+)+(/(" + pchar + ")*)?";
    "(\\?(" + pchar + "|/|\\?)+)?(#(" + pchar + "|/|\\?)+)?";
    "$";
    return new RegExp(format).test(uri);
  }
};

// node_modules/@sphereon/pex/dist/module/lib/utils/VCUtils.js
var import_dist23 = __toESM(require_dist());

// node_modules/@sphereon/pex/dist/module/lib/types/index.js
var import_dist22 = __toESM(require_dist());

// node_modules/@sphereon/pex/dist/module/lib/types/Internal.types.js
var import_dist20 = __toESM(require_dist());
var InternalPresentationDefinitionV1 = class {
  constructor(id, input_descriptors, format, name, purpose, submission_requirements) {
    __publicField(this, "input_descriptors");
    __publicField(this, "format");
    __publicField(this, "id");
    __publicField(this, "name");
    __publicField(this, "purpose");
    __publicField(this, "submission_requirements");
    this.id = id;
    this.input_descriptors = input_descriptors;
    this.format = format;
    this.name = name;
    this.purpose = purpose;
    this.submission_requirements = submission_requirements;
  }
  getVersion() {
    return PEVersion.v1;
  }
};
var InternalPresentationDefinitionV2 = class {
  constructor(id, input_descriptors, format, frame, name, purpose, submission_requirements) {
    __publicField(this, "format");
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    __publicField(this, "frame");
    __publicField(this, "id");
    __publicField(this, "input_descriptors");
    __publicField(this, "name");
    __publicField(this, "purpose");
    __publicField(this, "submission_requirements");
    this.format = format;
    this.frame = frame;
    this.id = id;
    this.input_descriptors = input_descriptors;
    this.name = name;
    this.purpose = purpose;
    this.submission_requirements = submission_requirements;
  }
  getVersion() {
    return PEVersion.v2;
  }
};
var PEVersion;
(function(PEVersion2) {
  PEVersion2["v1"] = "v1";
  PEVersion2["v2"] = "v2";
})(PEVersion || (PEVersion = {}));

// node_modules/@sphereon/pex/dist/module/lib/types/SSITypesBuilder.js
var import_dist21 = __toESM(require_dist());
var import_ssi_types = __toESM(require_dist2());
var SSITypesBuilder = class _SSITypesBuilder {
  static modelEntityToInternalPresentationDefinitionV1(p) {
    const pd = _SSITypesBuilder.createCopyAndModifyPresentationDefinition(p);
    return new InternalPresentationDefinitionV1(pd.id, pd.input_descriptors, pd.format, pd.name, pd.purpose, pd.submission_requirements);
  }
  static modelEntityInternalPresentationDefinitionV2(p) {
    const pd = _SSITypesBuilder.createCopyAndModifyPresentationDefinition(p);
    return new InternalPresentationDefinitionV2(pd.id, pd.input_descriptors, pd.format, pd.frame, pd.name, pd.purpose, pd.submission_requirements);
  }
  static createCopyAndModifyPresentationDefinition(p) {
    const pd = JSON.parse(JSON.stringify(p));
    JsonPathUtils.changePropertyNameRecursively(pd, "_const", "const");
    JsonPathUtils.changePropertyNameRecursively(pd, "_enum", "enum");
    JsonPathUtils.changeSpecialPathsRecursively(pd);
    return pd;
  }
  static mapExternalVerifiablePresentationToWrappedVP(presentation) {
    return import_ssi_types.CredentialMapper.toWrappedVerifiablePresentation(presentation);
  }
  static mapExternalVerifiableCredentialsToWrappedVcs(verifiableCredentials) {
    return import_ssi_types.CredentialMapper.toWrappedVerifiableCredentials(Array.isArray(verifiableCredentials) ? verifiableCredentials : [verifiableCredentials]);
  }
  static toInternalPresentationDefinition(presentationDefinition) {
    const presentationDefinitionCopy = JSON.parse(JSON.stringify(presentationDefinition));
    const versionResult = definitionVersionDiscovery(presentationDefinitionCopy);
    if (versionResult.error)
      throw versionResult.error;
    if (versionResult.version == PEVersion.v1) {
      return _SSITypesBuilder.modelEntityToInternalPresentationDefinitionV1(presentationDefinitionCopy);
    }
    return _SSITypesBuilder.modelEntityInternalPresentationDefinitionV2(presentationDefinitionCopy);
  }
};

// node_modules/@sphereon/pex/dist/module/lib/utils/VCUtils.js
var import_validatePDv1 = __toESM(require_validatePDv1());
var import_validatePDv2 = __toESM(require_validatePDv2());
function getSubjectIdsAsString(vc) {
  const subjects = Array.isArray(vc.credentialSubject) ? vc.credentialSubject : [vc.credentialSubject];
  return subjects.filter((s) => !!s.id).map((value) => value.id);
}
function getIssuerString(vc) {
  return ObjectUtils.isString(vc.issuer) ? vc.issuer : vc.issuer.id;
}
function definitionVersionDiscovery(presentationDefinition) {
  const presentationDefinitionCopy = JSON.parse(JSON.stringify(presentationDefinition));
  JsonPathUtils.changePropertyNameRecursively(presentationDefinitionCopy, "_const", "const");
  JsonPathUtils.changePropertyNameRecursively(presentationDefinitionCopy, "_enum", "enum");
  const data = { presentation_definition: presentationDefinitionCopy };
  let result = (0, import_validatePDv2.default)(data);
  if (result) {
    return { version: PEVersion.v2 };
  }
  result = (0, import_validatePDv1.default)(data);
  if (result) {
    return { version: PEVersion.v1 };
  }
  return { error: "This is not a valid PresentationDefinition" };
}
function uniformDIDMethods(dids, opts) {
  let result = (dids == null ? void 0 : dids.map((did) => did.toLowerCase()).map((did) => did.startsWith("did:") ? did : `did:${did}`)) ?? [];
  if (opts == null ? void 0 : opts.removePrefix) {
    const length2 = opts.removePrefix.endsWith(":") ? opts.removePrefix.length : opts.removePrefix.length + 1;
    result = result.map((did) => did.startsWith(opts.removePrefix) ? did.substring(length2) : did);
  }
  if (result.includes("did")) {
    return [];
  }
  return result;
}
function isRestrictedDID(DID, restrictToDIDMethods) {
  const methods = uniformDIDMethods(restrictToDIDMethods);
  return methods.length === 0 || methods.some((method) => DID.toLowerCase().startsWith(method));
}
function filterToRestrictedDIDs(DIDs, restrictToDIDMethods) {
  const methods = uniformDIDMethods(restrictToDIDMethods);
  if (methods.length === 0) {
    return DIDs;
  }
  return methods.flatMap((method) => DIDs.filter((DID) => DID.toLowerCase().startsWith(method)));
}

// node_modules/@sphereon/pex/dist/module/lib/evaluation/handlers/index.js
var import_dist39 = __toESM(require_dist());

// node_modules/@sphereon/pex/dist/module/lib/evaluation/handlers/abstractEvaluationHandler.js
var import_dist25 = __toESM(require_dist());
var AbstractEvaluationHandler = class {
  constructor(_client) {
    __publicField(this, "_client");
    __publicField(this, "nextHandler");
    this._client = _client;
  }
  setNext(handler) {
    this.nextHandler = handler;
    return handler;
  }
  getNext() {
    return this.nextHandler;
  }
  hasNext() {
    return this.nextHandler != void 0;
  }
  get client() {
    return this._client;
  }
  get wrappedVcs() {
    return this._client.wrappedVcs;
  }
  set wrappedVcs(wrappedVcs) {
    this._client.wrappedVcs = wrappedVcs;
  }
  get presentationSubmission() {
    return this._client.presentationSubmission;
  }
  set presentationSubmission(presentationSubmission) {
    this._client.presentationSubmission = presentationSubmission;
  }
  getResults() {
    return this._client.results;
  }
  updatePresentationSubmission(pd) {
    this._client.assertPresentationSubmission();
    this.presentationSubmission.descriptor_map.forEach((descriptor, index2, descriptorMap) => {
      let inputDescriptor;
      const result = this.getResults().filter((r2) => r2.status === Status.ERROR && r2.evaluator === this.getName()).find((result2) => {
        inputDescriptor = JSONPath.query(pd, result2.input_descriptor_path)[0];
        return result2.verifiable_credential_path === descriptor.path && (inputDescriptor == null ? void 0 : inputDescriptor.id) === descriptor.id;
      });
      if (result) {
        delete descriptorMap[index2];
      }
    });
  }
  removeDuplicate(results) {
    return results.reduce((arr, cur) => {
      const result = arr.find((i) => i.input_descriptor_path === cur.input_descriptor_path && i.verifiable_credential_path === cur.verifiable_credential_path);
      if (!result) {
        return arr.concat([cur]);
      } else {
        return arr;
      }
    }, []);
  }
};

// node_modules/@sphereon/pex/dist/module/lib/evaluation/handlers/evaluationHandler.js
var import_dist26 = __toESM(require_dist());

// node_modules/@sphereon/pex/dist/module/lib/evaluation/handlers/inputDescriptorFilterEvaluationHandler.js
var import_dist27 = __toESM(require_dist());
var import_ajv = __toESM(require_ajv());
var import_ajv_formats = __toESM(require_dist3());
var InputDescriptorFilterEvaluationHandler = class extends AbstractEvaluationHandler {
  constructor(client) {
    super(client);
  }
  getName() {
    return "FilterEvaluation";
  }
  handle(pd, wrappedVcs) {
    const fields = JSONPath.nodes(pd, "$..fields[*]");
    wrappedVcs.forEach((wvc, vcIndex) => {
      this.createNoFieldResults(pd, vcIndex, wvc);
      fields.forEach((field) => {
        let inputField = [];
        if (field.value.path) {
          inputField = JsonPathUtils.extractInputField(wvc.credential, field.value.path);
        }
        let resultFound = false;
        for (const inputFieldKey of inputField) {
          if (this.evaluateFilter(inputFieldKey, field.value)) {
            resultFound = true;
            const payload = { result: { ...inputField[0] }, valid: true, format: wvc.format };
            this.getResults().push({
              ...this.createResultObject(JSONPath.stringify(field.path.slice(0, 3)), vcIndex, payload)
            });
          }
        }
        if (!resultFound) {
          if (!inputField.length) {
            const payload = { valid: false, format: wvc.format };
            this.createResponse(field, vcIndex, payload, Messages_default.INPUT_CANDIDATE_DOESNT_CONTAIN_PROPERTY);
          } else {
            const payload = { result: { ...inputField[0] }, valid: false, format: wvc.format };
            this.createResponse(field, vcIndex, payload, Messages_default.INPUT_CANDIDATE_FAILED_FILTER_EVALUATION);
          }
        }
      });
    });
    this.updatePresentationSubmission(pd);
  }
  createNoFieldResults(pd, vcIndex, credential) {
    const noFields = pd.input_descriptors.map((inDesc, index2) => {
      return { index: index2, inDesc };
    }).filter((el) => {
      var _a, _b, _c;
      return ((_a = el.inDesc.constraints) == null ? void 0 : _a.fields) === void 0 || ((_c = (_b = el.inDesc.constraints) == null ? void 0 : _b.fields) == null ? void 0 : _c.length) === 0;
    });
    noFields.forEach((noField) => {
      const payload = { result: [], valid: true, format: credential.format };
      this.getResults().push({
        ...this.createResultObject(`$.input_descriptors[${noField.index}]`, vcIndex, payload)
      });
    });
  }
  createResponse(field, vcIndex, payload, message) {
    this.getResults().push({
      // TODO: why does this code assume a path to contain certain elements in the path?
      ...this.createResultObject(JSONPath.stringify(field.path.slice(0, 3)), vcIndex, payload),
      ["status"]: Status.ERROR,
      ["message"]: message
    });
  }
  createResultObject(path, vcIndex, payload) {
    return {
      input_descriptor_path: path,
      verifiable_credential_path: `$[${vcIndex}]`,
      evaluator: this.getName(),
      status: Status.INFO,
      message: Messages_default.INPUT_CANDIDATE_IS_ELIGIBLE_FOR_PRESENTATION_SUBMISSION,
      payload
    };
  }
  evaluateFilter(result, field) {
    var _a;
    if (((_a = field.filter) == null ? void 0 : _a.format) && field.filter.format === "date") {
      this.transformDateFormat(result);
    }
    const ajv = new import_ajv.default({ verbose: true, code: { source: true, lines: true, esm: false }, allowUnionTypes: true, allErrors: true, strict: false });
    (0, import_ajv_formats.default)(ajv);
    if (field.filter) {
      return ajv.validate(field.filter, result.value);
    }
    return true;
  }
  transformDateFormat(result) {
    const date = new Date(result.value);
    let month = date.getUTCMonth() + 1 + "";
    if (month.length === 1) {
      month = "0" + month;
    }
    let day = date.getUTCDate() + "";
    if (day.length === 1) {
      day = "0" + day;
    }
    result.value = date.getUTCFullYear() + "-" + month + "-" + day;
    result.value = date.toISOString().substring(0, date.toISOString().indexOf("T"));
  }
};

// node_modules/@sphereon/pex/dist/module/lib/evaluation/handlers/subjectIsHolderEvaluationHandler.js
var import_dist28 = __toESM(require_dist());
var import_pex_models = __toESM(require_dist4());
var SubjectIsHolderEvaluationHandler = class extends AbstractEvaluationHandler {
  constructor(client) {
    super(client);
    __publicField(this, "fieldIdzInputDescriptorsSameSubjectRequired");
    __publicField(this, "fieldIdzInputDescriptorsSameSubjectPreferred");
    __publicField(this, "fieldIds");
    __publicField(this, "isHolder");
    __publicField(this, "credentialsSubjectsByPath");
    __publicField(this, "credentialsByPath");
    __publicField(this, "messages");
    this.fieldIdzInputDescriptorsSameSubjectRequired = /* @__PURE__ */ new Map();
    this.fieldIdzInputDescriptorsSameSubjectPreferred = /* @__PURE__ */ new Map();
    this.isHolder = [];
    this.fieldIds = [];
    this.credentialsSubjectsByPath = /* @__PURE__ */ new Map();
    this.credentialsByPath = /* @__PURE__ */ new Map();
    this.messages = /* @__PURE__ */ new Map();
    this.messages.set(Status.INFO, "The field ids requiring the subject to be the holder");
    this.messages.set(Status.WARN, "The field ids preferring the subject to be the holder");
    this.messages.set(Status.ERROR, "The field id missing");
  }
  getName() {
    return "IsHolderEvaluation";
  }
  handle(pd, wrappedVcs) {
    this.findIsHolderFieldIdsToInputDescriptorsSets(pd);
    this.findAllCredentialSubjects(wrappedVcs);
    this.confirmAllFieldSetHasSameSubject(this.fieldIdzInputDescriptorsSameSubjectRequired, Status.INFO, import_pex_models.Optionality.Required);
    this.confirmAllFieldSetHasSameSubject(this.fieldIdzInputDescriptorsSameSubjectPreferred, Status.WARN, import_pex_models.Optionality.Preferred);
    this.updatePresentationSubmission(pd);
  }
  /**
   * We have input descriptor to field ids mapping. This function gets a (reverse) map from field id to input descriptor
   */
  findIsHolderFieldIdsToInputDescriptorsSets(pd) {
    var _a;
    this.fieldIds.push(...JSONPath.nodes(pd, "$..fields[*].id"));
    this.isHolder.push(...JSONPath.nodes(pd, "$..is_holder[*]"));
    const fields = (_a = this.fieldIds) == null ? void 0 : _a.map((n2) => n2.value);
    const error = [];
    error.push(...this.evaluateFields(this.fieldIdzInputDescriptorsSameSubjectPreferred, this.isHolder, fields, import_pex_models.Optionality.Preferred));
    error.push(...this.evaluateFields(this.fieldIdzInputDescriptorsSameSubjectRequired, this.isHolder, fields, import_pex_models.Optionality.Required));
    error.forEach((q) => this.getResults().push(this.createResult(q[1], q[0], ["", {}], Status.ERROR, void 0)));
  }
  evaluateFields(fieldsMapping, isHolder, fields, directive) {
    const error = [];
    isHolder.filter((d) => d.value.directive === directive).filter((e2) => e2.value.field_id.every((id) => fields.includes(id))).forEach((p) => fieldsMapping.set(JSONPath.stringify(p.path.slice(0, 3)), p.value.field_id));
    isHolder.filter((d) => d.value.directive === directive).filter((e2) => !e2.value.field_id.every((id) => fields.includes(id))).forEach((p) => error.push([JSONPath.stringify(p.path.slice(0, 3)), p.value.field_id]));
    return error;
  }
  findAllCredentialSubjects(wrappedVcs) {
    const credentialSubjects = JSONPath.nodes(wrappedVcs.map((wvc) => wvc.credential), "$..credentialSubject");
    for (let idx = 0; idx < credentialSubjects.length; idx++) {
      const cs = credentialSubjects[idx];
      const path = JSONPath.stringify(cs.path.slice(0, 2));
      this.credentialsSubjectsByPath.set(path, cs.value);
      this.credentialsByPath.set(path, wrappedVcs[idx]);
    }
  }
  confirmAllFieldSetHasSameSubject(fieldIdsInputDescriptorsGroups, status, directive) {
    const subjectsMatchingFields = Array.from(fieldIdsInputDescriptorsGroups).flatMap((k) => Array.from(this.credentialsSubjectsByPath).filter((a) => k[1].find((c) => Object.keys(a[1]).includes(c))));
    const credentialPathsToInputDescriptors = this.mapCredentialPathsToInputDescriptors(directive);
    const fields = Array.from(subjectsMatchingFields).flatMap((s) => Object.keys(s[1]).filter((w) => w !== "id"));
    const allFieldsMatched = Array.from(fieldIdsInputDescriptorsGroups.values()).flatMap((v) => v.every((e2) => fields.includes(e2)))[0];
    subjectsMatchingFields.forEach((subject) => {
      const inDescPath = credentialPathsToInputDescriptors.get(subject[0]);
      if (allFieldsMatched && subject[1].id && this.client.dids.includes(subject[1].id)) {
        this.getResults().push(this.createResult(Object.keys(subject[1]).filter((k) => k !== "id"), inDescPath, subject, status, this.credentialsByPath.get(subject[0])));
      } else {
        this.getResults().push(this.createResult(Object.keys(subject[1]).filter((k) => k !== "id"), inDescPath, subject, Status.ERROR, this.credentialsByPath.get(subject[0])));
      }
    });
  }
  mapCredentialPathsToInputDescriptors(directive) {
    var _a;
    const credentialsToInputDescriptors = /* @__PURE__ */ new Map();
    (_a = this.fieldIds) == null ? void 0 : _a.forEach((id) => {
      const inDescPath = JSONPath.stringify(id.path.slice(0, 3));
      this.credentialsSubjectsByPath.forEach((cs, credentialPath) => {
        const hs = this.isHolder.find((e2) => JSONPath.stringify(e2.path.slice(0, 3)) === inDescPath);
        if (Object.keys(cs).includes(id.value) && (hs == null ? void 0 : hs.value.directive) === directive) {
          credentialsToInputDescriptors.set(credentialPath, inDescPath);
        }
      });
    });
    return credentialsToInputDescriptors;
  }
  createResult(fieldIdSet, inputDescriptorPath, credentialSub, myStatus, wvc, message) {
    return {
      input_descriptor_path: inputDescriptorPath,
      verifiable_credential_path: credentialSub[0],
      evaluator: this.getName(),
      status: myStatus,
      payload: { fieldIdSet, credentialSubject: credentialSub[1], ...wvc ? { format: wvc.format } : {} },
      message: message ?? this.messages.get(myStatus)
    };
  }
};

// node_modules/@sphereon/pex/dist/module/lib/evaluation/handlers/limitDisclosureEvaluationHandler.js
var import_dist29 = __toESM(require_dist());
var import_pex_models2 = __toESM(require_dist4());
var LimitDisclosureEvaluationHandler = class extends AbstractEvaluationHandler {
  constructor(client) {
    super(client);
  }
  getName() {
    return "LimitDisclosureEvaluation";
  }
  handle(pd, wrappedVcs) {
    pd.input_descriptors.forEach((inDesc, index2) => {
      var _a, _b, _c;
      if (((_a = inDesc.constraints) == null ? void 0 : _a.fields) && (((_b = inDesc.constraints) == null ? void 0 : _b.limit_disclosure) === import_pex_models2.Optionality.Required || ((_c = inDesc.constraints) == null ? void 0 : _c.limit_disclosure) === import_pex_models2.Optionality.Preferred)) {
        this.evaluateLimitDisclosure(wrappedVcs, inDesc.constraints, index2);
      }
    });
  }
  isLimitDisclosureSupported(wvc, vcIdx, idIdx, optionality) {
    const limitDisclosureSignatures = this.client.limitDisclosureSignatureSuites;
    const proof = wvc.decoded.proof;
    if (!proof || Array.isArray(proof) || !proof.type) {
      return false;
    } else if (!(limitDisclosureSignatures == null ? void 0 : limitDisclosureSignatures.includes(proof.type))) {
      if (optionality == import_pex_models2.Optionality.Required) {
        this.createLimitDisclosureNotSupportedResult(idIdx, vcIdx);
      }
      return false;
    }
    return true;
  }
  evaluateLimitDisclosure(wrappedVcs, constraints, idIdx) {
    const fields = constraints == null ? void 0 : constraints.fields;
    const optionality = constraints.limit_disclosure;
    wrappedVcs.forEach((wvc, index2) => {
      if (optionality && this.isLimitDisclosureSupported(wvc, index2, idIdx, optionality)) {
        this.enforceLimitDisclosure(wvc.credential, fields, idIdx, index2, wrappedVcs, optionality);
      }
    });
  }
  enforceLimitDisclosure(vc, fields, idIdx, index2, wrappedVcs, limitDisclosure) {
    const internalCredentialToSend = this.createVcWithRequiredFields(vc, fields, idIdx, index2);
    if (internalCredentialToSend) {
      wrappedVcs[index2].credential = internalCredentialToSend;
      this.createSuccessResult(idIdx, `$[${index2}]`, limitDisclosure);
    }
  }
  createVcWithRequiredFields(vc, fields, idIdx, vcIdx) {
    let credentialToSend = {};
    credentialToSend = Object.assign(credentialToSend, vc);
    credentialToSend.credentialSubject = {};
    for (const field of fields) {
      if (field.path) {
        const inputField = JsonPathUtils.extractInputField(vc, field.path);
        if (inputField.length > 0) {
          credentialToSend = this.copyResultPathToDestinationCredential(inputField[0], vc, credentialToSend);
        } else {
          this.createMandatoryFieldNotFoundResult(idIdx, vcIdx, field.path);
          return void 0;
        }
      }
    }
    return credentialToSend;
  }
  copyResultPathToDestinationCredential(requiredField, internalCredential, internalCredentialToSend) {
    let credentialSubject = { ...internalCredential.credentialSubject };
    requiredField.path.forEach((e2) => {
      if (credentialSubject[e2]) {
        credentialSubject = { [e2]: credentialSubject[e2] };
      }
    });
    internalCredentialToSend.credentialSubject = {
      ...internalCredentialToSend.credentialSubject,
      ...credentialSubject
    };
    return internalCredentialToSend;
  }
  createSuccessResult(idIdx, path, limitDisclosure) {
    return this.getResults().push({
      input_descriptor_path: `$.input_descriptors[${idIdx}]`,
      verifiable_credential_path: `${path}`,
      evaluator: this.getName(),
      status: limitDisclosure === import_pex_models2.Optionality.Required ? Status.INFO : Status.WARN,
      message: Messages_default.LIMIT_DISCLOSURE_APPLIED,
      payload: void 0
    });
  }
  createMandatoryFieldNotFoundResult(idIdx, vcIdx, path) {
    return this.getResults().push({
      input_descriptor_path: `$.input_descriptors[${idIdx}]`,
      verifiable_credential_path: `$[${vcIdx}]`,
      evaluator: this.getName(),
      status: Status.ERROR,
      message: Messages_default.VERIFIABLE_CREDENTIAL_MANDATORY_FIELD_NOT_PRESENT,
      payload: path
    });
  }
  createLimitDisclosureNotSupportedResult(idIdx, vcIdx) {
    return this.getResults().push({
      input_descriptor_path: `$.input_descriptors[${idIdx}]`,
      verifiable_credential_path: `$[${vcIdx}]`,
      evaluator: this.getName(),
      status: Status.ERROR,
      message: Messages_default.LIMIT_DISCLOSURE_NOT_SUPPORTED
    });
  }
};

// node_modules/@sphereon/pex/dist/module/lib/evaluation/handlers/markForSubmissionEvaluationHandler.js
var import_dist30 = __toESM(require_dist());
var MarkForSubmissionEvaluationHandler = class extends AbstractEvaluationHandler {
  constructor(client) {
    super(client);
  }
  getName() {
    return "MarkForSubmissionEvaluation";
  }
  handle(pd, wrappedVcs) {
    const results = [...this.getResults()];
    const errors = results.filter((result) => result.status === Status.ERROR);
    const infos = this.retrieveNoErrorStatus(results, errors);
    this.client.wrappedVcs = wrappedVcs;
    this.produceErrorResults(errors);
    this.produceSuccessResults(infos, pd);
  }
  retrieveNoErrorStatus(results, errors) {
    const info = results.filter((e2) => e2.status !== Status.ERROR);
    return info.filter((a) => !errors.find((b) => a.input_descriptor_path === b.input_descriptor_path && a.verifiable_credential_path === b.verifiable_credential_path));
  }
  produceSuccessResults(infos, pd) {
    this.removeDuplicate(infos).forEach((info) => {
      const parsedPath = JSONPath.nodes(pd, info.input_descriptor_path);
      const group = parsedPath[0].value.group;
      this.getResults().push({
        input_descriptor_path: info.input_descriptor_path,
        verifiable_credential_path: info.verifiable_credential_path,
        evaluator: this.getName(),
        status: Status.INFO,
        payload: { group },
        message: Messages_default.INPUT_CANDIDATE_IS_ELIGIBLE_FOR_PRESENTATION_SUBMISSION
      });
    });
  }
  produceErrorResults(errors) {
    this.removeDuplicate(errors).forEach((error) => {
      const payload = { ...error.payload };
      payload.evaluator = error.evaluator;
      this.getResults().push({
        ...error,
        evaluator: this.getName(),
        message: Messages_default.INPUT_CANDIDATE_IS_NOT_ELIGIBLE_FOR_PRESENTATION_SUBMISSION,
        payload
      });
    });
  }
};

// node_modules/@sphereon/pex/dist/module/lib/evaluation/handlers/predicateRelatedFieldEvaluationHandler.js
var import_dist31 = __toESM(require_dist());
var import_pex_models3 = __toESM(require_dist4());
var PredicateRelatedFieldEvaluationHandler = class extends AbstractEvaluationHandler {
  constructor(client) {
    super(client);
  }
  getName() {
    return "PredicateRelatedFieldEvaluation";
  }
  handle(pd) {
    pd.input_descriptors.forEach((inDesc, index2) => {
      if (inDesc.constraints) {
        this.examinePredicateRelatedField(index2, inDesc.constraints);
      }
    });
  }
  examinePredicateRelatedField(input_descriptor_idx, constraints) {
    if (constraints == null ? void 0 : constraints.fields) {
      for (let i = 0; i < constraints.fields.length; i++) {
        for (let j = 0; j < this.getResults().length; j++) {
          this.examinePredicateForFilterEvaluationResult(this.getResults(), j, input_descriptor_idx, constraints, i);
        }
      }
    }
  }
  examinePredicateForFilterEvaluationResult(results, resultIdx, input_descriptor_idx, constraints, fieldIdx) {
    var _a;
    const resultInputDescriptorIdx = this.retrieveResultInputDescriptorIdx(results[resultIdx].input_descriptor_path);
    if (results[resultIdx].payload && results[resultIdx].payload.result && results[resultIdx].payload.result.path && results[resultIdx].evaluator === "FilterEvaluation" && input_descriptor_idx === resultInputDescriptorIdx && constraints && constraints.fields && constraints.fields[fieldIdx] && constraints.fields[fieldIdx].predicate && constraints.fields[fieldIdx].path && ((_a = constraints.fields[fieldIdx].path) == null ? void 0 : _a.includes(this.concatenatePath(results[resultIdx].payload.result.path)))) {
      const evaluationResult = { ...results[resultIdx].payload.result };
      const resultObject = this.createResultObject(input_descriptor_idx, resultIdx, evaluationResult, results);
      if (constraints.fields[fieldIdx].predicate === import_pex_models3.Optionality.Required) {
        results.push(resultObject);
      } else {
        resultObject.payload["value"] = true;
        results.push(resultObject);
      }
    }
  }
  retrieveResultInputDescriptorIdx(input_descriptor_path) {
    const inputDescriptorText = "$.input_descriptors[";
    const startIdx = input_descriptor_path.indexOf(inputDescriptorText);
    const startWithIdx = input_descriptor_path.substring(startIdx + inputDescriptorText.length);
    const endIdx = startWithIdx.indexOf("]");
    const idx = startWithIdx.substring(0, endIdx);
    return parseInt(idx);
  }
  concatenatePath(path) {
    let completePath = "";
    for (let i = 0; i < path.length; i++) {
      if (typeof path[i] === "number") {
        completePath = completePath.substring(0, completePath.length - 1);
        completePath += "[*].";
      } else {
        completePath += path[i] + ".";
      }
    }
    return completePath.substring(0, completePath.length - 1);
  }
  createResultObject(input_descriptor_idx, resultIdx, evaluationResult, results) {
    return {
      input_descriptor_path: `$.input_descriptors[${input_descriptor_idx}]`,
      verifiable_credential_path: results[resultIdx].verifiable_credential_path,
      evaluator: this.getName(),
      status: Status.INFO,
      message: Messages_default.INPUT_CANDIDATE_IS_ELIGIBLE_FOR_PRESENTATION_SUBMISSION,
      payload: evaluationResult
    };
  }
};

// node_modules/@sphereon/pex/dist/module/lib/evaluation/handlers/sameSubjectEvaluationHandler.js
var import_dist32 = __toESM(require_dist());
var import_pex_models4 = __toESM(require_dist4());
var SameSubjectEvaluationHandler = class extends AbstractEvaluationHandler {
  constructor(client) {
    super(client);
    __publicField(this, "fieldIds");
    __publicField(this, "sameSubject");
    __publicField(this, "messages");
    this.fieldIds = [];
    this.sameSubject = [];
    this.messages = /* @__PURE__ */ new Map();
    this.messages.set(Status.INFO, "The field ids requiring the same subject to belong to same subject");
    this.messages.set(Status.WARN, "The field ids preferring the same subject to belong to same subject");
    this.messages.set(Status.ERROR, "The fields ids not belong to the same subject");
  }
  getName() {
    return "SameSubjectEvaluation";
  }
  handle(pd, wrappedVcs) {
    const sameSubjectInDesc = this.mapSameSubjectFieldIdsToInputDescriptors(pd);
    const handlerCheckResults = this.mapCredentialsToResultObjecs(wrappedVcs, sameSubjectInDesc);
    const fieldIdOccurrencesCount = this.countSameSubjectOccurrences(sameSubjectInDesc, handlerCheckResults);
    this.generateErrorResults(fieldIdOccurrencesCount, handlerCheckResults);
    this.updatePresentationSubmission(pd);
  }
  mapSameSubjectFieldIdsToInputDescriptors(pd) {
    this.fieldIds.push(...JSONPath.nodes(pd, "$..fields[*].id"));
    this.sameSubject.push(...JSONPath.nodes(pd, "$..same_subject[*]"));
    const results = [];
    this.fieldIds.forEach((f) => {
      const sameSubject = this.sameSubject.find((ss) => ss.value.field_id.includes(f.value));
      if (sameSubject) {
        results.push([f, sameSubject]);
      }
    });
    return results;
  }
  generateErrorResults(fieldIdOccurrencesCount, handlerCheckResults) {
    fieldIdOccurrencesCount.forEach((v, k) => {
      const results = handlerCheckResults.filter((r2) => k === r2.payload.fieldIdSet).map((r2) => r2.payload.credentialSubject.id);
      if (results.length !== v || new Set(results).size !== 1) {
        handlerCheckResults.forEach((v2, i, arr) => {
          if (v2.payload.fieldIdSet === k) {
            v2.status = Status.ERROR;
            v2.message = this.messages.get(Status.ERROR);
            arr[i] = v2;
          }
        });
      }
    });
    this.client.results.push(...handlerCheckResults);
  }
  countSameSubjectOccurrences(sameSubjectInDesc, handlerCheckResults) {
    const fieldIdOccurrencesCount = /* @__PURE__ */ new Map();
    sameSubjectInDesc.forEach((s) => {
      const result = handlerCheckResults.filter((c) => s[1].value.field_id === c.payload.fieldIdSet);
      if (result) {
        if (fieldIdOccurrencesCount.has(s[1].value.field_id) && fieldIdOccurrencesCount.get(s[1].value.field_id)) {
          fieldIdOccurrencesCount.set(s[1].value.field_id, fieldIdOccurrencesCount.get(s[1].value.field_id) + 1);
        } else {
          fieldIdOccurrencesCount.set(s[1].value.field_id, 1);
        }
      }
    });
    return fieldIdOccurrencesCount;
  }
  mapCredentialsToResultObjecs(wrappedVcs, results) {
    const subjects = [
      ...JSONPath.nodes(wrappedVcs.map((wvc) => wvc.credential), "$..credentialSubject")
    ];
    const handlerCheckResults = [];
    subjects.forEach((s) => {
      const result = results.find((id) => JSONPath.query(s.value, `$..${id[0].value}`).length !== 0);
      if (result && result[1].value.directive === import_pex_models4.Optionality.Required) {
        handlerCheckResults.push({
          input_descriptor_path: JSONPath.stringify(result[0].path.slice(0, 3)),
          status: Status.INFO,
          evaluator: this.getName(),
          payload: { fieldIdSet: result[1].value.field_id, credentialSubject: s.value },
          message: this.messages.get(Status.INFO),
          verifiable_credential_path: JSONPath.stringify(s.path.slice(0, 2))
        });
      } else if (result && result[1].value.directive === import_pex_models4.Optionality.Preferred) {
        handlerCheckResults.push({
          input_descriptor_path: JSONPath.stringify(result[0].path.slice(0, 3)),
          status: Status.WARN,
          evaluator: this.getName(),
          payload: { fieldIdSet: result[1].value.field_id, credentialSubject: s.value },
          message: this.messages.get(Status.WARN),
          verifiable_credential_path: JSONPath.stringify(s.path.slice(0, 2))
        });
      }
    });
    return handlerCheckResults;
  }
};

// node_modules/@sphereon/pex/dist/module/lib/evaluation/handlers/subjectIsIssuerEvaluationHandler.js
var import_dist33 = __toESM(require_dist());
var import_pex_models5 = __toESM(require_dist4());
var import_ssi_types2 = __toESM(require_dist2());
var SubjectIsIssuerEvaluationHandler = class extends AbstractEvaluationHandler {
  constructor(client) {
    super(client);
  }
  getName() {
    return "SubjectIsIssuerEvaluation";
  }
  handle(pd, wrappedVcs) {
    pd.input_descriptors.forEach((inputDescriptor, index2) => {
      const constraints = inputDescriptor.constraints;
      if ((constraints == null ? void 0 : constraints.subject_is_issuer) === import_pex_models5.Optionality.Required) {
        this.checkSubjectIsIssuer(inputDescriptor.id, wrappedVcs, index2);
      } else {
        this.getResults().push(...wrappedVcs.map((wvc, vcIndex) => this.generateSuccessResult(index2, `$[${vcIndex}]`, wvc, "not applicable")));
      }
    });
    this.updatePresentationSubmission(pd);
  }
  checkSubjectIsIssuer(inputDescriptorId, wrappedVcs, idIdx) {
    this.client.presentationSubmission.descriptor_map.forEach((currentDescriptor) => {
      if (currentDescriptor.id === inputDescriptorId) {
        const mappings = JsonPathUtils.extractInputField(wrappedVcs.map((wvc) => wvc.credential), [currentDescriptor.path]);
        for (const mapping of mappings) {
          const issuer = getIssuerString(mapping.value);
          if (mapping && mapping.value && getSubjectIdsAsString(mapping.value).every((item) => item === issuer)) {
            this.getResults().push(this.generateSuccessResult(idIdx, currentDescriptor.path, import_ssi_types2.CredentialMapper.toWrappedVerifiableCredential(mapping.value)));
          } else {
            this.getResults().push(this.generateErrorResult(idIdx, currentDescriptor.path, import_ssi_types2.CredentialMapper.toWrappedVerifiableCredential(mapping.value)));
          }
        }
      }
    });
  }
  generateErrorResult(idIdx, vcPath, wvc) {
    return {
      input_descriptor_path: `$.input_descriptors[${idIdx}]`,
      evaluator: this.getName(),
      status: Status.ERROR,
      message: Messages_default.SUBJECT_IS_NOT_ISSUER,
      verifiable_credential_path: vcPath,
      payload: {
        format: wvc.format
      }
    };
  }
  generateSuccessResult(idIdx, vcPath, wvc, message) {
    return {
      input_descriptor_path: `$.input_descriptors[${idIdx}]`,
      evaluator: this.getName(),
      status: Status.INFO,
      message: message ?? Messages_default.SUBJECT_IS_ISSUER,
      verifiable_credential_path: vcPath,
      payload: {
        format: wvc.format
      }
    };
  }
};

// node_modules/@sphereon/pex/dist/module/lib/evaluation/handlers/uriEvaluationHandler.js
var import_dist36 = __toESM(require_dist());

// node_modules/nanoid/index.browser.js
var import_dist35 = __toESM(require_dist());

// node_modules/nanoid/url-alphabet/index.js
var import_dist34 = __toESM(require_dist(), 1);

// node_modules/nanoid/index.browser.js
var nanoid = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
  byte &= 63;
  if (byte < 36) {
    id += byte.toString(36);
  } else if (byte < 62) {
    id += (byte - 26).toString(36).toUpperCase();
  } else if (byte > 62) {
    id += "-";
  } else {
    id += "_";
  }
  return id;
}, "");

// node_modules/@sphereon/pex/dist/module/lib/evaluation/handlers/uriEvaluationHandler.js
var _UriEvaluationHandler = class _UriEvaluationHandler extends AbstractEvaluationHandler {
  constructor(client) {
    super(client);
  }
  getName() {
    return "UriEvaluation";
  }
  handle(definition, wrappedVcs) {
    definition.input_descriptors.forEach((inDesc, descriptorIdx) => {
      const uris = definition.getVersion() !== PEVersion.v2 ? inDesc.schema.map((so) => so.uri) : [];
      wrappedVcs.forEach((wvc, wrappedVCIdx) => {
        const vcUris = _UriEvaluationHandler.buildVcContextAndSchemaUris(wvc.credential, definition.getVersion());
        this.evaluateUris(wvc, vcUris, uris, descriptorIdx, wrappedVCIdx, definition.getVersion());
      });
    });
    const descriptorMap = this.getResults().filter((result) => result.status === Status.INFO).map((result) => {
      var _a;
      const inputDescriptor = JSONPath.nodes(definition, result.input_descriptor_path)[0].value;
      return {
        id: inputDescriptor.id,
        format: (_a = result.payload) == null ? void 0 : _a.format,
        path: result.verifiable_credential_path
      };
    });
    if (this.client.generatePresentationSubmission && (!this.presentationSubmission || Object.keys(this.presentationSubmission).length === 0)) {
      this.presentationSubmission = {
        id: nanoid(),
        definition_id: definition.id,
        descriptor_map: descriptorMap
      };
    }
  }
  evaluateUris(wvc, verifiableCredentialUris, inputDescriptorsUris, idIdx, vcIdx, pdVersion) {
    let hasAnyMatch = false;
    if (pdVersion === PEVersion.v1) {
      for (let i = 0; i < inputDescriptorsUris.length; i++) {
        if (_UriEvaluationHandler.containsHashlink(inputDescriptorsUris[i])) {
          this.getResults().push(this.createWarnResultObject(idIdx, vcIdx));
        }
      }
      for (let i = 0; i < verifiableCredentialUris.length; i++) {
        if (inputDescriptorsUris.find((el) => el === verifiableCredentialUris[i]) != void 0) {
          hasAnyMatch = true;
        }
      }
    } else {
      hasAnyMatch = true;
    }
    if (hasAnyMatch) {
      this.getResults().push(this.createSuccessResultObject(wvc, inputDescriptorsUris, idIdx, vcIdx));
    } else {
      this.getResults().push(this.createErrorResultObject(wvc, inputDescriptorsUris, idIdx, vcIdx));
    }
  }
  static buildVcContextAndSchemaUris(credential, version) {
    const uris = [];
    if (Array.isArray(credential["@context"])) {
      credential["@context"].forEach((value) => uris.push(value));
    } else {
      uris.push(credential["@context"]);
    }
    if (Array.isArray(credential.credentialSchema) && credential.credentialSchema.length > 0) {
      credential.credentialSchema.forEach((element) => uris.push(element.id));
    } else if (credential.credentialSchema) {
      uris.push(credential.credentialSchema.id);
    }
    if (version === PEVersion.v1) {
      Array.isArray(credential.type) ? credential.type.forEach((type) => uris.push(type)) : credential.type ? uris.push(credential.type) : void 0;
    }
    return uris;
  }
  createSuccessResultObject(wvc, inputDescriptorsUris, idIdx, vcIdx) {
    const result = this.createResult(idIdx, vcIdx);
    result.status = Status.INFO;
    result.message = Messages_default.URI_EVALUATION_PASSED;
    result.payload = {
      format: wvc.format,
      vcContext: wvc.credential["@context"],
      vcCredentialSchema: wvc.credential.credentialSchema,
      inputDescriptorsUris
    };
    return result;
  }
  createErrorResultObject(wvc, inputDescriptorsUris, idIdx, vcIdx) {
    const result = this.createResult(idIdx, vcIdx);
    result.status = Status.ERROR;
    result.message = Messages_default.URI_EVALUATION_DIDNT_PASS;
    result.payload = {
      format: wvc.format,
      vcContext: wvc.credential["@context"],
      vcCredentialSchema: wvc.credential.credentialSchema,
      inputDescriptorsUris
    };
    return result;
  }
  createWarnResultObject(idIdx, vcIdx) {
    const result = this.createResult(idIdx, vcIdx);
    result.status = Status.WARN;
    result.message = Messages_default.URI_EVALUATION_DIDNT_PASS;
    result.payload = Messages_default.INPUT_DESCRIPTOR_CONTEXT_CONTAINS_HASHLINK_VERIFICATION_NOT_SUPPORTED;
    return result;
  }
  createResult(idIdx, vcIdx) {
    return {
      input_descriptor_path: `$.input_descriptors[${idIdx}]`,
      verifiable_credential_path: `$[${vcIdx}]`,
      evaluator: this.getName(),
      status: Status.INFO,
      message: void 0
    };
  }
  static containsHashlink(url) {
    return !(this.matchAll(url, _UriEvaluationHandler.HASHLINK_QUERY_URL_REGEX).next().done && this.matchAll(url, _UriEvaluationHandler.HASHLINK_URL_ENCODED_REGEX).next().done);
  }
};
__publicField(_UriEvaluationHandler, "matchAll", require_string_prototype2());
__publicField(_UriEvaluationHandler, "HASHLINK_URL_ENCODED_REGEX", /hl:[a-zA-Z0-9]+:[a-zA-Z0-9]+/g);
__publicField(_UriEvaluationHandler, "HASHLINK_QUERY_URL_REGEX", /https*?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)(hl=[a-zA-Z0-9]+)/g);
var UriEvaluationHandler = _UriEvaluationHandler;

// node_modules/@sphereon/pex/dist/module/lib/evaluation/handlers/formatRestrictionEvaluationHandler.js
var import_dist37 = __toESM(require_dist());
var FormatRestrictionEvaluationHandler = class extends AbstractEvaluationHandler {
  constructor(client) {
    super(client);
  }
  getName() {
    return "FormatRestrictionEvaluation";
  }
  handle(pd, wrappedVcs) {
    pd.input_descriptors.forEach((_inputDescriptor, index2) => {
      wrappedVcs.forEach((wvc, vcIndex) => {
        if (!this.client.restrictToFormats || Object.keys(this.client.restrictToFormats).includes(wvc.format)) {
          this.getResults().push(this.generateSuccessResult(index2, `$[${vcIndex}]`, wvc, `${wvc.format} is allowed`));
        } else {
          this.getResults().push(this.generateErrorResult(index2, `$[${vcIndex}]`, wvc));
        }
      });
    });
    this.updatePresentationSubmission(pd);
  }
  generateErrorResult(idIdx, vcPath, wvc) {
    return {
      input_descriptor_path: `$.input_descriptors[${idIdx}]`,
      evaluator: this.getName(),
      status: Status.ERROR,
      message: Messages_default.FORMAT_RESTRICTION_DIDNT_PASS,
      verifiable_credential_path: vcPath,
      payload: {
        format: wvc.format
      }
    };
  }
  generateSuccessResult(idIdx, vcPath, wvc, message) {
    return {
      input_descriptor_path: `$.input_descriptors[${idIdx}]`,
      evaluator: this.getName(),
      status: Status.INFO,
      message: message ?? Messages_default.FORMAT_RESTRICTION_PASSED,
      verifiable_credential_path: vcPath,
      payload: {
        format: wvc.format
      }
    };
  }
};

// node_modules/@sphereon/pex/dist/module/lib/evaluation/handlers/didRestrictionEvaluationHandler.js
var import_dist38 = __toESM(require_dist());
var DIDRestrictionEvaluationHandler = class extends AbstractEvaluationHandler {
  constructor(client) {
    super(client);
  }
  getName() {
    return "DIDRestrictionEvaluation";
  }
  handle(pd, wrappedVcs) {
    pd.input_descriptors.forEach((_inputDescriptor, index2) => {
      wrappedVcs.forEach((wvc, vcIndex) => {
        const issuer = typeof wvc.credential.issuer === "object" ? wvc.credential.issuer.id : wvc.credential.issuer;
        if (!this.client.hasRestrictToDIDMethods() || !issuer || isRestrictedDID(issuer, this.client.restrictToDIDMethods) || !issuer.toLowerCase().startsWith("did:")) {
          this.getResults().push(this.generateSuccessResult(index2, `$[${vcIndex}]`, wvc, `${issuer} is allowed`));
        } else {
          this.getResults().push(this.generateErrorResult(index2, `$[${vcIndex}]`, wvc));
        }
      });
    });
    this.updatePresentationSubmission(pd);
  }
  generateErrorResult(idIdx, vcPath, wvc) {
    return {
      input_descriptor_path: `$.input_descriptors[${idIdx}]`,
      evaluator: this.getName(),
      status: Status.ERROR,
      message: Messages_default.FORMAT_RESTRICTION_DIDNT_PASS,
      verifiable_credential_path: vcPath,
      payload: {
        format: wvc.format
      }
    };
  }
  generateSuccessResult(idIdx, vcPath, wvc, message) {
    return {
      input_descriptor_path: `$.input_descriptors[${idIdx}]`,
      evaluator: this.getName(),
      status: Status.INFO,
      message: message ?? Messages_default.FORMAT_RESTRICTION_PASSED,
      verifiable_credential_path: vcPath,
      payload: {
        format: wvc.format
      }
    };
  }
};

// node_modules/@sphereon/pex/dist/module/lib/evaluation/evaluationClient.js
var DEFAULT_LIMIT_DISCLOSURE_TYPES = [import_ssi_types3.IProofType.BbsBlsSignatureProof2020];
var EvaluationClient = class {
  constructor() {
    __publicField(this, "failed_catched", {
      tag: "root",
      status: Status.ERROR,
      message: Messages_default.UNKNOWN_EXCEPTION,
      stacktrace: ""
    });
    __publicField(this, "_results");
    __publicField(this, "_wrappedVcs");
    __publicField(this, "_presentationSubmission");
    // private _requirePresentationSubmission: boolean;
    __publicField(this, "_dids");
    __publicField(this, "_limitDisclosureSignatureSuites");
    __publicField(this, "_restrictToFormats");
    __publicField(this, "_restrictToDIDMethods");
    __publicField(this, "_generatePresentationSubmission");
    this._results = [];
    this._wrappedVcs = [];
    this._presentationSubmission = {};
    this._dids = [];
    this._limitDisclosureSignatureSuites = DEFAULT_LIMIT_DISCLOSURE_TYPES;
    this._restrictToDIDMethods = [];
    this._generatePresentationSubmission = true;
  }
  evaluate(pd, wvcs, opts) {
    this._restrictToDIDMethods = (opts == null ? void 0 : opts.restrictToDIDMethods) ? uniformDIDMethods(opts == null ? void 0 : opts.restrictToDIDMethods) : [];
    this._dids = (opts == null ? void 0 : opts.holderDIDs) ? filterToRestrictedDIDs(opts.holderDIDs, this._restrictToDIDMethods) : [];
    this._limitDisclosureSignatureSuites = opts == null ? void 0 : opts.limitDisclosureSignatureSuites;
    this._restrictToFormats = opts == null ? void 0 : opts.restrictToFormats;
    this._generatePresentationSubmission = (opts == null ? void 0 : opts.generatePresentationSubmission) !== void 0 ? opts.generatePresentationSubmission : true;
    if (opts == null ? void 0 : opts.presentationSubmission) {
      this._presentationSubmission = opts.presentationSubmission;
    }
    let currentHandler = this.initEvaluationHandlers();
    currentHandler == null ? void 0 : currentHandler.handle(pd, wvcs);
    while (currentHandler == null ? void 0 : currentHandler.hasNext()) {
      currentHandler = currentHandler.getNext();
      try {
        currentHandler == null ? void 0 : currentHandler.handle(pd, wvcs);
      } catch (e2) {
        this.failed_catched.message += e2.message;
        this.failed_catched.stacktrace = e2;
        throw this.failed_catched;
      }
    }
  }
  get results() {
    return this._results;
  }
  get dids() {
    return this._dids;
  }
  set dids(dids) {
    this._dids = dids;
  }
  assertPresentationSubmission() {
    if (!this.generatePresentationSubmission && (!this.presentationSubmission || Object.keys(this.presentationSubmission).length === 0)) {
      throw Error("No presentation submission present, but required option was set");
    }
  }
  get generatePresentationSubmission() {
    return this._generatePresentationSubmission;
  }
  set generatePresentationSubmission(value) {
    this._generatePresentationSubmission = value;
  }
  get presentationSubmission() {
    return this._presentationSubmission;
  }
  set presentationSubmission(presentationSubmission) {
    this._presentationSubmission = presentationSubmission;
  }
  get wrappedVcs() {
    return this._wrappedVcs;
  }
  set wrappedVcs(wrappedVcs) {
    this._wrappedVcs = wrappedVcs;
  }
  get limitDisclosureSignatureSuites() {
    return this._limitDisclosureSignatureSuites || DEFAULT_LIMIT_DISCLOSURE_TYPES;
  }
  set limitDisclosureSignatureSuites(limitDisclosureSignatureSuites) {
    this._limitDisclosureSignatureSuites = limitDisclosureSignatureSuites;
  }
  get restrictToDIDMethods() {
    return this._restrictToDIDMethods;
  }
  set restrictToDIDMethods(value) {
    this._restrictToDIDMethods = uniformDIDMethods(value);
  }
  hasRestrictToDIDMethods() {
    return this.restrictToDIDMethods && this.restrictToDIDMethods.length > 0;
  }
  get restrictToFormats() {
    return this._restrictToFormats;
  }
  set restrictToFormats(value) {
    this._restrictToFormats = value;
  }
  initEvaluationHandlers() {
    const uriEvaluation = new UriEvaluationHandler(this);
    uriEvaluation.setNext(new DIDRestrictionEvaluationHandler(this)).setNext(new FormatRestrictionEvaluationHandler(this)).setNext(new InputDescriptorFilterEvaluationHandler(this)).setNext(new PredicateRelatedFieldEvaluationHandler(this)).setNext(new LimitDisclosureEvaluationHandler(this)).setNext(new SubjectIsIssuerEvaluationHandler(this)).setNext(new SubjectIsHolderEvaluationHandler(this)).setNext(new SameSubjectEvaluationHandler(this)).setNext(new MarkForSubmissionEvaluationHandler(this));
    return uriEvaluation;
  }
};

// node_modules/@sphereon/pex/dist/module/lib/evaluation/evaluationClientWrapper.js
var import_dist41 = __toESM(require_dist());
var import_pex_models6 = __toESM(require_dist4());
var EvaluationClientWrapper = class {
  constructor() {
    __publicField(this, "_client");
    this._client = new EvaluationClient();
  }
  getEvaluationClient() {
    return this._client;
  }
  selectFrom(presentationDefinition, wrappedVerifiableCredentials, opts) {
    var _a;
    let selectResults;
    this._client.evaluate(presentationDefinition, wrappedVerifiableCredentials, opts);
    const warnings = [...this.formatNotInfo(Status.WARN)];
    const errors = [...this.formatNotInfo(Status.ERROR)];
    if (presentationDefinition.submission_requirements) {
      const info = this._client.results.filter((result) => result.evaluator === "MarkForSubmissionEvaluation" && result.payload.group && result.status !== Status.ERROR);
      const marked = Array.from(new Set(info));
      let matchSubmissionRequirements;
      try {
        matchSubmissionRequirements = this.matchSubmissionRequirements(presentationDefinition, presentationDefinition.submission_requirements, marked);
      } catch (e2) {
        const matchingError = { status: Status.ERROR, message: JSON.stringify(e2), tag: "matchSubmissionRequirements" };
        return {
          errors: errors ? [...errors, matchingError] : [matchingError],
          warnings,
          areRequiredCredentialsPresent: Status.ERROR
        };
      }
      const matches = this.extractMatches(matchSubmissionRequirements);
      const credentials = matches.map((e2) => JSONPath.nodes(this._client.wrappedVcs.map((wrapped) => wrapped.original), e2)[0].value);
      const areRequiredCredentialsPresent = this.determineAreRequiredCredentialsPresent(presentationDefinition, matchSubmissionRequirements);
      selectResults = {
        errors: areRequiredCredentialsPresent === Status.INFO ? [] : errors,
        matches: [...matchSubmissionRequirements],
        areRequiredCredentialsPresent,
        verifiableCredential: credentials,
        warnings
      };
    } else {
      const marked = this._client.results.filter((result) => result.evaluator === "MarkForSubmissionEvaluation" && result.status !== Status.ERROR);
      const checkWithoutSRResults = this.checkWithoutSubmissionRequirements(marked, presentationDefinition);
      if (!checkWithoutSRResults.length) {
        const matchSubmissionRequirements = this.matchWithoutSubmissionRequirements(marked, presentationDefinition);
        const matches = this.extractMatches(matchSubmissionRequirements);
        const credentials = matches.map((e2) => JSONPath.nodes(this._client.wrappedVcs.map((wrapped) => wrapped.original), e2)[0].value);
        selectResults = {
          errors: [],
          matches: [...matchSubmissionRequirements],
          areRequiredCredentialsPresent: Status.INFO,
          verifiableCredential: credentials,
          warnings
        };
      } else {
        return {
          errors,
          matches: [],
          areRequiredCredentialsPresent: Status.ERROR,
          verifiableCredential: wrappedVerifiableCredentials.map((value) => value.original),
          warnings
        };
      }
    }
    this.fillSelectableCredentialsToVerifiableCredentialsMapping(selectResults, wrappedVerifiableCredentials);
    selectResults.areRequiredCredentialsPresent = this.determineAreRequiredCredentialsPresent(presentationDefinition, selectResults == null ? void 0 : selectResults.matches);
    this.remapMatches(wrappedVerifiableCredentials.map((wrapped) => wrapped.original), selectResults.matches, selectResults == null ? void 0 : selectResults.verifiableCredential);
    (_a = selectResults.matches) == null ? void 0 : _a.forEach((m) => {
      this.updateSubmissionRequirementMatchPathToAlias(m, "verifiableCredential");
    });
    if (selectResults.areRequiredCredentialsPresent === Status.INFO) {
      selectResults.errors = [];
    } else {
      selectResults.errors = errors;
      selectResults.warnings = warnings;
      selectResults.verifiableCredential = wrappedVerifiableCredentials.map((value) => value.original);
    }
    return selectResults;
  }
  remapMatches(verifiableCredentials, submissionRequirementMatches, vcsToSend) {
    submissionRequirementMatches == null ? void 0 : submissionRequirementMatches.forEach((srm) => {
      if (srm.from_nested) {
        this.remapMatches(verifiableCredentials, srm.from_nested, vcsToSend);
      } else {
        srm.vc_path.forEach((match2, index2, matches) => {
          const vc = JSONPath.query(verifiableCredentials, match2)[0];
          const newIndex = vcsToSend == null ? void 0 : vcsToSend.findIndex((svc) => JSON.stringify(svc) === JSON.stringify(vc));
          if (newIndex === -1) {
            throw new Error(`The index of the VerifiableCredential in your current call can't be found in your previously submitted credentials. Are you trying to send a new Credential?
verifiableCredential: ${vc}`);
          }
          matches[index2] = `$[${newIndex}]`;
        });
        srm.name;
      }
    });
  }
  extractMatches(matchSubmissionRequirements) {
    const matches = [];
    matchSubmissionRequirements.forEach((e2) => {
      matches.push(...e2.vc_path);
      if (e2.from_nested) {
        matches.push(...this.extractMatches(e2.from_nested));
      }
    });
    return Array.from(new Set(matches));
  }
  /**
   * Since this is without SubmissionRequirements object, each InputDescriptor has to have at least one corresponding VerifiableCredential
   * @param marked: info logs for `MarkForSubmissionEvaluation` handler
   * @param pd
   * @private
   */
  checkWithoutSubmissionRequirements(marked, pd) {
    const checkResult = [];
    if (!pd.input_descriptors) {
      return [];
    }
    if (!marked.length) {
      return [
        {
          input_descriptor_path: "",
          evaluator: "checkWithoutSubmissionRequirement",
          verifiable_credential_path: "",
          status: Status.ERROR,
          payload: `Not all the InputDescriptors are addressed`
        }
      ];
    }
    const inputDescriptors = pd.input_descriptors;
    const markedInputDescriptorPaths = ObjectUtils.getDistinctFieldInObject(marked, "input_descriptor_path");
    if (markedInputDescriptorPaths.length !== inputDescriptors.length) {
      const inputDescriptorsFromLogs = markedInputDescriptorPaths.map((value) => JsonPathUtils.extractInputField(pd, [value])[0].value).map((value) => value.id);
      for (let i = 0; i < pd.input_descriptors.length; i++) {
        if (inputDescriptorsFromLogs.indexOf(pd.input_descriptors[i].id) == -1) {
          checkResult.push({
            input_descriptor_path: `$.input_descriptors[${i}]`,
            evaluator: "checkWithoutSubmissionRequirement",
            verifiable_credential_path: "",
            status: Status.ERROR,
            payload: `Not all the InputDescriptors are addressed`
          });
        }
      }
    }
    return checkResult;
  }
  matchSubmissionRequirements(pd, submissionRequirements, marked) {
    const submissionRequirementMatches = [];
    for (const sr of submissionRequirements) {
      const srm = {
        name: pd.name || pd.id,
        rule: sr.rule,
        vc_path: []
      };
      if (sr.from) {
        srm.from = sr.from;
      }
      sr.min ? srm.min = sr.min : void 0;
      sr.max ? srm.max = sr.max : void 0;
      sr.count ? srm.count = sr.count : void 0;
      if (sr.from) {
        const matchingDescriptors = this.mapMatchingDescriptors(pd, sr, marked);
        if (matchingDescriptors) {
          srm.vc_path.push(...matchingDescriptors.vc_path);
          srm.name = matchingDescriptors.name;
          submissionRequirementMatches.push(srm);
        }
      } else if (sr.from_nested) {
        try {
          srm.from_nested = this.matchSubmissionRequirements(pd, sr.from_nested, marked);
          submissionRequirementMatches.push(srm);
        } catch (err) {
          throw new Error(`Error in handling value of from_nested: ${sr.from_nested}: err: ${err}`);
        }
      } else {
        throw new Error("Invalid SubmissionRequirement object: Must contain either 'from' or 'from_nested'");
      }
    }
    return submissionRequirementMatches;
  }
  matchWithoutSubmissionRequirements(marked, pd) {
    const submissionRequirementMatches = [];
    const partitionedIdToVcMap = this.createIdToVcMap(marked);
    for (const [idPath, sameIdVcs] of partitionedIdToVcMap.entries()) {
      if (!sameIdVcs || !sameIdVcs.length) {
        continue;
      }
      for (const vcPath of sameIdVcs) {
        const idRes = JsonPathUtils.extractInputField(pd, [idPath]);
        if (idRes.length) {
          submissionRequirementMatches.push({
            name: idRes[0].value.name || idRes[0].value.id,
            rule: import_pex_models6.Rules.All,
            vc_path: [vcPath]
          });
        }
      }
    }
    return this.removeDuplicateSubmissionRequirementMatches(submissionRequirementMatches);
  }
  mapMatchingDescriptors(pd, sr, marked) {
    var _a;
    const srm = { rule: sr.rule, vc_path: [] };
    if (sr == null ? void 0 : sr.from) {
      srm.from = sr.from;
      for (const m of marked) {
        const inDesc = JSONPath.query(pd, m.input_descriptor_path)[0];
        if (inDesc.group && inDesc.group.indexOf(sr.from) === -1) {
          continue;
        }
        srm.name = inDesc.name || inDesc.id;
        if (m.payload.group.includes(sr.from)) {
          if (((_a = srm.vc_path) == null ? void 0 : _a.indexOf(m.verifiable_credential_path)) === -1) {
            srm.vc_path.push(m.verifiable_credential_path);
          }
        }
      }
    }
    return srm;
  }
  evaluate(pd, wvcs, opts) {
    var _a, _b, _c, _d;
    this._client.evaluate(pd, wvcs, opts);
    const result = {
      areRequiredCredentialsPresent: Status.INFO,
      verifiableCredential: wvcs.map((wrapped) => wrapped.original)
    };
    result.warnings = this.formatNotInfo(Status.WARN);
    result.errors = this.formatNotInfo(Status.ERROR);
    this._client.assertPresentationSubmission();
    if ((_a = this._client.presentationSubmission) == null ? void 0 : _a.descriptor_map.length) {
      const len = (_b = this._client.presentationSubmission) == null ? void 0 : _b.descriptor_map.length;
      for (let i = 0; i < len; i++) {
        this._client.presentationSubmission.descriptor_map[i] && this._client.presentationSubmission.descriptor_map.push(this._client.presentationSubmission.descriptor_map[i]);
      }
      this._client.presentationSubmission.descriptor_map.splice(0, len);
      result.value = JSON.parse(JSON.stringify(this._client.presentationSubmission));
    }
    if (this._client.generatePresentationSubmission) {
      this.updatePresentationSubmissionPathToAlias("verifiableCredential", result.value);
    }
    result.verifiableCredential = this._client.wrappedVcs.map((wrapped) => wrapped.original);
    result.areRequiredCredentialsPresent = ((_d = (_c = result.value) == null ? void 0 : _c.descriptor_map) == null ? void 0 : _d.length) ? Status.INFO : Status.ERROR;
    return result;
  }
  formatNotInfo(status) {
    return this._client.results.filter((result) => result.status === status).map((x) => {
      const vcPath = x.verifiable_credential_path.substring(1);
      return {
        tag: x.evaluator,
        status: x.status,
        message: `${x.message}: ${x.input_descriptor_path}: $.verifiableCredential${vcPath}`
      };
    });
  }
  submissionFrom(pd, vcs) {
    if (!this._client.results.length) {
      throw Error("You need to call evaluate() before pex.presentationFrom()");
    }
    if (!this._client.generatePresentationSubmission) {
      return this._client.presentationSubmission;
    }
    if (pd.submission_requirements) {
      const marked2 = this._client.results.filter((result2) => result2.evaluator === "MarkForSubmissionEvaluation" && result2.payload.group && result2.status !== Status.ERROR);
      const [updatedMarked, upIdx] = this.matchUserSelectedVcs(marked2, vcs);
      const groupCount = /* @__PURE__ */ new Map();
      if ("input_descriptors" in pd) {
        pd.input_descriptors.forEach((e2) => {
          if (e2.group) {
            e2.group.forEach((key) => {
              if (groupCount.has(key)) {
                groupCount.set(key, groupCount.get(key) + 1);
              } else {
                groupCount.set(key, 1);
              }
            });
          }
        });
      }
      const result = this.evaluateRequirements(pd.submission_requirements, updatedMarked, groupCount, 0);
      const finalIdx = upIdx.filter((ui) => result[1].find((r2) => r2.verifiable_credential_path === ui[1]));
      this.updatePresentationSubmission(finalIdx);
      this.updatePresentationSubmissionPathToAlias("verifiableCredential");
      return this._client.presentationSubmission;
    }
    const marked = this._client.results.filter((result) => result.evaluator === "MarkForSubmissionEvaluation" && result.status !== Status.ERROR);
    const updatedIndexes = this.matchUserSelectedVcs(marked, vcs);
    this.updatePresentationSubmission(updatedIndexes[1]);
    this.updatePresentationSubmissionPathToAlias("verifiableCredential");
    return this._client.presentationSubmission;
  }
  updatePresentationSubmission(updatedIndexes) {
    if (!this._client.generatePresentationSubmission) {
      return;
    }
    this._client.presentationSubmission.descriptor_map = this._client.presentationSubmission.descriptor_map.filter((descriptor) => updatedIndexes.find((ui) => ui[0] === descriptor.path)).map((descriptor) => {
      const result = updatedIndexes.find((ui) => ui[0] === descriptor.path);
      if (result) {
        descriptor.path = result[1];
      }
      return descriptor;
    });
  }
  matchUserSelectedVcs(marked, vcs) {
    const userSelected = vcs.map((vc, index2) => [index2, JSON.stringify(vc.original)]);
    const allCredentials = this._client.wrappedVcs.map((vc, index2) => [index2, JSON.stringify(vc.original)]);
    const updatedIndexes = [];
    userSelected.forEach((us, i) => {
      allCredentials.forEach((ac, j) => {
        if (ac[1] === us[1]) {
          updatedIndexes.push([`$[${j}]`, `$[${i}]`]);
        }
      });
    });
    marked = marked.filter((m) => updatedIndexes.find((ui) => ui[0] === m.verifiable_credential_path)).map((m) => {
      const index2 = updatedIndexes.find((ui) => ui[0] === m.verifiable_credential_path);
      if (index2) {
        m.verifiable_credential_path = index2[1];
      }
      return m;
    });
    return [marked, updatedIndexes];
  }
  evaluateRequirements(submissionRequirement, marked, groupCount, level) {
    let total = 0;
    const result = [];
    for (const sr of submissionRequirement) {
      if (sr.from) {
        if (sr.rule === import_pex_models6.Rules.All) {
          const [count, matched] = this.countMatchingInputDescriptors(sr, marked);
          if (count !== groupCount.get(sr.from)) {
            throw Error(`Not all input descriptors are members of group ${sr.from}`);
          }
          total++;
          result.push(...matched);
        } else if (sr.rule === import_pex_models6.Rules.Pick) {
          const [count, matched] = this.countMatchingInputDescriptors(sr, marked);
          try {
            this.handleCount(sr, count, level);
            total++;
          } catch (error) {
            if (level === 0)
              throw error;
          }
          result.push(...matched);
        }
      } else if (sr.from_nested) {
        const [count, matched] = this.evaluateRequirements(sr.from_nested, marked, groupCount, ++level);
        total += count;
        result.push(...matched);
        this.handleCount(sr, count, level);
      }
    }
    return [total, result];
  }
  countMatchingInputDescriptors(submissionRequirement, marked) {
    let count = 0;
    const matched = [];
    for (const m of marked) {
      if (m.payload.group.includes(submissionRequirement.from)) {
        matched.push(m);
        count++;
      }
    }
    return [count, matched];
  }
  handleCount(submissionRequirement, count, level) {
    if (submissionRequirement.count) {
      if (count !== submissionRequirement.count) {
        throw Error(`Count: expected: ${submissionRequirement.count} actual: ${count} at level: ${level}`);
      }
    }
    if (submissionRequirement.min) {
      if (count < submissionRequirement.min) {
        throw Error(`Min: expected: ${submissionRequirement.min} actual: ${count} at level: ${level}`);
      }
    }
    if (submissionRequirement.max) {
      if (count > submissionRequirement.max) {
        throw Error(`Max: expected: ${submissionRequirement.max} actual: ${count} at level: ${level}`);
      }
    }
  }
  removeDuplicateSubmissionRequirementMatches(matches) {
    return matches.filter((match2, index2) => {
      const _match = JSON.stringify(match2);
      return index2 === matches.findIndex((obj) => {
        return JSON.stringify(obj) === _match;
      });
    });
  }
  fillSelectableCredentialsToVerifiableCredentialsMapping(selectResults, wrappedVcs) {
    var _a;
    if (selectResults) {
      (_a = selectResults.verifiableCredential) == null ? void 0 : _a.forEach((selectableCredential) => {
        var _a2;
        const foundIndex = ObjectUtils.isString(selectableCredential) ? wrappedVcs.findIndex((wrappedVc) => selectableCredential === wrappedVc.original) : wrappedVcs.findIndex((wrappedVc) => JSON.stringify(selectableCredential.proof) === JSON.stringify(wrappedVc.credential.proof));
        if (foundIndex === -1) {
          throw new Error("index is not right");
        }
        (_a2 = selectResults.vcIndexes) == null ? void 0 : _a2.push(foundIndex);
      });
    }
  }
  determineAreRequiredCredentialsPresent(presentationDefinition, matchSubmissionRequirements, parentMsr) {
    if (!matchSubmissionRequirements || !matchSubmissionRequirements.length) {
      return Status.ERROR;
    }
    const childStatuses = matchSubmissionRequirements.map((m) => this.determineSubmissionRequirementStatus(presentationDefinition, m));
    if (!parentMsr) {
      if (childStatuses.includes(Status.ERROR)) {
        return Status.ERROR;
      } else if (childStatuses.includes(Status.WARN)) {
        return Status.WARN;
      } else {
        return Status.INFO;
      }
    } else {
      if (parentMsr.rule === import_pex_models6.Rules.All && childStatuses.includes(Status.ERROR)) {
        return Status.ERROR;
      }
      const nonErrStatCount = childStatuses.filter((status) => status !== Status.ERROR).length;
      if (parentMsr.count) {
        return parentMsr.count > nonErrStatCount ? Status.ERROR : parentMsr.count < nonErrStatCount ? Status.WARN : Status.INFO;
      } else {
        if (parentMsr.min && parentMsr.min > nonErrStatCount) {
          return Status.ERROR;
        } else if (parentMsr.max && parentMsr.max < nonErrStatCount) {
          return Status.WARN;
        }
      }
    }
    return Status.INFO;
  }
  determineSubmissionRequirementStatus(pd, m) {
    if (m.from && m.from_nested) {
      throw new Error("Invalid submission_requirement object: MUST contain either a from or from_nested property.");
    }
    if (!m.from && !m.from_nested && m.vc_path.length !== 1) {
      return Status.ERROR;
    }
    if (m.from) {
      const groupCount = this.countGroupIDs(pd.input_descriptors, m.from);
      switch (m.rule) {
        case import_pex_models6.Rules.All:
          return m.vc_path.length === groupCount ? Status.INFO : Status.WARN;
        case import_pex_models6.Rules.Pick:
          return this.getPickRuleStatus(m);
        default:
          return Status.ERROR;
      }
    } else if (m.from_nested) {
      return this.determineAreRequiredCredentialsPresent(pd, m.from_nested, m);
    }
    return Status.INFO;
  }
  getPickRuleStatus(m) {
    if (m.vc_path.length === 0) {
      return Status.ERROR;
    }
    if (m.count && m.vc_path.length !== m.count) {
      return m.vc_path.length > m.count ? Status.WARN : Status.ERROR;
    }
    if (m.min && m.vc_path.length < m.min) {
      return Status.ERROR;
    }
    if (m.max && m.vc_path.length > m.max) {
      return Status.WARN;
    }
    return Status.INFO;
  }
  updateSubmissionRequirementMatchPathToAlias(submissionRequirementMatch, alias) {
    const vc_path = [];
    submissionRequirementMatch.vc_path.forEach((m) => {
      vc_path.push(m.replace("$", "$." + alias));
    });
    submissionRequirementMatch.vc_path = vc_path;
    if (submissionRequirementMatch.from_nested) {
      submissionRequirementMatch.from_nested.forEach((f) => {
        this.updateSubmissionRequirementMatchPathToAlias(f, alias);
      });
    }
  }
  updatePresentationSubmissionPathToAlias(alias, presentationSubmission) {
    if (presentationSubmission) {
      presentationSubmission.descriptor_map.forEach((d) => {
        this.replacePathWithAlias(d, alias);
      });
    } else if (this._client.generatePresentationSubmission) {
      this._client.presentationSubmission.descriptor_map.forEach((d) => {
        this.replacePathWithAlias(d, alias);
      });
    }
  }
  replacePathWithAlias(descriptor, alias) {
    descriptor.path = descriptor.path.replace("$", "$." + alias);
    if (descriptor.path_nested) {
      this.replacePathWithAlias(descriptor.path_nested, alias);
    }
  }
  createIdToVcMap(marked) {
    const partitionedResults = /* @__PURE__ */ new Map();
    const partitionedBasedOnId = /* @__PURE__ */ new Map();
    for (let i = 0; i < marked.length; i++) {
      const currentIdPath = marked[i].input_descriptor_path;
      if (partitionedBasedOnId.has(currentIdPath)) {
        const partBasedOnId = partitionedBasedOnId.get(currentIdPath);
        if (partBasedOnId) {
          partBasedOnId.push(marked[i]);
        }
      } else {
        partitionedBasedOnId.set(currentIdPath, [marked[i]]);
      }
    }
    for (const [idPath, sameVcCheckResults] of partitionedBasedOnId.entries()) {
      const vcPaths = [];
      for (let i = 0; i < sameVcCheckResults.length; i++) {
        if (vcPaths.indexOf(sameVcCheckResults[i].verifiable_credential_path) === -1) {
          vcPaths.push(sameVcCheckResults[i].verifiable_credential_path);
        }
      }
      partitionedResults.set(idPath, vcPaths);
    }
    return partitionedResults;
  }
  countGroupIDs(input_descriptors, from) {
    let count = 0;
    for (const descriptor of input_descriptors) {
      if (descriptor.group && descriptor.group.includes(from)) {
        count++;
      }
    }
    return count;
  }
};

// node_modules/@sphereon/pex/dist/module/lib/signing/index.js
var import_dist44 = __toESM(require_dist());

// node_modules/@sphereon/pex/dist/module/lib/signing/types.js
var import_dist43 = __toESM(require_dist());
var PresentationSubmissionLocation;
(function(PresentationSubmissionLocation2) {
  PresentationSubmissionLocation2[PresentationSubmissionLocation2["EXTERNAL"] = 0] = "EXTERNAL";
  PresentationSubmissionLocation2[PresentationSubmissionLocation2["PRESENTATION"] = 1] = "PRESENTATION";
})(PresentationSubmissionLocation || (PresentationSubmissionLocation = {}));
var KeyEncoding;
(function(KeyEncoding2) {
  KeyEncoding2["Jwk"] = "Jwk";
  KeyEncoding2["Base58"] = "Base58";
  KeyEncoding2["Hex"] = "Hex";
  KeyEncoding2["Multibase"] = "Multibase";
})(KeyEncoding || (KeyEncoding = {}));

// node_modules/@sphereon/pex/dist/module/lib/validation/index.js
var import_dist62 = __toESM(require_dist());

// node_modules/@sphereon/pex/dist/module/lib/validation/bundlers/index.js
var import_dist57 = __toESM(require_dist());

// node_modules/@sphereon/pex/dist/module/lib/validation/bundlers/fieldsVB.js
var import_dist46 = __toESM(require_dist());
var import_pex_models7 = __toESM(require_dist4());
var import_validateFilterv1 = __toESM(require_validateFilterv1());
var import_validateFilterv2 = __toESM(require_validateFilterv2());

// node_modules/@sphereon/pex/dist/module/lib/validation/bundlers/validationBundler.js
var import_dist45 = __toESM(require_dist());
var ValidationBundler = class {
  constructor(parentTag, myTag) {
    __publicField(this, "parentTag");
    __publicField(this, "myTag");
    this.parentTag = parentTag;
    this.myTag = myTag;
  }
  getTag() {
    return this.parentTag != null ? this.parentTag + "." + this.myTag : this.myTag;
  }
  toChecked(message) {
    return new Checked(this.getTag(), Status.ERROR, message);
  }
};

// node_modules/@sphereon/pex/dist/module/lib/validation/bundlers/fieldsVB.js
var FieldsVB = class _FieldsVB extends ValidationBundler {
  constructor(parentTag) {
    super(parentTag, "fields");
    // private readonly ajv: Ajv;
    __publicField(this, "mustHaveValidJsonPathsMsg", 'field object "path" property must contain array of valid json paths');
    __publicField(this, "pathObjMustHaveValidJsonPathMsg", 'field object "path" property must contain valid json paths.');
    __publicField(this, "filterMustBeValidJsonSchemaMsg", 'field object "filter" property must be valid json schema');
    __publicField(this, "filterIsMustInPresenceOfPredicateMsg", 'field object must have a "filter" property if "predicate" is present');
    __publicField(this, "filterIsNotValidJsonSchemaDescriptorMsg", 'could not parse "filter" object as a valid json schema descriptor.');
    __publicField(this, "purposeShouldBeANonEmptyStringMsg", "purpose should be a non empty string");
    __publicField(this, "shouldBeKnownOptionMsg", "Unknown predicate property");
  }
  getValidations(fields) {
    let validations = [];
    if (fields) {
      for (let srInd = 0; srInd < fields.length; srInd++) {
        validations = [...validations, ...this.getValidationsFor(fields[srInd], srInd)];
      }
    }
    return validations;
  }
  getValidationsFor(field, indx) {
    return [
      {
        tag: this.getMyTag(indx),
        target: field,
        predicate: this.mustHaveValidJsonPaths(),
        message: this.mustHaveValidJsonPathsMsg
      },
      {
        tag: this.getMyTag(indx),
        target: field,
        predicate: this.filterMustBeValidJsonSchema(),
        message: this.filterMustBeValidJsonSchemaMsg
      },
      {
        tag: this.getMyTag(indx),
        target: field,
        predicate: this.filterIsMustInPresenceOfPredicate(),
        message: this.filterIsMustInPresenceOfPredicateMsg
      },
      {
        tag: this.getMyTag(indx),
        target: field,
        predicate: (field2) => _FieldsVB.optionalNonEmptyString(field2 == null ? void 0 : field2.purpose),
        message: this.purposeShouldBeANonEmptyStringMsg
      },
      {
        tag: this.getMyTag(indx),
        target: field,
        predicate: (field2) => _FieldsVB.shouldBeKnownOption(field2 == null ? void 0 : field2.predicate),
        message: this.shouldBeKnownOptionMsg
      }
    ];
  }
  getMyTag(srInd) {
    return this.parentTag + "." + this.myTag + "[" + srInd + "]";
  }
  mustHaveValidJsonPaths() {
    return (fieldObj) => fieldObj.path != null && fieldObj.path.length > 0 && this._validateJsonPaths(fieldObj.path);
  }
  _validateJsonPaths(jsonPath) {
    const invalidPaths = [];
    jsonPath.forEach((path) => {
      try {
        JSONPath.parse(path);
      } catch (err) {
        invalidPaths.push(path);
      }
    });
    if (invalidPaths.length > 0) {
      throw this.toChecked(this.pathObjMustHaveValidJsonPathMsg + " Got: " + JSON.stringify(invalidPaths));
    }
    return true;
  }
  filterMustBeValidJsonSchema() {
    return (fieldObj) => this._validateFilter(fieldObj.filter);
  }
  _validateFilter(filter) {
    if (filter == null) {
      return true;
    }
    let valid = false;
    try {
      valid = (0, import_validateFilterv2.default)(filter);
      if (!valid) {
        valid = (0, import_validateFilterv1.default)(filter);
      }
    } catch (err) {
      throw this.toChecked(this.filterIsNotValidJsonSchemaDescriptorMsg + " Got " + JSON.stringify(filter));
    }
    return valid;
  }
  filterIsMustInPresenceOfPredicate() {
    return (fieldObj) => !(fieldObj.predicate != null && fieldObj.filter == null);
  }
  static optionalNonEmptyString(str) {
    return str == null || str.length > 0;
  }
  static shouldBeKnownOption(option) {
    return option == null || option == import_pex_models7.Optionality.Required || option == import_pex_models7.Optionality.Preferred;
  }
};

// node_modules/@sphereon/pex/dist/module/lib/validation/bundlers/inputDescriptorsV1VB.js
var import_dist48 = __toESM(require_dist());

// node_modules/@sphereon/pex/dist/module/lib/validation/bundlers/constraintsVB.js
var import_dist47 = __toESM(require_dist());
var import_pex_models8 = __toESM(require_dist4());
var ConstraintsVB = class _ConstraintsVB extends ValidationBundler {
  constructor(parentTag) {
    super(parentTag, "constraints");
    __publicField(this, "disclosureLimitShouldHaveKnownValueMsg", "limit_disclosure should have known value");
    __publicField(this, "statusShouldHaveKnownValueMsg", "Unknown status property");
    __publicField(this, "statusDirectiveShouldHaveKnownValueMsg", "status directive should have known value");
    __publicField(this, "subjectIsIssuerShouldBeKnownValueMsg", "subject_is_issuer should be known value");
    __publicField(this, "fieldIdIsMandatoryMsg", "field_id property is mandatory");
    __publicField(this, "fieldIdMustBeArrayOfStringsMsg", "field_id property must be an array of strings");
    __publicField(this, "fieldIdMustCorrespondToFieldIdMsg", "field_id must correspond to a present field object id property");
    __publicField(this, "directivePropertyIsMandatoryMsg", "directive property is mandatory");
    __publicField(this, "oneOfTheKnownDirectivePropertiesMandatoryMsg", "directive property must be one of [required, preferred]");
  }
  getValidations(constraints) {
    let validations = [];
    if (constraints) {
      validations = [
        {
          tag: this.getTag(),
          target: constraints,
          predicate: (constraints2) => _ConstraintsVB.disclosureLimitShouldHaveKnownValue(constraints2.limit_disclosure),
          message: this.disclosureLimitShouldHaveKnownValueMsg
        },
        {
          tag: this.getTag(),
          target: constraints,
          predicate: (constraints2) => _ConstraintsVB.statusShouldHaveKnownValue(constraints2.statuses),
          message: this.statusShouldHaveKnownValueMsg
        },
        {
          tag: this.getTag(),
          target: constraints,
          predicate: _ConstraintsVB.statusDirectiveShouldHaveKnownValue(),
          message: this.statusDirectiveShouldHaveKnownValueMsg
        },
        {
          tag: this.getTag(),
          target: constraints,
          predicate: (constraints2) => _ConstraintsVB.shouldBeKnownOption(constraints2.is_holder),
          message: this.subjectIsIssuerShouldBeKnownValueMsg
        },
        {
          tag: this.getTag(),
          target: constraints,
          predicate: (constraints2) => this.fieldIdInSubjectMustCorrespondToFieldId(constraints2, constraints2.is_holder),
          message: this.fieldIdMustCorrespondToFieldIdMsg
        },
        {
          tag: this.getTag(),
          target: constraints,
          predicate: (constraints2) => this.fieldIdInSubjectMustCorrespondToFieldId(constraints2, constraints2.same_subject),
          message: this.fieldIdMustCorrespondToFieldIdMsg
        },
        ...this.getSubjectsValidations(constraints == null ? void 0 : constraints.is_holder),
        ...this.getSubjectsValidations(constraints == null ? void 0 : constraints.same_subject),
        ...this.getFieldsValidations(constraints)
      ];
    }
    return validations;
  }
  getFieldsValidations(constraints) {
    var _a;
    if ((_a = constraints == null ? void 0 : constraints.fields) == null ? void 0 : _a.length) {
      return new FieldsVB(this.getTag()).getValidations(constraints.fields);
    }
    return [];
  }
  static disclosureLimitShouldHaveKnownValue(limit_disclosure) {
    return !limit_disclosure || limit_disclosure === import_pex_models8.Optionality.Preferred || limit_disclosure === import_pex_models8.Optionality.Required;
  }
  static statusShouldHaveKnownValue(statuses) {
    return statuses == null || statuses.active != null || statuses.revoked != null || statuses.suspended != null;
  }
  static statusDirectiveShouldHaveKnownValue() {
    return (constraints) => {
      var _a, _b, _c;
      return this.pdStatusShouldBeKnown((_a = constraints == null ? void 0 : constraints.statuses) == null ? void 0 : _a.active) && this.pdStatusShouldBeKnown((_b = constraints == null ? void 0 : constraints.statuses) == null ? void 0 : _b.revoked) && this.pdStatusShouldBeKnown((_c = constraints == null ? void 0 : constraints.statuses) == null ? void 0 : _c.suspended);
    };
  }
  static pdStatusShouldBeKnown(pdStatus) {
    return !pdStatus || pdStatus.directive === import_pex_models8.Directives.Allowed || pdStatus.directive === import_pex_models8.Directives.Disallowed || pdStatus.directive === import_pex_models8.Directives.Required;
  }
  static shouldBeKnownOption(subjects) {
    if (subjects) {
      return subjects.filter((subject) => subject.directive !== import_pex_models8.Optionality.Preferred && subject.directive !== import_pex_models8.Optionality.Required).length === 0;
    }
    return true;
  }
  getSubjectsValidations(holderSubjects) {
    if (holderSubjects) {
      let validations = [];
      for (let subjectInd = 0; subjectInd < holderSubjects.length; subjectInd++) {
        validations = [
          {
            tag: this.getMyTag(subjectInd),
            target: holderSubjects[subjectInd],
            predicate: (subject) => Array.isArray(subject.field_id),
            message: this.fieldIdMustBeArrayOfStringsMsg
          },
          {
            tag: this.getMyTag(subjectInd),
            target: holderSubjects[subjectInd],
            predicate: (subject) => !!subject.field_id,
            message: this.fieldIdIsMandatoryMsg
          },
          {
            tag: this.getMyTag(subjectInd),
            target: holderSubjects[subjectInd],
            predicate: (subject) => subject.field_id.length === subject.field_id.filter((id) => typeof id === "string").length,
            message: this.fieldIdMustBeArrayOfStringsMsg
          },
          {
            tag: this.getMyTag(subjectInd),
            target: holderSubjects[subjectInd],
            predicate: (subject) => subject.directive !== void 0,
            message: this.directivePropertyIsMandatoryMsg
          },
          {
            tag: this.getMyTag(subjectInd),
            target: holderSubjects[subjectInd],
            predicate: (subject) => subject.directive === import_pex_models8.Optionality.Preferred || subject.directive === import_pex_models8.Optionality.Required,
            message: this.oneOfTheKnownDirectivePropertiesMandatoryMsg
          }
        ];
      }
      return validations;
    }
    return [];
  }
  getMyTag(srInd) {
    return this.parentTag + "." + this.myTag + "[" + srInd + "]";
  }
  fieldIdInSubjectMustCorrespondToFieldId(constraints, subjects) {
    if (subjects) {
      for (const subject of subjects) {
        for (const fieldId of subject.field_id) {
          if (!_ConstraintsVB.isValidFieldId(constraints, fieldId)) {
            return false;
          }
        }
      }
    }
    return true;
  }
  static isValidFieldId(constraints, fieldId) {
    if (constraints == null ? void 0 : constraints.fields) {
      return constraints.fields.map((field) => field.id).includes(fieldId);
    }
    return false;
  }
};

// node_modules/@sphereon/pex/dist/module/lib/validation/bundlers/inputDescriptorsV1VB.js
var InputDescriptorsV1VB = class extends ValidationBundler {
  constructor(parentTag) {
    super(parentTag, "input_descriptor");
    __publicField(this, "idMustBeNonEmptyStringMsg", "input descriptor id must be non-empty string");
    __publicField(this, "nameShouldBeNonEmptyStringMsg", "input descriptor name should be non-empty string");
    __publicField(this, "purposeShouldBeNonEmptyStringMsg", "input descriptor purpose should be non-empty string");
    __publicField(this, "shouldHaveValidSchemaURIMsg", "schema should have valid URI");
  }
  getValidations(inputDescriptors) {
    let validations = [];
    validations.push({
      tag: this.getTag(),
      target: inputDescriptors,
      predicate: (inDescs) => this.shouldHaveUniqueIds(inDescs),
      message: "input descriptor ids must be unique"
    }, {
      tag: this.getTag(),
      target: inputDescriptors,
      predicate: (inDescs) => this.shouldHaveUniqueFieldsIds(inDescs),
      message: "fields id must be unique"
    });
    inputDescriptors.forEach((inputDescriptor, inDescInd) => {
      validations = [
        ...validations,
        ...this.getValidationFor(inputDescriptor, inDescInd),
        ...this.constraintsValidations(inputDescriptor, inDescInd)
      ];
    });
    return validations;
  }
  getValidationFor(inputDescriptor, inDescInd) {
    return [
      {
        tag: this.getMyTag(inDescInd),
        target: inputDescriptor,
        predicate: (inDesc) => ObjectValidationUtils.nonEmptyString(inDesc == null ? void 0 : inDesc.id),
        message: this.idMustBeNonEmptyStringMsg
      },
      {
        tag: this.getMyTag(inDescInd),
        target: inputDescriptor,
        predicate: this.isValidSchema(),
        message: this.shouldHaveValidSchemaURIMsg
      },
      {
        tag: this.getMyTag(inDescInd),
        target: inputDescriptor,
        predicate: (inDesc) => ObjectValidationUtils.optionalNonEmptyString(inDesc == null ? void 0 : inDesc.name),
        message: this.nameShouldBeNonEmptyStringMsg
      },
      {
        tag: this.getMyTag(inDescInd),
        target: inputDescriptor,
        predicate: (inDesc) => ObjectValidationUtils.optionalNonEmptyString(inDesc == null ? void 0 : inDesc.purpose),
        message: this.purposeShouldBeNonEmptyStringMsg
      }
    ];
  }
  shouldHaveUniqueFieldsIds(inputDescriptors) {
    const nonUniqueInputDescriptorFieldsIds = [];
    const uniqueInputDescriptorFieldsIds = /* @__PURE__ */ new Set();
    const tmp = [];
    inputDescriptors.map((e2) => {
      var _a;
      return (_a = e2.constraints) == null ? void 0 : _a.fields;
    }).forEach((e2) => {
      if (e2) {
        tmp.push(...e2);
      }
    });
    tmp.forEach((e2) => {
      if (e2.id) {
        nonUniqueInputDescriptorFieldsIds.push(e2.id);
      }
    });
    nonUniqueInputDescriptorFieldsIds.forEach((id) => uniqueInputDescriptorFieldsIds.add(id));
    return nonUniqueInputDescriptorFieldsIds.length === uniqueInputDescriptorFieldsIds.size;
  }
  shouldHaveUniqueIds(inputDescriptors) {
    const nonUniqueInputDescriptorIds = [];
    const uniqueInputDescriptorIds = /* @__PURE__ */ new Set();
    inputDescriptors.forEach((e2) => nonUniqueInputDescriptorIds.push(e2.id));
    nonUniqueInputDescriptorIds.forEach((e2) => uniqueInputDescriptorIds.add(e2));
    return nonUniqueInputDescriptorIds.length === uniqueInputDescriptorIds.size;
  }
  getMyTag(srInd) {
    return this.parentTag + "." + this.myTag + "[" + srInd + "]";
  }
  isValidSchema() {
    return (inDesc) => {
      return inDesc.schema.filter((schema) => this.isAValidURI(schema.uri) && (schema.required == null || typeof schema.required == "boolean")).length > 0;
    };
  }
  isAValidURI(uri) {
    if (!uri) {
      return false;
    } else if (!ObjectValidationUtils.nonEmptyString(uri)) {
      return false;
    }
    if (uri.startsWith("http://") || uri.startsWith("https://")) {
      try {
        new URL(uri);
      } catch (err) {
        return ObjectValidationUtils.isValidDIDURI(uri);
      }
    }
    return true;
  }
  constraintsValidations(inputDescriptor, inDescInd) {
    if (inputDescriptor.constraints) {
      return new ConstraintsVB(this.getMyTag(inDescInd)).getValidations(inputDescriptor.constraints);
    }
    return [];
  }
};

// node_modules/@sphereon/pex/dist/module/lib/validation/bundlers/inputDescriptorsV2VB.js
var import_dist49 = __toESM(require_dist());
var InputDescriptorsV2VB = class extends ValidationBundler {
  constructor(parentTag) {
    super(parentTag, "input_descriptor");
    __publicField(this, "idMustBeNonEmptyStringMsg", "input descriptor id must be non-empty string");
    __publicField(this, "nameShouldBeNonEmptyStringMsg", "input descriptor name should be non-empty string");
    __publicField(this, "purposeShouldBeNonEmptyStringMsg", "input descriptor purpose should be non-empty string");
  }
  getValidations(inputDescriptors) {
    let validations = [];
    validations.push({
      tag: this.getTag(),
      target: inputDescriptors,
      predicate: (inDescs) => this.shouldNotHaveSchema(inDescs),
      message: "input descriptor should not have schema property"
    }, {
      tag: this.getTag(),
      target: inputDescriptors,
      predicate: (inDescs) => this.shouldHaveUniqueIds(inDescs),
      message: "input descriptor ids must be unique"
    }, {
      tag: this.getTag(),
      target: inputDescriptors,
      predicate: (inDescs) => this.shouldHaveUniqueFieldsIds(inDescs),
      message: "fields id must be unique"
    });
    inputDescriptors.forEach((inputDescriptor, inDescInd) => {
      validations = [
        ...validations,
        ...this.getValidationFor(inputDescriptor, inDescInd),
        ...this.constraintsValidations(inputDescriptor, inDescInd)
      ];
    });
    return validations;
  }
  getValidationFor(inputDescriptor, inDescInd) {
    return [
      {
        tag: this.getMyTag(inDescInd),
        target: inputDescriptor,
        predicate: (inDesc) => ObjectValidationUtils.nonEmptyString(inDesc == null ? void 0 : inDesc.id),
        message: this.idMustBeNonEmptyStringMsg
      },
      {
        tag: this.getMyTag(inDescInd),
        target: inputDescriptor,
        predicate: (inDesc) => ObjectValidationUtils.optionalNonEmptyString(inDesc == null ? void 0 : inDesc.name),
        message: this.nameShouldBeNonEmptyStringMsg
      },
      {
        tag: this.getMyTag(inDescInd),
        target: inputDescriptor,
        predicate: (inDesc) => ObjectValidationUtils.optionalNonEmptyString(inDesc == null ? void 0 : inDesc.purpose),
        message: this.purposeShouldBeNonEmptyStringMsg
      }
    ];
  }
  shouldHaveUniqueFieldsIds(inputDescriptors) {
    const nonUniqueInputDescriptorFieldsIds = [];
    const uniqueInputDescriptorFieldsIds = /* @__PURE__ */ new Set();
    const tmp = [];
    inputDescriptors.map((e2) => {
      var _a;
      return (_a = e2.constraints) == null ? void 0 : _a.fields;
    }).forEach((e2) => {
      if (e2) {
        tmp.push(...e2);
      }
    });
    tmp.forEach((e2) => {
      if (e2.id) {
        nonUniqueInputDescriptorFieldsIds.push(e2.id);
      }
    });
    nonUniqueInputDescriptorFieldsIds.forEach((id) => uniqueInputDescriptorFieldsIds.add(id));
    return nonUniqueInputDescriptorFieldsIds.length === uniqueInputDescriptorFieldsIds.size;
  }
  shouldHaveUniqueIds(inputDescriptors) {
    const nonUniqueInputDescriptorIds = [];
    const uniqueInputDescriptorIds = /* @__PURE__ */ new Set();
    inputDescriptors.forEach((e2) => nonUniqueInputDescriptorIds.push(e2.id));
    nonUniqueInputDescriptorIds.forEach((e2) => uniqueInputDescriptorIds.add(e2));
    return nonUniqueInputDescriptorIds.length === uniqueInputDescriptorIds.size;
  }
  getMyTag(srInd) {
    return this.parentTag + "." + this.myTag + "[" + srInd + "]";
  }
  constraintsValidations(inputDescriptor, inDescInd) {
    if (inputDescriptor.constraints) {
      return new ConstraintsVB(this.getMyTag(inDescInd)).getValidations(inputDescriptor.constraints);
    }
    return [];
  }
  shouldNotHaveSchema(inputDescriptors) {
    let hasSchema = false;
    inputDescriptors.forEach((id) => {
      if (id["schema"]) {
        hasSchema = true;
      }
    });
    return !hasSchema;
  }
};

// node_modules/@sphereon/pex/dist/module/lib/validation/bundlers/presentationDefinitionV1VB.js
var import_dist53 = __toESM(require_dist());

// node_modules/@sphereon/pex/dist/module/lib/validation/core/jwtAlgos.js
var import_dist50 = __toESM(require_dist());
var JwtAlgos = class {
  //TODO: pass it with a config file
  static getJwtAlgos() {
    return [
      "HS256",
      "HS384",
      "HS512",
      "RS256",
      "RS384",
      "RS512",
      "ES256",
      "ES384",
      "ES512",
      "PS256",
      "PS384",
      "PS512",
      "none",
      "RSA1_5",
      "RSA-OAEP",
      "RSA-OAEP-256",
      "A128KW",
      "A192KW",
      "A256KW",
      "dir",
      "ECDH-ES",
      "ECDH-ES+A128KW",
      "ECDH-ES+A192KW",
      "ECDH-ES+A256KW",
      "A128GCMKW",
      "A192GCMKW",
      "A256GCMKW",
      "PBES2-HS256+A128KW",
      "PBES2-HS384+A192KW",
      "PBES2-HS512+A256KW"
    ];
  }
};

// node_modules/@sphereon/pex/dist/module/lib/validation/core/ldpTypes.js
var import_dist51 = __toESM(require_dist());
var LdpTypes = class {
  //TODO: pass it with a config file
  static getLdpTypes() {
    return [
      "Ed25519VerificationKey2018",
      "Ed25519Signature2018",
      "RsaSignature2018",
      "EcdsaSecp256k1Signature2019",
      "EcdsaSecp256k1RecoverySignature2020",
      "JsonWebSignature2020",
      "GpgSignature2020",
      "JcsEd25519Signature2020",
      "BbsBlsSignature2020",
      "Bls12381G2Key2020"
    ];
  }
};

// node_modules/@sphereon/pex/dist/module/lib/validation/bundlers/presentationDefinitionV1VB.js
var import_validatePDv12 = __toESM(require_validatePDv1());

// node_modules/@sphereon/pex/dist/module/lib/validation/bundlers/submissionRequirementVB.js
var import_dist52 = __toESM(require_dist());
var SubmissionRequirementVB = class _SubmissionRequirementVB extends ValidationBundler {
  constructor(parentTag) {
    super(parentTag, "submission_requirements");
    __publicField(this, "ruleIsMandatoryMsg", "rule is a mandatory field");
    __publicField(this, "needsOneFromOrFromNestedMsg", "needs exactly one of from or from_nested");
    __publicField(this, "fromNestedShouldBeArrayMsg", "The value of the from_nested property MUST be an array");
    __publicField(this, "isCountPositiveIntMsg", "count must be a practical positive number");
    __publicField(this, "isMinPositiveIntMsg", "min must be a practical positive number");
    __publicField(this, "isMaxPositiveIntMsg", "max must be a practical positive number");
    __publicField(this, "ruleShouldBePickOrAllMsg", "rule should be either pick or all");
  }
  getValidations(srs) {
    let validations = [];
    if (srs != null && srs.length > 0) {
      for (let srInd = 0; srInd < srs.length; srInd++) {
        validations = [...validations, ...this.getMyValidations(srInd, srs), ...this.getSubValidations(srInd, srs)];
      }
    }
    return validations;
  }
  getMyValidations(srInd, srs) {
    return [
      {
        tag: this.getMyTag(srInd),
        target: srs[srInd],
        predicate: _SubmissionRequirementVB.ruleIsMandatory,
        message: this.ruleIsMandatoryMsg
      },
      {
        tag: this.getMyTag(srInd),
        target: srs[srInd],
        predicate: _SubmissionRequirementVB.needsOneFromOrFromNested,
        message: this.needsOneFromOrFromNestedMsg
      },
      {
        tag: this.getMyTag(srInd),
        target: srs[srInd],
        predicate: _SubmissionRequirementVB.fromNestedShouldBeArray,
        message: this.fromNestedShouldBeArrayMsg
      },
      // TODO Validation 4.2.1.E All objects in from_nested should be of type SubmissionRequirement
      //      See if it can be implemented in pe-api yamls. currently in typescript type of this variable is 'any'
      //      i.e. from_nested?: Array<object>;
      {
        tag: this.getMyTag(srInd),
        target: srs[srInd],
        predicate: this.isCountPositiveInt,
        message: this.isCountPositiveIntMsg
      },
      {
        tag: this.getMyTag(srInd),
        target: srs[srInd],
        predicate: this.isMinPositiveInt,
        message: this.isMinPositiveIntMsg
      },
      {
        tag: this.getMyTag(srInd),
        target: srs[srInd],
        predicate: this.isMaxPositiveInt,
        message: this.isMaxPositiveIntMsg
      },
      {
        tag: this.getMyTag(srInd),
        target: srs[srInd],
        predicate: _SubmissionRequirementVB.ruleShouldBePickOrAll,
        message: this.ruleShouldBePickOrAllMsg
      }
      // Validation 4.2.4
    ];
  }
  getMyTag(srInd) {
    return this.parentTag + "." + this.myTag + "[" + srInd + "]";
  }
  getSubValidations(srInd, srs) {
    const fromNested = srs[srInd].from_nested;
    return fromNested != null ? new _SubmissionRequirementVB(this.getFromNestedTag(srInd)).getValidations(fromNested) : [];
  }
  getFromNestedTag(srInd) {
    return this.getMyTag(srInd) + ".from_nested";
  }
  isCountPositiveInt(sr) {
    return sr.rule !== "pick" || sr.count == null || 0 < sr.count;
  }
  isMinPositiveInt(sr) {
    return sr.rule !== "pick" || sr.min == null || 0 <= sr.min;
  }
  isMaxPositiveInt(sr) {
    return sr.rule !== "pick" || sr.max == null || 0 < sr.max;
  }
  static ruleIsMandatory(sr) {
    return sr.rule != null;
  }
  static needsOneFromOrFromNested(sr) {
    return sr.from == null !== (sr.from_nested == null);
  }
  static fromNestedShouldBeArray(sr) {
    return sr.from_nested == null || Array.isArray(sr.from_nested);
  }
  static ruleShouldBePickOrAll(sr) {
    return sr.rule === "pick" || sr.rule === "all";
  }
};

// node_modules/@sphereon/pex/dist/module/lib/validation/bundlers/presentationDefinitionV1VB.js
var PresentationDefinitionV1VB = class _PresentationDefinitionV1VB extends ValidationBundler {
  constructor(parentTag) {
    super(parentTag, "presentation_definition");
  }
  getValidations(pd) {
    if (pd.submission_requirements) {
      return [
        ...this.myValidations(pd),
        ...new InputDescriptorsV1VB(this.myTag).getValidations(pd.input_descriptors),
        ...new SubmissionRequirementVB(this.myTag).getValidations(pd.submission_requirements)
      ];
    } else {
      return [...this.myValidations(pd), ...new InputDescriptorsV1VB(this.myTag).getValidations(pd.input_descriptors)];
    }
  }
  myValidations(pd) {
    return [
      // E Section 4.B   : The Input Descriptors (#term:input-descriptors) required for submission are described by the submission_requirements. If no submission_requirements value is present, all inputs listed in the input_descriptors array are required for submission.
      {
        tag: this.getTag(),
        target: pd,
        predicate: (pd2) => pd2 != null,
        message: "presentation_definition should be non null."
      },
      {
        tag: this.getTag(),
        target: pd,
        predicate: this.shouldBeAsPerJsonSchema(),
        message: "presentation_definition should be as per json schema."
      },
      {
        tag: this.getTag(),
        target: pd,
        predicate: (pd2) => _PresentationDefinitionV1VB.nonEmptyString(pd2 == null ? void 0 : pd2.id),
        message: "id should not be empty"
      },
      {
        tag: this.getTag(),
        target: pd,
        predicate: (pd2) => _PresentationDefinitionV1VB.optionalNonEmptyString(pd2 == null ? void 0 : pd2.name),
        message: "name should be a non-empty string"
      },
      {
        tag: this.getTag(),
        target: pd,
        predicate: (pd2) => _PresentationDefinitionV1VB.optionalNonEmptyString(pd2 == null ? void 0 : pd2.purpose),
        message: "purpose should be a non-empty string"
      },
      {
        tag: this.getTag(),
        target: pd,
        predicate: (pd2) => _PresentationDefinitionV1VB.formatValuesShouldNotBeEmpty(pd2 == null ? void 0 : pd2.format),
        message: "formats values should not empty"
      },
      {
        tag: this.getTag(),
        target: pd,
        predicate: (pd2) => _PresentationDefinitionV1VB.formatValuesShouldBeAmongKnownValues(pd2 == null ? void 0 : pd2.format),
        message: "formats should only have known identifiers for alg or proof_type"
      },
      {
        tag: this.getTag(),
        target: pd,
        predicate: (pd2) => _PresentationDefinitionV1VB.groupShouldMatchSubmissionRequirements(pd2),
        message: "input descriptor group should match the from in submission requirements."
      },
      {
        tag: this.getTag(),
        target: pd,
        predicate: (pd2) => _PresentationDefinitionV1VB.shouldNotHaveFrameProperty(pd2),
        message: "input descriptor should not have frame property."
      }
    ];
  }
  static optionalNonEmptyString(str) {
    return str == null || str.length > 0;
  }
  static nonEmptyString(id) {
    return id != null && id.length > 0;
  }
  static formatValuesShouldNotBeEmpty(format) {
    var _a, _b, _c, _d, _e, _f;
    let areExpectedValuesPresent = true;
    if ((format == null ? void 0 : format.jwt) != null) {
      areExpectedValuesPresent = areExpectedValuesPresent && ((_a = format.jwt.alg) == null ? void 0 : _a.length) > 0;
    }
    if ((format == null ? void 0 : format.jwt_vc) != null) {
      areExpectedValuesPresent = areExpectedValuesPresent && ((_b = format.jwt_vc.alg) == null ? void 0 : _b.length) > 0;
    }
    if ((format == null ? void 0 : format.jwt_vp) != null) {
      areExpectedValuesPresent = areExpectedValuesPresent && ((_c = format.jwt_vp.alg) == null ? void 0 : _c.length) > 0;
    }
    if ((format == null ? void 0 : format.ldp) != null) {
      areExpectedValuesPresent = areExpectedValuesPresent && ((_d = format.ldp.proof_type) == null ? void 0 : _d.length) > 0;
    }
    if ((format == null ? void 0 : format.ldp_vc) != null) {
      areExpectedValuesPresent = areExpectedValuesPresent && ((_e = format.ldp_vc.proof_type) == null ? void 0 : _e.length) > 0;
    }
    if ((format == null ? void 0 : format.ldp_vp) != null) {
      areExpectedValuesPresent = areExpectedValuesPresent && ((_f = format.ldp_vp.proof_type) == null ? void 0 : _f.length) > 0;
    }
    return areExpectedValuesPresent;
  }
  static formatValuesShouldBeAmongKnownValues(format) {
    let unknownProofsAndAlgorithms = [];
    if (format) {
      const jwtAlgos = JwtAlgos.getJwtAlgos();
      const ldpTypes = LdpTypes.getLdpTypes();
      unknownProofsAndAlgorithms = [];
      for (const [key, value] of Object.entries(format)) {
        if (key.startsWith("jwt")) {
          unknownProofsAndAlgorithms.push(..._PresentationDefinitionV1VB.isJWTAlgoKnown(value, jwtAlgos));
        } else {
          unknownProofsAndAlgorithms.push(..._PresentationDefinitionV1VB.isLDPProofKnown(value, ldpTypes));
        }
      }
    }
    return unknownProofsAndAlgorithms.length === 0;
  }
  static isJWTAlgoKnown(jwtObject, jwtAlgos) {
    const unknownAlgorithms = [];
    if (jwtObject != null && jwtObject.alg != null) {
      for (const jwtAlgo of jwtObject.alg) {
        if (!jwtAlgos.includes(jwtAlgo)) {
          unknownAlgorithms.push(jwtAlgo);
        }
      }
    }
    return unknownAlgorithms;
  }
  static isLDPProofKnown(ldpObject, ldpTypes) {
    const unknownProofType = [];
    if (ldpObject != null && ldpObject.proof_type != null) {
      for (const ldpProof of ldpObject.proof_type) {
        if (!ldpTypes.includes(ldpProof)) {
          unknownProofType.push(ldpProof);
        }
      }
    }
    return unknownProofType;
  }
  static groupShouldMatchSubmissionRequirements(pd) {
    if (pd.submission_requirements != null && pd.submission_requirements.length > 0) {
      const groups = [];
      pd.input_descriptors.forEach((inDesc) => {
        if (inDesc.group) {
          groups.push(...inDesc.group);
        }
      });
      const groupStrings = new Set(groups);
      const fromValues = [];
      _PresentationDefinitionV1VB.flatten(pd.submission_requirements).forEach((srs) => {
        if (srs.from) {
          if (Array.isArray(srs.from)) {
            fromValues.push(...srs.from);
          } else {
            fromValues.push(srs.from);
          }
        }
      });
      const fromValueStrings = new Set(fromValues);
      const difference = new Set([...fromValueStrings].filter((x) => x != null && x.length > 0 && !groupStrings.has(x)));
      return difference.size === 0;
    }
    return true;
  }
  static flatten(srs) {
    return srs == null ? void 0 : srs.reduce((accumulator, submissionRequirement) => accumulator.concat(Array.isArray(submissionRequirement.from_nested) ? this.flatten(submissionRequirement.from_nested) : submissionRequirement), []);
  }
  shouldBeAsPerJsonSchema() {
    return (presentationDefinition) => {
      return (0, import_validatePDv12.default)({ presentation_definition: presentationDefinition });
    };
  }
  static shouldNotHaveFrameProperty(pd) {
    return !pd["frame"];
  }
};

// node_modules/@sphereon/pex/dist/module/lib/validation/bundlers/presentationDefinitionV2VB.js
var import_dist55 = __toESM(require_dist());
var import_validatePDv22 = __toESM(require_validatePDv2());

// node_modules/@sphereon/pex/dist/module/lib/validation/bundlers/frameVB.js
var import_dist54 = __toESM(require_dist());
var FrameVB = class _FrameVB extends ValidationBundler {
  constructor(parentTag) {
    super(parentTag, "frame");
    __publicField(this, "frameIsValidMsg", "frame value is not valid");
  }
  getValidations(frame) {
    let validations = [];
    validations = [...validations, ...this.getMyValidations(frame)];
    return validations;
  }
  getMyValidations(frame) {
    return [
      {
        tag: this.getMyTag(),
        target: frame,
        predicate: _FrameVB.frameIsValid,
        message: this.frameIsValidMsg
      }
    ];
  }
  getMyTag() {
    return this.parentTag + "." + this.myTag;
  }
  /**
   * this is based on https://github.com/digitalbazaar/jsonld.js/blob/main/lib/frame.js
   * @param frame
   */
  static frameIsValid(frame) {
    if (!frame || Array.isArray(frame) || !(typeof frame === "object")) {
      return false;
    }
    const fr = frame;
    if (fr && fr["@id"]) {
      for (const id of ObjectUtils.asArray(frame["@id"])) {
        if (!(ObjectUtils.isObject(id) || ObjectUtils.isUrlAbsolute(id)) || ObjectUtils.isString(id) && id.indexOf("_:") === 0) {
          return false;
        }
      }
    }
    if (fr["@types"]) {
      for (const type of ObjectUtils.asArray(frame["@types"])) {
        if (!(ObjectUtils.isObject(type) || ObjectUtils.isUrlAbsolute(type)) || ObjectUtils.isString(type) && type.indexOf("_:") === 0) {
          return false;
        }
      }
    }
    return true;
  }
};

// node_modules/@sphereon/pex/dist/module/lib/validation/bundlers/presentationDefinitionV2VB.js
var PresentationDefinitionV2VB = class _PresentationDefinitionV2VB extends ValidationBundler {
  constructor(parentTag) {
    super(parentTag, "presentation_definition");
  }
  getValidations(pd) {
    let validations = [];
    if (pd.submission_requirements) {
      validations = [
        ...this.myValidations(pd),
        ...new InputDescriptorsV2VB(this.myTag).getValidations(pd.input_descriptors),
        ...new SubmissionRequirementVB(this.myTag).getValidations(pd.submission_requirements)
      ];
    } else {
      validations = [...this.myValidations(pd), ...new InputDescriptorsV2VB(this.myTag).getValidations(pd.input_descriptors)];
    }
    if (pd.frame) {
      validations.push(...new FrameVB(this.myTag).getValidations(pd.frame));
    }
    return validations;
  }
  myValidations(pd) {
    return [
      // E Section 4.B   : The Input Descriptors (#term:input-descriptors) required for submission are described by the submission_requirements. If no submission_requirements value is present, all inputs listed in the input_descriptors array are required for submission.
      {
        tag: this.getTag(),
        target: pd,
        predicate: (pd2) => pd2 != null,
        message: "presentation_definition should be non null."
      },
      {
        tag: this.getTag(),
        target: pd,
        predicate: this.shouldBeAsPerJsonSchema(),
        message: "presentation_definition should be as per json schema."
      },
      {
        tag: this.getTag(),
        target: pd,
        predicate: (pd2) => _PresentationDefinitionV2VB.nonEmptyString(pd2 == null ? void 0 : pd2.id),
        message: "id should not be empty"
      },
      {
        tag: this.getTag(),
        target: pd,
        predicate: (pd2) => _PresentationDefinitionV2VB.optionalNonEmptyString(pd2 == null ? void 0 : pd2.name),
        message: "name should be a non-empty string"
      },
      {
        tag: this.getTag(),
        target: pd,
        predicate: (pd2) => _PresentationDefinitionV2VB.optionalNonEmptyString(pd2 == null ? void 0 : pd2.purpose),
        message: "purpose should be a non-empty string"
      },
      {
        tag: this.getTag(),
        target: pd,
        predicate: (pd2) => _PresentationDefinitionV2VB.formatValuesShouldNotBeEmpty(pd2 == null ? void 0 : pd2.format),
        message: "formats values should not empty"
      },
      {
        tag: this.getTag(),
        target: pd,
        predicate: (pd2) => _PresentationDefinitionV2VB.formatValuesShouldBeAmongKnownValues(pd2 == null ? void 0 : pd2.format),
        message: "formats should only have known identifiers for alg or proof_type"
      },
      {
        tag: this.getTag(),
        target: pd,
        predicate: (pd2) => _PresentationDefinitionV2VB.groupShouldMatchSubmissionRequirements(pd2),
        message: "input descriptor group should match the from in submission requirements."
      }
    ];
  }
  static optionalNonEmptyString(str) {
    return str == null || str.length > 0;
  }
  static nonEmptyString(id) {
    return id != null && id.length > 0;
  }
  static formatValuesShouldNotBeEmpty(format) {
    var _a, _b, _c, _d, _e, _f;
    let areExpectedValuesPresent = true;
    if ((format == null ? void 0 : format.jwt) != null) {
      areExpectedValuesPresent = areExpectedValuesPresent && ((_a = format.jwt.alg) == null ? void 0 : _a.length) > 0;
    }
    if ((format == null ? void 0 : format.jwt_vc) != null) {
      areExpectedValuesPresent = areExpectedValuesPresent && ((_b = format.jwt_vc.alg) == null ? void 0 : _b.length) > 0;
    }
    if ((format == null ? void 0 : format.jwt_vp) != null) {
      areExpectedValuesPresent = areExpectedValuesPresent && ((_c = format.jwt_vp.alg) == null ? void 0 : _c.length) > 0;
    }
    if ((format == null ? void 0 : format.ldp) != null) {
      areExpectedValuesPresent = areExpectedValuesPresent && ((_d = format.ldp.proof_type) == null ? void 0 : _d.length) > 0;
    }
    if ((format == null ? void 0 : format.ldp_vc) != null) {
      areExpectedValuesPresent = areExpectedValuesPresent && ((_e = format.ldp_vc.proof_type) == null ? void 0 : _e.length) > 0;
    }
    if ((format == null ? void 0 : format.ldp_vp) != null) {
      areExpectedValuesPresent = areExpectedValuesPresent && ((_f = format.ldp_vp.proof_type) == null ? void 0 : _f.length) > 0;
    }
    return areExpectedValuesPresent;
  }
  static formatValuesShouldBeAmongKnownValues(format) {
    let unknownProofsAndAlgorithms = [];
    if (format) {
      const jwtAlgos = JwtAlgos.getJwtAlgos();
      const ldpTypes = LdpTypes.getLdpTypes();
      unknownProofsAndAlgorithms = [];
      for (const [key, value] of Object.entries(format)) {
        if (key.startsWith("jwt")) {
          unknownProofsAndAlgorithms.push(..._PresentationDefinitionV2VB.isJWTAlgoKnown(value, jwtAlgos));
        } else {
          unknownProofsAndAlgorithms.push(..._PresentationDefinitionV2VB.isLDPProofKnown(value, ldpTypes));
        }
      }
    }
    return unknownProofsAndAlgorithms.length === 0;
  }
  static isJWTAlgoKnown(jwtObject, jwtAlgos) {
    const unknownAlgorithms = [];
    if (jwtObject != null && jwtObject.alg != null) {
      for (const jwtAlgo of jwtObject.alg) {
        if (!jwtAlgos.includes(jwtAlgo)) {
          unknownAlgorithms.push(jwtAlgo);
        }
      }
    }
    return unknownAlgorithms;
  }
  static isLDPProofKnown(ldpObject, ldpTypes) {
    const unknownProofType = [];
    if (ldpObject != null && ldpObject.proof_type != null) {
      for (const ldpProof of ldpObject.proof_type) {
        if (!ldpTypes.includes(ldpProof)) {
          unknownProofType.push(ldpProof);
        }
      }
    }
    return unknownProofType;
  }
  static groupShouldMatchSubmissionRequirements(pd) {
    if (pd.submission_requirements != null && pd.submission_requirements.length > 0) {
      const groups = [];
      pd.input_descriptors.forEach((inDesc) => {
        if (inDesc.group) {
          groups.push(...inDesc.group);
        }
      });
      const groupStrings = new Set(groups);
      const fromValues = [];
      _PresentationDefinitionV2VB.flatten(pd.submission_requirements).forEach((srs) => {
        if (srs.from) {
          fromValues.push(...srs.from);
        }
      });
      const fromValueStrings = new Set(fromValues);
      const difference = new Set([...fromValueStrings].filter((x) => x != null && x.length > 0 && !groupStrings.has(x)));
      return difference.size === 0;
    }
    return true;
  }
  static flatten(srs) {
    return srs == null ? void 0 : srs.reduce((accumulator, submissionRequirement) => accumulator.concat(Array.isArray(submissionRequirement.from_nested) ? this.flatten(submissionRequirement.from_nested) : submissionRequirement), []);
  }
  shouldBeAsPerJsonSchema() {
    return (presentationDefinition) => {
      return (0, import_validatePDv22.default)({ presentation_definition: presentationDefinition });
    };
  }
};

// node_modules/@sphereon/pex/dist/module/lib/validation/bundlers/presentationSubmissionVB.js
var import_dist56 = __toESM(require_dist());
var PresentationSubmissionVB = class _PresentationSubmissionVB extends ValidationBundler {
  constructor(parentTag) {
    super(parentTag, "presentation_submission");
  }
  getValidations(ps) {
    return [
      {
        tag: this.getTag(),
        target: ps,
        predicate: (ps2) => ps2 != null,
        message: "presentation_submission should be non null."
      },
      {
        tag: this.getTag(),
        target: ps,
        predicate: (ps2) => _PresentationSubmissionVB.nonEmptyString(ps2 == null ? void 0 : ps2.id),
        message: "id should not be empty"
      },
      {
        tag: this.getTag(),
        target: ps,
        predicate: (ps2) => _PresentationSubmissionVB.nonEmptyString(ps2 == null ? void 0 : ps2.definition_id),
        message: "presentation_definition_id should not be empty"
      },
      {
        tag: this.getTag(),
        target: ps,
        predicate: (ps2) => _PresentationSubmissionVB.descriptorMapMustBePresent(ps2 == null ? void 0 : ps2.descriptor_map),
        message: "descriptor_map should be a non-empty list"
      },
      {
        tag: this.getTag(),
        target: ps,
        predicate: (ps2) => _PresentationSubmissionVB.idMustBeSameForEachLevelOfNesting(ps2 == null ? void 0 : ps2.descriptor_map),
        message: "each descriptor should have a one id in it, on all levels"
      },
      {
        tag: this.getTag(),
        target: ps,
        predicate: (ps2) => _PresentationSubmissionVB.formatsShouldBeKnown(ps2 == null ? void 0 : ps2.descriptor_map),
        message: "each format should be one of the known format"
      },
      {
        tag: this.getTag(),
        target: ps,
        predicate: (ps2) => _PresentationSubmissionVB.pathsShouldBeValidJsonPaths(ps2 == null ? void 0 : ps2.descriptor_map),
        message: "each path should be a valid jsonPath"
      }
    ];
  }
  static nonEmptyString(id) {
    return id != null && id.length > 0;
  }
  static descriptorMapMustBePresent(descriptor_map) {
    return descriptor_map != null && descriptor_map.length > 0;
  }
  static idMustBeSameForEachLevelOfNesting(descriptor_map) {
    let doesEachDescriptorHasOneIdOnAllLevelsOfNesting = true;
    if (descriptor_map != null) {
      for (let i = 0; i < descriptor_map.length; i++) {
        doesEachDescriptorHasOneIdOnAllLevelsOfNesting = doesEachDescriptorHasOneIdOnAllLevelsOfNesting && _PresentationSubmissionVB.isIdSameForEachLevelOfNesting(descriptor_map[i], descriptor_map[i].id);
      }
    }
    return doesEachDescriptorHasOneIdOnAllLevelsOfNesting;
  }
  static isIdSameForEachLevelOfNesting(descriptor, id) {
    let isSame = true;
    if (descriptor != null && descriptor.path_nested != null) {
      if (descriptor.path_nested.id == id) {
        isSame = isSame && _PresentationSubmissionVB.isIdSameForEachLevelOfNesting(descriptor.path_nested, id);
      } else {
        isSame = false;
      }
    }
    return isSame;
  }
  static formatsShouldBeKnown(descriptor_map) {
    let isProofFormatKnown = true;
    if (descriptor_map != null) {
      const formats = ["jwt", "jwt_vc", "jwt_vp", "ldp", "ldp_vc", "ldp_vp"];
      for (let i = 0; i < descriptor_map.length; i++) {
        isProofFormatKnown = _PresentationSubmissionVB.formatShouldBeKnown(descriptor_map[i], formats);
      }
    }
    return isProofFormatKnown;
  }
  static formatShouldBeKnown(descriptor, formats) {
    let isProofFormatKnown = true;
    if (descriptor != null) {
      isProofFormatKnown = formats.includes(descriptor.format);
    }
    if (descriptor.path_nested != null) {
      isProofFormatKnown = isProofFormatKnown && _PresentationSubmissionVB.formatShouldBeKnown(descriptor.path_nested, formats);
    }
    return isProofFormatKnown;
  }
  static pathsShouldBeValidJsonPaths(descriptor_map) {
    let isPathValidJsonPath = true;
    if (descriptor_map != null) {
      for (let i = 0; i < descriptor_map.length; i++) {
        isPathValidJsonPath = _PresentationSubmissionVB.pathShouldBeValid(descriptor_map[i], []);
      }
    }
    return isPathValidJsonPath;
  }
  static pathShouldBeValid(descriptor, invalidPaths) {
    if (descriptor != null) {
      try {
        JSONPath.parse(descriptor.path);
      } catch (err) {
        invalidPaths.push(descriptor.path);
      }
      if (descriptor.path_nested != null) {
        _PresentationSubmissionVB.pathShouldBeValid(descriptor.path_nested, invalidPaths);
      }
    }
    if (invalidPaths.length > 0) {
      throw new Checked("", Status.ERROR, "These were not parsable json paths: " + JSON.stringify(invalidPaths));
    }
    return true;
  }
};

// node_modules/@sphereon/pex/dist/module/lib/validation/core/index.js
var import_dist61 = __toESM(require_dist());

// node_modules/@sphereon/pex/dist/module/lib/validation/core/validator.js
var import_dist58 = __toESM(require_dist());
var validate = (validations) => {
  const validateResults = validations.map((validation) => mapper(validation));
  function toChecked(validation) {
    return new Checked(validation.tag, Status.ERROR, validation.message);
  }
  function toCheckedSuccess(tag) {
    return new Checked(tag, Status.INFO, "ok");
  }
  function mapper(validation) {
    let result;
    try {
      if (validation.predicate(validation.target)) {
        result = toCheckedSuccess(validation.tag);
      } else {
        result = toChecked(validation);
      }
    } catch (error) {
      result = toChecked(validation);
    }
    return result;
  }
  const accumulateErrors = (accumulator, checked) => {
    if (checked.status !== Status.INFO) {
      accumulator.push(checked);
    }
    return accumulator;
  };
  const validated = validateResults.reduce(accumulateErrors, []);
  if (hasErrors(validated)) {
    return validated;
  } else {
    return [toCheckedSuccess("root")];
  }
};

// node_modules/@sphereon/pex/dist/module/lib/validation/core/validated.js
var import_dist59 = __toESM(require_dist());

// node_modules/@sphereon/pex/dist/module/lib/validation/core/validationEngine.js
var import_dist60 = __toESM(require_dist());
var ValidationEngine = class {
  validate(validators) {
    let validations = [];
    for (const validator of validators) {
      validations = validations.concat(validator.bundler.getValidations(validator.target));
    }
    return validate(validations);
  }
};

// node_modules/@sphereon/pex/dist/module/lib/PEX.js
var PEX = class _PEX {
  constructor() {
    __publicField(this, "_evaluationClientWrapper");
    this._evaluationClientWrapper = new EvaluationClientWrapper();
  }
  /***
   * The evaluatePresentation compares what is expected from a presentation with a presentationDefinition.
   * presentationDefinition: It can be either v1 or v2 of presentationDefinition
   *
   * @param presentationDefinition the definition of what is expected in the presentation.
   * @param presentation the presentation which has to be evaluated in comparison of the definition.
   * @param opts - limitDisclosureSignatureSuites the credential signature suites that support limit disclosure
   *
   * @return the evaluation results specify what was expected and was fulfilled and also specifies which requirements described in the input descriptors
   * were not fulfilled by the presentation.
   */
  evaluatePresentation(presentationDefinition, presentation, opts) {
    const generatePresentationSubmission = (opts == null ? void 0 : opts.generatePresentationSubmission) !== void 0 ? opts.generatePresentationSubmission : (opts == null ? void 0 : opts.presentationSubmission) !== void 0;
    const pd = SSITypesBuilder.toInternalPresentationDefinition(presentationDefinition);
    const presentationCopy = JSON.parse(JSON.stringify(presentation));
    const wrappedPresentation = SSITypesBuilder.mapExternalVerifiablePresentationToWrappedVP(presentationCopy);
    const presentationSubmission = (opts == null ? void 0 : opts.presentationSubmission) || wrappedPresentation.presentation.presentation_submission;
    if (!presentationSubmission && !generatePresentationSubmission) {
      throw Error(`Either a presentation submission as part of the VP or provided separately was expected`);
    }
    const holderDIDs = wrappedPresentation.presentation.holder ? [wrappedPresentation.presentation.holder] : [];
    const updatedOpts = {
      ...opts,
      holderDIDs,
      presentationSubmission,
      generatePresentationSubmission
    };
    const result = this._evaluationClientWrapper.evaluate(pd, wrappedPresentation.vcs, updatedOpts);
    if (result.value && result.value.descriptor_map.length) {
      const selectFromClientWrapper = new EvaluationClientWrapper();
      const selectResults = selectFromClientWrapper.selectFrom(pd, wrappedPresentation.vcs, updatedOpts);
      if (selectResults.areRequiredCredentialsPresent !== Status.ERROR) {
        result.errors = [];
      }
    }
    return result;
  }
  /***
   * The evaluate compares what is expected from a verifiableCredentials with the presentationDefinition.
   *
   * @param presentationDefinition the v1 or v2 definition of what is expected in the presentation.
   * @param verifiableCredentials the verifiable credentials which are candidates to fulfill requirements defined in the presentationDefinition param.
   * @param opts - holderDIDs the list of the DIDs that the wallet holders controls. Optional, but needed by some input requirements that do a holderDID check.
   * @           - limitDisclosureSignatureSuites the credential signature suites that support limit disclosure
   *
   * @return the evaluation results specify what was expected and was fulfilled and also specifies which requirements described in the input descriptors
   * were not fulfilled by the verifiable credentials.
   */
  evaluateCredentials(presentationDefinition, verifiableCredentials, opts) {
    const wrappedVerifiableCredentials = SSITypesBuilder.mapExternalVerifiableCredentialsToWrappedVcs(verifiableCredentials);
    this._evaluationClientWrapper = new EvaluationClientWrapper();
    const pd = SSITypesBuilder.toInternalPresentationDefinition(presentationDefinition);
    const result = this._evaluationClientWrapper.evaluate(pd, wrappedVerifiableCredentials, opts);
    if (result.value && result.value.descriptor_map.length) {
      const selectFromClientWrapper = new EvaluationClientWrapper();
      const selectResults = selectFromClientWrapper.selectFrom(pd, wrappedVerifiableCredentials, opts);
      result.areRequiredCredentialsPresent = selectResults.areRequiredCredentialsPresent;
      result.errors = selectResults.errors;
    } else {
      result.areRequiredCredentialsPresent = Status.ERROR;
    }
    return result;
  }
  /**
   * The selectFrom method is a helper function that helps filter out the verifiable credentials which can not be selected and returns
   * the selectable credentials.
   *
   * @param presentationDefinition the v1 or v2 definition of what is expected in the presentation.
   * @param verifiableCredentials verifiable credentials are the credentials from wallet provided to the library to find selectable credentials.
   * @param opts - holderDIDs the decentralized identifier(s) of the wallet holderDID. This is used to identify the credentials issued to the holderDID of wallet in certain scenario's.
   *             - limitDisclosureSignatureSuites the credential signature suites that support limit disclosure
   *
   * @return the selectable credentials.
   */
  selectFrom(presentationDefinition, verifiableCredentials, opts) {
    const verifiableCredentialCopy = JSON.parse(JSON.stringify(verifiableCredentials));
    const pd = SSITypesBuilder.toInternalPresentationDefinition(presentationDefinition);
    this._evaluationClientWrapper = new EvaluationClientWrapper();
    return this._evaluationClientWrapper.selectFrom(pd, SSITypesBuilder.mapExternalVerifiableCredentialsToWrappedVcs(verifiableCredentialCopy), opts);
  }
  presentationSubmissionFrom(presentationDefinition, selectedCredentials) {
    const pd = SSITypesBuilder.toInternalPresentationDefinition(presentationDefinition);
    return this._evaluationClientWrapper.submissionFrom(pd, SSITypesBuilder.mapExternalVerifiableCredentialsToWrappedVcs(selectedCredentials));
  }
  /**
   * This method helps create an Unsigned Presentation. An Unsigned Presentation after signing becomes a Presentation. And can be sent to
   * the verifier after signing it.
   *
   * @param presentationDefinition the v1 or v2 definition of what is expected in the presentation.
   * @param selectedCredentials the credentials which were declared selectable by getSelectableCredentials and then chosen by the intelligent-user
   * (e.g. human).
   * @param opts? - holderDID optional; the decentralized identity of the wallet holderDID. This is used to identify the holderDID of the presentation.
   *
   * @return the presentation.
   */
  presentationFrom(presentationDefinition, selectedCredentials, opts) {
    const presentationSubmissionLocation = (opts == null ? void 0 : opts.presentationSubmissionLocation) ?? PresentationSubmissionLocation.PRESENTATION;
    const presentationSubmission = this.presentationSubmissionFrom(presentationDefinition, selectedCredentials);
    const presentation = _PEX.constructPresentation(selectedCredentials, {
      ...opts,
      presentationSubmission: presentationSubmissionLocation === PresentationSubmissionLocation.PRESENTATION ? presentationSubmission : void 0
    });
    return {
      presentation,
      presentationSubmissionLocation,
      presentationSubmission
    };
  }
  static constructPresentation(selectedCredentials, opts) {
    var _a, _b, _c, _d;
    const holder = opts == null ? void 0 : opts.holderDID;
    const type = Array.isArray((_a = opts == null ? void 0 : opts.basePresentationPayload) == null ? void 0 : _a.type) ? ((_b = opts == null ? void 0 : opts.basePresentationPayload) == null ? void 0 : _b.type) || [] : ((_c = opts == null ? void 0 : opts.basePresentationPayload) == null ? void 0 : _c.type) ? [opts.basePresentationPayload.type] : [];
    const context = ((_d = opts == null ? void 0 : opts.basePresentationPayload) == null ? void 0 : _d["@context"]) ? Array.isArray(opts.basePresentationPayload["@context"]) ? opts.basePresentationPayload["@context"] : [opts.basePresentationPayload["@context"]] : [];
    if (!context.includes("https://www.w3.org/2018/credentials/v1")) {
      context.push("https://www.w3.org/2018/credentials/v1");
    }
    if (!type.includes("VerifiablePresentation")) {
      type.push("VerifiablePresentation");
    }
    if (opts == null ? void 0 : opts.presentationSubmission) {
      if (!type.includes("PresentationSubmission")) {
        type.push("PresentationSubmission");
      }
      if (!context.includes("https://identity.foundation/presentation-exchange/submission/v1")) {
        context.push("https://identity.foundation/presentation-exchange/submission/v1");
      }
    }
    return {
      ...opts == null ? void 0 : opts.basePresentationPayload,
      "@context": context,
      type,
      holder,
      ...!!(opts == null ? void 0 : opts.presentationSubmission) && { presentation_submission: opts.presentationSubmission },
      verifiableCredential: Array.isArray(selectedCredentials) ? selectedCredentials : [selectedCredentials]
    };
  }
  /**
   * This method validates whether an object is usable as a presentation definition or not.
   *
   * @param presentationDefinition: presentationDefinition of V1 or v2 to be validated.
   *
   * @return the validation results to reveal what is acceptable/unacceptable about the passed object to be considered a valid presentation definition
   */
  static validateDefinition(presentationDefinition) {
    const result = definitionVersionDiscovery(presentationDefinition);
    if (result.error) {
      throw result.error;
    }
    const validators = [];
    result.version === PEVersion.v1 ? validators.push({
      bundler: new PresentationDefinitionV1VB("root"),
      target: SSITypesBuilder.modelEntityToInternalPresentationDefinitionV1(presentationDefinition)
    }) : validators.push({
      bundler: new PresentationDefinitionV2VB("root"),
      target: SSITypesBuilder.modelEntityInternalPresentationDefinitionV2(presentationDefinition)
    });
    return new ValidationEngine().validate(validators);
  }
  /**
   * This method validates whether an object is usable as a presentation submission or not.
   *
   * @param presentationSubmission the object to be validated.
   *
   * @return the validation results to reveal what is acceptable/unacceptable about the passed object to be considered a valid presentation submission
   */
  static validateSubmission(presentationSubmission) {
    return new ValidationEngine().validate([
      {
        bundler: new PresentationSubmissionVB("root"),
        target: presentationSubmission
      }
    ]);
  }
  /**
   * This method can be used to combine a definition, selected Verifiable Credentials, together with
   * signing opts and a callback to sign a presentation, making it a Verifiable Presentation before sending.
   *
   * Please note that PEX has no signature support on purpose. We didn't want this library to depend on all kinds of signature suites.
   * The callback function next to the Signing Params also gets a Presentation which is evaluated against the definition.
   * It is up to you to decide whether you simply update the supplied partial proof and add it to the presentation in the callback,
   * or whether you will use the selected Credentials, Presentation definition, evaluation results and/or presentation submission together with the signature opts
   *
   * @param presentationDefinition the Presentation Definition V1 or V2
   * @param selectedCredentials the PEX and/or User selected/filtered credentials that will become part of the Verifiable Presentation
   * @param signingCallBack the function which will be provided as a parameter. And this will be the method that will be able to perform actual
   *        signing. One example of signing is available in the project named. pe-selective-disclosure.
   * @param opts: Signing Params these are the signing params required to sign.
   *
   * @return the signed and thus Verifiable Presentation.
   */
  async verifiablePresentationFrom(presentationDefinition, selectedCredentials, signingCallBack, opts) {
    const { holderDID, signatureOptions, proofOptions } = opts;
    const presentationSubmissionLocation = opts.presentationSubmissionLocation ?? PresentationSubmissionLocation.PRESENTATION;
    function limitedDisclosureSuites() {
      let limitDisclosureSignatureSuites2 = [];
      if (proofOptions == null ? void 0 : proofOptions.typeSupportsSelectiveDisclosure) {
        if (!(proofOptions == null ? void 0 : proofOptions.type)) {
          throw Error("Please provide a proof type if you enable selective disclosure");
        }
        limitDisclosureSignatureSuites2 = [proofOptions.type];
      }
      return limitDisclosureSignatureSuites2;
    }
    const holderDIDs = holderDID ? [holderDID] : [];
    const limitDisclosureSignatureSuites = limitedDisclosureSuites();
    const evaluationResult = this.evaluateCredentials(presentationDefinition, selectedCredentials, {
      holderDIDs,
      limitDisclosureSignatureSuites
    });
    const presentationResult = this.presentationFrom(presentationDefinition, evaluationResult.verifiableCredential, {
      ...opts,
      presentationSubmissionLocation
    });
    const evaluationResults = this.evaluatePresentation(presentationDefinition, presentationResult.presentation, { limitDisclosureSignatureSuites });
    if (!evaluationResults.value) {
      throw new Error("Could not get evaluation results from presentationResult");
    }
    const proof = {
      type: proofOptions == null ? void 0 : proofOptions.type,
      verificationMethod: signatureOptions == null ? void 0 : signatureOptions.verificationMethod,
      created: (proofOptions == null ? void 0 : proofOptions.created) ? proofOptions.created : (/* @__PURE__ */ new Date()).toISOString(),
      proofPurpose: proofOptions == null ? void 0 : proofOptions.proofPurpose,
      proofValue: signatureOptions == null ? void 0 : signatureOptions.proofValue,
      jws: signatureOptions == null ? void 0 : signatureOptions.jws,
      challenge: proofOptions == null ? void 0 : proofOptions.challenge,
      nonce: proofOptions == null ? void 0 : proofOptions.nonce,
      domain: proofOptions == null ? void 0 : proofOptions.domain
    };
    const callBackParams = {
      options: opts,
      presentation: presentationResult.presentation,
      presentationDefinition,
      selectedCredentials,
      proof,
      presentationSubmission: evaluationResults.value,
      evaluationResults
    };
    const verifiablePresentation = await signingCallBack(callBackParams);
    return {
      verifiablePresentation,
      presentationSubmissionLocation,
      presentationSubmission: evaluationResults.value
    };
  }
  static definitionVersionDiscovery(presentationDefinition) {
    return definitionVersionDiscovery(presentationDefinition);
  }
};

// node_modules/@sphereon/pex/dist/module/lib/index.js
var import_dist66 = __toESM(require_dist());

// node_modules/@sphereon/pex/dist/module/lib/PEXv1.js
var import_dist64 = __toESM(require_dist());

// node_modules/@sphereon/pex/dist/module/lib/PEXv2.js
var import_dist65 = __toESM(require_dist());

// node_modules/@sphereon/pex/dist/module/index.js
var import_dist67 = __toESM(require_dist());

export {
  require_equal,
  require_ajv,
  PEX
};
//# sourceMappingURL=chunk-IDIKVVDV.js.map
