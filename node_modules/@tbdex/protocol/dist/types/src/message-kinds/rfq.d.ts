import type { MessageKind, MessageModel, RfqData, RfqMetadata, RfqPrivateData, CreateRfqData } from '../types.js';
import { Offering } from '../resource-kinds/index.js';
import { Message } from '../message.js';
/**
 * Options passed to {@link Rfq.create}
 * @beta
 */
export type CreateRfqOptions = {
    data: CreateRfqData;
    metadata: Omit<RfqMetadata, 'id' | 'kind' | 'createdAt' | 'exchangeId' | 'protocol'> & {
        protocol?: RfqMetadata['protocol'];
    };
};
/**
 * Options passed to {@link Rfq.parse}
 * @beta
 */
export type ParseRfqOptions = {
    /**
     * If true, validate that all private data properties are present and run integrity check.
     * Otherwise, only check integrity of private fields which are present.
     * If false, validate only the private data properties that are currently present in `privateData`
     */
    requireAllPrivateData: boolean;
};
/**
 * Message sent by Alice to PFI to request a quote (RFQ)
 * @beta
 */
export declare class Rfq extends Message {
    /** a set of valid Message kinds that can come after an rfq */
    readonly validNext: Set<MessageKind>;
    /** The message kind (rfq) */
    readonly kind = "rfq";
    /** Metadata such as sender, recipient, date created, and ID */
    readonly metadata: RfqMetadata;
    /** Rfq's data containing information to initiate an exchange between Alice and a PFI */
    readonly data: RfqData;
    /** Rfq's unhashed private information to initiate an exchange between Alice and a PFI */
    readonly privateData: RfqPrivateData | undefined;
    constructor(metadata: RfqMetadata, data: RfqData, signature?: string, privateData?: RfqPrivateData);
    /**
     * Parses a json message into an Rfq
     * @param rawMessage - the rfq to parse
     * @throws if the rfq could not be parsed or is not a valid Rfq
     * @returns The parsed Rfq
     */
    static parse(rawMessage: MessageModel | string, opts?: ParseRfqOptions): Promise<Rfq>;
    /**
     * Valid structure of the message including the presence of the signature
     * using the official spec JSON Schemas
     * @override
     * @throws If the message's structure does not match the JSON schemas
     */
    validate(): void;
    /**
     * Creates an rfq with the given options
     * @param opts - options to create an rfq
     * @returns {@link Rfq}
     */
    static create(opts: CreateRfqOptions): Rfq;
    /**
     * Hash private RFQ data and set private fields in an RfqPrivateData object
     * @param - unhashedRfqData
     * @returns An object with fields data and privateData.
     * @returns {@link RfqData} The value of data field.
     * @returns {@link RfqPrivateData} The value of privateData field.
     */
    private static hashPrivateData;
    /**
     * Verify the presence and integrity of all possible properties in {@link Rfq.privateData}.
     * @throws if there are properties missing in {@link Rfq.privateData} or which do not match the corresponding
     *         hashed property in {@link Rfq.data}
     */
    private verifyAllPrivateData;
    /**
     * Verify the integrity properties that are present in {@link Rfq.privateData}.
     * @throws if there are properties present in {@link Rfq.privateData} which do not match the corresponding
     *         hashed property in {@link Rfq.data}
     */
    private verifyPresentPrivateData;
    private verifyPayinDetailsHash;
    private verifyPayoutDetailsHash;
    private verifyClaimsHash;
    /**
     * Given a salt and a value, compute a deterministic digest used in hashed fields in RfqData
     * @param - salt
     * @param - value
     * @returns salted hash of the private data value
     */
    private static digestPrivateData;
    /**
     * evaluates this rfq against the provided offering
     * @param offering - the offering to evaluate this rfq against
     * @throws if Rfq.data.offeringId doesn't match the provided offering's id
     * @see RfqData#offeringId
     * @throws if payinAmount in {@link Rfq.data} exceeds the provided offering's max units allowed or is below the offering's min units allowed
     * @throws if payinMethod in {@link Rfq.data} property `kind` cannot be validated against the provided offering's payinMethod kinds
     * @throws if payinMethod in {@link Rfq.data} property `paymentDetails` cannot be validated against the provided offering's payinMethod requiredPaymentDetails
     * @throws if payoutMethod in {@link Rfq.data} property `kind` cannot be validated against the provided offering's payoutMethod kinds
     * @throws if payoutMethod in {@link Rfq.data} property `paymentDetails` cannot be validated against the provided offering's payoutMethod requiredPaymentDetails
     */
    verifyOfferingRequirements(offering: Offering): Promise<void>;
    /**
     * Validate the Rfq's payin/payout method against an Offering's allow payin/payout methods
     *
     * @param rfqPaymentMethod - The Rfq's selected payin/payout method being validated
     * @param allowedPaymentMethods - The Offering's allowed payin/payout methods
     * @param payDirection - Either 'payin' or 'payout', used to provide more detailed error messages.
     *
     * @throws if rfqPaymentMethod property `kind` cannot be validated against the provided offering's paymentMethod's kinds
     * @throws if {@link Rfq.privateData} property `paymentDetails` is missing but is necessary to validate against the provided offering's paymentMethod's kinds
     * @throws if rfqPaymentMethod property `paymentDetails` cannot be validated against the provided offering's paymentMethod's requiredPaymentDetails
     */
    private verifyPaymentMethod;
    /**
     * checks the claims provided in this rfq against an offering's requirements
     * @param offering - the offering to check against
     * @throws if rfq's claims do not fulfill the offering's requirements
     */
    verifyClaims(offering: Offering): Promise<void>;
    /**
     * Converts this rfq message to a json object
     */
    toJSON(): MessageModel;
}
//# sourceMappingURL=rfq.d.ts.map