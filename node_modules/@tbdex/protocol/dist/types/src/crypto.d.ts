import { BearerDid } from '@web5/dids';
/**
 * Options passed to {@link Crypto.sign}
 * @beta
 */
export type SignOptions = {
    /** Indicates whether the payload is detached from the JWS. If `true`, the payload is not included in the resulting JWS. */
    detached: boolean;
    /** The payload to be signed. */
    payload: Uint8Array;
    /** the DID to sign with */
    did: BearerDid;
};
/**
 * Options passed to {@link Crypto.verify}
 * @beta
 */
export type VerifyOptions = {
    /** The payload that was signed. required only if the signature is a detached JWS */
    detachedPayload?: Uint8Array;
    signature: string;
};
/**
 * Cryptographic utility functions, such as hashing, signing, and verifying
 * @beta
 */
export declare class Crypto {
    /**
     * Computes a digest of the payload by:
     * * JSON serializing the payload as per [RFC-8785: JSON Canonicalization Scheme](https://www.rfc-editor.org/rfc/rfc8785)
     * * sha256 hashing the serialized payload
     *
     * @returns The SHA-256 hash of the canonicalized payload, represented as a byte array.
     */
    static digest(payload: any): Uint8Array;
    /**
     * Signs the provided payload and produces a compact JSON Web Signature (JWS).
     *
     * @param opts - The options required for signing.
     * @returns A promise that resolves to the generated compact JWS.
     * @throws Will throw an error if the specified algorithm is not supported.
     */
    static sign(opts: SignOptions): Promise<string>;
    /**
     * Verifies the integrity of a message or resource's signature.
     *
     * @param opts - The options required for verification.
     * @returns A promise that resolves to the DID of the signer if verification is successful.
     * @throws Various errors related to invalid input or failed verification.
     */
    static verify(opts: VerifyOptions): Promise<string>;
}
//# sourceMappingURL=crypto.d.ts.map