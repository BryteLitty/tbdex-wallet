import type { ResourceModel, ResourceMetadata, ResourceKind, ResourceData } from './types.js';
import type { Balance, Offering } from './resource-kinds/index.js';
import { BearerDid } from '@web5/dids';
/**
 * tbDEX Resources are published by PFIs for anyone to consume and generally used as a part of the discovery process.
 * They are not part of the message exchange, i.e Alice cannot reply to a Resource.
 * @beta
 */
export declare abstract class Resource {
    /** The resource kind (e.g. offering) */
    abstract kind: ResourceKind;
    /** Metadata such as creator, date created, date updated, and ID */
    protected metadata: ResourceMetadata;
    /** Resource kind-specific data */
    protected data: ResourceData;
    /** signature that verifies that authenticity and integrity of a message */
    private _signature;
    /**
     * Constructor is primarily for intended for internal use. For a better developer experience,
     * consumers should use concrete classes to programmatically create and parse resources,
     * e.g. {@link Offering.parse} and {@link Offering.create}
     * @param metadata - {@link Resource.metadata}
     * @param data - {@link Resource.data}
     * @param signature - {@link Resource._signature}
     */
    protected constructor(metadata: ResourceMetadata, data: ResourceData, signature?: string);
    /** Generates a unique id with the resource kind's prefix */
    static generateId(resourceKind: ResourceKind): string;
    /**
     * Signs the resource as a jws with detached content and sets the signature property
     * @param did - the signer's DID
     * @throws If the signature could not be produced
     */
    sign(did: BearerDid): Promise<void>;
    /**
     * Validates the resource structure and verifies the cryptographic signature
     * @throws if the resource signature is invalid
     * @throws if the signer's DID does not match Resource.metadata.from
     * @throws if the resource structure is invalid
     * @throws see {@link Crypto.verify}
     * @returns Resource signer's DID
     */
    verify(): Promise<string>;
    /**
     * Verifies the integrity of the cryptographic signature
     * @throws if the resource signature is invalid
     * @throws if the signer's DID does not match Resource.metadata.from
     * @returns Resource signer's DID
     */
    verifySignature(): Promise<string>;
    /**
     * Computes a digest of the payload by:
     * * JSON serializing the payload as per [RFC-8785: JSON Canonicalization Scheme](https://www.rfc-editor.org/rfc/rfc8785)
     * * sha256 hashing the serialized payload
     *
     * @returns The SHA-256 hash of the canonicalized payload, represented as a byte array.
     */
    digest(): Uint8Array;
    /**
     * Valid structure of the resource including the presence of the signature
     * using the official spec JSON Schemas
     * @throws If the resource's structure does not match the JSON schemas
     */
    validate(): void;
    /**
     * Validates `data` section of resource only using the official TBDex JSON Schemas.
     * This is useful for partially validating unsigned resources.
     * @throws If the structure of the Resource's data does not match the JSON schemas
     */
    validateData(): void;
    /**
     * returns the resource as a json object. Automatically used by `JSON.stringify` method.
     */
    toJSON(): ResourceModel;
    /** the resource's cryptographic signature */
    get signature(): string | undefined;
    /** the resource's id */
    get id(): string;
    /** The sender's DID */
    get from(): string;
    /** Resource creation time. Expressed as ISO8601 */
    get createdAt(): string;
    /** Resource last updated time. Expressed as ISO8601 */
    get updatedAt(): string | undefined;
    /** the protocol version */
    get protocol(): `${number}`;
    /** offering type guard */
    isOffering(): this is Offering;
    /** balance type guard */
    isBalance(): this is Balance;
}
//# sourceMappingURL=resource.d.ts.map