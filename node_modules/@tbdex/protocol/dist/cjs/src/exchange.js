var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/**
 * State-machine for validating the order and metadata of Tbdex messages in an exchange.
 *
 * This state-machine does not validate the {@link Message.signature} or {@link Message.data}
 * of messages in the exchange.
 *
 * Either add messages in order one at a time using {@link Exchange.addNextMessage},
 * or add a list of unsorted messages in an exchange using {@link Exchange.addMessages}
 *
 * @beta
 */
var Exchange = /** @class */ (function () {
    function Exchange() {
        this.orderstatus = [];
    }
    /**
     * Add a list of unsorted messages to an exchange.
     * @param messages - An unsorted array of Tbdex messages in a given exchange
     */
    Exchange.prototype.addMessages = function (messages) {
        // Sort with earliest dateCreated first
        var sortedMessages = messages.sort(function (m1, m2) {
            var time1 = new Date(m1.metadata.createdAt).getTime();
            var time2 = new Date(m2.metadata.createdAt).getTime();
            return time1 - time2;
        });
        for (var _i = 0, sortedMessages_1 = sortedMessages; _i < sortedMessages_1.length; _i++) {
            var message = sortedMessages_1[_i];
            this.addNextMessage(message);
        }
    };
    /**
     * Add the next message in the exchange
     * @param message - The next allowed message in the exchange
     * @throws if message's protocol version does not match protocol version of other messages in the exchange
     * @throws if message is not a valid next message. See {@link Exchange.isValidNext}
     * @throws if message's exchangeId does not match id of the exchange
     */
    Exchange.prototype.addNextMessage = function (message) {
        if (this.protocol !== undefined && message.metadata.protocol !== this.protocol) {
            throw new Error("Could not add message (".concat(message.metadata.id, ") with protocol version ").concat(message.metadata.protocol, " to exchange because it does not have matching ") +
                "protocol version ".concat(this.protocol, " as other messages in the exchange"));
        }
        if (!this.isValidNext(message.metadata.kind)) {
            throw new Error("Could not add message (".concat(message.metadata.id, ") to exchange because ").concat(message.metadata.kind, " ") +
                "is not a valid next message");
        }
        if (this.exchangeId !== undefined && message.metadata.exchangeId !== this.exchangeId) {
            throw new Error("Could not add message (".concat(message.metadata.id, ") with exchange id ").concat(message.metadata.exchangeId, " to exchange because it does not have matching ") +
                "exchange id ".concat(this.exchangeId, " as the exchange"));
        }
        if (message.isRfq()) {
            this.rfq = message;
        }
        else if (message.isQuote()) {
            this.quote = message;
        }
        else if (message.isClose()) {
            this.close = message;
        }
        else if (message.isOrder()) {
            this.order = message;
        }
        else if (message.isOrderStatus()) {
            this.orderstatus.push(message);
        }
        else {
            // Unreachable
            throw new Error('Unrecognized message kind');
        }
    };
    /**
     * Determines if the message kind is a valid next message in the current exchange
     * @param messageKind - the kind of TBDex message
     * @returns true if the next message in the exchange may have kind messageKind, false otherwise
     */
    Exchange.prototype.isValidNext = function (messageKind) {
        var _a, _b;
        var validNext = (_b = (_a = this.latestMessage) === null || _a === void 0 ? void 0 : _a.validNext) !== null && _b !== void 0 ? _b : new Set(['rfq']);
        return validNext.has(messageKind);
    };
    Object.defineProperty(Exchange.prototype, "latestMessage", {
        /**
         * Latest message in an exchange if there are any messages currently
         */
        get: function () {
            var _a, _b, _c, _d;
            return (_d = (_c = (_b = (_a = this.close) !== null && _a !== void 0 ? _a : this.orderstatus[this.orderstatus.length - 1]) !== null && _b !== void 0 ? _b : this.order) !== null && _c !== void 0 ? _c : this.quote) !== null && _d !== void 0 ? _d : this.rfq;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Exchange.prototype, "exchangeId", {
        /**
         * The exchangeId of all messages in the Exchange
         */
        get: function () {
            var _a, _b;
            return (_b = (_a = this.rfq) === null || _a === void 0 ? void 0 : _a.metadata) === null || _b === void 0 ? void 0 : _b.exchangeId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Exchange.prototype, "protocol", {
        /**
         * The protocol version of all messages in the Exchange
         */
        get: function () {
            var _a, _b;
            return (_b = (_a = this.rfq) === null || _a === void 0 ? void 0 : _a.metadata) === null || _b === void 0 ? void 0 : _b.protocol;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Exchange.prototype, "messages", {
        /**
         * A sorted list of messages currently in the exchange.
         */
        get: function () {
            var allPossibleMessages = __spreadArray(__spreadArray([
                this.rfq,
                this.quote,
                this.order
            ], this.orderstatus, true), [
                this.close
            ], false);
            return allPossibleMessages.filter(function (message) { return message !== undefined; });
        },
        enumerable: false,
        configurable: true
    });
    return Exchange;
}());
export { Exchange };
